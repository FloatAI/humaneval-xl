{"task_id": "swift/0", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Σας δίνεται μια λίστα με λειτουργίες κατάθεσης και ανάληψης σε έναν τραπεζικό λογαριασμό που ξεκινά με μηδενικό υπόλοιπο. Η εργασία σας είναι να ανιχνεύσετε αν σε οποιοδήποτε σημείο το υπόλοιπο του λογαριασμού πέσει κάτω από το μηδέν, και σε αυτό το σημείο η συνάρτηση θα πρέπει να επιστρέψει True. Διαφορετικά θα πρέπει να επιστρέψει False.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n *\n */\nfunc belowZero(operations : [AnyHashable]) -> Bool {\n", "entry_point": "belowZero", "test": "\n\nvar arg00 : [AnyHashable] = []\nvar x0 : Bool = belowZero(operations : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [1, 2, -3, 1, 2, -3]\nvar x1 : Bool = belowZero(operations : arg10)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [1, 2, -4, 5, 6]\nvar x2 : Bool = belowZero(operations : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [1, -1, 2, -2, 5, -5, 4, -4]\nvar x3 : Bool = belowZero(operations : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [1, -1, 2, -2, 5, -5, 4, -5]\nvar x4 : Bool = belowZero(operations : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable] = [1, -2, 2, -2, 5, -5, 4, -4]\nvar x5 : Bool = belowZero(operations : arg50)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "Σας δίνεται μια λίστα με λειτουργίες κατάθεσης και ανάληψης σε έναν τραπεζικό λογαριασμό που ξεκινά με μηδενικό υπόλοιπο. Η εργασία σας είναι να ανιχνεύσετε αν σε οποιοδήποτε σημείο το υπόλοιπο του λογαριασμού πέσει κάτω από το μηδέν, και σε αυτό το σημείο η συνάρτηση θα πρέπει να επιστρέψει True. Διαφορετικά θα πρέπει να επιστρέψει False.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/1", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Για μια δεδομένη λίστα ακεραίων, επιστρέψτε ένα tuple που αποτελείται από το άθροισμα και το γινόμενο όλων των ακεραίων στη λίστα.\n * Το άθροισμα της κενής λίστας πρέπει να είναι ίσο με 0 και το γινόμενο της κενής λίστας πρέπει να είναι ίσο με 1.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n *\n */\nfunc sumProduct(numbers : [AnyHashable]) -> [Int] {\n", "entry_point": "sumProduct", "test": "\n\nvar arg00 : [AnyHashable] = []\nvar x0 : [Int] = sumProduct(numbers : arg00)\nvar v0 : [Int] = [0, 1]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [1, 1, 1]\nvar x1 : [Int] = sumProduct(numbers : arg10)\nvar v1 : [Int] = [3, 1]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [100, 0]\nvar x2 : [Int] = sumProduct(numbers : arg20)\nvar v2 : [Int] = [100, 0]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [3, 5, 7]\nvar x3 : [Int] = sumProduct(numbers : arg30)\nvar v3 : [Int] = [15, 105]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [10]\nvar x4 : [Int] = sumProduct(numbers : arg40)\nvar v4 : [Int] = [10, 10]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Για μια δεδομένη λίστα ακεραίων, επιστρέψτε ένα tuple που αποτελείται από το άθροισμα και το γινόμενο όλων των ακεραίων στη λίστα.\nΤο άθροισμα της κενής λίστας πρέπει να είναι ίσο με 0 και το γινόμενο της κενής λίστας πρέπει να είναι ίσο με 1.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/2", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Τα εισαγόμενα είναι δύο συμβολοσειρές a και b που αποτελούνται μόνο από 1s και 0s.\n *     Εκτελέστε δυαδικό XOR σε αυτές τις εισόδους και επιστρέψτε το αποτέλεσμα επίσης ως συμβολοσειρά.\n * >>> string_xor('010', '110')\n * '100'\n *\n */\nfunc stringXor(a : String, b : String) -> String {\n", "entry_point": "stringXor", "test": "\n\nvar arg00 : String = #\"111000\"#\nvar arg01 : String = #\"101010\"#\nvar x0 : String = stringXor(a : arg00, b : arg01)\nvar v0 : String = #\"010010\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"1\"#\nvar arg11 : String = #\"1\"#\nvar x1 : String = stringXor(a : arg10, b : arg11)\nvar v1 : String = #\"0\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"0101\"#\nvar arg21 : String = #\"0000\"#\nvar x2 : String = stringXor(a : arg20, b : arg21)\nvar v2 : String = #\"0101\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\n", "description": "Τα εισαγόμενα είναι δύο συμβολοσειρές a και b που αποτελούνται μόνο από 1s και 0s.\n    Εκτελέστε δυαδικό XOR σε αυτές τις εισόδους και επιστρέψτε το αποτέλεσμα επίσης ως συμβολοσειρά.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/3", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Από μια λίστα από αλφαριθμητικά, επιστρέψτε το μακρύτερο. Επιστρέψτε το πρώτο στην περίπτωση πολλαπλών αλφαριθμητικών με το ίδιο μήκος. Επιστρέψτε null στην περίπτωση που η εισαγωγική λίστα είναι άδεια.\n * >>> longest([])\n\n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n *\n */\nfunc longest(strings : [AnyHashable]) -> String {\n", "entry_point": "longest", "test": "\n\nvar arg00 : [AnyHashable] = []\nvar x0 : String = longest(strings : arg00)\nvar v0 : String = \"none\"\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [#\"x\"#, #\"y\"#, #\"z\"#]\nvar x1 : String = longest(strings : arg10)\nvar v1 : String = #\"x\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [#\"x\"#, #\"yyy\"#, #\"zzzz\"#, #\"www\"#, #\"kkkk\"#, #\"abc\"#]\nvar x2 : String = longest(strings : arg20)\nvar v2 : String = #\"zzzz\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\n", "description": "Από μια λίστα από αλφαριθμητικά, επιστρέψτε το μακρύτερο. Επιστρέψτε το πρώτο στην περίπτωση πολλαπλών αλφαριθμητικών με το ίδιο μήκος. Επιστρέψτε null στην περίπτωση που η εισαγωγική λίστα είναι άδεια.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/4", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Επιστροφή του μεγαλύτερου κοινού διαιρέτη δύο ακεραίων αριθμών a και b.\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n *\n */\nfunc greatestCommonDivisor(a : Int, b : Int) -> Int {\n", "entry_point": "greatestCommonDivisor", "test": "\n\nvar arg00 : Int = 3\nvar arg01 : Int = 7\nvar x0 : Int = greatestCommonDivisor(a : arg00, b : arg01)\nvar v0 : Int = 1\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 10\nvar arg11 : Int = 15\nvar x1 : Int = greatestCommonDivisor(a : arg10, b : arg11)\nvar v1 : Int = 5\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 49\nvar arg21 : Int = 14\nvar x2 : Int = greatestCommonDivisor(a : arg20, b : arg21)\nvar v2 : Int = 7\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 144\nvar arg31 : Int = 60\nvar x3 : Int = greatestCommonDivisor(a : arg30, b : arg31)\nvar v3 : Int = 12\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "Επιστροφή του μεγαλύτερου κοινού διαιρέτη δύο ακεραίων αριθμών a και b.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/5", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Η είσοδος είναι μια συμβολοσειρά διαχωρισμένη με κενό από αριθμητικά χαρακτήρες από το 'μηδέν' έως το 'εννέα'.\n *     Οι έγκυρες επιλογές είναι 'μηδέν', 'ένα', 'δύο', 'τρία', 'τέσσερα', 'πέντε', 'έξι', 'επτά', 'οκτώ' και 'εννέα'.\n *     Επιστρέψτε τη συμβολοσειρά με τους αριθμούς ταξινομημένους από τον μικρότερο στον μεγαλύτερο.\n * >>> sort_numbers('three one five')\n * 'one three five'\n *\n */\nfunc sortNumbers(numbers : String) -> String {\n", "entry_point": "sortNumbers", "test": "\n\nvar arg00 : String = #\"\"#\nvar x0 : String = sortNumbers(numbers : arg00)\nvar v0 : String = #\"\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"three\"#\nvar x1 : String = sortNumbers(numbers : arg10)\nvar v1 : String = #\"three\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"three five nine\"#\nvar x2 : String = sortNumbers(numbers : arg20)\nvar v2 : String = #\"three five nine\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"five zero four seven nine eight\"#\nvar x3 : String = sortNumbers(numbers : arg30)\nvar v3 : String = #\"zero four five seven eight nine\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"six five four three two one zero\"#\nvar x4 : String = sortNumbers(numbers : arg40)\nvar v4 : String = #\"zero one two three four five six\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Η είσοδος είναι μια συμβολοσειρά διαχωρισμένη με κενό από αριθμητικά χαρακτήρες από το 'μηδέν' έως το 'εννέα'.\n    Οι έγκυρες επιλογές είναι 'μηδέν', 'ένα', 'δύο', 'τρία', 'τέσσερα', 'πέντε', 'έξι', 'επτά', 'οκτώ' και 'εννέα'.\n    Επιστρέψτε τη συμβολοσειρά με τους αριθμούς ταξινομημένους από τον μικρότερο στον μεγαλύτερο.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/6", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Δεδομένης μιας λίστας αριθμών (τουλάχιστον δύο στοιχείων), εφαρμόστε μια γραμμική μετασχηματιστική λειτουργία σε αυτήν τη λίστα, έτσι ώστε ο μικρότερος αριθμός να γίνει 0 και ο μεγαλύτερος να γίνει 1.\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n *\n */\nfunc rescaleToUnit(numbers : [Double]) -> [Double] {\n", "entry_point": "rescaleToUnit", "test": "\n\nvar arg00 : [Double] = [2.0, 49.9]\nvar x0 : [Double] = rescaleToUnit(numbers : arg00)\nvar v0 : [Double] = [0.0, 1.0]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Double] = [100.0, 49.9]\nvar x1 : [Double] = rescaleToUnit(numbers : arg10)\nvar v1 : [Double] = [1.0, 0.0]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Double] = [1.0, 2.0, 3.0, 4.0, 5.0]\nvar x2 : [Double] = rescaleToUnit(numbers : arg20)\nvar v2 : [Double] = [0.0, 0.25, 0.5, 0.75, 1.0]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Double] = [2.0, 1.0, 5.0, 3.0, 4.0]\nvar x3 : [Double] = rescaleToUnit(numbers : arg30)\nvar v3 : [Double] = [0.25, 0.0, 1.0, 0.5, 0.75]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Double] = [12.0, 11.0, 15.0, 13.0, 14.0]\nvar x4 : [Double] = rescaleToUnit(numbers : arg40)\nvar v4 : [Double] = [0.25, 0.0, 1.0, 0.5, 0.75]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Δεδομένης μιας λίστας αριθμών (τουλάχιστον δύο στοιχείων), εφαρμόστε μια γραμμική μετασχηματιστική λειτουργία σε αυτήν τη λίστα, έτσι ώστε ο μικρότερος αριθμός να γίνει 0 και ο μεγαλύτερος να γίνει 1.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/7", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Για μια δεδομένη συμβολοσειρά, αντιστρέψτε τους πεζούς χαρακτήρες σε κεφαλαίους και τους κεφαλαίους σε πεζούς.\n * >>> flip_case('Hello')\n * 'hELLO'\n *\n */\nfunc flipCase(string : String) -> String {\n", "entry_point": "flipCase", "test": "\n\nvar arg00 : String = #\"\"#\nvar x0 : String = flipCase(string : arg00)\nvar v0 : String = #\"\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"Hello!\"#\nvar x1 : String = flipCase(string : arg10)\nvar v1 : String = #\"hELLO!\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"These violent delights have violent ends\"#\nvar x2 : String = flipCase(string : arg20)\nvar v2 : String = #\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\n", "description": "Για μια δεδομένη συμβολοσειρά, αντιστρέψτε τους πεζούς χαρακτήρες σε κεφαλαίους και τους κεφαλαίους σε πεζούς.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/8", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Επιστρέψτε μόνο θετικούς αριθμούς στη λίστα.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n *\n */\nfunc getPositive(l : [AnyHashable]) -> [AnyHashable] {\n", "entry_point": "getPositive", "test": "\n\nvar arg00 : [AnyHashable] = [-1, -2, 4, 5, 6]\nvar x0 : [AnyHashable] = getPositive(l : arg00)\nvar v0 : [AnyHashable] = [4, 5, 6]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]\nvar x1 : [AnyHashable] = getPositive(l : arg10)\nvar v1 : [AnyHashable] = [5, 3, 2, 3, 3, 9, 123, 1]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [-1, -2]\nvar x2 : [AnyHashable] = getPositive(l : arg20)\nvar v2 : [AnyHashable] = []\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = []\nvar x3 : [AnyHashable] = getPositive(l : arg30)\nvar v3 : [AnyHashable] = []\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "Επιστρέψτε μόνο θετικούς αριθμούς στη λίστα.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/9", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Επιστρέφει αληθές αν ένας δεδομένος αριθμός είναι πρώτος και ψευδές σε διαφορετική περίπτωση.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n *\n */\nfunc isPrime(n : Int) -> Bool {\n", "entry_point": "isPrime", "test": "\n\nvar arg00 : Int = 6\nvar x0 : Bool = isPrime(n : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 101\nvar x1 : Bool = isPrime(n : arg10)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 11\nvar x2 : Bool = isPrime(n : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 13441\nvar x3 : Bool = isPrime(n : arg30)\nvar v3 : Bool = true\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 61\nvar x4 : Bool = isPrime(n : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 4\nvar x5 : Bool = isPrime(n : arg50)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 1\nvar x6 : Bool = isPrime(n : arg60)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 5\nvar x7 : Bool = isPrime(n : arg70)\nvar v7 : Bool = true\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 11\nvar x8 : Bool = isPrime(n : arg80)\nvar v8 : Bool = true\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 17\nvar x9 : Bool = isPrime(n : arg90)\nvar v9 : Bool = true\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : Int = 85\nvar x10 : Bool = isPrime(n : arg100)\nvar v10 : Bool = false\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : Int = 77\nvar x11 : Bool = isPrime(n : arg110)\nvar v11 : Bool = false\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : Int = 255379\nvar x12 : Bool = isPrime(n : arg120)\nvar v12 : Bool = false\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\n", "description": "Επιστρέφει αληθές αν ένας δεδομένος αριθμός είναι πρώτος και ψευδές σε διαφορετική περίπτωση.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/10", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Επιστροφή ταξινομημένων μοναδικών στοιχείων σε μια λίστα.\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n *\n */\nfunc unique(l : [Int]) -> [Int] {\n", "entry_point": "unique", "test": "\n\nvar arg00 : [Int] = [5, 3, 5, 2, 3, 3, 9, 0, 123]\nvar x0 : [Int] = unique(l : arg00)\nvar v0 : [Int] = [0, 2, 3, 5, 9, 123]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\n", "description": "Επιστροφή ταξινομημένων μοναδικών στοιχείων σε μια λίστα.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/11", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Η prime_fib επιστρέφει τον n-οστό αριθμό που είναι Fibonacci και είναι επίσης πρώτος.\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n *\n */\nfunc primeFib(n : Int) -> Int {\n", "entry_point": "primeFib", "test": "\n\nvar arg00 : Int = 1\nvar x0 : Int = primeFib(n : arg00)\nvar v0 : Int = 2\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 2\nvar x1 : Int = primeFib(n : arg10)\nvar v1 : Int = 3\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 3\nvar x2 : Int = primeFib(n : arg20)\nvar v2 : Int = 5\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 4\nvar x3 : Int = primeFib(n : arg30)\nvar v3 : Int = 13\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 5\nvar x4 : Int = primeFib(n : arg40)\nvar v4 : Int = 89\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 6\nvar x5 : Int = primeFib(n : arg50)\nvar v5 : Int = 233\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 7\nvar x6 : Int = primeFib(n : arg60)\nvar v6 : Int = 1597\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 8\nvar x7 : Int = primeFib(n : arg70)\nvar v7 : Int = 28657\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 9\nvar x8 : Int = primeFib(n : arg80)\nvar v8 : Int = 514229\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 10\nvar x9 : Int = primeFib(n : arg90)\nvar v9 : Int = 433494437\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\n", "description": "Η prime_fib επιστρέφει τον n-οστό αριθμό που είναι Fibonacci και είναι επίσης πρώτος.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/12", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Η triples_sum_to_zero λαμβάνει μια λίστα ακεραίων ως είσοδο.\n *     επιστρέφει True αν υπάρχουν τρία διακριτά στοιχεία στη λίστα που\n *     άθροισμα τους είναι μηδέν, και False διαφορετικά.\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n *\n */\nfunc triplesSumToZero(l : [Int]) -> Bool {\n", "entry_point": "triplesSumToZero", "test": "\n\nvar arg00 : [Int] = [1, 3, 5, 0]\nvar x0 : Bool = triplesSumToZero(l : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 3, 5, -1]\nvar x1 : Bool = triplesSumToZero(l : arg10)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [1, 3, -2, 1]\nvar x2 : Bool = triplesSumToZero(l : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [1, 2, 3, 7]\nvar x3 : Bool = triplesSumToZero(l : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [1, 2, 5, 7]\nvar x4 : Bool = triplesSumToZero(l : arg40)\nvar v4 : Bool = false\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [2, 4, -5, 3, 9, 7]\nvar x5 : Bool = triplesSumToZero(l : arg50)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [1]\nvar x6 : Bool = triplesSumToZero(l : arg60)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Int] = [1, 3, 5, -100]\nvar x7 : Bool = triplesSumToZero(l : arg70)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [Int] = [100, 3, 5, -100]\nvar x8 : Bool = triplesSumToZero(l : arg80)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\n", "description": "Η triples_sum_to_zero λαμβάνει μια λίστα ακεραίων ως είσοδο.\n    επιστρέφει True αν υπάρχουν τρία διακριτά στοιχεία στη λίστα που\n    άθροισμα τους είναι μηδέν, και False διαφορετικά.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/13", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Η συνάρτηση pairs_sum_to_zero παίρνει μια λίστα ακεραίων ως είσοδο.\n *     Επιστρέφει True αν υπάρχουν δύο διακριτά στοιχεία στη λίστα που\n *     έχουν άθροισμα μηδέν, και False αλλιώς.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n *\n */\nfunc pairsSumToZero(l : [Int]) -> Bool {\n", "entry_point": "pairsSumToZero", "test": "\n\nvar arg00 : [Int] = [1, 3, 5, 0]\nvar x0 : Bool = pairsSumToZero(l : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 3, -2, 1]\nvar x1 : Bool = pairsSumToZero(l : arg10)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [1, 2, 3, 7]\nvar x2 : Bool = pairsSumToZero(l : arg20)\nvar v2 : Bool = false\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [2, 4, -5, 3, 5, 7]\nvar x3 : Bool = pairsSumToZero(l : arg30)\nvar v3 : Bool = true\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [1]\nvar x4 : Bool = pairsSumToZero(l : arg40)\nvar v4 : Bool = false\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [-3, 9, -1, 3, 2, 30]\nvar x5 : Bool = pairsSumToZero(l : arg50)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [-3, 9, -1, 3, 2, 31]\nvar x6 : Bool = pairsSumToZero(l : arg60)\nvar v6 : Bool = true\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Int] = [-3, 9, -1, 4, 2, 30]\nvar x7 : Bool = pairsSumToZero(l : arg70)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [Int] = [-3, 9, -1, 4, 2, 31]\nvar x8 : Bool = pairsSumToZero(l : arg80)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\n", "description": "Η συνάρτηση pairs_sum_to_zero παίρνει μια λίστα ακεραίων ως είσοδο.\n    Επιστρέφει True αν υπάρχουν δύο διακριτά στοιχεία στη λίστα που\n    έχουν άθροισμα μηδέν, και False αλλιώς.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/14", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Η ακολουθία αριθμών Fib4 είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n *     Παρακαλούμε γράψτε μια συνάρτηση για τον αποτελεσματικό υπολογισμό του n-οστού στοιχείου της ακολουθίας Fib4. Μην χρησιμοποιήσετε αναδρομή.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n *\n */\nfunc fib4(n : Int) -> Int {\n", "entry_point": "fib4", "test": "\n\nvar arg00 : Int = 5\nvar x0 : Int = fib4(n : arg00)\nvar v0 : Int = 4\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 8\nvar x1 : Int = fib4(n : arg10)\nvar v1 : Int = 28\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 10\nvar x2 : Int = fib4(n : arg20)\nvar v2 : Int = 104\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 12\nvar x3 : Int = fib4(n : arg30)\nvar v3 : Int = 386\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "Η ακολουθία αριθμών Fib4 είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Παρακαλούμε γράψτε μια συνάρτηση για τον αποτελεσματικό υπολογισμό του n-οστού στοιχείου της ακολουθίας Fib4. Μην χρησιμοποιήσετε αναδρομή.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/15", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Επιστροφή της μεσαίας τιμής των στοιχείων στη λίστα l.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n *\n */\nfunc median(l : [Int]) -> Double {\n", "entry_point": "median", "test": "\n\nvar arg00 : [Int] = [3, 1, 2, 4, 5]\nvar x0 : Double = median(l : arg00)\nvar v0 : Double = 3\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [-10, 4, 6, 1000, 10, 20]\nvar x1 : Double = median(l : arg10)\nvar v1 : Double = 8.0\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [5]\nvar x2 : Double = median(l : arg20)\nvar v2 : Double = 5\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [6, 5]\nvar x3 : Double = median(l : arg30)\nvar v3 : Double = 5.5\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [8, 1, 3, 9, 9, 2, 7]\nvar x4 : Double = median(l : arg40)\nvar v4 : Double = 7\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Επιστροφή της μεσαίας τιμής των στοιχείων στη λίστα l.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/16", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Ελέγχει αν η δοθείσα συμβολοσειρά είναι παλίνδρομη.\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n *\n */\nfunc isPalindrome(text : String) -> Bool {\n", "entry_point": "isPalindrome", "test": "\n\nvar arg00 : String = #\"\"#\nvar x0 : Bool = isPalindrome(text : arg00)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"aba\"#\nvar x1 : Bool = isPalindrome(text : arg10)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"aaaaa\"#\nvar x2 : Bool = isPalindrome(text : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"zbcd\"#\nvar x3 : Bool = isPalindrome(text : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"xywyx\"#\nvar x4 : Bool = isPalindrome(text : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"xywyz\"#\nvar x5 : Bool = isPalindrome(text : arg50)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"xywzx\"#\nvar x6 : Bool = isPalindrome(text : arg60)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Ελέγχει αν η δοθείσα συμβολοσειρά είναι παλίνδρομη.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/17", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Η remove_vowels είναι μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει το αλφαριθμητικό χωρίς φωνήεντα.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n *\n */\nfunc removeVowels(text : String) -> String {\n", "entry_point": "removeVowels", "test": "\n\nvar arg00 : String = #\"\"#\nvar x0 : String = removeVowels(text : arg00)\nvar v0 : String = #\"\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"abcdef\\nghijklm\"#\nvar x1 : String = removeVowels(text : arg10)\nvar v1 : String = #\"bcdf\\nghjklm\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"fedcba\"#\nvar x2 : String = removeVowels(text : arg20)\nvar v2 : String = #\"fdcb\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"eeeee\"#\nvar x3 : String = removeVowels(text : arg30)\nvar v3 : String = #\"\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"acBAA\"#\nvar x4 : String = removeVowels(text : arg40)\nvar v4 : String = #\"cB\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"EcBOO\"#\nvar x5 : String = removeVowels(text : arg50)\nvar v5 : String = #\"cB\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"ybcd\"#\nvar x6 : String = removeVowels(text : arg60)\nvar v6 : String = #\"ybcd\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Η remove_vowels είναι μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει το αλφαριθμητικό χωρίς φωνήεντα.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/18", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Επιστρέφει True αν όλοι οι αριθμοί στη λίστα l είναι κάτω από το κατώφλι t.\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n *\n */\nfunc belowThreshold(l : [Int], t : Int) -> Bool {\n", "entry_point": "belowThreshold", "test": "\n\nvar arg00 : [Int] = [1, 2, 4, 10]\nvar arg01 : Int = 100\nvar x0 : Bool = belowThreshold(l : arg00, t : arg01)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 20, 4, 10]\nvar arg11 : Int = 5\nvar x1 : Bool = belowThreshold(l : arg10, t : arg11)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [1, 20, 4, 10]\nvar arg21 : Int = 21\nvar x2 : Bool = belowThreshold(l : arg20, t : arg21)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [1, 20, 4, 10]\nvar arg31 : Int = 22\nvar x3 : Bool = belowThreshold(l : arg30, t : arg31)\nvar v3 : Bool = true\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [1, 8, 4, 10]\nvar arg41 : Int = 11\nvar x4 : Bool = belowThreshold(l : arg40, t : arg41)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [1, 8, 4, 10]\nvar arg51 : Int = 10\nvar x5 : Bool = belowThreshold(l : arg50, t : arg51)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "Επιστρέφει True αν όλοι οι αριθμοί στη λίστα l είναι κάτω από το κατώφλι t.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/19", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Προσθέστε δύο αριθμούς x και y.\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n *\n */\nfunc add(x : Int, y : Int) -> Int {\n", "entry_point": "add", "test": "\n\nvar arg00 : Int = 0\nvar arg01 : Int = 1\nvar x0 : Int = add(x : arg00, y : arg01)\nvar v0 : Int = 1\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 1\nvar arg11 : Int = 0\nvar x1 : Int = add(x : arg10, y : arg11)\nvar v1 : Int = 1\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 2\nvar arg21 : Int = 3\nvar x2 : Int = add(x : arg20, y : arg21)\nvar v2 : Int = 5\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 5\nvar arg31 : Int = 7\nvar x3 : Int = add(x : arg30, y : arg31)\nvar v3 : Int = 12\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 7\nvar arg41 : Int = 5\nvar x4 : Int = add(x : arg40, y : arg41)\nvar v4 : Int = 12\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 572\nvar arg51 : Int = 725\nvar x5 : Int = add(x : arg50, y : arg51)\nvar v5 : Int = 1297\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 51\nvar arg61 : Int = 804\nvar x6 : Int = add(x : arg60, y : arg61)\nvar v6 : Int = 855\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 645\nvar arg71 : Int = 96\nvar x7 : Int = add(x : arg70, y : arg71)\nvar v7 : Int = 741\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 712\nvar arg81 : Int = 853\nvar x8 : Int = add(x : arg80, y : arg81)\nvar v8 : Int = 1565\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 223\nvar arg91 : Int = 101\nvar x9 : Int = add(x : arg90, y : arg91)\nvar v9 : Int = 324\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : Int = 76\nvar arg101 : Int = 29\nvar x10 : Int = add(x : arg100, y : arg101)\nvar v10 : Int = 105\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : Int = 416\nvar arg111 : Int = 149\nvar x11 : Int = add(x : arg110, y : arg111)\nvar v11 : Int = 565\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : Int = 145\nvar arg121 : Int = 409\nvar x12 : Int = add(x : arg120, y : arg121)\nvar v12 : Int = 554\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\nvar arg130 : Int = 535\nvar arg131 : Int = 430\nvar x13 : Int = add(x : arg130, y : arg131)\nvar v13 : Int = 965\nassert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \")\n\nvar arg140 : Int = 118\nvar arg141 : Int = 303\nvar x14 : Int = add(x : arg140, y : arg141)\nvar v14 : Int = 421\nassert(x14 == v14, \"Exception -- test case 14 did not pass. x14 = \")\n\nvar arg150 : Int = 287\nvar arg151 : Int = 94\nvar x15 : Int = add(x : arg150, y : arg151)\nvar v15 : Int = 381\nassert(x15 == v15, \"Exception -- test case 15 did not pass. x15 = \")\n\nvar arg160 : Int = 768\nvar arg161 : Int = 257\nvar x16 : Int = add(x : arg160, y : arg161)\nvar v16 : Int = 1025\nassert(x16 == v16, \"Exception -- test case 16 did not pass. x16 = \")\n\nvar arg170 : Int = 421\nvar arg171 : Int = 677\nvar x17 : Int = add(x : arg170, y : arg171)\nvar v17 : Int = 1098\nassert(x17 == v17, \"Exception -- test case 17 did not pass. x17 = \")\n\nvar arg180 : Int = 802\nvar arg181 : Int = 814\nvar x18 : Int = add(x : arg180, y : arg181)\nvar v18 : Int = 1616\nassert(x18 == v18, \"Exception -- test case 18 did not pass. x18 = \")\n\nvar arg190 : Int = 510\nvar arg191 : Int = 922\nvar x19 : Int = add(x : arg190, y : arg191)\nvar v19 : Int = 1432\nassert(x19 == v19, \"Exception -- test case 19 did not pass. x19 = \")\n\nvar arg200 : Int = 345\nvar arg201 : Int = 819\nvar x20 : Int = add(x : arg200, y : arg201)\nvar v20 : Int = 1164\nassert(x20 == v20, \"Exception -- test case 20 did not pass. x20 = \")\n\nvar arg210 : Int = 895\nvar arg211 : Int = 436\nvar x21 : Int = add(x : arg210, y : arg211)\nvar v21 : Int = 1331\nassert(x21 == v21, \"Exception -- test case 21 did not pass. x21 = \")\n\nvar arg220 : Int = 123\nvar arg221 : Int = 424\nvar x22 : Int = add(x : arg220, y : arg221)\nvar v22 : Int = 547\nassert(x22 == v22, \"Exception -- test case 22 did not pass. x22 = \")\n\nvar arg230 : Int = 923\nvar arg231 : Int = 245\nvar x23 : Int = add(x : arg230, y : arg231)\nvar v23 : Int = 1168\nassert(x23 == v23, \"Exception -- test case 23 did not pass. x23 = \")\n\nvar arg240 : Int = 23\nvar arg241 : Int = 438\nvar x24 : Int = add(x : arg240, y : arg241)\nvar v24 : Int = 461\nassert(x24 == v24, \"Exception -- test case 24 did not pass. x24 = \")\n\nvar arg250 : Int = 565\nvar arg251 : Int = 133\nvar x25 : Int = add(x : arg250, y : arg251)\nvar v25 : Int = 698\nassert(x25 == v25, \"Exception -- test case 25 did not pass. x25 = \")\n\nvar arg260 : Int = 945\nvar arg261 : Int = 925\nvar x26 : Int = add(x : arg260, y : arg261)\nvar v26 : Int = 1870\nassert(x26 == v26, \"Exception -- test case 26 did not pass. x26 = \")\n\nvar arg270 : Int = 261\nvar arg271 : Int = 983\nvar x27 : Int = add(x : arg270, y : arg271)\nvar v27 : Int = 1244\nassert(x27 == v27, \"Exception -- test case 27 did not pass. x27 = \")\n\nvar arg280 : Int = 139\nvar arg281 : Int = 577\nvar x28 : Int = add(x : arg280, y : arg281)\nvar v28 : Int = 716\nassert(x28 == v28, \"Exception -- test case 28 did not pass. x28 = \")\n\nvar arg290 : Int = 763\nvar arg291 : Int = 178\nvar x29 : Int = add(x : arg290, y : arg291)\nvar v29 : Int = 941\nassert(x29 == v29, \"Exception -- test case 29 did not pass. x29 = \")\n\nvar arg300 : Int = 147\nvar arg301 : Int = 892\nvar x30 : Int = add(x : arg300, y : arg301)\nvar v30 : Int = 1039\nassert(x30 == v30, \"Exception -- test case 30 did not pass. x30 = \")\n\nvar arg310 : Int = 436\nvar arg311 : Int = 402\nvar x31 : Int = add(x : arg310, y : arg311)\nvar v31 : Int = 838\nassert(x31 == v31, \"Exception -- test case 31 did not pass. x31 = \")\n\nvar arg320 : Int = 610\nvar arg321 : Int = 581\nvar x32 : Int = add(x : arg320, y : arg321)\nvar v32 : Int = 1191\nassert(x32 == v32, \"Exception -- test case 32 did not pass. x32 = \")\n\nvar arg330 : Int = 103\nvar arg331 : Int = 416\nvar x33 : Int = add(x : arg330, y : arg331)\nvar v33 : Int = 519\nassert(x33 == v33, \"Exception -- test case 33 did not pass. x33 = \")\n\nvar arg340 : Int = 339\nvar arg341 : Int = 990\nvar x34 : Int = add(x : arg340, y : arg341)\nvar v34 : Int = 1329\nassert(x34 == v34, \"Exception -- test case 34 did not pass. x34 = \")\n\nvar arg350 : Int = 130\nvar arg351 : Int = 504\nvar x35 : Int = add(x : arg350, y : arg351)\nvar v35 : Int = 634\nassert(x35 == v35, \"Exception -- test case 35 did not pass. x35 = \")\n\nvar arg360 : Int = 242\nvar arg361 : Int = 717\nvar x36 : Int = add(x : arg360, y : arg361)\nvar v36 : Int = 959\nassert(x36 == v36, \"Exception -- test case 36 did not pass. x36 = \")\n\nvar arg370 : Int = 562\nvar arg371 : Int = 110\nvar x37 : Int = add(x : arg370, y : arg371)\nvar v37 : Int = 672\nassert(x37 == v37, \"Exception -- test case 37 did not pass. x37 = \")\n\nvar arg380 : Int = 396\nvar arg381 : Int = 909\nvar x38 : Int = add(x : arg380, y : arg381)\nvar v38 : Int = 1305\nassert(x38 == v38, \"Exception -- test case 38 did not pass. x38 = \")\n\nvar arg390 : Int = 887\nvar arg391 : Int = 703\nvar x39 : Int = add(x : arg390, y : arg391)\nvar v39 : Int = 1590\nassert(x39 == v39, \"Exception -- test case 39 did not pass. x39 = \")\n\nvar arg400 : Int = 870\nvar arg401 : Int = 551\nvar x40 : Int = add(x : arg400, y : arg401)\nvar v40 : Int = 1421\nassert(x40 == v40, \"Exception -- test case 40 did not pass. x40 = \")\n\nvar arg410 : Int = 422\nvar arg411 : Int = 391\nvar x41 : Int = add(x : arg410, y : arg411)\nvar v41 : Int = 813\nassert(x41 == v41, \"Exception -- test case 41 did not pass. x41 = \")\n\nvar arg420 : Int = 299\nvar arg421 : Int = 505\nvar x42 : Int = add(x : arg420, y : arg421)\nvar v42 : Int = 804\nassert(x42 == v42, \"Exception -- test case 42 did not pass. x42 = \")\n\nvar arg430 : Int = 346\nvar arg431 : Int = 56\nvar x43 : Int = add(x : arg430, y : arg431)\nvar v43 : Int = 402\nassert(x43 == v43, \"Exception -- test case 43 did not pass. x43 = \")\n\nvar arg440 : Int = 36\nvar arg441 : Int = 706\nvar x44 : Int = add(x : arg440, y : arg441)\nvar v44 : Int = 742\nassert(x44 == v44, \"Exception -- test case 44 did not pass. x44 = \")\n\nvar arg450 : Int = 738\nvar arg451 : Int = 411\nvar x45 : Int = add(x : arg450, y : arg451)\nvar v45 : Int = 1149\nassert(x45 == v45, \"Exception -- test case 45 did not pass. x45 = \")\n\nvar arg460 : Int = 679\nvar arg461 : Int = 87\nvar x46 : Int = add(x : arg460, y : arg461)\nvar v46 : Int = 766\nassert(x46 == v46, \"Exception -- test case 46 did not pass. x46 = \")\n\nvar arg470 : Int = 25\nvar arg471 : Int = 303\nvar x47 : Int = add(x : arg470, y : arg471)\nvar v47 : Int = 328\nassert(x47 == v47, \"Exception -- test case 47 did not pass. x47 = \")\n\nvar arg480 : Int = 161\nvar arg481 : Int = 612\nvar x48 : Int = add(x : arg480, y : arg481)\nvar v48 : Int = 773\nassert(x48 == v48, \"Exception -- test case 48 did not pass. x48 = \")\n\nvar arg490 : Int = 306\nvar arg491 : Int = 841\nvar x49 : Int = add(x : arg490, y : arg491)\nvar v49 : Int = 1147\nassert(x49 == v49, \"Exception -- test case 49 did not pass. x49 = \")\n\nvar arg500 : Int = 973\nvar arg501 : Int = 411\nvar x50 : Int = add(x : arg500, y : arg501)\nvar v50 : Int = 1384\nassert(x50 == v50, \"Exception -- test case 50 did not pass. x50 = \")\n\nvar arg510 : Int = 711\nvar arg511 : Int = 157\nvar x51 : Int = add(x : arg510, y : arg511)\nvar v51 : Int = 868\nassert(x51 == v51, \"Exception -- test case 51 did not pass. x51 = \")\n\nvar arg520 : Int = 471\nvar arg521 : Int = 27\nvar x52 : Int = add(x : arg520, y : arg521)\nvar v52 : Int = 498\nassert(x52 == v52, \"Exception -- test case 52 did not pass. x52 = \")\n\nvar arg530 : Int = 714\nvar arg531 : Int = 792\nvar x53 : Int = add(x : arg530, y : arg531)\nvar v53 : Int = 1506\nassert(x53 == v53, \"Exception -- test case 53 did not pass. x53 = \")\n\nvar arg540 : Int = 38\nvar arg541 : Int = 206\nvar x54 : Int = add(x : arg540, y : arg541)\nvar v54 : Int = 244\nassert(x54 == v54, \"Exception -- test case 54 did not pass. x54 = \")\n\nvar arg550 : Int = 907\nvar arg551 : Int = 343\nvar x55 : Int = add(x : arg550, y : arg551)\nvar v55 : Int = 1250\nassert(x55 == v55, \"Exception -- test case 55 did not pass. x55 = \")\n\nvar arg560 : Int = 23\nvar arg561 : Int = 760\nvar x56 : Int = add(x : arg560, y : arg561)\nvar v56 : Int = 783\nassert(x56 == v56, \"Exception -- test case 56 did not pass. x56 = \")\n\nvar arg570 : Int = 524\nvar arg571 : Int = 859\nvar x57 : Int = add(x : arg570, y : arg571)\nvar v57 : Int = 1383\nassert(x57 == v57, \"Exception -- test case 57 did not pass. x57 = \")\n\nvar arg580 : Int = 30\nvar arg581 : Int = 529\nvar x58 : Int = add(x : arg580, y : arg581)\nvar v58 : Int = 559\nassert(x58 == v58, \"Exception -- test case 58 did not pass. x58 = \")\n\nvar arg590 : Int = 341\nvar arg591 : Int = 691\nvar x59 : Int = add(x : arg590, y : arg591)\nvar v59 : Int = 1032\nassert(x59 == v59, \"Exception -- test case 59 did not pass. x59 = \")\n\nvar arg600 : Int = 167\nvar arg601 : Int = 729\nvar x60 : Int = add(x : arg600, y : arg601)\nvar v60 : Int = 896\nassert(x60 == v60, \"Exception -- test case 60 did not pass. x60 = \")\n\nvar arg610 : Int = 636\nvar arg611 : Int = 289\nvar x61 : Int = add(x : arg610, y : arg611)\nvar v61 : Int = 925\nassert(x61 == v61, \"Exception -- test case 61 did not pass. x61 = \")\n\nvar arg620 : Int = 503\nvar arg621 : Int = 144\nvar x62 : Int = add(x : arg620, y : arg621)\nvar v62 : Int = 647\nassert(x62 == v62, \"Exception -- test case 62 did not pass. x62 = \")\n\nvar arg630 : Int = 51\nvar arg631 : Int = 985\nvar x63 : Int = add(x : arg630, y : arg631)\nvar v63 : Int = 1036\nassert(x63 == v63, \"Exception -- test case 63 did not pass. x63 = \")\n\nvar arg640 : Int = 287\nvar arg641 : Int = 149\nvar x64 : Int = add(x : arg640, y : arg641)\nvar v64 : Int = 436\nassert(x64 == v64, \"Exception -- test case 64 did not pass. x64 = \")\n\nvar arg650 : Int = 659\nvar arg651 : Int = 75\nvar x65 : Int = add(x : arg650, y : arg651)\nvar v65 : Int = 734\nassert(x65 == v65, \"Exception -- test case 65 did not pass. x65 = \")\n\nvar arg660 : Int = 462\nvar arg661 : Int = 797\nvar x66 : Int = add(x : arg660, y : arg661)\nvar v66 : Int = 1259\nassert(x66 == v66, \"Exception -- test case 66 did not pass. x66 = \")\n\nvar arg670 : Int = 406\nvar arg671 : Int = 141\nvar x67 : Int = add(x : arg670, y : arg671)\nvar v67 : Int = 547\nassert(x67 == v67, \"Exception -- test case 67 did not pass. x67 = \")\n\nvar arg680 : Int = 106\nvar arg681 : Int = 44\nvar x68 : Int = add(x : arg680, y : arg681)\nvar v68 : Int = 150\nassert(x68 == v68, \"Exception -- test case 68 did not pass. x68 = \")\n\nvar arg690 : Int = 300\nvar arg691 : Int = 934\nvar x69 : Int = add(x : arg690, y : arg691)\nvar v69 : Int = 1234\nassert(x69 == v69, \"Exception -- test case 69 did not pass. x69 = \")\n\nvar arg700 : Int = 471\nvar arg701 : Int = 524\nvar x70 : Int = add(x : arg700, y : arg701)\nvar v70 : Int = 995\nassert(x70 == v70, \"Exception -- test case 70 did not pass. x70 = \")\n\nvar arg710 : Int = 122\nvar arg711 : Int = 429\nvar x71 : Int = add(x : arg710, y : arg711)\nvar v71 : Int = 551\nassert(x71 == v71, \"Exception -- test case 71 did not pass. x71 = \")\n\nvar arg720 : Int = 735\nvar arg721 : Int = 195\nvar x72 : Int = add(x : arg720, y : arg721)\nvar v72 : Int = 930\nassert(x72 == v72, \"Exception -- test case 72 did not pass. x72 = \")\n\nvar arg730 : Int = 335\nvar arg731 : Int = 484\nvar x73 : Int = add(x : arg730, y : arg731)\nvar v73 : Int = 819\nassert(x73 == v73, \"Exception -- test case 73 did not pass. x73 = \")\n\nvar arg740 : Int = 28\nvar arg741 : Int = 809\nvar x74 : Int = add(x : arg740, y : arg741)\nvar v74 : Int = 837\nassert(x74 == v74, \"Exception -- test case 74 did not pass. x74 = \")\n\nvar arg750 : Int = 430\nvar arg751 : Int = 20\nvar x75 : Int = add(x : arg750, y : arg751)\nvar v75 : Int = 450\nassert(x75 == v75, \"Exception -- test case 75 did not pass. x75 = \")\n\nvar arg760 : Int = 916\nvar arg761 : Int = 635\nvar x76 : Int = add(x : arg760, y : arg761)\nvar v76 : Int = 1551\nassert(x76 == v76, \"Exception -- test case 76 did not pass. x76 = \")\n\nvar arg770 : Int = 301\nvar arg771 : Int = 999\nvar x77 : Int = add(x : arg770, y : arg771)\nvar v77 : Int = 1300\nassert(x77 == v77, \"Exception -- test case 77 did not pass. x77 = \")\n\nvar arg780 : Int = 454\nvar arg781 : Int = 466\nvar x78 : Int = add(x : arg780, y : arg781)\nvar v78 : Int = 920\nassert(x78 == v78, \"Exception -- test case 78 did not pass. x78 = \")\n\nvar arg790 : Int = 905\nvar arg791 : Int = 259\nvar x79 : Int = add(x : arg790, y : arg791)\nvar v79 : Int = 1164\nassert(x79 == v79, \"Exception -- test case 79 did not pass. x79 = \")\n\nvar arg800 : Int = 168\nvar arg801 : Int = 205\nvar x80 : Int = add(x : arg800, y : arg801)\nvar v80 : Int = 373\nassert(x80 == v80, \"Exception -- test case 80 did not pass. x80 = \")\n\nvar arg810 : Int = 570\nvar arg811 : Int = 434\nvar x81 : Int = add(x : arg810, y : arg811)\nvar v81 : Int = 1004\nassert(x81 == v81, \"Exception -- test case 81 did not pass. x81 = \")\n\nvar arg820 : Int = 64\nvar arg821 : Int = 959\nvar x82 : Int = add(x : arg820, y : arg821)\nvar v82 : Int = 1023\nassert(x82 == v82, \"Exception -- test case 82 did not pass. x82 = \")\n\nvar arg830 : Int = 957\nvar arg831 : Int = 510\nvar x83 : Int = add(x : arg830, y : arg831)\nvar v83 : Int = 1467\nassert(x83 == v83, \"Exception -- test case 83 did not pass. x83 = \")\n\nvar arg840 : Int = 722\nvar arg841 : Int = 598\nvar x84 : Int = add(x : arg840, y : arg841)\nvar v84 : Int = 1320\nassert(x84 == v84, \"Exception -- test case 84 did not pass. x84 = \")\n\nvar arg850 : Int = 770\nvar arg851 : Int = 226\nvar x85 : Int = add(x : arg850, y : arg851)\nvar v85 : Int = 996\nassert(x85 == v85, \"Exception -- test case 85 did not pass. x85 = \")\n\nvar arg860 : Int = 579\nvar arg861 : Int = 66\nvar x86 : Int = add(x : arg860, y : arg861)\nvar v86 : Int = 645\nassert(x86 == v86, \"Exception -- test case 86 did not pass. x86 = \")\n\nvar arg870 : Int = 117\nvar arg871 : Int = 674\nvar x87 : Int = add(x : arg870, y : arg871)\nvar v87 : Int = 791\nassert(x87 == v87, \"Exception -- test case 87 did not pass. x87 = \")\n\nvar arg880 : Int = 530\nvar arg881 : Int = 30\nvar x88 : Int = add(x : arg880, y : arg881)\nvar v88 : Int = 560\nassert(x88 == v88, \"Exception -- test case 88 did not pass. x88 = \")\n\nvar arg890 : Int = 776\nvar arg891 : Int = 345\nvar x89 : Int = add(x : arg890, y : arg891)\nvar v89 : Int = 1121\nassert(x89 == v89, \"Exception -- test case 89 did not pass. x89 = \")\n\nvar arg900 : Int = 327\nvar arg901 : Int = 389\nvar x90 : Int = add(x : arg900, y : arg901)\nvar v90 : Int = 716\nassert(x90 == v90, \"Exception -- test case 90 did not pass. x90 = \")\n\nvar arg910 : Int = 596\nvar arg911 : Int = 12\nvar x91 : Int = add(x : arg910, y : arg911)\nvar v91 : Int = 608\nassert(x91 == v91, \"Exception -- test case 91 did not pass. x91 = \")\n\nvar arg920 : Int = 599\nvar arg921 : Int = 511\nvar x92 : Int = add(x : arg920, y : arg921)\nvar v92 : Int = 1110\nassert(x92 == v92, \"Exception -- test case 92 did not pass. x92 = \")\n\nvar arg930 : Int = 936\nvar arg931 : Int = 476\nvar x93 : Int = add(x : arg930, y : arg931)\nvar v93 : Int = 1412\nassert(x93 == v93, \"Exception -- test case 93 did not pass. x93 = \")\n\nvar arg940 : Int = 461\nvar arg941 : Int = 14\nvar x94 : Int = add(x : arg940, y : arg941)\nvar v94 : Int = 475\nassert(x94 == v94, \"Exception -- test case 94 did not pass. x94 = \")\n\nvar arg950 : Int = 966\nvar arg951 : Int = 157\nvar x95 : Int = add(x : arg950, y : arg951)\nvar v95 : Int = 1123\nassert(x95 == v95, \"Exception -- test case 95 did not pass. x95 = \")\n\nvar arg960 : Int = 326\nvar arg961 : Int = 91\nvar x96 : Int = add(x : arg960, y : arg961)\nvar v96 : Int = 417\nassert(x96 == v96, \"Exception -- test case 96 did not pass. x96 = \")\n\nvar arg970 : Int = 392\nvar arg971 : Int = 455\nvar x97 : Int = add(x : arg970, y : arg971)\nvar v97 : Int = 847\nassert(x97 == v97, \"Exception -- test case 97 did not pass. x97 = \")\n\nvar arg980 : Int = 446\nvar arg981 : Int = 477\nvar x98 : Int = add(x : arg980, y : arg981)\nvar v98 : Int = 923\nassert(x98 == v98, \"Exception -- test case 98 did not pass. x98 = \")\n\nvar arg990 : Int = 324\nvar arg991 : Int = 860\nvar x99 : Int = add(x : arg990, y : arg991)\nvar v99 : Int = 1184\nassert(x99 == v99, \"Exception -- test case 99 did not pass. x99 = \")\n\nvar arg1000 : Int = 945\nvar arg1001 : Int = 85\nvar x100 : Int = add(x : arg1000, y : arg1001)\nvar v100 : Int = 1030\nassert(x100 == v100, \"Exception -- test case 100 did not pass. x100 = \")\n\nvar arg1010 : Int = 886\nvar arg1011 : Int = 582\nvar x101 : Int = add(x : arg1010, y : arg1011)\nvar v101 : Int = 1468\nassert(x101 == v101, \"Exception -- test case 101 did not pass. x101 = \")\n\nvar arg1020 : Int = 886\nvar arg1021 : Int = 712\nvar x102 : Int = add(x : arg1020, y : arg1021)\nvar v102 : Int = 1598\nassert(x102 == v102, \"Exception -- test case 102 did not pass. x102 = \")\n\nvar arg1030 : Int = 842\nvar arg1031 : Int = 953\nvar x103 : Int = add(x : arg1030, y : arg1031)\nvar v103 : Int = 1795\nassert(x103 == v103, \"Exception -- test case 103 did not pass. x103 = \")\n\n", "description": "Προσθέστε δύο αριθμούς x και y.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/20", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Ελέγξτε αν δύο λέξεις έχουν τους ίδιους χαρακτήρες.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n *\n */\nfunc sameChars(s0 : String, s1 : String) -> Bool {\n", "entry_point": "sameChars", "test": "\n\nvar arg00 : String = #\"eabcdzzzz\"#\nvar arg01 : String = #\"dddzzzzzzzddeddabc\"#\nvar x0 : Bool = sameChars(s0 : arg00, s1 : arg01)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"abcd\"#\nvar arg11 : String = #\"dddddddabc\"#\nvar x1 : Bool = sameChars(s0 : arg10, s1 : arg11)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"dddddddabc\"#\nvar arg21 : String = #\"abcd\"#\nvar x2 : Bool = sameChars(s0 : arg20, s1 : arg21)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"eabcd\"#\nvar arg31 : String = #\"dddddddabc\"#\nvar x3 : Bool = sameChars(s0 : arg30, s1 : arg31)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"abcd\"#\nvar arg41 : String = #\"dddddddabcf\"#\nvar x4 : Bool = sameChars(s0 : arg40, s1 : arg41)\nvar v4 : Bool = false\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"eabcdzzzz\"#\nvar arg51 : String = #\"dddzzzzzzzddddabc\"#\nvar x5 : Bool = sameChars(s0 : arg50, s1 : arg51)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"aabb\"#\nvar arg61 : String = #\"aaccc\"#\nvar x6 : Bool = sameChars(s0 : arg60, s1 : arg61)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Ελέγξτε αν δύο λέξεις έχουν τους ίδιους χαρακτήρες.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/21", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Επιστροφή του n-οστού αριθμού Fibonacci.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n *\n */\nfunc fib(n : Int) -> Int {\n", "entry_point": "fib", "test": "\n\nvar arg00 : Int = 10\nvar x0 : Int = fib(n : arg00)\nvar v0 : Int = 55\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 1\nvar x1 : Int = fib(n : arg10)\nvar v1 : Int = 1\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 8\nvar x2 : Int = fib(n : arg20)\nvar v2 : Int = 21\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 11\nvar x3 : Int = fib(n : arg30)\nvar v3 : Int = 89\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 12\nvar x4 : Int = fib(n : arg40)\nvar v4 : Int = 144\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Επιστροφή του n-οστού αριθμού Fibonacci.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/22", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Επιστροφή ταξινομημένων μοναδικών κοινών στοιχείων για δύο λίστες.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n\n *\n */\nfunc common(l1 : [Int], l2 : [AnyHashable]) -> [AnyHashable] {\n", "entry_point": "common", "test": "\n\nvar arg00 : [Int] = [1, 4, 3, 34, 653, 2, 5]\nvar arg01 : [AnyHashable] = [5, 7, 1, 5, 9, 653, 121]\nvar x0 : [AnyHashable] = common(l1 : arg00, l2 : arg01)\nvar v0 : [AnyHashable] = [1, 5, 653]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [5, 3, 2, 8]\nvar arg11 : [AnyHashable] = [3, 2]\nvar x1 : [AnyHashable] = common(l1 : arg10, l2 : arg11)\nvar v1 : [AnyHashable] = [2, 3]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [4, 3, 2, 8]\nvar arg21 : [AnyHashable] = [3, 2, 4]\nvar x2 : [AnyHashable] = common(l1 : arg20, l2 : arg21)\nvar v2 : [AnyHashable] = [2, 3, 4]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [4, 3, 2, 8]\nvar arg31 : [AnyHashable] = []\nvar x3 : [AnyHashable] = common(l1 : arg30, l2 : arg31)\nvar v3 : [AnyHashable] = []\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "Επιστροφή ταξινομημένων μοναδικών κοινών στοιχείων για δύο λίστες.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/23", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Επιστρέφει το μεγαλύτερο πρώτο παράγοντα του n. Υποθέτουμε ότι το n > 1 και δεν είναι πρώτος.\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n *\n */\nfunc largestPrimeFactor(n : Int) -> Int {\n", "entry_point": "largestPrimeFactor", "test": "\n\nvar arg00 : Int = 15\nvar x0 : Int = largestPrimeFactor(n : arg00)\nvar v0 : Int = 5\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 27\nvar x1 : Int = largestPrimeFactor(n : arg10)\nvar v1 : Int = 3\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 63\nvar x2 : Int = largestPrimeFactor(n : arg20)\nvar v2 : Int = 7\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 330\nvar x3 : Int = largestPrimeFactor(n : arg30)\nvar v3 : Int = 11\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 13195\nvar x4 : Int = largestPrimeFactor(n : arg40)\nvar v4 : Int = 29\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Επιστρέφει το μεγαλύτερο πρώτο παράγοντα του n. Υποθέτουμε ότι το n > 1 και δεν είναι πρώτος.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/24", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Η sum_to_n είναι μια συνάρτηση που αθροίζει αριθμούς από το 1 έως το n.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n *\n */\nfunc sumToN(n : Int) -> Int {\n", "entry_point": "sumToN", "test": "\n\nvar arg00 : Int = 1\nvar x0 : Int = sumToN(n : arg00)\nvar v0 : Int = 1\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 6\nvar x1 : Int = sumToN(n : arg10)\nvar v1 : Int = 21\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 11\nvar x2 : Int = sumToN(n : arg20)\nvar v2 : Int = 66\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 30\nvar x3 : Int = sumToN(n : arg30)\nvar v3 : Int = 465\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 100\nvar x4 : Int = sumToN(n : arg40)\nvar v4 : Int = 5050\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Η sum_to_n είναι μια συνάρτηση που αθροίζει αριθμούς από το 1 έως το n.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/25", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Οι xs αντιπροσωπεύουν τους συντελεστές ενός πολυωνύμου.\n *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n *     Επιστρέφει την παράγωγο αυτού του πολυωνύμου στην ίδια μορφή.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n *\n */\nfunc derivative(xs : [Int]) -> [AnyHashable] {\n", "entry_point": "derivative", "test": "\n\nvar arg00 : [Int] = [3, 1, 2, 4, 5]\nvar x0 : [AnyHashable] = derivative(xs : arg00)\nvar v0 : [AnyHashable] = [1, 4, 12, 20]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 2, 3]\nvar x1 : [AnyHashable] = derivative(xs : arg10)\nvar v1 : [AnyHashable] = [2, 6]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [3, 2, 1]\nvar x2 : [AnyHashable] = derivative(xs : arg20)\nvar v2 : [AnyHashable] = [2, 2]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [3, 2, 1, 0, 4]\nvar x3 : [AnyHashable] = derivative(xs : arg30)\nvar v3 : [AnyHashable] = [2, 2, 0, 16]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [1]\nvar x4 : [AnyHashable] = derivative(xs : arg40)\nvar v4 : [AnyHashable] = []\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Οι xs αντιπροσωπεύουν τους συντελεστές ενός πολυωνύμου.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Επιστρέφει την παράγωγο αυτού του πολυωνύμου στην ίδια μορφή.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/26", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Η ακολουθία αριθμών FibFib είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n *     fibfib(0) == 0\n *     fibfib(1) == 0\n *     fibfib(2) == 1\n *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n *     Παρακαλούμε γράψτε μια συνάρτηση για τον αποδοτικό υπολογισμό του n-οστού στοιχείου της ακολουθίας αριθμών FibFib.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n *\n */\nfunc fibfib(n : Int) -> Int {\n", "entry_point": "fibfib", "test": "\n\nvar arg00 : Int = 2\nvar x0 : Int = fibfib(n : arg00)\nvar v0 : Int = 1\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 1\nvar x1 : Int = fibfib(n : arg10)\nvar v1 : Int = 0\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 5\nvar x2 : Int = fibfib(n : arg20)\nvar v2 : Int = 4\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 8\nvar x3 : Int = fibfib(n : arg30)\nvar v3 : Int = 24\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 10\nvar x4 : Int = fibfib(n : arg40)\nvar v4 : Int = 81\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 12\nvar x5 : Int = fibfib(n : arg50)\nvar v5 : Int = 274\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 14\nvar x6 : Int = fibfib(n : arg60)\nvar v6 : Int = 927\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Η ακολουθία αριθμών FibFib είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Παρακαλούμε γράψτε μια συνάρτηση για τον αποδοτικό υπολογισμό του n-οστού στοιχείου της ακολουθίας αριθμών FibFib.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/27", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Γράψτε μια συνάρτηση vowels_count η οποία παίρνει ως είσοδο μια συμβολοσειρά που αναπαριστά ένα λέξη και επιστρέφει τον αριθμό των φωνηέντων στη συμβολοσειρά. Τα φωνήεντα σε αυτήν την περίπτωση είναι 'a', 'e', 'i', 'o', 'u'. Εδώ, το 'y' είναι επίσης ένα φωνήεν, αλλά μόνο όταν βρίσκεται στο τέλος της δοθείσας λέξης.\n * \n * Παράδειγμα:\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n *\n */\nfunc vowelsCount(s : String) -> Int {\n", "entry_point": "vowelsCount", "test": "\n\nvar arg00 : String = #\"abcde\"#\nvar x0 : Int = vowelsCount(s : arg00)\nvar v0 : Int = 2\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"Alone\"#\nvar x1 : Int = vowelsCount(s : arg10)\nvar v1 : Int = 3\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"key\"#\nvar x2 : Int = vowelsCount(s : arg20)\nvar v2 : Int = 2\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"bye\"#\nvar x3 : Int = vowelsCount(s : arg30)\nvar v3 : Int = 1\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"keY\"#\nvar x4 : Int = vowelsCount(s : arg40)\nvar v4 : Int = 2\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"bYe\"#\nvar x5 : Int = vowelsCount(s : arg50)\nvar v5 : Int = 1\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"ACEDY\"#\nvar x6 : Int = vowelsCount(s : arg60)\nvar v6 : Int = 3\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Γράψτε μια συνάρτηση vowels_count η οποία παίρνει ως είσοδο μια συμβολοσειρά που αναπαριστά ένα λέξη και επιστρέφει τον αριθμό των φωνηέντων στη συμβολοσειρά. Τα φωνήεντα σε αυτήν την περίπτωση είναι 'a', 'e', 'i', 'o', 'u'. Εδώ, το 'y' είναι επίσης ένα φωνήεν, αλλά μόνο όταν βρίσκεται στο τέλος της δοθείσας λέξης.\n\nΠαράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/28", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Σας δίνεται μια μη κενή λίστα θετικών ακεραίων. Επιστρέψτε το μεγαλύτερο ακέραιο που είναι μεγαλύτερο από το μηδέν και έχει συχνότητα μεγαλύτερη ή ίση με την τιμή του ακεραίου. Η συχνότητα ενός ακεραίου είναι ο αριθμός των φορών που εμφανίζεται στη λίστα. Εάν δεν υπάρχει τέτοια τιμή, επιστρέψτε -1. Παραδείγματα:\n * \n *     search([4, 1, 2, 2, 3, 1]) == 2\n *     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n *     search([5, 5, 4, 4, 4]) == -1\n *\n */\nfunc search(lst : [Int]) -> Int {\n", "entry_point": "search", "test": "\n\nvar arg00 : [Int] = [5, 5, 5, 5, 1]\nvar x0 : Int = search(lst : arg00)\nvar v0 : Int = 1\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [4, 1, 4, 1, 4, 4]\nvar x1 : Int = search(lst : arg10)\nvar v1 : Int = 4\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [3, 3]\nvar x2 : Int = search(lst : arg20)\nvar v2 : Int = -1\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [8, 8, 8, 8, 8, 8, 8, 8]\nvar x3 : Int = search(lst : arg30)\nvar v3 : Int = 8\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [2, 3, 3, 2, 2]\nvar x4 : Int = search(lst : arg40)\nvar v4 : Int = 2\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]\nvar x5 : Int = search(lst : arg50)\nvar v5 : Int = 1\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [3, 2, 8, 2]\nvar x6 : Int = search(lst : arg60)\nvar v6 : Int = 2\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Int] = [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]\nvar x7 : Int = search(lst : arg70)\nvar v7 : Int = 1\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [Int] = [8, 8, 3, 6, 5, 6, 4]\nvar x8 : Int = search(lst : arg80)\nvar v8 : Int = -1\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : [Int] = [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]\nvar x9 : Int = search(lst : arg90)\nvar v9 : Int = 1\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : [Int] = [1, 9, 10, 1, 3]\nvar x10 : Int = search(lst : arg100)\nvar v10 : Int = 1\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : [Int] = [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]\nvar x11 : Int = search(lst : arg110)\nvar v11 : Int = 5\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : [Int] = [1]\nvar x12 : Int = search(lst : arg120)\nvar v12 : Int = 1\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\nvar arg130 : [Int] = [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]\nvar x13 : Int = search(lst : arg130)\nvar v13 : Int = 4\nassert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \")\n\nvar arg140 : [Int] = [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]\nvar x14 : Int = search(lst : arg140)\nvar v14 : Int = 2\nassert(x14 == v14, \"Exception -- test case 14 did not pass. x14 = \")\n\nvar arg150 : [Int] = [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]\nvar x15 : Int = search(lst : arg150)\nvar v15 : Int = 1\nassert(x15 == v15, \"Exception -- test case 15 did not pass. x15 = \")\n\nvar arg160 : [Int] = [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]\nvar x16 : Int = search(lst : arg160)\nvar v16 : Int = 4\nassert(x16 == v16, \"Exception -- test case 16 did not pass. x16 = \")\n\nvar arg170 : [Int] = [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]\nvar x17 : Int = search(lst : arg170)\nvar v17 : Int = 4\nassert(x17 == v17, \"Exception -- test case 17 did not pass. x17 = \")\n\nvar arg180 : [Int] = [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]\nvar x18 : Int = search(lst : arg180)\nvar v18 : Int = 2\nassert(x18 == v18, \"Exception -- test case 18 did not pass. x18 = \")\n\nvar arg190 : [Int] = [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]\nvar x19 : Int = search(lst : arg190)\nvar v19 : Int = -1\nassert(x19 == v19, \"Exception -- test case 19 did not pass. x19 = \")\n\nvar arg200 : [Int] = [10]\nvar x20 : Int = search(lst : arg200)\nvar v20 : Int = -1\nassert(x20 == v20, \"Exception -- test case 20 did not pass. x20 = \")\n\nvar arg210 : [Int] = [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]\nvar x21 : Int = search(lst : arg210)\nvar v21 : Int = 2\nassert(x21 == v21, \"Exception -- test case 21 did not pass. x21 = \")\n\nvar arg220 : [Int] = [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]\nvar x22 : Int = search(lst : arg220)\nvar v22 : Int = 1\nassert(x22 == v22, \"Exception -- test case 22 did not pass. x22 = \")\n\nvar arg230 : [Int] = [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]\nvar x23 : Int = search(lst : arg230)\nvar v23 : Int = 1\nassert(x23 == v23, \"Exception -- test case 23 did not pass. x23 = \")\n\nvar arg240 : [Int] = [3, 10, 10, 9, 2]\nvar x24 : Int = search(lst : arg240)\nvar v24 : Int = -1\nassert(x24 == v24, \"Exception -- test case 24 did not pass. x24 = \")\n\n", "description": "Σας δίνεται μια μη κενή λίστα θετικών ακεραίων. Επιστρέψτε το μεγαλύτερο ακέραιο που είναι μεγαλύτερο από το μηδέν και έχει συχνότητα μεγαλύτερη ή ίση με την τιμή του ακεραίου. Η συχνότητα ενός ακεραίου είναι ο αριθμός των φορών που εμφανίζεται στη λίστα. Εάν δεν υπάρχει τέτοια τιμή, επιστρέψτε -1. Παραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/29", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέψτε την περιοχή του τριγώνου στρογγυλοποιημένη στα 2 δεκαδικά ψηφία αν οι τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο. Διαφορετικά, επιστρέψτε -1. Τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο όταν το άθροισμα οποιωνδήποτε δύο πλευρών είναι μεγαλύτερο από την τρίτη πλευρά. Παράδειγμα:\n * \n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n *\n */\nfunc triangleArea(a : Int, b : Int, c : Int) -> Double {\n", "entry_point": "triangleArea", "test": "\n\nvar arg00 : Int = 3\nvar arg01 : Int = 4\nvar arg02 : Int = 5\nvar x0 : Double = triangleArea(a : arg00, b : arg01, c : arg02)\nvar v0 : Double = 6.0\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 1\nvar arg11 : Int = 2\nvar arg12 : Int = 10\nvar x1 : Double = triangleArea(a : arg10, b : arg11, c : arg12)\nvar v1 : Double = -1\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 4\nvar arg21 : Int = 8\nvar arg22 : Int = 5\nvar x2 : Double = triangleArea(a : arg20, b : arg21, c : arg22)\nvar v2 : Double = 8.18\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 2\nvar arg31 : Int = 2\nvar arg32 : Int = 2\nvar x3 : Double = triangleArea(a : arg30, b : arg31, c : arg32)\nvar v3 : Double = 1.73\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 1\nvar arg41 : Int = 2\nvar arg42 : Int = 3\nvar x4 : Double = triangleArea(a : arg40, b : arg41, c : arg42)\nvar v4 : Double = -1\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 10\nvar arg51 : Int = 5\nvar arg52 : Int = 7\nvar x5 : Double = triangleArea(a : arg50, b : arg51, c : arg52)\nvar v5 : Double = 16.25\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 2\nvar arg61 : Int = 6\nvar arg62 : Int = 3\nvar x6 : Double = triangleArea(a : arg60, b : arg61, c : arg62)\nvar v6 : Double = -1\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 1\nvar arg71 : Int = 1\nvar arg72 : Int = 1\nvar x7 : Double = triangleArea(a : arg70, b : arg71, c : arg72)\nvar v7 : Double = 0.43\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 2\nvar arg81 : Int = 2\nvar arg82 : Int = 10\nvar x8 : Double = triangleArea(a : arg80, b : arg81, c : arg82)\nvar v8 : Double = -1\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\n", "description": "Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέψτε την περιοχή του τριγώνου στρογγυλοποιημένη στα 2 δεκαδικά ψηφία αν οι τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο. Διαφορετικά, επιστρέψτε -1. Τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο όταν το άθροισμα οποιωνδήποτε δύο πλευρών είναι μεγαλύτερο από την τρίτη πλευρά. Παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/30", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Γράψτε μια συνάρτηση που επιστρέφει True αν το αντικείμενο q θα πετάξει, και False αλλιώς.\n * Το αντικείμενο q θα πετάξει αν είναι ισορροπημένο (είναι παλινδρομική λίστα) και άθροισμα των στοιχείων του είναι μικρότερο ή ίσο του μέγιστου δυνατού βάρους w.\n * \n * Παράδειγμα:\n * will_it_fly([1, 2], 5) ➞ False\n * # 1+2 είναι μικρότερο από το μέγιστο δυνατό βάρος, αλλά δεν είναι ισορροπημένο.\n * \n * will_it_fly([3, 2, 3], 1) ➞ False\n * # είναι ισορροπημένο, αλλά 3+2+3 είναι περισσότερο από το μέγιστο δυνατό βάρος.\n * \n * will_it_fly([3, 2, 3], 9) ➞ True\n * # 3+2+3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n * \n * will_it_fly([3], 5) ➞ True\n * # 3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n * \n *\n */\nfunc willItFly(q : [Int], w : Int) -> Bool {\n", "entry_point": "willItFly", "test": "\n\nvar arg00 : [Int] = [3, 2, 3]\nvar arg01 : Int = 9\nvar x0 : Bool = willItFly(q : arg00, w : arg01)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 2]\nvar arg11 : Int = 5\nvar x1 : Bool = willItFly(q : arg10, w : arg11)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [3]\nvar arg21 : Int = 5\nvar x2 : Bool = willItFly(q : arg20, w : arg21)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [3, 2, 3]\nvar arg31 : Int = 1\nvar x3 : Bool = willItFly(q : arg30, w : arg31)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [1, 2, 3]\nvar arg41 : Int = 6\nvar x4 : Bool = willItFly(q : arg40, w : arg41)\nvar v4 : Bool = false\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [5]\nvar arg51 : Int = 5\nvar x5 : Bool = willItFly(q : arg50, w : arg51)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "Γράψτε μια συνάρτηση που επιστρέφει True αν το αντικείμενο q θα πετάξει, και False αλλιώς.\nΤο αντικείμενο q θα πετάξει αν είναι ισορροπημένο (είναι παλινδρομική λίστα) και άθροισμα των στοιχείων του είναι μικρότερο ή ίσο του μέγιστου δυνατού βάρους w.\n\nΠαράδειγμα:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 είναι μικρότερο από το μέγιστο δυνατό βάρος, αλλά δεν είναι ισορροπημένο.\n\nwill_it_fly([3, 2, 3], 1) ➞ False\n# είναι ισορροπημένο, αλλά 3+2+3 είναι περισσότερο από το μέγιστο δυνατό βάρος.\n\nwill_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n\nwill_it_fly([3], 5) ➞ True\n# 3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/31", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Γράψτε μια συνάρτηση που επιστρέφει true αν το δοθέν αριθμός είναι το γινόμενο τριών πρώτων αριθμών και false σε διαφορετική περίπτωση.\n *     Γνωρίζοντας ότι (α) είναι μικρότερο από το 100.\n *     Παράδειγμα:\n * \n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n *\n */\nfunc isMultiplyPrime(a : Int) -> Bool {\n", "entry_point": "isMultiplyPrime", "test": "\n\nvar arg00 : Int = 5\nvar x0 : Bool = isMultiplyPrime(a : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 30\nvar x1 : Bool = isMultiplyPrime(a : arg10)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 8\nvar x2 : Bool = isMultiplyPrime(a : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 10\nvar x3 : Bool = isMultiplyPrime(a : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 125\nvar x4 : Bool = isMultiplyPrime(a : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 105\nvar x5 : Bool = isMultiplyPrime(a : arg50)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 126\nvar x6 : Bool = isMultiplyPrime(a : arg60)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 729\nvar x7 : Bool = isMultiplyPrime(a : arg70)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 891\nvar x8 : Bool = isMultiplyPrime(a : arg80)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 1001\nvar x9 : Bool = isMultiplyPrime(a : arg90)\nvar v9 : Bool = true\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\n", "description": "Γράψτε μια συνάρτηση που επιστρέφει true αν το δοθέν αριθμός είναι το γινόμενο τριών πρώτων αριθμών και false σε διαφορετική περίπτωση.\n    Γνωρίζοντας ότι (α) είναι μικρότερο από το 100.\n    Παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/32", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Θα σας δοθεί ένας αριθμός σε δεκαδική μορφή και η εργασία σας είναι να τον μετατρέψετε σε δυαδική μορφή. Η συνάρτηση θα πρέπει να επιστρέφει μια συμβολοσειρά, με κάθε χαρακτήρα που αντιπροσωπεύει ένα δυαδικό αριθμό. Κάθε χαρακτήρας στη συμβολοσειρά θα είναι '0' ή '1'.\n * \n * Θα υπάρχουν μερικοί επιπλέον χαρακτήρες 'db' στην αρχή και στο τέλος της συμβολοσειράς. Οι επιπλέον χαρακτήρες είναι εκεί για να βοηθήσουν με τη μορφοποίηση.\n * \n * Παραδείγματα:\n * \n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n *\n */\nfunc decimalToBinary(decimal : Int) -> String {\n", "entry_point": "decimalToBinary", "test": "\n\nvar arg00 : Int = 0\nvar x0 : String = decimalToBinary(decimal : arg00)\nvar v0 : String = #\"db0db\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 32\nvar x1 : String = decimalToBinary(decimal : arg10)\nvar v1 : String = #\"db100000db\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 103\nvar x2 : String = decimalToBinary(decimal : arg20)\nvar v2 : String = #\"db1100111db\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 15\nvar x3 : String = decimalToBinary(decimal : arg30)\nvar v3 : String = #\"db1111db\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "Θα σας δοθεί ένας αριθμός σε δεκαδική μορφή και η εργασία σας είναι να τον μετατρέψετε σε δυαδική μορφή. Η συνάρτηση θα πρέπει να επιστρέφει μια συμβολοσειρά, με κάθε χαρακτήρα που αντιπροσωπεύει ένα δυαδικό αριθμό. Κάθε χαρακτήρας στη συμβολοσειρά θα είναι '0' ή '1'.\n\nΘα υπάρχουν μερικοί επιπλέον χαρακτήρες 'db' στην αρχή και στο τέλος της συμβολοσειράς. Οι επιπλέον χαρακτήρες είναι εκεί για να βοηθήσουν με τη μορφοποίηση.\n\nΠαραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/33", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Σας δίνεται μια συμβολοσειρά s.\n *     Η εργασία σας είναι να ελέγξετε αν η συμβολοσειρά είναι ευτυχισμένη ή όχι.\n *     Μια συμβολοσειρά είναι ευτυχισμένη αν η μήκος της είναι τουλάχιστον 3 και κάθε 3 συνεχόμενα γράμματα είναι διαφορετικά.\n *     Για παράδειγμα:\n * \n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n *\n */\nfunc isHappy(s : String) -> Bool {\n", "entry_point": "isHappy", "test": "\n\nvar arg00 : String = #\"a\"#\nvar x0 : Bool = isHappy(s : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"aa\"#\nvar x1 : Bool = isHappy(s : arg10)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"abcd\"#\nvar x2 : Bool = isHappy(s : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"aabb\"#\nvar x3 : Bool = isHappy(s : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"adb\"#\nvar x4 : Bool = isHappy(s : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"xyy\"#\nvar x5 : Bool = isHappy(s : arg50)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"iopaxpoi\"#\nvar x6 : Bool = isHappy(s : arg60)\nvar v6 : Bool = true\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"iopaxioi\"#\nvar x7 : Bool = isHappy(s : arg70)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\n", "description": "Σας δίνεται μια συμβολοσειρά s.\n    Η εργασία σας είναι να ελέγξετε αν η συμβολοσειρά είναι ευτυχισμένη ή όχι.\n    Μια συμβολοσειρά είναι ευτυχισμένη αν η μήκος της είναι τουλάχιστον 3 και κάθε 3 συνεχόμενα γράμματα είναι διαφορετικά.\n    Για παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/34", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Είναι η τελευταία εβδομάδα του εξαμήνου και ο καθηγητής πρέπει να δώσει τους βαθμούς στους μαθητές. Ο καθηγητής έχει δημιουργήσει το δικό του αλγόριθμο για τη βαθμολογία. Το μόνο πρόβλημα είναι ότι έχασε τον κώδικα που χρησιμοποιούσε για τη βαθμολογία. Σας έχει δώσει μια λίστα με τα GPA για μερικούς μαθητές και πρέπει να γράψετε μια συνάρτηση που μπορεί να εξάγει μια λίστα με τις βαθμολογίες γραμμάτων χρησιμοποιώντας τον παρακάτω πίνακα:\n *              GPA       |    Βαθμός γράμματος\n *               4.0                Α+\n *             > 3.7                Α \n *             > 3.3                Α- \n *             > 3.0                Β+\n *             > 2.7                Β \n *             > 2.3                Β-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                Ε\n *     \n * \n *     Παράδειγμα:\n * \n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n *\n */\nfunc numericalLetterGrade(grades : [Double]) -> [String] {\n", "entry_point": "numericalLetterGrade", "test": "\n\nvar arg00 : [Double] = [4.0, 3, 1.7, 2, 3.5]\nvar x0 : [String] = numericalLetterGrade(grades : arg00)\nvar v0 : [String] = [#\"A+\"#, #\"B\"#, #\"C-\"#, #\"C\"#, #\"A-\"#]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Double] = [1.2]\nvar x1 : [String] = numericalLetterGrade(grades : arg10)\nvar v1 : [String] = [#\"D+\"#]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Double] = [0.5]\nvar x2 : [String] = numericalLetterGrade(grades : arg20)\nvar v2 : [String] = [#\"D-\"#]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Double] = [0.0]\nvar x3 : [String] = numericalLetterGrade(grades : arg30)\nvar v3 : [String] = [#\"E\"#]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Double] = [1, 0.3, 1.5, 2.8, 3.3]\nvar x4 : [String] = numericalLetterGrade(grades : arg40)\nvar v4 : [String] = [#\"D\"#, #\"D-\"#, #\"C-\"#, #\"B\"#, #\"B+\"#]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Double] = [0, 0.7]\nvar x5 : [String] = numericalLetterGrade(grades : arg50)\nvar v5 : [String] = [#\"E\"#, #\"D-\"#]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "Είναι η τελευταία εβδομάδα του εξαμήνου και ο καθηγητής πρέπει να δώσει τους βαθμούς στους μαθητές. Ο καθηγητής έχει δημιουργήσει το δικό του αλγόριθμο για τη βαθμολογία. Το μόνο πρόβλημα είναι ότι έχασε τον κώδικα που χρησιμοποιούσε για τη βαθμολογία. Σας έχει δώσει μια λίστα με τα GPA για μερικούς μαθητές και πρέπει να γράψετε μια συνάρτηση που μπορεί να εξάγει μια λίστα με τις βαθμολογίες γραμμάτων χρησιμοποιώντας τον παρακάτω πίνακα:\n             GPA       |    Βαθμός γράμματος\n              4.0                Α+\n            > 3.7                Α \n            > 3.3                Α- \n            > 3.0                Β+\n            > 2.7                Β \n            > 2.3                Β-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                Ε\n    \n\n    Παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/35", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Γράψτε μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει True αν το μήκος του αλφαριθμητικού είναι πρώτος αριθμός ή False αλλιώς. Παραδείγματα.\n * \n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n *\n */\nfunc primeLength(string : String) -> Bool {\n", "entry_point": "primeLength", "test": "\n\nvar arg00 : String = #\"Hello\"#\nvar x0 : Bool = primeLength(string : arg00)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"abcdcba\"#\nvar x1 : Bool = primeLength(string : arg10)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"kittens\"#\nvar x2 : Bool = primeLength(string : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"orange\"#\nvar x3 : Bool = primeLength(string : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"wow\"#\nvar x4 : Bool = primeLength(string : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"world\"#\nvar x5 : Bool = primeLength(string : arg50)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"MadaM\"#\nvar x6 : Bool = primeLength(string : arg60)\nvar v6 : Bool = true\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"Wow\"#\nvar x7 : Bool = primeLength(string : arg70)\nvar v7 : Bool = true\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : String = #\"\"#\nvar x8 : Bool = primeLength(string : arg80)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : String = #\"HI\"#\nvar x9 : Bool = primeLength(string : arg90)\nvar v9 : Bool = true\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : String = #\"go\"#\nvar x10 : Bool = primeLength(string : arg100)\nvar v10 : Bool = true\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : String = #\"gogo\"#\nvar x11 : Bool = primeLength(string : arg110)\nvar v11 : Bool = false\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : String = #\"aaaaaaaaaaaaaaa\"#\nvar x12 : Bool = primeLength(string : arg120)\nvar v12 : Bool = false\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\nvar arg130 : String = #\"Madam\"#\nvar x13 : Bool = primeLength(string : arg130)\nvar v13 : Bool = true\nassert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \")\n\nvar arg140 : String = #\"M\"#\nvar x14 : Bool = primeLength(string : arg140)\nvar v14 : Bool = false\nassert(x14 == v14, \"Exception -- test case 14 did not pass. x14 = \")\n\nvar arg150 : String = #\"0\"#\nvar x15 : Bool = primeLength(string : arg150)\nvar v15 : Bool = false\nassert(x15 == v15, \"Exception -- test case 15 did not pass. x15 = \")\n\n", "description": "Γράψτε μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει True αν το μήκος του αλφαριθμητικού είναι πρώτος αριθμός ή False αλλιώς. Παραδείγματα.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/36", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Δεδομένου ενός θετικού ακεραίου N, επιστρέφεται το συνολικό άθροισμα των ψηφίων του σε δυαδική μορφή.\n * \n *     Παράδειγμα\n *         Για N = 1000, το άθροισμα των ψηφίων θα είναι 1 και η έξοδος θα πρέπει να είναι \"1\".\n *         Για N = 150, το άθροισμα των ψηφίων θα είναι 6 και η έξοδος θα πρέπει να είναι \"110\".\n *         Για N = 147, το άθροισμα των ψηφίων θα είναι 12 και η έξοδος θα πρέπει να είναι \"1100\".\n *     \n *     Μεταβλητές:\n *         @N ακέραιος\n *              Περιορισμοί: 0 ≤ N ≤ 10000.\n *     Έξοδος:\n *          μια συμβολοσειρά δυαδικού αριθμού\n * \n *\n */\nfunc solve(n : Int) -> String {\n", "entry_point": "solve", "test": "\n\nvar arg00 : Int = 1000\nvar x0 : String = solve(n : arg00)\nvar v0 : String = #\"1\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 150\nvar x1 : String = solve(n : arg10)\nvar v1 : String = #\"110\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 147\nvar x2 : String = solve(n : arg20)\nvar v2 : String = #\"1100\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 333\nvar x3 : String = solve(n : arg30)\nvar v3 : String = #\"1001\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 963\nvar x4 : String = solve(n : arg40)\nvar v4 : String = #\"10010\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Δεδομένου ενός θετικού ακεραίου N, επιστρέφεται το συνολικό άθροισμα των ψηφίων του σε δυαδική μορφή.\n\n    Παράδειγμα\n        Για N = 1000, το άθροισμα των ψηφίων θα είναι 1 και η έξοδος θα πρέπει να είναι \"1\".\n        Για N = 150, το άθροισμα των ψηφίων θα είναι 6 και η έξοδος θα πρέπει να είναι \"110\".\n        Για N = 147, το άθροισμα των ψηφίων θα είναι 12 και η έξοδος θα πρέπει να είναι \"1100\".\n    \n    Μεταβλητές:\n        @N ακέραιος\n             Περιορισμοί: 0 ≤ N ≤ 10000.\n    Έξοδος:\n         μια συμβολοσειρά δυαδικού αριθμού", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/37", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Σας δίνεται μια δισδιάστατη δομή δεδομένων, ως εμφωλευμένες λίστες, που είναι παρόμοια με μια πίνακα, αλλά, αντίθετα από τους πίνακες, κάθε γραμμή μπορεί να περιέχει διαφορετικό αριθμό στηλών. Δεδομένης της λίστας lst και του ακεραίου x, βρείτε τους ακεραίους x στη λίστα και επιστρέψτε μια λίστα από tuples, [(x1, y1), (x2, y2) ...] ώστε κάθε tuple να είναι μια συντεταγμένη - (γραμμή, στήλες), ξεκινώντας από το 0. Ταξινομήστε αρχικά τις συντεταγμένες ανά γραμμή με αύξουσα σειρά. Επίσης, ταξινομήστε τις συντεταγμένες της γραμμής με φθίνουσα σειρά.\n * \n * Παραδείγματα:\n * \n * get_row([\n *   [1,2,3,4,5,6],\n *   [1,2,3,4,1,6],\n *   [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n *\n */\nfunc getRow(lst : [AnyHashable], x : Int) -> [AnyHashable] {\n", "entry_point": "getRow", "test": "\n\nvar arg00 : [AnyHashable] = []\nvar arg01 : Int = 1\nvar x0 : [AnyHashable] = getRow(lst : arg00, x : arg01)\nvar v0 : [AnyHashable] = []\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [[1]]\nvar arg11 : Int = 2\nvar x1 : [AnyHashable] = getRow(lst : arg10, x : arg11)\nvar v1 : [AnyHashable] = []\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [[], [1], [1, 2, 3]]\nvar arg21 : Int = 3\nvar x2 : [AnyHashable] = getRow(lst : arg20, x : arg21)\nvar v2 : [AnyHashable] = [[2, 2]]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\n", "description": "Σας δίνεται μια δισδιάστατη δομή δεδομένων, ως εμφωλευμένες λίστες, που είναι παρόμοια με μια πίνακα, αλλά, αντίθετα από τους πίνακες, κάθε γραμμή μπορεί να περιέχει διαφορετικό αριθμό στηλών. Δεδομένης της λίστας lst και του ακεραίου x, βρείτε τους ακεραίους x στη λίστα και επιστρέψτε μια λίστα από tuples, [(x1, y1), (x2, y2) ...] ώστε κάθε tuple να είναι μια συντεταγμένη - (γραμμή, στήλες), ξεκινώντας από το 0. Ταξινομήστε αρχικά τις συντεταγμένες ανά γραμμή με αύξουσα σειρά. Επίσης, ταξινομήστε τις συντεταγμένες της γραμμής με φθίνουσα σειρά.\n\nΠαραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/38", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Σας δίνεται μια λίστα ακεραίων.\n * Γράψτε μια συνάρτηση next_smallest() που επιστρέφει τον δεύτερο μικρότερο στοιχείο της λίστας.\n * Επιστρέψτε null αν δεν υπάρχει τέτοιο στοιχείο.\n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n *\n */\nfunc nextSmallest(lst : [AnyHashable]) -> AnyHashable {\n", "entry_point": "nextSmallest", "test": "\n\nvar arg00 : [AnyHashable] = [1, 2, 3, 4, 5]\nvar x0 : AnyHashable = nextSmallest(lst : arg00)\nvar v0 : AnyHashable = 2\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [5, 1, 4, 3, 2]\nvar x1 : AnyHashable = nextSmallest(lst : arg10)\nvar v1 : AnyHashable = 2\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = []\nvar x2 : AnyHashable = nextSmallest(lst : arg20)\nvar v2 : AnyHashable = \"none\"\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [1, 1]\nvar x3 : AnyHashable = nextSmallest(lst : arg30)\nvar v3 : AnyHashable = \"none\"\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [1, 1, 1, 1, 0]\nvar x4 : AnyHashable = nextSmallest(lst : arg40)\nvar v4 : AnyHashable = 1\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable] = [1, 1]\nvar x5 : AnyHashable = nextSmallest(lst : arg50)\nvar v5 : AnyHashable = \"none\"\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [AnyHashable] = [-35, 34, 12, -45]\nvar x6 : AnyHashable = nextSmallest(lst : arg60)\nvar v6 : AnyHashable = -35\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Σας δίνεται μια λίστα ακεραίων.\nΓράψτε μια συνάρτηση next_smallest() που επιστρέφει τον δεύτερο μικρότερο στοιχείο της λίστας.\nΕπιστρέψτε null αν δεν υπάρχει τέτοιο στοιχείο.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/39", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Θα σας δοθεί μια συμβολοσειρά λέξεων και η εργασία σας είναι να μετρήσετε τον αριθμό των βαρεμάρων. Μια βαρεμάρα είναι μια πρόταση που ξεκινά με τη λέξη \"Εγώ\". Οι προτάσεις διαχωρίζονται μεταξύ τους με '.' , '?' ή '!'.\n * \n * Για παράδειγμα:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n *\n */\nfunc isBored(s : String) -> Int {\n", "entry_point": "isBored", "test": "\n\nvar arg00 : String = #\"Hello world\"#\nvar x0 : Int = isBored(s : arg00)\nvar v0 : Int = 0\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"Is the sky blue?\"#\nvar x1 : Int = isBored(s : arg10)\nvar v1 : Int = 0\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"I love It !\"#\nvar x2 : Int = isBored(s : arg20)\nvar v2 : Int = 1\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"bIt\"#\nvar x3 : Int = isBored(s : arg30)\nvar v3 : Int = 0\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"I feel good today. I will be productive. will kill It\"#\nvar x4 : Int = isBored(s : arg40)\nvar v4 : Int = 2\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"You and I are going for a walk\"#\nvar x5 : Int = isBored(s : arg50)\nvar v5 : Int = 0\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "Θα σας δοθεί μια συμβολοσειρά λέξεων και η εργασία σας είναι να μετρήσετε τον αριθμό των βαρεμάρων. Μια βαρεμάρα είναι μια πρόταση που ξεκινά με τη λέξη \"Εγώ\". Οι προτάσεις διαχωρίζονται μεταξύ τους με '.' , '?' ή '!'.\n\nΓια παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/40", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Σας δίνεται μια λίστα ακεραίων.\n *     Πρέπει να βρείτε τη μεγαλύτερη πρώτη τιμή και να επιστρέψετε το άθροισμα των ψηφίων της.\n * \n *     Παραδείγματα:\n * \n * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n * For lst = [0,81,12,3,1,21] the output should be 3\n * For lst = [0,8,1,2,1,7] the output should be 7\n *\n */\nfunc skjkasdkd(lst : [Int]) -> Int {\n", "entry_point": "skjkasdkd", "test": "\n\nvar arg00 : [Int] = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]\nvar x0 : Int = skjkasdkd(lst : arg00)\nvar v0 : Int = 10\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]\nvar x1 : Int = skjkasdkd(lst : arg10)\nvar v1 : Int = 25\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]\nvar x2 : Int = skjkasdkd(lst : arg20)\nvar v2 : Int = 13\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]\nvar x3 : Int = skjkasdkd(lst : arg30)\nvar v3 : Int = 11\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [0, 81, 12, 3, 1, 21]\nvar x4 : Int = skjkasdkd(lst : arg40)\nvar v4 : Int = 3\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [0, 8, 1, 2, 1, 7]\nvar x5 : Int = skjkasdkd(lst : arg50)\nvar v5 : Int = 7\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [8191]\nvar x6 : Int = skjkasdkd(lst : arg60)\nvar v6 : Int = 19\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Int] = [8191, 123456, 127, 7]\nvar x7 : Int = skjkasdkd(lst : arg70)\nvar v7 : Int = 19\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [Int] = [127, 97, 8192]\nvar x8 : Int = skjkasdkd(lst : arg80)\nvar v8 : Int = 10\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\n", "description": "Σας δίνεται μια λίστα ακεραίων.\n    Πρέπει να βρείτε τη μεγαλύτερη πρώτη τιμή και να επιστρέψετε το άθροισμα των ψηφίων της.\n\n    Παραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/41", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δεδομένου ενός λεξικού, επιστρέψτε True αν όλα τα κλειδιά είναι συμβολοσειρές σε πεζά γράμματα ή όλα τα κλειδιά είναι συμβολοσειρές σε κεφαλαία γράμματα, αλλιώς επιστρέψτε False. Η συνάρτηση πρέπει να επιστρέφει False αν το δοσμένο λεξικό είναι κενό. Παραδείγματα:\n * \n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n *\n */\nfunc checkDictCase(dict : [AnyHashable: AnyHashable]) -> Bool {\n", "entry_point": "checkDictCase", "test": "\n\nvar arg00 : [AnyHashable: AnyHashable] = [#\"p\"# : #\"pineapple\"#, #\"b\"# : #\"banana\"#]\nvar x0 : Bool = checkDictCase(dict : arg00)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable: AnyHashable] = [#\"p\"# : #\"pineapple\"#, #\"A\"# : #\"banana\"#, #\"B\"# : #\"banana\"#]\nvar x1 : Bool = checkDictCase(dict : arg10)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable: AnyHashable] = [#\"p\"# : #\"pineapple\"#, 5 : #\"banana\"#, #\"a\"# : #\"apple\"#]\nvar x2 : Bool = checkDictCase(dict : arg20)\nvar v2 : Bool = false\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable: AnyHashable] = [#\"Name\"# : #\"John\"#, #\"Age\"# : #\"36\"#, #\"City\"# : #\"Houston\"#]\nvar x3 : Bool = checkDictCase(dict : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable: AnyHashable] = [#\"STATE\"# : #\"NC\"#, #\"ZIP\"# : #\"12345\"#]\nvar x4 : Bool = checkDictCase(dict : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable: AnyHashable] = [#\"fruit\"# : #\"Orange\"#, #\"taste\"# : #\"Sweet\"#]\nvar x5 : Bool = checkDictCase(dict : arg50)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [AnyHashable: AnyHashable] = []\nvar x6 : Bool = checkDictCase(dict : arg60)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Δεδομένου ενός λεξικού, επιστρέψτε True αν όλα τα κλειδιά είναι συμβολοσειρές σε πεζά γράμματα ή όλα τα κλειδιά είναι συμβολοσειρές σε κεφαλαία γράμματα, αλλιώς επιστρέψτε False. Η συνάρτηση πρέπει να επιστρέφει False αν το δοσμένο λεξικό είναι κενό. Παραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/42", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δημιουργήστε μια συνάρτηση που παίρνει μια τιμή (συμβολοσειρά) που αναπαριστά έναν αριθμό και επιστρέφει τον πλησιέστερο ακέραιο αριθμό σε αυτόν. Εάν ο αριθμός είναι ισοαπόστακτος από δύο ακεραίους, στρογγυλοποιήστε τον μακριά από το μηδέν.\n * \n * Παραδείγματα\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n\n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n *\n */\nfunc closestInteger(value : String) -> Int {\n", "entry_point": "closestInteger", "test": "\n\nvar arg00 : String = #\"10\"#\nvar x0 : Int = closestInteger(value : arg00)\nvar v0 : Int = 10\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"14.5\"#\nvar x1 : Int = closestInteger(value : arg10)\nvar v1 : Int = 15\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"-15.5\"#\nvar x2 : Int = closestInteger(value : arg20)\nvar v2 : Int = -16\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"15.3\"#\nvar x3 : Int = closestInteger(value : arg30)\nvar v3 : Int = 15\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"0\"#\nvar x4 : Int = closestInteger(value : arg40)\nvar v4 : Int = 0\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Δημιουργήστε μια συνάρτηση που παίρνει μια τιμή (συμβολοσειρά) που αναπαριστά έναν αριθμό και επιστρέφει τον πλησιέστερο ακέραιο αριθμό σε αυτόν. Εάν ο αριθμός είναι ισοαπόστακτος από δύο ακεραίους, στρογγυλοποιήστε τον μακριά από το μηδέν.\n\nΠαραδείγματα", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/43", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δεδομένου ενός θετικού ακεραίου n, πρέπει να φτιάξετε ένα σωρό από n επίπεδα πέτρες.\n *     Το πρώτο επίπεδο έχει n πέτρες.\n *     Ο αριθμός των πετρών στο επόμενο επίπεδο είναι:\n *         - ο επόμενος μονός αριθμός αν το n είναι περιττός.\n *         - ο επόμενος άρτιος αριθμός αν το n είναι άρτιος.\n *     Επιστρέψτε τον αριθμό των πετρών σε κάθε επίπεδο σε μια λίστα, όπου το στοιχείο στη θέση\n *     i αντιπροσωπεύει τον αριθμό των πετρών στο επίπεδο (i + 1).\n * \n *     Παραδείγματα:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n *\n */\nfunc makeAPile(n : Int) -> [Int] {\n", "entry_point": "makeAPile", "test": "\n\nvar arg00 : Int = 3\nvar x0 : [Int] = makeAPile(n : arg00)\nvar v0 : [Int] = [3, 5, 7]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 4\nvar x1 : [Int] = makeAPile(n : arg10)\nvar v1 : [Int] = [4, 6, 8, 10]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 5\nvar x2 : [Int] = makeAPile(n : arg20)\nvar v2 : [Int] = [5, 7, 9, 11, 13]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 6\nvar x3 : [Int] = makeAPile(n : arg30)\nvar v3 : [Int] = [6, 8, 10, 12, 14, 16]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 8\nvar x4 : [Int] = makeAPile(n : arg40)\nvar v4 : [Int] = [8, 10, 12, 14, 16, 18, 20, 22]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Δεδομένου ενός θετικού ακεραίου n, πρέπει να φτιάξετε ένα σωρό από n επίπεδα πέτρες.\n    Το πρώτο επίπεδο έχει n πέτρες.\n    Ο αριθμός των πετρών στο επόμενο επίπεδο είναι:\n        - ο επόμενος μονός αριθμός αν το n είναι περιττός.\n        - ο επόμενος άρτιος αριθμός αν το n είναι άρτιος.\n    Επιστρέψτε τον αριθμό των πετρών σε κάθε επίπεδο σε μια λίστα, όπου το στοιχείο στη θέση\n    i αντιπροσωπεύει τον αριθμό των πετρών στο επίπεδο (i + 1).\n\n    Παραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/44", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Θα σας δοθεί μια συμβολοσειρά λέξεων που χωρίζονται με κόμματα ή κενά. Η εργασία σας είναι να χωρίσετε τη συμβολοσειρά σε λέξεις και να επιστρέψετε έναν πίνακα με τις λέξεις.\n * \n * Για παράδειγμα:\n * \n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n *\n */\nfunc wordsString(s : String) -> [AnyHashable] {\n", "entry_point": "wordsString", "test": "\n\nvar arg00 : String = #\"Hi, my name is John\"#\nvar x0 : [AnyHashable] = wordsString(s : arg00)\nvar v0 : [AnyHashable] = [#\"Hi\"#, #\"my\"#, #\"name\"#, #\"is\"#, #\"John\"#]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"One, two, three, four, five, six\"#\nvar x1 : [AnyHashable] = wordsString(s : arg10)\nvar v1 : [AnyHashable] = [#\"One\"#, #\"two\"#, #\"three\"#, #\"four\"#, #\"five\"#, #\"six\"#]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"Hi, my name\"#\nvar x2 : [AnyHashable] = wordsString(s : arg20)\nvar v2 : [AnyHashable] = [#\"Hi\"#, #\"my\"#, #\"name\"#]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"One,, two, three, four, five, six,\"#\nvar x3 : [AnyHashable] = wordsString(s : arg30)\nvar v3 : [AnyHashable] = [#\"One\"#, #\"two\"#, #\"three\"#, #\"four\"#, #\"five\"#, #\"six\"#]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"\"#\nvar x4 : [AnyHashable] = wordsString(s : arg40)\nvar v4 : [AnyHashable] = []\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"ahmed     , gamal\"#\nvar x5 : [AnyHashable] = wordsString(s : arg50)\nvar v5 : [AnyHashable] = [#\"ahmed\"#, #\"gamal\"#]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "Θα σας δοθεί μια συμβολοσειρά λέξεων που χωρίζονται με κόμματα ή κενά. Η εργασία σας είναι να χωρίσετε τη συμβολοσειρά σε λέξεις και να επιστρέψετε έναν πίνακα με τις λέξεις.\n\nΓια παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/45", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Αυτή η συνάρτηση παίρνει δύο θετικούς αριθμούς x και y και επιστρέφει το μεγαλύτερο άρτιο ακέραιο αριθμό που βρίσκεται στο διάστημα [x, y] συμπεριλαμβανομένου. Εάν δεν υπάρχει τέτοιος αριθμός, η συνάρτηση θα πρέπει να επιστρέψει -1.\n * \n * Για παράδειγμα:\n * \n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n *\n */\nfunc chooseNum(x : Int, y : Int) -> Int {\n", "entry_point": "chooseNum", "test": "\n\nvar arg00 : Int = 12\nvar arg01 : Int = 15\nvar x0 : Int = chooseNum(x : arg00, y : arg01)\nvar v0 : Int = 14\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 13\nvar arg11 : Int = 12\nvar x1 : Int = chooseNum(x : arg10, y : arg11)\nvar v1 : Int = -1\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 33\nvar arg21 : Int = 12354\nvar x2 : Int = chooseNum(x : arg20, y : arg21)\nvar v2 : Int = 12354\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 5234\nvar arg31 : Int = 5233\nvar x3 : Int = chooseNum(x : arg30, y : arg31)\nvar v3 : Int = -1\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 6\nvar arg41 : Int = 29\nvar x4 : Int = chooseNum(x : arg40, y : arg41)\nvar v4 : Int = 28\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 27\nvar arg51 : Int = 10\nvar x5 : Int = chooseNum(x : arg50, y : arg51)\nvar v5 : Int = -1\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 7\nvar arg61 : Int = 7\nvar x6 : Int = chooseNum(x : arg60, y : arg61)\nvar v6 : Int = -1\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 546\nvar arg71 : Int = 546\nvar x7 : Int = chooseNum(x : arg70, y : arg71)\nvar v7 : Int = 546\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\n", "description": "Αυτή η συνάρτηση παίρνει δύο θετικούς αριθμούς x και y και επιστρέφει το μεγαλύτερο άρτιο ακέραιο αριθμό που βρίσκεται στο διάστημα [x, y] συμπεριλαμβανομένου. Εάν δεν υπάρχει τέτοιος αριθμός, η συνάρτηση θα πρέπει να επιστρέψει -1.\n\nΓια παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/46", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Σας δίνονται δύο θετικοί ακέραιοι αριθμοί n και m, και η εργασία σας είναι να υπολογίσετε τον μέσο όρο των ακεραίων από το n έως το m (συμπεριλαμβανομένων του n και του m). Στρογγυλοποιήστε την απάντηση στον πλησιέστερο ακέραιο και μετατρέψτε τον σε δυαδικό. Εάν το n είναι μεγαλύτερο από το m, επιστρέψτε -1. Παράδειγμα:\n * \n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n *\n */\nfunc roundedAvg(n : Int, m : Int) -> AnyHashable {\n", "entry_point": "roundedAvg", "test": "\n\nvar arg00 : Int = 1\nvar arg01 : Int = 5\nvar x0 : AnyHashable = roundedAvg(n : arg00, m : arg01)\nvar v0 : AnyHashable = #\"0b11\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 7\nvar arg11 : Int = 13\nvar x1 : AnyHashable = roundedAvg(n : arg10, m : arg11)\nvar v1 : AnyHashable = #\"0b1010\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 964\nvar arg21 : Int = 977\nvar x2 : AnyHashable = roundedAvg(n : arg20, m : arg21)\nvar v2 : AnyHashable = #\"0b1111001010\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 996\nvar arg31 : Int = 997\nvar x3 : AnyHashable = roundedAvg(n : arg30, m : arg31)\nvar v3 : AnyHashable = #\"0b1111100100\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 560\nvar arg41 : Int = 851\nvar x4 : AnyHashable = roundedAvg(n : arg40, m : arg41)\nvar v4 : AnyHashable = #\"0b1011000010\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 185\nvar arg51 : Int = 546\nvar x5 : AnyHashable = roundedAvg(n : arg50, m : arg51)\nvar v5 : AnyHashable = #\"0b101101110\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 362\nvar arg61 : Int = 496\nvar x6 : AnyHashable = roundedAvg(n : arg60, m : arg61)\nvar v6 : AnyHashable = #\"0b110101101\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 350\nvar arg71 : Int = 902\nvar x7 : AnyHashable = roundedAvg(n : arg70, m : arg71)\nvar v7 : AnyHashable = #\"0b1001110010\"#\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 197\nvar arg81 : Int = 233\nvar x8 : AnyHashable = roundedAvg(n : arg80, m : arg81)\nvar v8 : AnyHashable = #\"0b11010111\"#\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 7\nvar arg91 : Int = 5\nvar x9 : AnyHashable = roundedAvg(n : arg90, m : arg91)\nvar v9 : AnyHashable = -1\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : Int = 5\nvar arg101 : Int = 1\nvar x10 : AnyHashable = roundedAvg(n : arg100, m : arg101)\nvar v10 : AnyHashable = -1\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : Int = 5\nvar arg111 : Int = 5\nvar x11 : AnyHashable = roundedAvg(n : arg110, m : arg111)\nvar v11 : AnyHashable = #\"0b101\"#\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\n", "description": "Σας δίνονται δύο θετικοί ακέραιοι αριθμοί n και m, και η εργασία σας είναι να υπολογίσετε τον μέσο όρο των ακεραίων από το n έως το m (συμπεριλαμβανομένων του n και του m). Στρογγυλοποιήστε την απάντηση στον πλησιέστερο ακέραιο και μετατρέψτε τον σε δυαδικό. Εάν το n είναι μεγαλύτερο από το m, επιστρέψτε -1. Παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/47", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Υλοποιήστε τη συνάρτηση f που παίρνει το n ως παράμετρο και επιστρέφει μια λίστα μεγέθους n, όπου η τιμή του στοιχείου στη θέση i είναι το παραγοντικό του i αν είναι άρτιος ή άθροισμα αριθμών από 1 έως i αλλιώς. Το i ξεκινά από 1. Το παραγοντικό του i είναι ο πολλαπλασιασμός των αριθμών από 1 έως i (1 * 2 * ... * i). Παράδειγμα:\n * \n * f(5) == [1, 2, 6, 24, 15]\n *\n */\nfunc f(n : Int) -> [Int] {\n", "entry_point": "f", "test": "\n\nvar arg00 : Int = 5\nvar x0 : [Int] = f(n : arg00)\nvar v0 : [Int] = [1, 2, 6, 24, 15]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 7\nvar x1 : [Int] = f(n : arg10)\nvar v1 : [Int] = [1, 2, 6, 24, 15, 720, 28]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 1\nvar x2 : [Int] = f(n : arg20)\nvar v2 : [Int] = [1]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 3\nvar x3 : [Int] = f(n : arg30)\nvar v3 : [Int] = [1, 2, 6]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "Υλοποιήστε τη συνάρτηση f που παίρνει το n ως παράμετρο και επιστρέφει μια λίστα μεγέθους n, όπου η τιμή του στοιχείου στη θέση i είναι το παραγοντικό του i αν είναι άρτιος ή άθροισμα αριθμών από 1 έως i αλλιώς. Το i ξεκινά από 1. Το παραγοντικό του i είναι ο πολλαπλασιασμός των αριθμών από 1 έως i (1 * 2 * ... * i). Παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/48", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δεδομένου ενός θετικού ακεραίου n, επιστρέφεται ένα tuple που περιέχει τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών που βρίσκονται στο εύρος (1, n), συμπεριλαμβανομένου του n.\n * \n *     Παράδειγμα 1:\n * \n *         Είσοδος: 3\n *         Έξοδος: (1, 2)\n *         Εξήγηση:\n *         Οι παλινδρομικοί αριθμοί είναι 1, 2, 3. Ένας από αυτούς είναι άρτιος και δύο είναι περιττοί.\n * \n *     Παράδειγμα 2:\n * \n *         Είσοδος: 12\n *         Έξοδος: (4, 6)\n *         Εξήγηση:\n *         Οι παλινδρομικοί αριθμοί είναι 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Τέσσερις από αυτούς είναι άρτιοι και έξι είναι περιττοί.\n * \n *     Σημείωση:\n *         1. 1 <= n <= 10^3\n *         2. Το επιστρεφόμενο tuple περιέχει αντίστοιχα τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών.\n * \n *\n */\nfunc evenOddPalindrome(n : Int) -> [Int] {\n", "entry_point": "evenOddPalindrome", "test": "\n\nvar arg00 : Int = 123\nvar x0 : [Int] = evenOddPalindrome(n : arg00)\nvar v0 : [Int] = [8, 13]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 12\nvar x1 : [Int] = evenOddPalindrome(n : arg10)\nvar v1 : [Int] = [4, 6]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 3\nvar x2 : [Int] = evenOddPalindrome(n : arg20)\nvar v2 : [Int] = [1, 2]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 63\nvar x3 : [Int] = evenOddPalindrome(n : arg30)\nvar v3 : [Int] = [6, 8]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 25\nvar x4 : [Int] = evenOddPalindrome(n : arg40)\nvar v4 : [Int] = [5, 6]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 19\nvar x5 : [Int] = evenOddPalindrome(n : arg50)\nvar v5 : [Int] = [4, 6]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 9\nvar x6 : [Int] = evenOddPalindrome(n : arg60)\nvar v6 : [Int] = [4, 5]\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 1\nvar x7 : [Int] = evenOddPalindrome(n : arg70)\nvar v7 : [Int] = [0, 1]\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\n", "description": "Δεδομένου ενός θετικού ακεραίου n, επιστρέφεται ένα tuple που περιέχει τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών που βρίσκονται στο εύρος (1, n), συμπεριλαμβανομένου του n.\n\n    Παράδειγμα 1:\n\n        Είσοδος: 3\n        Έξοδος: (1, 2)\n        Εξήγηση:\n        Οι παλινδρομικοί αριθμοί είναι 1, 2, 3. Ένας από αυτούς είναι άρτιος και δύο είναι περιττοί.\n\n    Παράδειγμα 2:\n\n        Είσοδος: 12\n        Έξοδος: (4, 6)\n        Εξήγηση:\n        Οι παλινδρομικοί αριθμοί είναι 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Τέσσερις από αυτούς είναι άρτιοι και έξι είναι περιττοί.\n\n    Σημείωση:\n        1. 1 <= n <= 10^3\n        2. Το επιστρεφόμενο tuple περιέχει αντίστοιχα τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/49", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Έχουμε έναν πίνακα 'arr' από N ακεραίους arr[1], arr[2], ..., arr[N]. Οι αριθμοί στον πίνακα θα είναι τυχαία ταξινομημένοι. Η εργασία σας είναι να καθορίσετε εάν είναι δυνατόν να λάβετε έναν ταξινομημένο πίνακα σε μη φθίνουσα σειρά εκτελώντας την ακόλουθη λειτουργία στον δοσμένο πίνακα:\n *         Σας επιτρέπεται να εκτελέσετε τη λειτουργία μετατόπισης δεξιά οποιοδήποτε αριθμό φορών.\n *     \n *     Μια λειτουργία μετατόπισης δεξιά σημαίνει τη μετατόπιση όλων των στοιχείων του πίνακα κατά ένα θέση προς τη δεξιά κατεύθυνση. Το τελευταίο στοιχείο του πίνακα θα μετακινηθεί στην αρχική θέση στον πίνακα, δηλαδή στη θέση 0. \n * \n *     Εάν είναι δυνατόν να λάβετε τον ταξινομημένο πίνακα εκτελώντας την παραπάνω λειτουργία, τότε επιστρέψτε True, αλλιώς επιστρέψτε False.\n *     Εάν ο δοσμένος πίνακας είναι κενός, τότε επιστρέψτε True.\n * \n *     Σημείωση: Εγγυόμαστε ότι ο δοσμένος πίνακας θα έχει μοναδικά στοιχεία.\n * \n *     Για παράδειγμα:\n *     \n *     move_one_ball([3, 4, 5, 1, 2])==>True\n *     Εξήγηση: Εκτελώντας 2 λειτουργίες μετατόπισης δεξιά, μπορεί να επιτευχθεί μη φθίνουσα σειρά για τον δοσμένο πίνακα.\n *     move_one_ball([3, 5, 4, 1, 2])==>False\n *     Εξήγηση: Δεν είναι δυνατόν να λάβετε μη φθίνουσα σειρά για τον δοσμένο πίνακα εκτελώντας οποιονδήποτε αριθμό λειτουργιών μετατόπισης δεξιά.\n * \n *             \n *\n */\nfunc moveOneBall(arr : [AnyHashable]) -> Bool {\n", "entry_point": "moveOneBall", "test": "\n\nvar arg00 : [AnyHashable] = [3, 4, 5, 1, 2]\nvar x0 : Bool = moveOneBall(arr : arg00)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [3, 5, 10, 1, 2]\nvar x1 : Bool = moveOneBall(arr : arg10)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [4, 3, 1, 2]\nvar x2 : Bool = moveOneBall(arr : arg20)\nvar v2 : Bool = false\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [3, 5, 4, 1, 2]\nvar x3 : Bool = moveOneBall(arr : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = []\nvar x4 : Bool = moveOneBall(arr : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Έχουμε έναν πίνακα 'arr' από N ακεραίους arr[1], arr[2], ..., arr[N]. Οι αριθμοί στον πίνακα θα είναι τυχαία ταξινομημένοι. Η εργασία σας είναι να καθορίσετε εάν είναι δυνατόν να λάβετε έναν ταξινομημένο πίνακα σε μη φθίνουσα σειρά εκτελώντας την ακόλουθη λειτουργία στον δοσμένο πίνακα:\n        Σας επιτρέπεται να εκτελέσετε τη λειτουργία μετατόπισης δεξιά οποιοδήποτε αριθμό φορών.\n    \n    Μια λειτουργία μετατόπισης δεξιά σημαίνει τη μετατόπιση όλων των στοιχείων του πίνακα κατά ένα θέση προς τη δεξιά κατεύθυνση. Το τελευταίο στοιχείο του πίνακα θα μετακινηθεί στην αρχική θέση στον πίνακα, δηλαδή στη θέση 0. \n\n    Εάν είναι δυνατόν να λάβετε τον ταξινομημένο πίνακα εκτελώντας την παραπάνω λειτουργία, τότε επιστρέψτε True, αλλιώς επιστρέψτε False.\n    Εάν ο δοσμένος πίνακας είναι κενός, τότε επιστρέψτε True.\n\n    Σημείωση: Εγγυόμαστε ότι ο δοσμένος πίνακας θα έχει μοναδικά στοιχεία.\n\n    Για παράδειγμα:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Εξήγηση: Εκτελώντας 2 λειτουργίες μετατόπισης δεξιά, μπορεί να επιτευχθεί μη φθίνουσα σειρά για τον δοσμένο πίνακα.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Εξήγηση: Δεν είναι δυνατόν να λάβετε μη φθίνουσα σειρά για τον δοσμένο πίνακα εκτελώντας οποιονδήποτε αριθμό λειτουργιών μετατόπισης δεξιά.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/50", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Σε αυτό το πρόβλημα, θα υλοποιήσετε μια συνάρτηση που παίρνει δύο λίστες αριθμών και καθορίζει εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ τους για να κάνει την lst1 μια λίστα μόνο με άρτιους αριθμούς. Δεν υπάρχει όριο στον αριθμό των ανταλλαγών στοιχείων μεταξύ lst1 και lst2. Εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ των lst1 και lst2 για να κάνει όλα τα στοιχεία της lst1 να είναι άρτια, επιστρέψτε \"YES\". Διαφορετικά, επιστρέψτε \"NO\". Για παράδειγμα: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\", exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Υποθέτειται ότι οι λίστες εισόδου θα είναι μη κενές.\n * \n *\n */\nfunc exchange(lst1 : [Int], lst2 : [Int]) -> String {\n", "entry_point": "exchange", "test": "\n\nvar arg00 : [Int] = [1, 2, 3, 4]\nvar arg01 : [Int] = [1, 2, 3, 4]\nvar x0 : String = exchange(lst1 : arg00, lst2 : arg01)\nvar v0 : String = #\"YES\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 2, 3, 4]\nvar arg11 : [Int] = [1, 5, 3, 4]\nvar x1 : String = exchange(lst1 : arg10, lst2 : arg11)\nvar v1 : String = #\"NO\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [1, 2, 3, 4]\nvar arg21 : [Int] = [2, 1, 4, 3]\nvar x2 : String = exchange(lst1 : arg20, lst2 : arg21)\nvar v2 : String = #\"YES\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [5, 7, 3]\nvar arg31 : [Int] = [2, 6, 4]\nvar x3 : String = exchange(lst1 : arg30, lst2 : arg31)\nvar v3 : String = #\"YES\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [5, 7, 3]\nvar arg41 : [Int] = [2, 6, 3]\nvar x4 : String = exchange(lst1 : arg40, lst2 : arg41)\nvar v4 : String = #\"NO\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [3, 2, 6, 1, 8, 9]\nvar arg51 : [Int] = [3, 5, 5, 1, 1, 1]\nvar x5 : String = exchange(lst1 : arg50, lst2 : arg51)\nvar v5 : String = #\"NO\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [100, 200]\nvar arg61 : [Int] = [200, 200]\nvar x6 : String = exchange(lst1 : arg60, lst2 : arg61)\nvar v6 : String = #\"YES\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Σε αυτό το πρόβλημα, θα υλοποιήσετε μια συνάρτηση που παίρνει δύο λίστες αριθμών και καθορίζει εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ τους για να κάνει την lst1 μια λίστα μόνο με άρτιους αριθμούς. Δεν υπάρχει όριο στον αριθμό των ανταλλαγών στοιχείων μεταξύ lst1 και lst2. Εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ των lst1 και lst2 για να κάνει όλα τα στοιχεία της lst1 να είναι άρτια, επιστρέψτε \"YES\". Διαφορετικά, επιστρέψτε \"NO\". Για παράδειγμα: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\", exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Υποθέτειται ότι οι λίστες εισόδου θα είναι μη κενές.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/51", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Εργασία\n *     Δίνονται δύο αλφαριθμητικά s και c, πρέπει να διαγράψετε όλους τους χαρακτήρες στο s που είναι ίσοι με οποιονδήποτε χαρακτήρα στο c\n *     και στη συνέχεια να ελέγξετε αν το αποτέλεσμα είναι παλίνδρομο.\n *     Ένα αλφαριθμητικό ονομάζεται παλίνδρομο αν διαβάζεται το ίδιο προς τα πίσω και προς τα εμπρός.\n *     Θα πρέπει να επιστρέψετε ένα tuple που περιέχει το αποτέλεσμα αλφαριθμητικό και True/False για τον έλεγχο.\n *     Παράδειγμα\n *     Για s = \"abcde\", c = \"ae\", το αποτέλεσμα θα πρέπει να είναι ('bcd',False)\n *     Για s = \"abcdef\", c = \"b\" το αποτέλεσμα θα πρέπει να είναι ('acdef',False)\n *     Για s = \"abcdedcba\", c = \"ab\", το αποτέλεσμα θα πρέπει να είναι ('cdedc',True)\n * \n *\n */\nfunc reverseDelete(s : String, c : String) -> [AnyHashable] {\n", "entry_point": "reverseDelete", "test": "\n\nvar arg00 : String = #\"abcde\"#\nvar arg01 : String = #\"ae\"#\nvar x0 : [AnyHashable] = reverseDelete(s : arg00, c : arg01)\nvar v0 : [AnyHashable] = [#\"bcd\"#, false]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"abcdef\"#\nvar arg11 : String = #\"b\"#\nvar x1 : [AnyHashable] = reverseDelete(s : arg10, c : arg11)\nvar v1 : [AnyHashable] = [#\"acdef\"#, false]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"abcdedcba\"#\nvar arg21 : String = #\"ab\"#\nvar x2 : [AnyHashable] = reverseDelete(s : arg20, c : arg21)\nvar v2 : [AnyHashable] = [#\"cdedc\"#, true]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"dwik\"#\nvar arg31 : String = #\"w\"#\nvar x3 : [AnyHashable] = reverseDelete(s : arg30, c : arg31)\nvar v3 : [AnyHashable] = [#\"dik\"#, false]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"a\"#\nvar arg41 : String = #\"a\"#\nvar x4 : [AnyHashable] = reverseDelete(s : arg40, c : arg41)\nvar v4 : [AnyHashable] = [#\"\"#, true]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"abcdedcba\"#\nvar arg51 : String = #\"\"#\nvar x5 : [AnyHashable] = reverseDelete(s : arg50, c : arg51)\nvar v5 : [AnyHashable] = [#\"abcdedcba\"#, true]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"abcdedcba\"#\nvar arg61 : String = #\"v\"#\nvar x6 : [AnyHashable] = reverseDelete(s : arg60, c : arg61)\nvar v6 : [AnyHashable] = [#\"abcdedcba\"#, true]\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"vabba\"#\nvar arg71 : String = #\"v\"#\nvar x7 : [AnyHashable] = reverseDelete(s : arg70, c : arg71)\nvar v7 : [AnyHashable] = [#\"abba\"#, true]\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : String = #\"mamma\"#\nvar arg81 : String = #\"mia\"#\nvar x8 : [AnyHashable] = reverseDelete(s : arg80, c : arg81)\nvar v8 : [AnyHashable] = [#\"\"#, true]\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\n", "description": "Εργασία\n    Δίνονται δύο αλφαριθμητικά s και c, πρέπει να διαγράψετε όλους τους χαρακτήρες στο s που είναι ίσοι με οποιονδήποτε χαρακτήρα στο c\n    και στη συνέχεια να ελέγξετε αν το αποτέλεσμα είναι παλίνδρομο.\n    Ένα αλφαριθμητικό ονομάζεται παλίνδρομο αν διαβάζεται το ίδιο προς τα πίσω και προς τα εμπρός.\n    Θα πρέπει να επιστρέψετε ένα tuple που περιέχει το αποτέλεσμα αλφαριθμητικό και True/False για τον έλεγχο.\n    Παράδειγμα\n    Για s = \"abcde\", c = \"ae\", το αποτέλεσμα θα πρέπει να είναι ('bcd',False)\n    Για s = \"abcdef\", c = \"b\" το αποτέλεσμα θα πρέπει να είναι ('acdef',False)\n    Για s = \"abcdedcba\", c = \"ab\", το αποτέλεσμα θα πρέπει να είναι ('cdedc',True)", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/52", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Σας δίνεται ένα ορθογώνιο πλέγμα από πηγάδια. Κάθε σειρά αντιπροσωπεύει ένα μόνο πηγάδι, και κάθε 1 σε μια σειρά αντιπροσωπεύει μια μονάδα νερού. Κάθε πηγάδι έχει ένα αντίστοιχο κουβά που μπορεί να χρησιμοποιηθεί για να αντλήσει νερό από αυτό, και όλοι οι κουβάδες έχουν την ίδια χωρητικότητα. Η εργασία σας είναι να χρησιμοποιήσετε τους κουβάδες για να αδειάσετε τα πηγάδια. Εξαγάγετε τον αριθμό των φορών που χρειάζεται να χαμηλώσετε τους κουβάδες.\n * \n *     Παράδειγμα 1:\n *         Είσοδος:\n *             grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n *             χωρητικότητα κουβά: 1\n *         Έξοδος: 6\n * \n *     Παράδειγμα 2:\n *         Είσοδος:\n *             grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n *             χωρητικότητα κουβά: 2\n *         Έξοδος: 5\n *     \n *     Παράδειγμα 3:\n *         Είσοδος:\n *             grid: [[0,0,0], [0,0,0]]\n *             χωρητικότητα κουβά: 5\n *         Έξοδος: 0\n * \n *     Περιορισμοί:\n *         * όλα τα πηγάδια έχουν το ίδιο μήκος\n *         * 1 <= μήκος πλέγματος <= 10^2\n *         * 1 <= μήκος grid[:,1] <= 10^2\n *         * grid[i][j] -> 0 | 1\n *         * 1 <= χωρητικότητα <= 10\n * \n *\n */\nfunc maxFill(grid : [[Int]], capacity : Int) -> Int {\n", "entry_point": "maxFill", "test": "\n\nvar arg00 : [[Int]] = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\nvar arg01 : Int = 1\nvar x0 : Int = maxFill(grid : arg00, capacity : arg01)\nvar v0 : Int = 6\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [[Int]] = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\nvar arg11 : Int = 2\nvar x1 : Int = maxFill(grid : arg10, capacity : arg11)\nvar v1 : Int = 5\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [[Int]] = [[0, 0, 0], [0, 0, 0]]\nvar arg21 : Int = 5\nvar x2 : Int = maxFill(grid : arg20, capacity : arg21)\nvar v2 : Int = 0\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [[Int]] = [[1, 1, 1, 1], [1, 1, 1, 1]]\nvar arg31 : Int = 2\nvar x3 : Int = maxFill(grid : arg30, capacity : arg31)\nvar v3 : Int = 4\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [[Int]] = [[1, 1, 1, 1], [1, 1, 1, 1]]\nvar arg41 : Int = 9\nvar x4 : Int = maxFill(grid : arg40, capacity : arg41)\nvar v4 : Int = 2\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Σας δίνεται ένα ορθογώνιο πλέγμα από πηγάδια. Κάθε σειρά αντιπροσωπεύει ένα μόνο πηγάδι, και κάθε 1 σε μια σειρά αντιπροσωπεύει μια μονάδα νερού. Κάθε πηγάδι έχει ένα αντίστοιχο κουβά που μπορεί να χρησιμοποιηθεί για να αντλήσει νερό από αυτό, και όλοι οι κουβάδες έχουν την ίδια χωρητικότητα. Η εργασία σας είναι να χρησιμοποιήσετε τους κουβάδες για να αδειάσετε τα πηγάδια. Εξαγάγετε τον αριθμό των φορών που χρειάζεται να χαμηλώσετε τους κουβάδες.\n\n    Παράδειγμα 1:\n        Είσοδος:\n            grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            χωρητικότητα κουβά: 1\n        Έξοδος: 6\n\n    Παράδειγμα 2:\n        Είσοδος:\n            grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            χωρητικότητα κουβά: 2\n        Έξοδος: 5\n    \n    Παράδειγμα 3:\n        Είσοδος:\n            grid: [[0,0,0], [0,0,0]]\n            χωρητικότητα κουβά: 5\n        Έξοδος: 0\n\n    Περιορισμοί:\n        * όλα τα πηγάδια έχουν το ίδιο μήκος\n        * 1 <= μήκος πλέγματος <= 10^2\n        * 1 <= μήκος grid[:,1] <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= χωρητικότητα <= 10", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/53", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Δεδομένου ενός αλφαριθμητικού s και ενός φυσικού αριθμού n, σας έχει ανατεθεί να υλοποιήσετε μια συνάρτηση που επιστρέφει μια λίστα με όλες τις λέξεις από το αλφαριθμητικό s που περιέχουν ακριβώς n σύμφωνα, με τη σειρά που εμφανίζονται στο αλφαριθμητικό s. Εάν το αλφαριθμητικό s είναι κενό, τότε η συνάρτηση θα πρέπει να επιστρέψει μια κενή λίστα. Σημείωση: μπορείτε να υποθέσετε ότι το εισαγόμενο αλφαριθμητικό περιέχει μόνο γράμματα και κενά. Παραδείγματα:\n * \n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n *\n */\nfunc selectWords(s : String, n : Int) -> [AnyHashable] {\n", "entry_point": "selectWords", "test": "\n\nvar arg00 : String = #\"Mary had a little lamb\"#\nvar arg01 : Int = 4\nvar x0 : [AnyHashable] = selectWords(s : arg00, n : arg01)\nvar v0 : [AnyHashable] = [#\"little\"#]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"Mary had a little lamb\"#\nvar arg11 : Int = 3\nvar x1 : [AnyHashable] = selectWords(s : arg10, n : arg11)\nvar v1 : [AnyHashable] = [#\"Mary\"#, #\"lamb\"#]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"simple white space\"#\nvar arg21 : Int = 2\nvar x2 : [AnyHashable] = selectWords(s : arg20, n : arg21)\nvar v2 : [AnyHashable] = []\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"Hello world\"#\nvar arg31 : Int = 4\nvar x3 : [AnyHashable] = selectWords(s : arg30, n : arg31)\nvar v3 : [AnyHashable] = [#\"world\"#]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"Uncle sam\"#\nvar arg41 : Int = 3\nvar x4 : [AnyHashable] = selectWords(s : arg40, n : arg41)\nvar v4 : [AnyHashable] = [#\"Uncle\"#]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"\"#\nvar arg51 : Int = 4\nvar x5 : [AnyHashable] = selectWords(s : arg50, n : arg51)\nvar v5 : [AnyHashable] = []\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"a b c d e f\"#\nvar arg61 : Int = 1\nvar x6 : [AnyHashable] = selectWords(s : arg60, n : arg61)\nvar v6 : [AnyHashable] = [#\"b\"#, #\"c\"#, #\"d\"#, #\"f\"#]\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Δεδομένου ενός αλφαριθμητικού s και ενός φυσικού αριθμού n, σας έχει ανατεθεί να υλοποιήσετε μια συνάρτηση που επιστρέφει μια λίστα με όλες τις λέξεις από το αλφαριθμητικό s που περιέχουν ακριβώς n σύμφωνα, με τη σειρά που εμφανίζονται στο αλφαριθμητικό s. Εάν το αλφαριθμητικό s είναι κενό, τότε η συνάρτηση θα πρέπει να επιστρέψει μια κενή λίστα. Σημείωση: μπορείτε να υποθέσετε ότι το εισαγόμενο αλφαριθμητικό περιέχει μόνο γράμματα και κενά. Παραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/54", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δεδομένου ενός πίνακα arr ακεραίων και ενός θετικού ακεραίου k, επιστρέφει μια ταξινομημένη λίστα μήκους k με τους μεγαλύτερους k αριθμούς στον πίνακα arr.\n * \n *     Παράδειγμα 1:\n * \n *         Είσοδος: arr = [-3, -4, 5], k = 3\n *         Έξοδος: [-4, -3, 5]\n * \n *     Παράδειγμα 2:\n * \n *         Είσοδος: arr = [4, -4, 4], k = 2\n *         Έξοδος: [4, 4]\n * \n *     Παράδειγμα 3:\n * \n *         Είσοδος: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n *         Έξοδος: [2]\n * \n *     Σημείωση:\n *         1. Το μήκος του πίνακα θα είναι στο εύρος [1, 1000].\n *         2. Τα στοιχεία του πίνακα θα είναι στο εύρος [-1000, 1000].\n *         3. 0 <= k <= len(arr)\n * \n *\n */\nfunc maximum(arr : [Int], k : Int) -> [AnyHashable] {\n", "entry_point": "maximum", "test": "\n\nvar arg00 : [Int] = [-3, -4, 5]\nvar arg01 : Int = 3\nvar x0 : [AnyHashable] = maximum(arr : arg00, k : arg01)\nvar v0 : [AnyHashable] = [-4, -3, 5]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [4, -4, 4]\nvar arg11 : Int = 2\nvar x1 : [AnyHashable] = maximum(arr : arg10, k : arg11)\nvar v1 : [AnyHashable] = [4, 4]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [-3, 2, 1, 2, -1, -2, 1]\nvar arg21 : Int = 1\nvar x2 : [AnyHashable] = maximum(arr : arg20, k : arg21)\nvar v2 : [AnyHashable] = [2]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [123, -123, 20, 0, 1, 2, -3]\nvar arg31 : Int = 3\nvar x3 : [AnyHashable] = maximum(arr : arg30, k : arg31)\nvar v3 : [AnyHashable] = [2, 20, 123]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [-123, 20, 0, 1, 2, -3]\nvar arg41 : Int = 4\nvar x4 : [AnyHashable] = maximum(arr : arg40, k : arg41)\nvar v4 : [AnyHashable] = [0, 1, 2, 20]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [5, 15, 0, 3, -13, -8, 0]\nvar arg51 : Int = 7\nvar x5 : [AnyHashable] = maximum(arr : arg50, k : arg51)\nvar v5 : [AnyHashable] = [-13, -8, 0, 0, 3, 5, 15]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [-1, 0, 2, 5, 3, -10]\nvar arg61 : Int = 2\nvar x6 : [AnyHashable] = maximum(arr : arg60, k : arg61)\nvar v6 : [AnyHashable] = [3, 5]\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Int] = [1, 0, 5, -7]\nvar arg71 : Int = 1\nvar x7 : [AnyHashable] = maximum(arr : arg70, k : arg71)\nvar v7 : [AnyHashable] = [5]\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [Int] = [4, -4]\nvar arg81 : Int = 2\nvar x8 : [AnyHashable] = maximum(arr : arg80, k : arg81)\nvar v8 : [AnyHashable] = [-4, 4]\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : [Int] = [-10, 10]\nvar arg91 : Int = 2\nvar x9 : [AnyHashable] = maximum(arr : arg90, k : arg91)\nvar v9 : [AnyHashable] = [-10, 10]\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : [Int] = [1, 2, 3, -23, 243, -400, 0]\nvar arg101 : Int = 0\nvar x10 : [AnyHashable] = maximum(arr : arg100, k : arg101)\nvar v10 : [AnyHashable] = []\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\n", "description": "Δεδομένου ενός πίνακα arr ακεραίων και ενός θετικού ακεραίου k, επιστρέφει μια ταξινομημένη λίστα μήκους k με τους μεγαλύτερους k αριθμούς στον πίνακα arr.\n\n    Παράδειγμα 1:\n\n        Είσοδος: arr = [-3, -4, 5], k = 3\n        Έξοδος: [-4, -3, 5]\n\n    Παράδειγμα 2:\n\n        Είσοδος: arr = [4, -4, 4], k = 2\n        Έξοδος: [4, 4]\n\n    Παράδειγμα 3:\n\n        Είσοδος: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Έξοδος: [2]\n\n    Σημείωση:\n        1. Το μήκος του πίνακα θα είναι στο εύρος [1, 1000].\n        2. Τα στοιχεία του πίνακα θα είναι στο εύρος [-1000, 1000].\n        3. 0 <= k <= len(arr)", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/55", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δεδομένου ενός μη κενού πίνακα ακεραίων arr και ενός ακεραίου k, επιστρέφεται\n *     το άθροισμα των στοιχείων με τουλάχιστον δύο ψηφία από τα πρώτα k στοιχεία του arr.\n * \n *     Παράδειγμα:\n * \n *         Είσοδος: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n *         Έξοδος: 24 # άθροισμα των 21 + 3\n * \n *     Περιορισμοί:\n *         1. 1 <= len(arr) <= 100\n *         2. 1 <= k <= len(arr)\n * \n *\n */\nfunc addElements(arr : [Int], k : Int) -> Int {\n", "entry_point": "addElements", "test": "\n\nvar arg00 : [Int] = [1, -2, -3, 41, 57, 76, 87, 88, 99]\nvar arg01 : Int = 3\nvar x0 : Int = addElements(arr : arg00, k : arg01)\nvar v0 : Int = -4\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [111, 121, 3, 4000, 5, 6]\nvar arg11 : Int = 2\nvar x1 : Int = addElements(arr : arg10, k : arg11)\nvar v1 : Int = 0\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [11, 21, 3, 90, 5, 6, 7, 8, 9]\nvar arg21 : Int = 4\nvar x2 : Int = addElements(arr : arg20, k : arg21)\nvar v2 : Int = 125\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [111, 21, 3, 4000, 5, 6, 7, 8, 9]\nvar arg31 : Int = 4\nvar x3 : Int = addElements(arr : arg30, k : arg31)\nvar v3 : Int = 24\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [1]\nvar arg41 : Int = 1\nvar x4 : Int = addElements(arr : arg40, k : arg41)\nvar v4 : Int = 1\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Δεδομένου ενός μη κενού πίνακα ακεραίων arr και ενός ακεραίου k, επιστρέφεται\n    το άθροισμα των στοιχείων με τουλάχιστον δύο ψηφία από τα πρώτα k στοιχεία του arr.\n\n    Παράδειγμα:\n\n        Είσοδος: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Έξοδος: 24 # άθροισμα των 21 + 3\n\n    Περιορισμοί:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/56", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Σας δίνονται δύο διαστήματα,\n *     όπου κάθε διάστημα είναι ένα ζευγάρι ακεραίων. Για παράδειγμα, διάστημα = (αρχή, τέλος) = (1, 2).\n *     Τα δεδομένα διαστήματα είναι κλειστά, που σημαίνει ότι το διάστημα (αρχή, τέλος)\n *     περιλαμβάνει τόσο την αρχή όσο και το τέλος.\n *     Για κάθε δοσμένο διάστημα, υποθέτεται ότι η αρχή του είναι μικρότερη ή ίση με το τέλος του.\n *     Η εργασία σας είναι να καθορίσετε εάν το μήκος της τομής αυτών των δύο\n *     διαστημάτων είναι ένας πρώτος αριθμός.\n *     Για παράδειγμα, η τομή των διαστημάτων (1, 3), (2, 4) είναι (2, 3)\n *     το οποίο το μήκος του είναι 1, που δεν είναι πρώτος αριθμός.\n *     Εάν το μήκος της τομής είναι ένας πρώτος αριθμός, επιστρέψτε \"YES\",\n *     διαφορετικά, επιστρέψτε \"NO\".\n *     Εάν τα δύο διαστήματα δεν τέμνονται, επιστρέψτε \"NO\".\n * \n * \n *     [είσοδος/έξοδος] δείγματα:\n * \n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n *\n */\nfunc intersection(interval1 : [Int], interval2 : [Int]) -> String {\n", "entry_point": "intersection", "test": "\n\nvar arg00 : [Int] = [1, 2]\nvar arg01 : [Int] = [2, 3]\nvar x0 : String = intersection(interval1 : arg00, interval2 : arg01)\nvar v0 : String = #\"NO\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [-1, 1]\nvar arg11 : [Int] = [0, 4]\nvar x1 : String = intersection(interval1 : arg10, interval2 : arg11)\nvar v1 : String = #\"NO\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [-3, -1]\nvar arg21 : [Int] = [-5, 5]\nvar x2 : String = intersection(interval1 : arg20, interval2 : arg21)\nvar v2 : String = #\"YES\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [-2, 2]\nvar arg31 : [Int] = [-4, 0]\nvar x3 : String = intersection(interval1 : arg30, interval2 : arg31)\nvar v3 : String = #\"YES\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [-11, 2]\nvar arg41 : [Int] = [-1, -1]\nvar x4 : String = intersection(interval1 : arg40, interval2 : arg41)\nvar v4 : String = #\"NO\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [1, 2]\nvar arg51 : [Int] = [3, 5]\nvar x5 : String = intersection(interval1 : arg50, interval2 : arg51)\nvar v5 : String = #\"NO\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [1, 2]\nvar arg61 : [Int] = [1, 2]\nvar x6 : String = intersection(interval1 : arg60, interval2 : arg61)\nvar v6 : String = #\"NO\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Int] = [-2, -2]\nvar arg71 : [Int] = [-3, -2]\nvar x7 : String = intersection(interval1 : arg70, interval2 : arg71)\nvar v7 : String = #\"NO\"#\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\n", "description": "Σας δίνονται δύο διαστήματα,\n    όπου κάθε διάστημα είναι ένα ζευγάρι ακεραίων. Για παράδειγμα, διάστημα = (αρχή, τέλος) = (1, 2).\n    Τα δεδομένα διαστήματα είναι κλειστά, που σημαίνει ότι το διάστημα (αρχή, τέλος)\n    περιλαμβάνει τόσο την αρχή όσο και το τέλος.\n    Για κάθε δοσμένο διάστημα, υποθέτεται ότι η αρχή του είναι μικρότερη ή ίση με το τέλος του.\n    Η εργασία σας είναι να καθορίσετε εάν το μήκος της τομής αυτών των δύο\n    διαστημάτων είναι ένας πρώτος αριθμός.\n    Για παράδειγμα, η τομή των διαστημάτων (1, 3), (2, 4) είναι (2, 3)\n    το οποίο το μήκος του είναι 1, που δεν είναι πρώτος αριθμός.\n    Εάν το μήκος της τομής είναι ένας πρώτος αριθμός, επιστρέψτε \"YES\",\n    διαφορετικά, επιστρέψτε \"NO\".\n    Εάν τα δύο διαστήματα δεν τέμνονται, επιστρέψτε \"NO\".\n\n\n    [είσοδος/έξοδος] δείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/57", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Όλοι γνωρίζουν την ακολουθία του Fibonacci, η οποία μελετήθηκε βαθιά από μαθηματικούς τα τελευταία δύο αιώνες. Ωστόσο, αυτό που οι άνθρωποι δεν γνωρίζουν είναι η ακολουθία του Tribonacci. Η ακολουθία του Tribonacci ορίζεται από την επανάληψη:\n *     tri(1) = 3\n *     tri(n) = 1 + n / 2, αν το n είναι ζυγός.\n *     tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), αν το n είναι περιττό.\n *     Για παράδειγμα:\n *     tri(2) = 1 + (2 / 2) = 2\n *     tri(4) = 3\n *     tri(3) = tri(2) + tri(1) + tri(4)\n *            = 2 + 3 + 3 = 8 \n *     Σας δίνεται ένας μη αρνητικός ακέραιος αριθμός n, πρέπει να επιστρέψετε μια λίστα με τους πρώτους n + 1 αριθμούς της ακολουθίας του Tribonacci.\n *     Παραδείγματα:\n *     tri(3) = [1, 3, 2, 8]\n * \n *\n */\nfunc tri(n : Int) -> [Double] {\n", "entry_point": "tri", "test": "\n\nvar arg00 : Int = 3\nvar x0 : [Double] = tri(n : arg00)\nvar v0 : [Double] = [1, 3, 2.0, 8.0]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 4\nvar x1 : [Double] = tri(n : arg10)\nvar v1 : [Double] = [1, 3, 2.0, 8.0, 3.0]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 5\nvar x2 : [Double] = tri(n : arg20)\nvar v2 : [Double] = [1, 3, 2.0, 8.0, 3.0, 15.0]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 6\nvar x3 : [Double] = tri(n : arg30)\nvar v3 : [Double] = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 7\nvar x4 : [Double] = tri(n : arg40)\nvar v4 : [Double] = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 8\nvar x5 : [Double] = tri(n : arg50)\nvar v5 : [Double] = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 9\nvar x6 : [Double] = tri(n : arg60)\nvar v6 : [Double] = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 20\nvar x7 : [Double] = tri(n : arg70)\nvar v7 : [Double] = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 0\nvar x8 : [Double] = tri(n : arg80)\nvar v8 : [Double] = [1]\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 1\nvar x9 : [Double] = tri(n : arg90)\nvar v9 : [Double] = [1, 3]\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\n", "description": "Όλοι γνωρίζουν την ακολουθία του Fibonacci, η οποία μελετήθηκε βαθιά από μαθηματικούς τα τελευταία δύο αιώνες. Ωστόσο, αυτό που οι άνθρωποι δεν γνωρίζουν είναι η ακολουθία του Tribonacci. Η ακολουθία του Tribonacci ορίζεται από την επανάληψη:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, αν το n είναι ζυγός.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), αν το n είναι περιττό.\n    Για παράδειγμα:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    Σας δίνεται ένας μη αρνητικός ακέραιος αριθμός n, πρέπει να επιστρέψετε μια λίστα με τους πρώτους n + 1 αριθμούς της ακολουθίας του Tribonacci.\n    Παραδείγματα:\n    tri(3) = [1, 3, 2, 8]", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/58", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Δεδομένου ενός θετικού ακεραίου n, επιστρέφει το γινόμενο των μονών ψηφίων.\n *     Επιστρέφει 0 αν όλα τα ψηφία είναι άρτια.\n *     Για παράδειγμα:\n * \n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n *\n */\nfunc digits(n : Int) -> Int {\n", "entry_point": "digits", "test": "\n\nvar arg00 : Int = 5\nvar x0 : Int = digits(n : arg00)\nvar v0 : Int = 5\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 54\nvar x1 : Int = digits(n : arg10)\nvar v1 : Int = 5\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 120\nvar x2 : Int = digits(n : arg20)\nvar v2 : Int = 1\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 5014\nvar x3 : Int = digits(n : arg30)\nvar v3 : Int = 5\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 98765\nvar x4 : Int = digits(n : arg40)\nvar v4 : Int = 315\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 5576543\nvar x5 : Int = digits(n : arg50)\nvar v5 : Int = 2625\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 2468\nvar x6 : Int = digits(n : arg60)\nvar v6 : Int = 0\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Δεδομένου ενός θετικού ακεραίου n, επιστρέφει το γινόμενο των μονών ψηφίων.\n    Επιστρέφει 0 αν όλα τα ψηφία είναι άρτια.\n    Για παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/59", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δημιουργήστε μια συνάρτηση που παίρνει μια συμβολοσειρά ως είσοδο η οποία περιέχει μόνο αγκύλες.\n *     Η συνάρτηση θα πρέπει να επιστρέφει True μόνο αν υπάρχει μια έγκυρη υποακολουθία αγκυλών \n *     όπου τουλάχιστον μια αγκύλη στην υποακολουθία είναι ενσωματωμένη.\n * is_nested('[[]]') ➞ True\n * is_nested('[]]]]]]][[[[[]') ➞ False\n * is_nested('[][]') ➞ False\n * is_nested('[]') ➞ False\n * is_nested('[[][]]') ➞ True\n * is_nested('[[]][[') ➞ True\n *\n */\nfunc isNested(string : String) -> Bool {\n", "entry_point": "isNested", "test": "\n\nvar arg00 : String = #\"[[]]\"#\nvar x0 : Bool = isNested(string : arg00)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"[]]]]]]][[[[[]\"#\nvar x1 : Bool = isNested(string : arg10)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"[][]\"#\nvar x2 : Bool = isNested(string : arg20)\nvar v2 : Bool = false\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"[]\"#\nvar x3 : Bool = isNested(string : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"[[[[]]]]\"#\nvar x4 : Bool = isNested(string : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"[]]]]]]]]]]\"#\nvar x5 : Bool = isNested(string : arg50)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"[][][[]]\"#\nvar x6 : Bool = isNested(string : arg60)\nvar v6 : Bool = true\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"[[]\"#\nvar x7 : Bool = isNested(string : arg70)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : String = #\"[]]\"#\nvar x8 : Bool = isNested(string : arg80)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : String = #\"[[]][[\"#\nvar x9 : Bool = isNested(string : arg90)\nvar v9 : Bool = true\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : String = #\"[[][]]\"#\nvar x10 : Bool = isNested(string : arg100)\nvar v10 : Bool = true\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : String = #\"\"#\nvar x11 : Bool = isNested(string : arg110)\nvar v11 : Bool = false\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : String = #\"[[[[[[[[\"#\nvar x12 : Bool = isNested(string : arg120)\nvar v12 : Bool = false\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\nvar arg130 : String = #\"]]]]]]]]\"#\nvar x13 : Bool = isNested(string : arg130)\nvar v13 : Bool = false\nassert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \")\n\n", "description": "Δημιουργήστε μια συνάρτηση που παίρνει μια συμβολοσειρά ως είσοδο η οποία περιέχει μόνο αγκύλες.\n    Η συνάρτηση θα πρέπει να επιστρέφει True μόνο αν υπάρχει μια έγκυρη υποακολουθία αγκυλών \n    όπου τουλάχιστον μια αγκύλη στην υποακολουθία είναι ενσωματωμένη.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/60", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Σας δίνεται μια λίστα αριθμών.\n *     Χρειάζεστε να επιστρέψετε το άθροισμα των τετραγωνισμένων αριθμών στην δεδομένη λίστα,\n *     στρογγυλοποιήστε κάθε στοιχείο στη λίστα στο ανώτατο ακέραιο (Ceiling) πρώτα.\n *     Παραδείγματα:\n *     Για lst = [1,2,3] η έξοδος πρέπει να είναι 14\n *     Για lst = [1,4,9] η έξοδος πρέπει να είναι 98\n *     Για lst = [1,3,5,7] η έξοδος πρέπει να είναι 84\n *     Για lst = [1.4,4.2,0] η έξοδος πρέπει να είναι 29\n *     Για lst = [-2.4,1,1] η έξοδος πρέπει να είναι 6\n * \n * \n\n *\n */\nfunc sumSquares(lst : [Double]) -> Int {\n", "entry_point": "sumSquares", "test": "\n\nvar arg00 : [Double] = [1, 2, 3]\nvar x0 : Int = sumSquares(lst : arg00)\nvar v0 : Int = 14\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Double] = [1.0, 2, 3]\nvar x1 : Int = sumSquares(lst : arg10)\nvar v1 : Int = 14\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Double] = [1, 3, 5, 7]\nvar x2 : Int = sumSquares(lst : arg20)\nvar v2 : Int = 84\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Double] = [1.4, 4.2, 0]\nvar x3 : Int = sumSquares(lst : arg30)\nvar v3 : Int = 29\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Double] = [-2.4, 1, 1]\nvar x4 : Int = sumSquares(lst : arg40)\nvar v4 : Int = 6\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Double] = [100, 1, 15, 2]\nvar x5 : Int = sumSquares(lst : arg50)\nvar v5 : Int = 10230\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Double] = [10000, 10000]\nvar x6 : Int = sumSquares(lst : arg60)\nvar v6 : Int = 200000000\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Double] = [-1.4, 4.6, 6.3]\nvar x7 : Int = sumSquares(lst : arg70)\nvar v7 : Int = 75\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [Double] = [-1.4, 17.9, 18.9, 19.9]\nvar x8 : Int = sumSquares(lst : arg80)\nvar v8 : Int = 1086\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : [Double] = [0]\nvar x9 : Int = sumSquares(lst : arg90)\nvar v9 : Int = 0\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : [Double] = [-1]\nvar x10 : Int = sumSquares(lst : arg100)\nvar v10 : Int = 1\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : [Double] = [-1, 1, 0]\nvar x11 : Int = sumSquares(lst : arg110)\nvar v11 : Int = 2\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\n", "description": "Σας δίνεται μια λίστα αριθμών.\n    Χρειάζεστε να επιστρέψετε το άθροισμα των τετραγωνισμένων αριθμών στην δεδομένη λίστα,\n    στρογγυλοποιήστε κάθε στοιχείο στη λίστα στο ανώτατο ακέραιο (Ceiling) πρώτα.\n    Παραδείγματα:\n    Για lst = [1,2,3] η έξοδος πρέπει να είναι 14\n    Για lst = [1,4,9] η έξοδος πρέπει να είναι 98\n    Για lst = [1,3,5,7] η έξοδος πρέπει να είναι 84\n    Για lst = [1.4,4.2,0] η έξοδος πρέπει να είναι 29\n    Για lst = [-2.4,1,1] η έξοδος πρέπει να είναι 6", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/61", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δημιουργήστε μια συνάρτηση που επιστρέφει True αν ο τελευταίος χαρακτήρας\n *     ενός δεδομένου string είναι αλφαβητικός χαρακτήρας και δεν είναι\n *     μέρος ενός λέξης, και False αλλιώς.\n *     Σημείωση: \"λέξη\" είναι μια ομάδα χαρακτήρων που χωρίζονται από κενό.\n * \n *     Παραδείγματα:\n * \n * check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n * check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n * check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n * check_if_last_char_is_a_letter(\"\") ➞ False \n *\n */\nfunc checkIfLastCharIsALetter(txt : String) -> Bool {\n", "entry_point": "checkIfLastCharIsALetter", "test": "\n\nvar arg00 : String = #\"apple\"#\nvar x0 : Bool = checkIfLastCharIsALetter(txt : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"apple pi e\"#\nvar x1 : Bool = checkIfLastCharIsALetter(txt : arg10)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"eeeee\"#\nvar x2 : Bool = checkIfLastCharIsALetter(txt : arg20)\nvar v2 : Bool = false\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"A\"#\nvar x3 : Bool = checkIfLastCharIsALetter(txt : arg30)\nvar v3 : Bool = true\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"Pumpkin pie \"#\nvar x4 : Bool = checkIfLastCharIsALetter(txt : arg40)\nvar v4 : Bool = false\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"Pumpkin pie 1\"#\nvar x5 : Bool = checkIfLastCharIsALetter(txt : arg50)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"\"#\nvar x6 : Bool = checkIfLastCharIsALetter(txt : arg60)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"eeeee e \"#\nvar x7 : Bool = checkIfLastCharIsALetter(txt : arg70)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : String = #\"apple pie\"#\nvar x8 : Bool = checkIfLastCharIsALetter(txt : arg80)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : String = #\"apple pi e \"#\nvar x9 : Bool = checkIfLastCharIsALetter(txt : arg90)\nvar v9 : Bool = false\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\n", "description": "Δημιουργήστε μια συνάρτηση που επιστρέφει True αν ο τελευταίος χαρακτήρας\n    ενός δεδομένου string είναι αλφαβητικός χαρακτήρας και δεν είναι\n    μέρος ενός λέξης, και False αλλιώς.\n    Σημείωση: \"λέξη\" είναι μια ομάδα χαρακτήρων που χωρίζονται από κενό.\n\n    Παραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/62", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Δημιουργήστε μια συνάρτηση η οποία επιστρέφει το μεγαλύτερο δείκτη ενός στοιχείου που δεν είναι μεγαλύτερο ή ίσο από το στοιχείο που ακολουθεί αμέσως πριν από αυτό. Εάν δεν υπάρχει τέτοιο στοιχείο, τότε επιστρέψτε -1. Ο δοσμένος πίνακας δεν θα περιέχει διπλότυπες τιμές.\n * \n * Παραδείγματα:\n * \n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n *\n */\nfunc canArrange(arr : [AnyHashable]) -> Int {\n", "entry_point": "canArrange", "test": "\n\nvar arg00 : [AnyHashable] = [1, 2, 4, 3, 5]\nvar x0 : Int = canArrange(arr : arg00)\nvar v0 : Int = 3\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [1, 2, 4, 5]\nvar x1 : Int = canArrange(arr : arg10)\nvar v1 : Int = -1\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [1, 4, 2, 5, 6, 7, 8, 9, 10]\nvar x2 : Int = canArrange(arr : arg20)\nvar v2 : Int = 2\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [4, 8, 5, 7, 3]\nvar x3 : Int = canArrange(arr : arg30)\nvar v3 : Int = 4\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = []\nvar x4 : Int = canArrange(arr : arg40)\nvar v4 : Int = -1\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "Δημιουργήστε μια συνάρτηση η οποία επιστρέφει το μεγαλύτερο δείκτη ενός στοιχείου που δεν είναι μεγαλύτερο ή ίσο από το στοιχείο που ακολουθεί αμέσως πριν από αυτό. Εάν δεν υπάρχει τέτοιο στοιχείο, τότε επιστρέψτε -1. Ο δοσμένος πίνακας δεν θα περιέχει διπλότυπες τιμές.\n\nΠαραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/63", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δημιουργήστε μια συνάρτηση που επιστρέφει ένα tuple (a, b), όπου 'a' είναι ο μεγαλύτερος από τους αρνητικούς ακέραιους και 'b' είναι ο μικρότερος από τους θετικούς ακέραιους σε μια λίστα. Εάν δεν υπάρχουν αρνητικοί ή θετικοί ακέραιοι, επιστρέψτε τους ως None.\n * \n * Παραδείγματα:\n * \n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n *\n */\nfunc largestSmallestIntegers(lst : [AnyHashable]) -> [AnyHashable] {\n", "entry_point": "largestSmallestIntegers", "test": "\n\nvar arg00 : [AnyHashable] = [2, 4, 1, 3, 5, 7]\nvar x0 : [AnyHashable] = largestSmallestIntegers(lst : arg00)\nvar v0 : [AnyHashable] = [\"none\", 1]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [2, 4, 1, 3, 5, 7, 0]\nvar x1 : [AnyHashable] = largestSmallestIntegers(lst : arg10)\nvar v1 : [AnyHashable] = [\"none\", 1]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [1, 3, 2, 4, 5, 6, -2]\nvar x2 : [AnyHashable] = largestSmallestIntegers(lst : arg20)\nvar v2 : [AnyHashable] = [-2, 1]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [4, 5, 3, 6, 2, 7, -7]\nvar x3 : [AnyHashable] = largestSmallestIntegers(lst : arg30)\nvar v3 : [AnyHashable] = [-7, 2]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [7, 3, 8, 4, 9, 2, 5, -9]\nvar x4 : [AnyHashable] = largestSmallestIntegers(lst : arg40)\nvar v4 : [AnyHashable] = [-9, 2]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable] = []\nvar x5 : [AnyHashable] = largestSmallestIntegers(lst : arg50)\nvar v5 : [AnyHashable] = [\"none\", \"none\"]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [AnyHashable] = [0]\nvar x6 : [AnyHashable] = largestSmallestIntegers(lst : arg60)\nvar v6 : [AnyHashable] = [\"none\", \"none\"]\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [AnyHashable] = [-1, -3, -5, -6]\nvar x7 : [AnyHashable] = largestSmallestIntegers(lst : arg70)\nvar v7 : [AnyHashable] = [-1, \"none\"]\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [AnyHashable] = [-1, -3, -5, -6, 0]\nvar x8 : [AnyHashable] = largestSmallestIntegers(lst : arg80)\nvar v8 : [AnyHashable] = [-1, \"none\"]\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : [AnyHashable] = [-6, -4, -4, -3, 1]\nvar x9 : [AnyHashable] = largestSmallestIntegers(lst : arg90)\nvar v9 : [AnyHashable] = [-3, 1]\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : [AnyHashable] = [-6, -4, -4, -3, -100, 1]\nvar x10 : [AnyHashable] = largestSmallestIntegers(lst : arg100)\nvar v10 : [AnyHashable] = [-3, 1]\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\n", "description": "Δημιουργήστε μια συνάρτηση που επιστρέφει ένα tuple (a, b), όπου 'a' είναι ο μεγαλύτερος από τους αρνητικούς ακέραιους και 'b' είναι ο μικρότερος από τους θετικούς ακέραιους σε μια λίστα. Εάν δεν υπάρχουν αρνητικοί ή θετικοί ακέραιοι, επιστρέψτε τους ως None.\n\nΠαραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/64", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Το βραζιλιάνικο παραγοντικό ορίζεται ως:\n *     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     όπου n > 0\n * \n *     Για παράδειγμα:\n * >>> special_factorial(4)\n * 288\n\n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n *\n */\nfunc specialFactorial(n : Int) -> Int {\n", "entry_point": "specialFactorial", "test": "\n\nvar arg00 : Int = 4\nvar x0 : Int = specialFactorial(n : arg00)\nvar v0 : Int = 288\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 5\nvar x1 : Int = specialFactorial(n : arg10)\nvar v1 : Int = 34560\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 7\nvar x2 : Int = specialFactorial(n : arg20)\nvar v2 : Int = 125411328000\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 1\nvar x3 : Int = specialFactorial(n : arg30)\nvar v3 : Int = 1\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "Το βραζιλιάνικο παραγοντικό ορίζεται ως:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    όπου n > 0\n\n    Για παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/65", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Σας δίνεται μια συμβολοσειρά που αντιπροσωπεύει μια πρόταση,\n *     η πρόταση περιέχει μερικές λέξεις που χωρίζονται από ένα κενό,\n *     και πρέπει να επιστρέψετε μια συμβολοσειρά που περιέχει τις λέξεις από την αρχική πρόταση,\n *     οι οποίες έχουν πρωταρχικά μήκη,\n *     η σειρά των λέξεων στη νέα συμβολοσειρά πρέπει να είναι η ίδια με την αρχική.\n * \n *     Παράδειγμα 1:\n *         Είσοδος: πρόταση = \"Αυτό είναι ένα τεστ\"\n *         Έξοδος: \"είναι\"\n * \n *     Παράδειγμα 2:\n *         Είσοδος: πρόταση = \"πάμε για κολύμπι\"\n *         Έξοδος: \"για\"\n * \n *     Περιορισμοί:\n *         * 1 <= len(sentence) <= 100\n *         * Η πρόταση περιέχει μόνο γράμματα.\n * \n *\n */\nfunc wordsInSentence(sentence : String) -> String {\n", "entry_point": "wordsInSentence", "test": "\n\nvar arg00 : String = #\"This is a test\"#\nvar x0 : String = wordsInSentence(sentence : arg00)\nvar v0 : String = #\"is\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"lets go for swimming\"#\nvar x1 : String = wordsInSentence(sentence : arg10)\nvar v1 : String = #\"go for\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"there is no place available here\"#\nvar x2 : String = wordsInSentence(sentence : arg20)\nvar v2 : String = #\"there is no place\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"Hi I am Hussein\"#\nvar x3 : String = wordsInSentence(sentence : arg30)\nvar v3 : String = #\"Hi am Hussein\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"go for it\"#\nvar x4 : String = wordsInSentence(sentence : arg40)\nvar v4 : String = #\"go for it\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"here\"#\nvar x5 : String = wordsInSentence(sentence : arg50)\nvar v5 : String = #\"\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"here is\"#\nvar x6 : String = wordsInSentence(sentence : arg60)\nvar v6 : String = #\"is\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Σας δίνεται μια συμβολοσειρά που αντιπροσωπεύει μια πρόταση,\n    η πρόταση περιέχει μερικές λέξεις που χωρίζονται από ένα κενό,\n    και πρέπει να επιστρέψετε μια συμβολοσειρά που περιέχει τις λέξεις από την αρχική πρόταση,\n    οι οποίες έχουν πρωταρχικά μήκη,\n    η σειρά των λέξεων στη νέα συμβολοσειρά πρέπει να είναι η ίδια με την αρχική.\n\n    Παράδειγμα 1:\n        Είσοδος: πρόταση = \"Αυτό είναι ένα τεστ\"\n        Έξοδος: \"είναι\"\n\n    Παράδειγμα 2:\n        Είσοδος: πρόταση = \"πάμε για κολύμπι\"\n        Έξοδος: \"για\"\n\n    Περιορισμοί:\n        * 1 <= len(sentence) <= 100\n        * Η πρόταση περιέχει μόνο γράμματα.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/66", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Η εργασία σας είναι να υλοποιήσετε μια συνάρτηση που θα απλοποιεί την έκφραση x * n. Η συνάρτηση επιστρέφει True αν το x * n αξιολογείται σε έναν ακέραιο αριθμό και False διαφορετικά. Και τα δύο x και n είναι αναπαράσταση συντελεστή, και έχουν την ακόλουθη μορφή, <αριθμητέας>/<παρονομαστής> όπου και ο αριθμητέας και ο παρονομαστής είναι θετικοί ακέραιοι αριθμοί.\n * \n * Μπορείτε να υποθέσετε ότι το x και το n είναι έγκυροι συντελεστές και δεν έχουν μηδέν ως παρονομαστή.\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n *\n */\nfunc simplify(x : String, n : String) -> Bool {\n", "entry_point": "simplify", "test": "\n\nvar arg00 : String = #\"1/5\"#\nvar arg01 : String = #\"5/1\"#\nvar x0 : Bool = simplify(x : arg00, n : arg01)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"1/6\"#\nvar arg11 : String = #\"2/1\"#\nvar x1 : Bool = simplify(x : arg10, n : arg11)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"5/1\"#\nvar arg21 : String = #\"3/1\"#\nvar x2 : Bool = simplify(x : arg20, n : arg21)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"7/10\"#\nvar arg31 : String = #\"10/2\"#\nvar x3 : Bool = simplify(x : arg30, n : arg31)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"2/10\"#\nvar arg41 : String = #\"50/10\"#\nvar x4 : Bool = simplify(x : arg40, n : arg41)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"7/2\"#\nvar arg51 : String = #\"4/2\"#\nvar x5 : Bool = simplify(x : arg50, n : arg51)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"11/6\"#\nvar arg61 : String = #\"6/1\"#\nvar x6 : Bool = simplify(x : arg60, n : arg61)\nvar v6 : Bool = true\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"2/3\"#\nvar arg71 : String = #\"5/2\"#\nvar x7 : Bool = simplify(x : arg70, n : arg71)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : String = #\"5/2\"#\nvar arg81 : String = #\"3/5\"#\nvar x8 : Bool = simplify(x : arg80, n : arg81)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : String = #\"2/4\"#\nvar arg91 : String = #\"8/4\"#\nvar x9 : Bool = simplify(x : arg90, n : arg91)\nvar v9 : Bool = true\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : String = #\"2/4\"#\nvar arg101 : String = #\"4/2\"#\nvar x10 : Bool = simplify(x : arg100, n : arg101)\nvar v10 : Bool = true\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : String = #\"1/5\"#\nvar arg111 : String = #\"5/1\"#\nvar x11 : Bool = simplify(x : arg110, n : arg111)\nvar v11 : Bool = true\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : String = #\"1/5\"#\nvar arg121 : String = #\"1/5\"#\nvar x12 : Bool = simplify(x : arg120, n : arg121)\nvar v12 : Bool = false\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\n", "description": "Η εργασία σας είναι να υλοποιήσετε μια συνάρτηση που θα απλοποιεί την έκφραση x * n. Η συνάρτηση επιστρέφει True αν το x * n αξιολογείται σε έναν ακέραιο αριθμό και False διαφορετικά. Και τα δύο x και n είναι αναπαράσταση συντελεστή, και έχουν την ακόλουθη μορφή, <αριθμητέας>/<παρονομαστής> όπου και ο αριθμητέας και ο παρονομαστής είναι θετικοί ακέραιοι αριθμοί.\n\nΜπορείτε να υποθέσετε ότι το x και το n είναι έγκυροι συντελεστές και δεν έχουν μηδέν ως παρονομαστή.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/67", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Γράψτε μια συνάρτηση η οποία ταξινομεί τη δοσμένη λίστα ακεραίων σε αύξουσα σειρά βάσει του αθροίσματος των ψηφίων τους. Σημείωση: αν υπάρχουν πολλά στοιχεία με παρόμοιο άθροισμα των ψηφίων τους, ταξινομήστε τα βάσει της θέσης τους στην αρχική λίστα.\n * \n * Παράδειγμα:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n *\n */\nfunc orderByPoints(nums : [AnyHashable]) -> [AnyHashable] {\n", "entry_point": "orderByPoints", "test": "\n\nvar arg00 : [AnyHashable] = [1, 11, -1, -11, -12]\nvar x0 : [AnyHashable] = orderByPoints(nums : arg00)\nvar v0 : [AnyHashable] = [-1, -11, 1, -12, 11]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\nvar x1 : [AnyHashable] = orderByPoints(nums : arg10)\nvar v1 : [AnyHashable] = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = []\nvar x2 : [AnyHashable] = orderByPoints(nums : arg20)\nvar v2 : [AnyHashable] = []\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [1, -11, -32, 43, 54, -98, 2, -3]\nvar x3 : [AnyHashable] = orderByPoints(nums : arg30)\nvar v3 : [AnyHashable] = [-3, -32, -98, -11, 1, 2, 43, 54]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\nvar x4 : [AnyHashable] = orderByPoints(nums : arg40)\nvar v4 : [AnyHashable] = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable] = [0, 6, 6, -76, -21, 23, 4]\nvar x5 : [AnyHashable] = orderByPoints(nums : arg50)\nvar v5 : [AnyHashable] = [-76, -21, 0, 4, 23, 6, 6]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "Γράψτε μια συνάρτηση η οποία ταξινομεί τη δοσμένη λίστα ακεραίων σε αύξουσα σειρά βάσει του αθροίσματος των ψηφίων τους. Σημείωση: αν υπάρχουν πολλά στοιχεία με παρόμοιο άθροισμα των ψηφίων τους, ταξινομήστε τα βάσει της θέσης τους στην αρχική λίστα.\n\nΠαράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/68", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Γράψτε μια συνάρτηση που παίρνει έναν πίνακα αριθμών ως είσοδο και επιστρέφει τον αριθμό των στοιχείων στον πίνακα που είναι μεγαλύτερα από 10 και και οι πρώτοι και οι τελευταίοι αριθμοί ενός αριθμού είναι περιττοί (1, 3, 5, 7, 9). Για παράδειγμα:\n * \n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n *\n */\nfunc specialfilter(nums : [AnyHashable]) -> Int {\n", "entry_point": "specialfilter", "test": "\n\nvar arg00 : [AnyHashable] = [5, -2, 1, -5]\nvar x0 : Int = specialfilter(nums : arg00)\nvar v0 : Int = 0\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [15, -73, 14, -15]\nvar x1 : Int = specialfilter(nums : arg10)\nvar v1 : Int = 1\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [33, -2, -3, 45, 21, 109]\nvar x2 : Int = specialfilter(nums : arg20)\nvar v2 : Int = 2\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [43, -12, 93, 125, 121, 109]\nvar x3 : Int = specialfilter(nums : arg30)\nvar v3 : Int = 4\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [71, -2, -33, 75, 21, 19]\nvar x4 : Int = specialfilter(nums : arg40)\nvar v4 : Int = 3\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable] = [1]\nvar x5 : Int = specialfilter(nums : arg50)\nvar v5 : Int = 0\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [AnyHashable] = []\nvar x6 : Int = specialfilter(nums : arg60)\nvar v6 : Int = 0\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Γράψτε μια συνάρτηση που παίρνει έναν πίνακα αριθμών ως είσοδο και επιστρέφει τον αριθμό των στοιχείων στον πίνακα που είναι μεγαλύτερα από 10 και και οι πρώτοι και οι τελευταίοι αριθμοί ενός αριθμού είναι περιττοί (1, 3, 5, 7, 9). Για παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/69", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Σας δίνεται ένα θετικό ακέραιο n. Πρέπει να δημιουργήσετε έναν πίνακα ακεραίων a μήκους n. Για κάθε i (1 ≤ i ≤ n), η τιμή του a[i] = i * i - i + 1. Επιστρέψτε τον αριθμό των τριάδων (a[i], a[j], a[k]) του a όπου i < j < k, και a[i] + a[j] + a[k] είναι πολλαπλάσιο του 3.\n * \n * Παράδειγμα:\n *     Είσοδος: n = 5\n *     Έξοδος: 1\n *     Εξήγηση:\n *     a = [1, 3, 7, 13, 21]\n *     Η μόνη έγκυρη τριάδα είναι (1, 7, 13).\n * \n *\n */\nfunc getMaxTriples(n : Int) -> Int {\n", "entry_point": "getMaxTriples", "test": "\n\nvar arg00 : Int = 5\nvar x0 : Int = getMaxTriples(n : arg00)\nvar v0 : Int = 1\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 6\nvar x1 : Int = getMaxTriples(n : arg10)\nvar v1 : Int = 4\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 10\nvar x2 : Int = getMaxTriples(n : arg20)\nvar v2 : Int = 36\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 100\nvar x3 : Int = getMaxTriples(n : arg30)\nvar v3 : Int = 53361\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "Σας δίνεται ένα θετικό ακέραιο n. Πρέπει να δημιουργήσετε έναν πίνακα ακεραίων a μήκους n. Για κάθε i (1 ≤ i ≤ n), η τιμή του a[i] = i * i - i + 1. Επιστρέψτε τον αριθμό των τριάδων (a[i], a[j], a[k]) του a όπου i < j < k, και a[i] + a[j] + a[k] είναι πολλαπλάσιο του 3.\n\nΠαράδειγμα:\n    Είσοδος: n = 5\n    Έξοδος: 1\n    Εξήγηση:\n    a = [1, 3, 7, 13, 21]\n    Η μόνη έγκυρη τριάδα είναι (1, 7, 13).", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/70", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Υπάρχουν οκτώ πλανήτες στο ηλιακό μας σύστημα: ο πλανήτης που βρίσκεται πιο κοντά στον Ήλιο είναι ο Ερμής, ο επόμενος είναι η Αφροδίτη, έπειτα η Γη, ο Άρης, ο Δίας, ο Κρόνος, ο Ουρανός και ο Ποσειδώνας. \n * Γράψτε μια συνάρτηση που παίρνει δύο ονόματα πλανητών ως αλφαριθμητικά planet1 και planet2. Η συνάρτηση θα πρέπει να επιστρέφει ένα tuple που περιέχει όλους τους πλανήτες των οποίων οι τροχιές βρίσκονται μεταξύ της τροχιάς του πλανήτη1 και της τροχιάς του πλανήτη2, ταξινομημένους κατά την εγγύτητά τους στον Ήλιο. Η συνάρτηση θα πρέπει να επιστρέφει ένα κενό tuple εάν το planet1 ή το planet2 δεν είναι σωστά ονόματα πλανητών. \n * Παραδείγματα:\n * \n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n *\n */\nfunc bf(planet1 : String, planet2 : String) -> [AnyHashable] {\n", "entry_point": "bf", "test": "\n\nvar arg00 : String = #\"Jupiter\"#\nvar arg01 : String = #\"Neptune\"#\nvar x0 : [AnyHashable] = bf(planet1 : arg00, planet2 : arg01)\nvar v0 : [AnyHashable] = [#\"Saturn\"#, #\"Uranus\"#]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"Earth\"#\nvar arg11 : String = #\"Mercury\"#\nvar x1 : [AnyHashable] = bf(planet1 : arg10, planet2 : arg11)\nvar v1 : [AnyHashable] = [#\"Venus\"#]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"Mercury\"#\nvar arg21 : String = #\"Uranus\"#\nvar x2 : [AnyHashable] = bf(planet1 : arg20, planet2 : arg21)\nvar v2 : [AnyHashable] = [#\"Venus\"#, #\"Earth\"#, #\"Mars\"#, #\"Jupiter\"#, #\"Saturn\"#]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"Neptune\"#\nvar arg31 : String = #\"Venus\"#\nvar x3 : [AnyHashable] = bf(planet1 : arg30, planet2 : arg31)\nvar v3 : [AnyHashable] = [#\"Earth\"#, #\"Mars\"#, #\"Jupiter\"#, #\"Saturn\"#, #\"Uranus\"#]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"Earth\"#\nvar arg41 : String = #\"Earth\"#\nvar x4 : [AnyHashable] = bf(planet1 : arg40, planet2 : arg41)\nvar v4 : [AnyHashable] = []\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"Mars\"#\nvar arg51 : String = #\"Earth\"#\nvar x5 : [AnyHashable] = bf(planet1 : arg50, planet2 : arg51)\nvar v5 : [AnyHashable] = []\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"Jupiter\"#\nvar arg61 : String = #\"Makemake\"#\nvar x6 : [AnyHashable] = bf(planet1 : arg60, planet2 : arg61)\nvar v6 : [AnyHashable] = []\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Υπάρχουν οκτώ πλανήτες στο ηλιακό μας σύστημα: ο πλανήτης που βρίσκεται πιο κοντά στον Ήλιο είναι ο Ερμής, ο επόμενος είναι η Αφροδίτη, έπειτα η Γη, ο Άρης, ο Δίας, ο Κρόνος, ο Ουρανός και ο Ποσειδώνας. \nΓράψτε μια συνάρτηση που παίρνει δύο ονόματα πλανητών ως αλφαριθμητικά planet1 και planet2. Η συνάρτηση θα πρέπει να επιστρέφει ένα tuple που περιέχει όλους τους πλανήτες των οποίων οι τροχιές βρίσκονται μεταξύ της τροχιάς του πλανήτη1 και της τροχιάς του πλανήτη2, ταξινομημένους κατά την εγγύτητά τους στον Ήλιο. Η συνάρτηση θα πρέπει να επιστρέφει ένα κενό tuple εάν το planet1 ή το planet2 δεν είναι σωστά ονόματα πλανητών. \nΠαραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/71", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Ένα απλό πρόγραμμα που θα πρέπει να επιστρέφει την τιμή του x αν το n είναι πρώτος αριθμός και θα πρέπει να επιστρέφει την τιμή του y σε διαφορετική περίπτωση.\n * \n * Παραδείγματα:\n * \n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n *\n */\nfunc xOrY(n : Int, x : Int, y : Int) -> Int {\n", "entry_point": "xOrY", "test": "\n\nvar arg00 : Int = 7\nvar arg01 : Int = 34\nvar arg02 : Int = 12\nvar x0 : Int = xOrY(n : arg00, x : arg01, y : arg02)\nvar v0 : Int = 34\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 15\nvar arg11 : Int = 8\nvar arg12 : Int = 5\nvar x1 : Int = xOrY(n : arg10, x : arg11, y : arg12)\nvar v1 : Int = 5\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 3\nvar arg21 : Int = 33\nvar arg22 : Int = 5212\nvar x2 : Int = xOrY(n : arg20, x : arg21, y : arg22)\nvar v2 : Int = 33\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 1259\nvar arg31 : Int = 3\nvar arg32 : Int = 52\nvar x3 : Int = xOrY(n : arg30, x : arg31, y : arg32)\nvar v3 : Int = 3\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 7919\nvar arg41 : Int = -1\nvar arg42 : Int = 12\nvar x4 : Int = xOrY(n : arg40, x : arg41, y : arg42)\nvar v4 : Int = -1\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 3609\nvar arg51 : Int = 1245\nvar arg52 : Int = 583\nvar x5 : Int = xOrY(n : arg50, x : arg51, y : arg52)\nvar v5 : Int = 583\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 91\nvar arg61 : Int = 56\nvar arg62 : Int = 129\nvar x6 : Int = xOrY(n : arg60, x : arg61, y : arg62)\nvar v6 : Int = 129\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 6\nvar arg71 : Int = 34\nvar arg72 : Int = 1234\nvar x7 : Int = xOrY(n : arg70, x : arg71, y : arg72)\nvar v7 : Int = 1234\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 1\nvar arg81 : Int = 2\nvar arg82 : Int = 0\nvar x8 : Int = xOrY(n : arg80, x : arg81, y : arg82)\nvar v8 : Int = 0\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 2\nvar arg91 : Int = 2\nvar arg92 : Int = 0\nvar x9 : Int = xOrY(n : arg90, x : arg91, y : arg92)\nvar v9 : Int = 2\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\n", "description": "Ένα απλό πρόγραμμα που θα πρέπει να επιστρέφει την τιμή του x αν το n είναι πρώτος αριθμός και θα πρέπει να επιστρέφει την τιμή του y σε διαφορετική περίπτωση.\n\nΠαραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/72", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δεδομένης μιας λίστας αριθμών, επιστρέψτε το άθροισμα των τετραγώνων των αριθμών στη λίστα που είναι περιττοί. Αγνοήστε τους αριθμούς που είναι αρνητικοί ή δεν είναι ακέραιοι.\n * \n *     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n *     double_the_difference([-1, -2, 0]) == 0\n *     double_the_difference([9, -2]) == 81\n *     double_the_difference([0]) == 0\n * \n *     Εάν η είσοδος είναι κενή λίστα, επιστρέψτε 0.\n * \n *\n */\nfunc doubleTheDifference(lst : [AnyHashable]) -> Int {\n", "entry_point": "doubleTheDifference", "test": "\n\nvar arg00 : [AnyHashable] = []\nvar x0 : Int = doubleTheDifference(lst : arg00)\nvar v0 : Int = 0\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [5, 4]\nvar x1 : Int = doubleTheDifference(lst : arg10)\nvar v1 : Int = 25\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [0.1, 0.2, 0.3]\nvar x2 : Int = doubleTheDifference(lst : arg20)\nvar v2 : Int = 0\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [-10, -20, -30]\nvar x3 : Int = doubleTheDifference(lst : arg30)\nvar v3 : Int = 0\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [-1, -2, 8]\nvar x4 : Int = doubleTheDifference(lst : arg40)\nvar v4 : Int = 0\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable] = [0.2, 3, 5]\nvar x5 : Int = doubleTheDifference(lst : arg50)\nvar v5 : Int = 34\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [AnyHashable] = [-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]\nvar x6 : Int = doubleTheDifference(lst : arg60)\nvar v6 : Int = 166650\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "Δεδομένης μιας λίστας αριθμών, επιστρέψτε το άθροισμα των τετραγώνων των αριθμών στη λίστα που είναι περιττοί. Αγνοήστε τους αριθμούς που είναι αρνητικοί ή δεν είναι ακέραιοι.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    Εάν η είσοδος είναι κενή λίστα, επιστρέψτε 0.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/73", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Θα σας δοθεί το όνομα μιας κλάσης (ένα string) και μια λίστα επεκτάσεων. Οι επεκτάσεις πρέπει να χρησιμοποιηθούν για να φορτώσουν επιπλέον κλάσεις στην κλάση. Η δύναμη της επέκτασης είναι ως εξής: Ας είναι CAP ο αριθμός των κεφαλαίων γραμμάτων στο όνομα της επέκτασης και ας είναι SM ο αριθμός των πεζών γραμμάτων στο όνομα της επέκτασης, η δύναμη δίνεται από το κλάσμα CAP - SM. Θα πρέπει να βρείτε την ισχυρότερη επέκταση και να επιστρέψετε ένα string σε αυτή τη μορφή: ClassName.StrongestExtensionName. Εάν υπάρχουν δύο ή περισσότερες επεκτάσεις με την ίδια δύναμη, θα πρέπει να επιλέξετε αυτή που έρχεται πρώτη στη λίστα. Για παράδειγμα, εάν σας δοθεί \"Slices\" ως κλάση και μια λίστα επεκτάσεων: ['SErviNGSliCes', 'Cheese', 'StuFfed'], τότε θα πρέπει να επιστρέψετε 'Slices.SErviNGSliCes' καθώς η 'SErviNGSliCes' είναι η ισχυρότερη επέκταση (η δύναμή της είναι -1). Παράδειγμα:\n * \n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n *\n */\nfunc strongestExtension(className : String, extensions : [String]) -> String {\n", "entry_point": "strongestExtension", "test": "\n\nvar arg00 : String = #\"Watashi\"#\nvar arg01 : [String] = [#\"tEN\"#, #\"niNE\"#, #\"eIGHt8OKe\"#]\nvar x0 : String = strongestExtension(className : arg00, extensions : arg01)\nvar v0 : String = #\"Watashi.eIGHt8OKe\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"Boku123\"#\nvar arg11 : [String] = [#\"nani\"#, #\"NazeDa\"#, #\"YEs.WeCaNe\"#, #\"32145tggg\"#]\nvar x1 : String = strongestExtension(className : arg10, extensions : arg11)\nvar v1 : String = #\"Boku123.YEs.WeCaNe\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"__YESIMHERE\"#\nvar arg21 : [String] = [#\"t\"#, #\"eMptY\"#, #\"nothing\"#, #\"zeR00\"#, #\"NuLl__\"#, #\"123NoooneB321\"#]\nvar x2 : String = strongestExtension(className : arg20, extensions : arg21)\nvar v2 : String = #\"__YESIMHERE.NuLl__\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"K\"#\nvar arg31 : [String] = [#\"Ta\"#, #\"TAR\"#, #\"t234An\"#, #\"cosSo\"#]\nvar x3 : String = strongestExtension(className : arg30, extensions : arg31)\nvar v3 : String = #\"K.TAR\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"__HAHA\"#\nvar arg41 : [String] = [#\"Tab\"#, #\"123\"#, #\"781345\"#, #\"-_-\"#]\nvar x4 : String = strongestExtension(className : arg40, extensions : arg41)\nvar v4 : String = #\"__HAHA.123\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"YameRore\"#\nvar arg51 : [String] = [#\"HhAas\"#, #\"okIWILL123\"#, #\"WorkOut\"#, #\"Fails\"#, #\"-_-\"#]\nvar x5 : String = strongestExtension(className : arg50, extensions : arg51)\nvar v5 : String = #\"YameRore.okIWILL123\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"finNNalLLly\"#\nvar arg61 : [String] = [#\"Die\"#, #\"NowW\"#, #\"Wow\"#, #\"WoW\"#]\nvar x6 : String = strongestExtension(className : arg60, extensions : arg61)\nvar v6 : String = #\"finNNalLLly.WoW\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"_\"#\nvar arg71 : [String] = [#\"Bb\"#, #\"91245\"#]\nvar x7 : String = strongestExtension(className : arg70, extensions : arg71)\nvar v7 : String = #\"_.Bb\"#\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : String = #\"Sp\"#\nvar arg81 : [String] = [#\"671235\"#, #\"Bb\"#]\nvar x8 : String = strongestExtension(className : arg80, extensions : arg81)\nvar v8 : String = #\"Sp.671235\"#\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\n", "description": "Θα σας δοθεί το όνομα μιας κλάσης (ένα string) και μια λίστα επεκτάσεων. Οι επεκτάσεις πρέπει να χρησιμοποιηθούν για να φορτώσουν επιπλέον κλάσεις στην κλάση. Η δύναμη της επέκτασης είναι ως εξής: Ας είναι CAP ο αριθμός των κεφαλαίων γραμμάτων στο όνομα της επέκτασης και ας είναι SM ο αριθμός των πεζών γραμμάτων στο όνομα της επέκτασης, η δύναμη δίνεται από το κλάσμα CAP - SM. Θα πρέπει να βρείτε την ισχυρότερη επέκταση και να επιστρέψετε ένα string σε αυτή τη μορφή: ClassName.StrongestExtensionName. Εάν υπάρχουν δύο ή περισσότερες επεκτάσεις με την ίδια δύναμη, θα πρέπει να επιλέξετε αυτή που έρχεται πρώτη στη λίστα. Για παράδειγμα, εάν σας δοθεί \"Slices\" ως κλάση και μια λίστα επεκτάσεων: ['SErviNGSliCes', 'Cheese', 'StuFfed'], τότε θα πρέπει να επιστρέψετε 'Slices.SErviNGSliCes' καθώς η 'SErviNGSliCes' είναι η ισχυρότερη επέκταση (η δύναμή της είναι -1). Παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/74", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Σας δίνονται 2 λέξεις. Χρειάζεται να επιστρέψετε True αν η δεύτερη λέξη ή οποιαδήποτε από τις περιστροφές της είναι υποσυμβολοσειρά στην πρώτη λέξη.\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n\n *\n */\nfunc cycpatternCheck(a : String, b : String) -> Bool {\n", "entry_point": "cycpatternCheck", "test": "\n\nvar arg00 : String = #\"xyzw\"#\nvar arg01 : String = #\"xyw\"#\nvar x0 : Bool = cycpatternCheck(a : arg00, b : arg01)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"yello\"#\nvar arg11 : String = #\"ell\"#\nvar x1 : Bool = cycpatternCheck(a : arg10, b : arg11)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"whattup\"#\nvar arg21 : String = #\"ptut\"#\nvar x2 : Bool = cycpatternCheck(a : arg20, b : arg21)\nvar v2 : Bool = false\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"efef\"#\nvar arg31 : String = #\"fee\"#\nvar x3 : Bool = cycpatternCheck(a : arg30, b : arg31)\nvar v3 : Bool = true\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"abab\"#\nvar arg41 : String = #\"aabb\"#\nvar x4 : Bool = cycpatternCheck(a : arg40, b : arg41)\nvar v4 : Bool = false\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"winemtt\"#\nvar arg51 : String = #\"tinem\"#\nvar x5 : Bool = cycpatternCheck(a : arg50, b : arg51)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "Σας δίνονται 2 λέξεις. Χρειάζεται να επιστρέψετε True αν η δεύτερη λέξη ή οποιαδήποτε από τις περιστροφές της είναι υποσυμβολοσειρά στην πρώτη λέξη.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/75", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δεδομένου ενός θετικού ακεραίου, να ανακτηθεί η αντίστοιχη ρωμαϊκή αριθμητική του σε μορφή συμβολοσειράς και να επιστραφεί σε πεζά γράμματα.\n *     Περιορισμοί: 1 <= num <= 1000\n * \n *     Παραδείγματα:\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n *\n */\nfunc intToMiniRoman(number : Int) -> String {\n", "entry_point": "intToMiniRoman", "test": "\n\nvar arg00 : Int = 19\nvar x0 : String = intToMiniRoman(number : arg00)\nvar v0 : String = #\"xix\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 152\nvar x1 : String = intToMiniRoman(number : arg10)\nvar v1 : String = #\"clii\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 251\nvar x2 : String = intToMiniRoman(number : arg20)\nvar v2 : String = #\"ccli\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 426\nvar x3 : String = intToMiniRoman(number : arg30)\nvar v3 : String = #\"cdxxvi\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 500\nvar x4 : String = intToMiniRoman(number : arg40)\nvar v4 : String = #\"d\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 1\nvar x5 : String = intToMiniRoman(number : arg50)\nvar v5 : String = #\"i\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 4\nvar x6 : String = intToMiniRoman(number : arg60)\nvar v6 : String = #\"iv\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 43\nvar x7 : String = intToMiniRoman(number : arg70)\nvar v7 : String = #\"xliii\"#\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 90\nvar x8 : String = intToMiniRoman(number : arg80)\nvar v8 : String = #\"xc\"#\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 94\nvar x9 : String = intToMiniRoman(number : arg90)\nvar v9 : String = #\"xciv\"#\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : Int = 532\nvar x10 : String = intToMiniRoman(number : arg100)\nvar v10 : String = #\"dxxxii\"#\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : Int = 900\nvar x11 : String = intToMiniRoman(number : arg110)\nvar v11 : String = #\"cm\"#\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : Int = 994\nvar x12 : String = intToMiniRoman(number : arg120)\nvar v12 : String = #\"cmxciv\"#\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\nvar arg130 : Int = 1000\nvar x13 : String = intToMiniRoman(number : arg130)\nvar v13 : String = #\"m\"#\nassert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \")\n\n", "description": "Δεδομένου ενός θετικού ακεραίου, να ανακτηθεί η αντίστοιχη ρωμαϊκή αριθμητική του σε μορφή συμβολοσειράς και να επιστραφεί σε πεζά γράμματα.\n    Περιορισμοί: 1 <= num <= 1000\n\n    Παραδείγματα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/76", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέφει True αν οι τρεις πλευρές σχηματίζουν ένα ορθογώνιο τρίγωνο, False διαφορετικά. Ένα ορθογώνιο τρίγωνο είναι ένα τρίγωνο στο οποίο ένα γωνία είναι ορθή ή 90 μοίρες. Παράδειγμα:\n * \n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n *\n */\nfunc rightAngleTriangle(a : Int, b : Int, c : Int) -> Bool {\n", "entry_point": "rightAngleTriangle", "test": "\n\nvar arg00 : Int = 3\nvar arg01 : Int = 4\nvar arg02 : Int = 5\nvar x0 : Bool = rightAngleTriangle(a : arg00, b : arg01, c : arg02)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 1\nvar arg11 : Int = 2\nvar arg12 : Int = 3\nvar x1 : Bool = rightAngleTriangle(a : arg10, b : arg11, c : arg12)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 10\nvar arg21 : Int = 6\nvar arg22 : Int = 8\nvar x2 : Bool = rightAngleTriangle(a : arg20, b : arg21, c : arg22)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 2\nvar arg31 : Int = 2\nvar arg32 : Int = 2\nvar x3 : Bool = rightAngleTriangle(a : arg30, b : arg31, c : arg32)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 7\nvar arg41 : Int = 24\nvar arg42 : Int = 25\nvar x4 : Bool = rightAngleTriangle(a : arg40, b : arg41, c : arg42)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 10\nvar arg51 : Int = 5\nvar arg52 : Int = 7\nvar x5 : Bool = rightAngleTriangle(a : arg50, b : arg51, c : arg52)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 5\nvar arg61 : Int = 12\nvar arg62 : Int = 13\nvar x6 : Bool = rightAngleTriangle(a : arg60, b : arg61, c : arg62)\nvar v6 : Bool = true\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 15\nvar arg71 : Int = 8\nvar arg72 : Int = 17\nvar x7 : Bool = rightAngleTriangle(a : arg70, b : arg71, c : arg72)\nvar v7 : Bool = true\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 48\nvar arg81 : Int = 55\nvar arg82 : Int = 73\nvar x8 : Bool = rightAngleTriangle(a : arg80, b : arg81, c : arg82)\nvar v8 : Bool = true\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 1\nvar arg91 : Int = 1\nvar arg92 : Int = 1\nvar x9 : Bool = rightAngleTriangle(a : arg90, b : arg91, c : arg92)\nvar v9 : Bool = false\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : Int = 2\nvar arg101 : Int = 2\nvar arg102 : Int = 10\nvar x10 : Bool = rightAngleTriangle(a : arg100, b : arg101, c : arg102)\nvar v10 : Bool = false\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\n", "description": "Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέφει True αν οι τρεις πλευρές σχηματίζουν ένα ορθογώνιο τρίγωνο, False διαφορετικά. Ένα ορθογώνιο τρίγωνο είναι ένα τρίγωνο στο οποίο ένα γωνία είναι ορθή ή 90 μοίρες. Παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/77", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * Σας δίνεται μια συμβολοσειρά s.\n *     Αν s[i] είναι γράμμα, αντιστρέψτε την πεζή πεζή σε κεφαλαία ή αντίστροφα, \n *     διαφορετικά κρατήστε το όπως είναι.\n *     Εάν η συμβολοσειρά δεν περιέχει γράμματα, αντιστρέψτε τη συμβολοσειρά.\n *     Η συνάρτηση πρέπει να επιστρέψει τη συμβολοσειρά που προέκυψε.\n *     Παραδείγματα\n * \n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n *\n */\nfunc solve(s : String) -> String {\n", "entry_point": "solve", "test": "\n\nvar arg00 : String = #\"AsDf\"#\nvar x0 : String = solve(s : arg00)\nvar v0 : String = #\"aSdF\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"1234\"#\nvar x1 : String = solve(s : arg10)\nvar v1 : String = #\"4321\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"ab\"#\nvar x2 : String = solve(s : arg20)\nvar v2 : String = #\"AB\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"#a@C\"#\nvar x3 : String = solve(s : arg30)\nvar v3 : String = #\"#A@c\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"#AsdfW^45\"#\nvar x4 : String = solve(s : arg40)\nvar v4 : String = #\"#aSDFw^45\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"#6@2\"#\nvar x5 : String = solve(s : arg50)\nvar v5 : String = #\"2@6#\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"#\\$a^D\"#\nvar x6 : String = solve(s : arg60)\nvar v6 : String = #\"#\\$A^d\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"#ccc\"#\nvar x7 : String = solve(s : arg70)\nvar v7 : String = #\"#CCC\"#\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\n", "description": "Σας δίνεται μια συμβολοσειρά s.\n    Αν s[i] είναι γράμμα, αντιστρέψτε την πεζή πεζή σε κεφαλαία ή αντίστροφα, \n    διαφορετικά κρατήστε το όπως είναι.\n    Εάν η συμβολοσειρά δεν περιέχει γράμματα, αντιστρέψτε τη συμβολοσειρά.\n    Η συνάρτηση πρέπει να επιστρέψει τη συμβολοσειρά που προέκυψε.\n    Παραδείγματα", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/78", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δεδομένου ενός αλφαριθμητικού 'text', επιστρέψτε ένα αντίστοιχο αλφαριθμητικό md5 hash του. Εάν το 'text' είναι ένα κενό αλφαριθμητικό, επιστρέψτε null.\n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n *\n */\nfunc stringToMd5(text : String) -> String {\n", "entry_point": "stringToMd5", "test": "\n\nvar arg00 : String = #\"Hello world\"#\nvar x0 : String = stringToMd5(text : arg00)\nvar v0 : String = #\"3e25960a79dbc69b674cd4ec67a72c62\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"\"#\nvar x1 : String = stringToMd5(text : arg10)\nvar v1 : String = \"none\"\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"A B C\"#\nvar x2 : String = stringToMd5(text : arg20)\nvar v2 : String = #\"0ef78513b0cb8cef12743f5aeb35f888\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"password\"#\nvar x3 : String = stringToMd5(text : arg30)\nvar v3 : String = #\"5f4dcc3b5aa765d61d8327deb882cf99\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "Δεδομένου ενός αλφαριθμητικού 'text', επιστρέψτε ένα αντίστοιχο αλφαριθμητικό md5 hash του. Εάν το 'text' είναι ένα κενό αλφαριθμητικό, επιστρέψτε null.", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "swift/79", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής Swift και αυτή είναι η εργασία σας.\n * * Δεδομένων δύο θετικών ακεραίων a και b, επιστρέφονται οι άρτιοι αριθμοί μεταξύ a και b, με αύξουσα σειρά.\n * \n * Για παράδειγμα:\n * \n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n *\n */\nfunc generateIntegers(a : Int, b : Int) -> [AnyHashable] {\n", "entry_point": "generateIntegers", "test": "\n\nvar arg00 : Int = 2\nvar arg01 : Int = 10\nvar x0 : [AnyHashable] = generateIntegers(a : arg00, b : arg01)\nvar v0 : [AnyHashable] = [2, 4, 6, 8]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 10\nvar arg11 : Int = 2\nvar x1 : [AnyHashable] = generateIntegers(a : arg10, b : arg11)\nvar v1 : [AnyHashable] = [2, 4, 6, 8]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 132\nvar arg21 : Int = 2\nvar x2 : [AnyHashable] = generateIntegers(a : arg20, b : arg21)\nvar v2 : [AnyHashable] = [2, 4, 6, 8]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 17\nvar arg31 : Int = 89\nvar x3 : [AnyHashable] = generateIntegers(a : arg30, b : arg31)\nvar v3 : [AnyHashable] = []\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "Δεδομένων δύο θετικών ακεραίων a και b, επιστρέφονται οι άρτιοι αριθμοί μεταξύ a και b, με αύξουσα σειρά.\n\nΓια παράδειγμα:", "language": "swift", "canonical_solution": NaN, "natural_language": "Greek"}
