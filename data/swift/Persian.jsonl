{"task_id": "swift/0", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * شما یک لیست از عملیات واریز و برداشت در یک حساب بانکی با موجودی صفر داده شده است. وظیفه شما این است که در صورتی که در هر نقطه موجودی حساب کمتر از صفر شود، تشخیص دهید و در آن نقطه تابع باید True را برگرداند. در غیر این صورت باید False را برگرداند.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n *\n */\nfunc belowZero(operations : [AnyHashable]) -> Bool {\n", "entry_point": "belowZero", "test": "\n\nvar arg00 : [AnyHashable] = []\nvar x0 : Bool = belowZero(operations : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [1, 2, -3, 1, 2, -3]\nvar x1 : Bool = belowZero(operations : arg10)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [1, 2, -4, 5, 6]\nvar x2 : Bool = belowZero(operations : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [1, -1, 2, -2, 5, -5, 4, -4]\nvar x3 : Bool = belowZero(operations : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [1, -1, 2, -2, 5, -5, 4, -5]\nvar x4 : Bool = belowZero(operations : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable] = [1, -2, 2, -2, 5, -5, 4, -4]\nvar x5 : Bool = belowZero(operations : arg50)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "شما یک لیست از عملیات واریز و برداشت در یک حساب بانکی با موجودی صفر داده شده است. وظیفه شما این است که در صورتی که در هر نقطه موجودی حساب کمتر از صفر شود، تشخیص دهید و در آن نقطه تابع باید True را برگرداند. در غیر این صورت باید False را برگرداند.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/1", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * برای یک لیست داده شده از اعداد صحیح، یک تاپل شامل جمع و ضرب تمام اعداد در لیست برگردانید.\n * جمع خالی باید برابر با 0 و ضرب خالی باید برابر با 1 باشد.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n *\n */\nfunc sumProduct(numbers : [AnyHashable]) -> [Int] {\n", "entry_point": "sumProduct", "test": "\n\nvar arg00 : [AnyHashable] = []\nvar x0 : [Int] = sumProduct(numbers : arg00)\nvar v0 : [Int] = [0, 1]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [1, 1, 1]\nvar x1 : [Int] = sumProduct(numbers : arg10)\nvar v1 : [Int] = [3, 1]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [100, 0]\nvar x2 : [Int] = sumProduct(numbers : arg20)\nvar v2 : [Int] = [100, 0]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [3, 5, 7]\nvar x3 : [Int] = sumProduct(numbers : arg30)\nvar v3 : [Int] = [15, 105]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [10]\nvar x4 : [Int] = sumProduct(numbers : arg40)\nvar v4 : [Int] = [10, 10]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "برای یک لیست داده شده از اعداد صحیح، یک تاپل شامل جمع و ضرب تمام اعداد در لیست برگردانید.\nجمع خالی باید برابر با 0 و ضرب خالی باید برابر با 1 باشد.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/2", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * ورودی دو رشته a و b هستند که فقط شامل اعداد ۱ و ۰ هستند.\n *     عملگر XOR دودویی را روی این ورودی ها انجام داده و نتیجه را نیز به صورت یک رشته برگردانید.\n * >>> string_xor('010', '110')\n * '100'\n *\n */\nfunc stringXor(a : String, b : String) -> String {\n", "entry_point": "stringXor", "test": "\n\nvar arg00 : String = #\"111000\"#\nvar arg01 : String = #\"101010\"#\nvar x0 : String = stringXor(a : arg00, b : arg01)\nvar v0 : String = #\"010010\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"1\"#\nvar arg11 : String = #\"1\"#\nvar x1 : String = stringXor(a : arg10, b : arg11)\nvar v1 : String = #\"0\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"0101\"#\nvar arg21 : String = #\"0000\"#\nvar x2 : String = stringXor(a : arg20, b : arg21)\nvar v2 : String = #\"0101\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\n", "description": "ورودی دو رشته a و b هستند که فقط شامل اعداد ۱ و ۰ هستند.\n    عملگر XOR دودویی را روی این ورودی ها انجام داده و نتیجه را نیز به صورت یک رشته برگردانید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/3", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * از لیستی از رشته‌ها، بزرگترین رشته را بازگردانید. در صورت وجود چند رشته با طول یکسان، اولین رشته را بازگردانید. در صورت خالی بودن لیست ورودی، null بازگردانید.\n * >>> longest([])\n\n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n *\n */\nfunc longest(strings : [AnyHashable]) -> String {\n", "entry_point": "longest", "test": "\n\nvar arg00 : [AnyHashable] = []\nvar x0 : String = longest(strings : arg00)\nvar v0 : String = \"none\"\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [#\"x\"#, #\"y\"#, #\"z\"#]\nvar x1 : String = longest(strings : arg10)\nvar v1 : String = #\"x\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [#\"x\"#, #\"yyy\"#, #\"zzzz\"#, #\"www\"#, #\"kkkk\"#, #\"abc\"#]\nvar x2 : String = longest(strings : arg20)\nvar v2 : String = #\"zzzz\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\n", "description": "از لیستی از رشته‌ها، بزرگترین رشته را بازگردانید. در صورت وجود چند رشته با طول یکسان، اولین رشته را بازگردانید. در صورت خالی بودن لیست ورودی، null بازگردانید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/4", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * بازگشت بزرگترین مقسوم علیه مشترک دو عدد a و b\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n *\n */\nfunc greatestCommonDivisor(a : Int, b : Int) -> Int {\n", "entry_point": "greatestCommonDivisor", "test": "\n\nvar arg00 : Int = 3\nvar arg01 : Int = 7\nvar x0 : Int = greatestCommonDivisor(a : arg00, b : arg01)\nvar v0 : Int = 1\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 10\nvar arg11 : Int = 15\nvar x1 : Int = greatestCommonDivisor(a : arg10, b : arg11)\nvar v1 : Int = 5\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 49\nvar arg21 : Int = 14\nvar x2 : Int = greatestCommonDivisor(a : arg20, b : arg21)\nvar v2 : Int = 7\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 144\nvar arg31 : Int = 60\nvar x3 : Int = greatestCommonDivisor(a : arg30, b : arg31)\nvar v3 : Int = 12\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "بازگشت بزرگترین مقسوم علیه مشترک دو عدد a و b", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/5", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * ورودی یک رشته با فاصله جدا شده از اعداد از 'صفر' تا 'نه' است.\n *     انتخاب های معتبر عبارتند از 'صفر'، 'یک'، 'دو'، 'سه'، 'چهار'، 'پنج'، 'شش'، 'هفت'، 'هشت' و 'نه'.\n *     رشته را با اعداد مرتب شده از کوچکترین تا بزرگترین برگردانید.\n * >>> sort_numbers('three one five')\n * 'one three five'\n *\n */\nfunc sortNumbers(numbers : String) -> String {\n", "entry_point": "sortNumbers", "test": "\n\nvar arg00 : String = #\"\"#\nvar x0 : String = sortNumbers(numbers : arg00)\nvar v0 : String = #\"\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"three\"#\nvar x1 : String = sortNumbers(numbers : arg10)\nvar v1 : String = #\"three\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"three five nine\"#\nvar x2 : String = sortNumbers(numbers : arg20)\nvar v2 : String = #\"three five nine\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"five zero four seven nine eight\"#\nvar x3 : String = sortNumbers(numbers : arg30)\nvar v3 : String = #\"zero four five seven eight nine\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"six five four three two one zero\"#\nvar x4 : String = sortNumbers(numbers : arg40)\nvar v4 : String = #\"zero one two three four five six\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "ورودی یک رشته با فاصله جدا شده از اعداد از 'صفر' تا 'نه' است.\n    انتخاب های معتبر عبارتند از 'صفر'، 'یک'، 'دو'، 'سه'، 'چهار'، 'پنج'، 'شش'، 'هفت'، 'هشت' و 'نه'.\n    رشته را با اعداد مرتب شده از کوچکترین تا بزرگترین برگردانید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/6", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * در لیستی از اعداد (حداقل دو عنصر)، یک تبدیل خطی به این لیست اعمال شود، به گونه‌ای که کوچکترین عدد برابر با ۰ و بزرگترین عدد برابر با ۱ شود.\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n *\n */\nfunc rescaleToUnit(numbers : [Double]) -> [Double] {\n", "entry_point": "rescaleToUnit", "test": "\n\nvar arg00 : [Double] = [2.0, 49.9]\nvar x0 : [Double] = rescaleToUnit(numbers : arg00)\nvar v0 : [Double] = [0.0, 1.0]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Double] = [100.0, 49.9]\nvar x1 : [Double] = rescaleToUnit(numbers : arg10)\nvar v1 : [Double] = [1.0, 0.0]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Double] = [1.0, 2.0, 3.0, 4.0, 5.0]\nvar x2 : [Double] = rescaleToUnit(numbers : arg20)\nvar v2 : [Double] = [0.0, 0.25, 0.5, 0.75, 1.0]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Double] = [2.0, 1.0, 5.0, 3.0, 4.0]\nvar x3 : [Double] = rescaleToUnit(numbers : arg30)\nvar v3 : [Double] = [0.25, 0.0, 1.0, 0.5, 0.75]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Double] = [12.0, 11.0, 15.0, 13.0, 14.0]\nvar x4 : [Double] = rescaleToUnit(numbers : arg40)\nvar v4 : [Double] = [0.25, 0.0, 1.0, 0.5, 0.75]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "در لیستی از اعداد (حداقل دو عنصر)، یک تبدیل خطی به این لیست اعمال شود، به گونه‌ای که کوچکترین عدد برابر با ۰ و بزرگترین عدد برابر با ۱ شود.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/7", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * برای یک رشته داده شده، حروف کوچک را به حروف بزرگ و حروف بزرگ را به حروف کوچک تبدیل کنید.\n * >>> flip_case('Hello')\n * 'hELLO'\n *\n */\nfunc flipCase(string : String) -> String {\n", "entry_point": "flipCase", "test": "\n\nvar arg00 : String = #\"\"#\nvar x0 : String = flipCase(string : arg00)\nvar v0 : String = #\"\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"Hello!\"#\nvar x1 : String = flipCase(string : arg10)\nvar v1 : String = #\"hELLO!\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"These violent delights have violent ends\"#\nvar x2 : String = flipCase(string : arg20)\nvar v2 : String = #\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\n", "description": "برای یک رشته داده شده، حروف کوچک را به حروف بزرگ و حروف بزرگ را به حروف کوچک تبدیل کنید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/8", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * تنها اعداد مثبت در لیست را بازگردانید.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n *\n */\nfunc getPositive(l : [AnyHashable]) -> [AnyHashable] {\n", "entry_point": "getPositive", "test": "\n\nvar arg00 : [AnyHashable] = [-1, -2, 4, 5, 6]\nvar x0 : [AnyHashable] = getPositive(l : arg00)\nvar v0 : [AnyHashable] = [4, 5, 6]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]\nvar x1 : [AnyHashable] = getPositive(l : arg10)\nvar v1 : [AnyHashable] = [5, 3, 2, 3, 3, 9, 123, 1]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [-1, -2]\nvar x2 : [AnyHashable] = getPositive(l : arg20)\nvar v2 : [AnyHashable] = []\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = []\nvar x3 : [AnyHashable] = getPositive(l : arg30)\nvar v3 : [AnyHashable] = []\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "تنها اعداد مثبت در لیست را بازگردانید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/9", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * اگر یک عدد داده شده اول باشد، true برگردانید و در غیر این صورت false.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n *\n */\nfunc isPrime(n : Int) -> Bool {\n", "entry_point": "isPrime", "test": "\n\nvar arg00 : Int = 6\nvar x0 : Bool = isPrime(n : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 101\nvar x1 : Bool = isPrime(n : arg10)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 11\nvar x2 : Bool = isPrime(n : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 13441\nvar x3 : Bool = isPrime(n : arg30)\nvar v3 : Bool = true\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 61\nvar x4 : Bool = isPrime(n : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 4\nvar x5 : Bool = isPrime(n : arg50)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 1\nvar x6 : Bool = isPrime(n : arg60)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 5\nvar x7 : Bool = isPrime(n : arg70)\nvar v7 : Bool = true\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 11\nvar x8 : Bool = isPrime(n : arg80)\nvar v8 : Bool = true\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 17\nvar x9 : Bool = isPrime(n : arg90)\nvar v9 : Bool = true\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : Int = 85\nvar x10 : Bool = isPrime(n : arg100)\nvar v10 : Bool = false\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : Int = 77\nvar x11 : Bool = isPrime(n : arg110)\nvar v11 : Bool = false\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : Int = 255379\nvar x12 : Bool = isPrime(n : arg120)\nvar v12 : Bool = false\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\n", "description": "اگر یک عدد داده شده اول باشد، true برگردانید و در غیر این صورت false.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/10", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * بازگشت عناصر منحصر به فرد مرتب شده در یک لیست\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n *\n */\nfunc unique(l : [Int]) -> [Int] {\n", "entry_point": "unique", "test": "\n\nvar arg00 : [Int] = [5, 3, 5, 2, 3, 3, 9, 0, 123]\nvar x0 : [Int] = unique(l : arg00)\nvar v0 : [Int] = [0, 2, 3, 5, 9, 123]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\n", "description": "بازگشت عناصر منحصر به فرد مرتب شده در یک لیست", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/11", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * prime_fib عدد n ام را برمیگرداند که یک عدد فیبوناچی است و همچنین اول است.\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n *\n */\nfunc primeFib(n : Int) -> Int {\n", "entry_point": "primeFib", "test": "\n\nvar arg00 : Int = 1\nvar x0 : Int = primeFib(n : arg00)\nvar v0 : Int = 2\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 2\nvar x1 : Int = primeFib(n : arg10)\nvar v1 : Int = 3\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 3\nvar x2 : Int = primeFib(n : arg20)\nvar v2 : Int = 5\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 4\nvar x3 : Int = primeFib(n : arg30)\nvar v3 : Int = 13\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 5\nvar x4 : Int = primeFib(n : arg40)\nvar v4 : Int = 89\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 6\nvar x5 : Int = primeFib(n : arg50)\nvar v5 : Int = 233\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 7\nvar x6 : Int = primeFib(n : arg60)\nvar v6 : Int = 1597\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 8\nvar x7 : Int = primeFib(n : arg70)\nvar v7 : Int = 28657\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 9\nvar x8 : Int = primeFib(n : arg80)\nvar v8 : Int = 514229\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 10\nvar x9 : Int = primeFib(n : arg90)\nvar v9 : Int = 433494437\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\n", "description": "prime_fib عدد n ام را برمیگرداند که یک عدد فیبوناچی است و همچنین اول است.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/12", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * تابع triples_sum_to_zero یک لیست اعداد صحیح را به عنوان ورودی دریافت می‌کند.\n *     اگر در لیست سه عنصر متمایز وجود داشته باشد که مجموع آن‌ها صفر باشد، True برمی‌گرداند و در غیر این صورت False.\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n *\n */\nfunc triplesSumToZero(l : [Int]) -> Bool {\n", "entry_point": "triplesSumToZero", "test": "\n\nvar arg00 : [Int] = [1, 3, 5, 0]\nvar x0 : Bool = triplesSumToZero(l : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 3, 5, -1]\nvar x1 : Bool = triplesSumToZero(l : arg10)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [1, 3, -2, 1]\nvar x2 : Bool = triplesSumToZero(l : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [1, 2, 3, 7]\nvar x3 : Bool = triplesSumToZero(l : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [1, 2, 5, 7]\nvar x4 : Bool = triplesSumToZero(l : arg40)\nvar v4 : Bool = false\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [2, 4, -5, 3, 9, 7]\nvar x5 : Bool = triplesSumToZero(l : arg50)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [1]\nvar x6 : Bool = triplesSumToZero(l : arg60)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Int] = [1, 3, 5, -100]\nvar x7 : Bool = triplesSumToZero(l : arg70)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [Int] = [100, 3, 5, -100]\nvar x8 : Bool = triplesSumToZero(l : arg80)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\n", "description": "تابع triples_sum_to_zero یک لیست اعداد صحیح را به عنوان ورودی دریافت می‌کند.\n    اگر در لیست سه عنصر متمایز وجود داشته باشد که مجموع آن‌ها صفر باشد، True برمی‌گرداند و در غیر این صورت False.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/13", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * pairs_sum_to_zero یک لیست اعداد صحیح را به عنوان ورودی می‌گیرد.\n *     اگر دو عنصر متمایز در لیست وجود داشته باشند که مجموع آن‌ها صفر باشد، True برمی‌گرداند و در غیر این صورت False.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n *\n */\nfunc pairsSumToZero(l : [Int]) -> Bool {\n", "entry_point": "pairsSumToZero", "test": "\n\nvar arg00 : [Int] = [1, 3, 5, 0]\nvar x0 : Bool = pairsSumToZero(l : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 3, -2, 1]\nvar x1 : Bool = pairsSumToZero(l : arg10)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [1, 2, 3, 7]\nvar x2 : Bool = pairsSumToZero(l : arg20)\nvar v2 : Bool = false\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [2, 4, -5, 3, 5, 7]\nvar x3 : Bool = pairsSumToZero(l : arg30)\nvar v3 : Bool = true\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [1]\nvar x4 : Bool = pairsSumToZero(l : arg40)\nvar v4 : Bool = false\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [-3, 9, -1, 3, 2, 30]\nvar x5 : Bool = pairsSumToZero(l : arg50)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [-3, 9, -1, 3, 2, 31]\nvar x6 : Bool = pairsSumToZero(l : arg60)\nvar v6 : Bool = true\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Int] = [-3, 9, -1, 4, 2, 30]\nvar x7 : Bool = pairsSumToZero(l : arg70)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [Int] = [-3, 9, -1, 4, 2, 31]\nvar x8 : Bool = pairsSumToZero(l : arg80)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\n", "description": "pairs_sum_to_zero یک لیست اعداد صحیح را به عنوان ورودی می‌گیرد.\n    اگر دو عنصر متمایز در لیست وجود داشته باشند که مجموع آن‌ها صفر باشد، True برمی‌گرداند و در غیر این صورت False.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/14", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * دنباله اعداد فیبوناچی 4 یک دنباله مشابه دنباله فیبوناچی است که به شرح زیر تعریف می‌شود:\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n *     لطفا یک تابع برای محاسبه بهینه عنصر n ام از دنباله اعداد فیبوناچی 4 بنویسید. از بازگشتی استفاده نکنید.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n *\n */\nfunc fib4(n : Int) -> Int {\n", "entry_point": "fib4", "test": "\n\nvar arg00 : Int = 5\nvar x0 : Int = fib4(n : arg00)\nvar v0 : Int = 4\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 8\nvar x1 : Int = fib4(n : arg10)\nvar v1 : Int = 28\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 10\nvar x2 : Int = fib4(n : arg20)\nvar v2 : Int = 104\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 12\nvar x3 : Int = fib4(n : arg30)\nvar v3 : Int = 386\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "دنباله اعداد فیبوناچی 4 یک دنباله مشابه دنباله فیبوناچی است که به شرح زیر تعریف می‌شود:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    لطفا یک تابع برای محاسبه بهینه عنصر n ام از دنباله اعداد فیبوناچی 4 بنویسید. از بازگشتی استفاده نکنید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/15", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * بازگشت میانگین عناصر لیست l.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n *\n */\nfunc median(l : [Int]) -> Double {\n", "entry_point": "median", "test": "\n\nvar arg00 : [Int] = [3, 1, 2, 4, 5]\nvar x0 : Double = median(l : arg00)\nvar v0 : Double = 3\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [-10, 4, 6, 1000, 10, 20]\nvar x1 : Double = median(l : arg10)\nvar v1 : Double = 8.0\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [5]\nvar x2 : Double = median(l : arg20)\nvar v2 : Double = 5\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [6, 5]\nvar x3 : Double = median(l : arg30)\nvar v3 : Double = 5.5\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [8, 1, 3, 9, 9, 2, 7]\nvar x4 : Double = median(l : arg40)\nvar v4 : Double = 7\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "بازگشت میانگین عناصر لیست l.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/16", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * بررسی می‌کند که رشته داده شده یک پالیندروم است یا خیر.\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n *\n */\nfunc isPalindrome(text : String) -> Bool {\n", "entry_point": "isPalindrome", "test": "\n\nvar arg00 : String = #\"\"#\nvar x0 : Bool = isPalindrome(text : arg00)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"aba\"#\nvar x1 : Bool = isPalindrome(text : arg10)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"aaaaa\"#\nvar x2 : Bool = isPalindrome(text : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"zbcd\"#\nvar x3 : Bool = isPalindrome(text : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"xywyx\"#\nvar x4 : Bool = isPalindrome(text : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"xywyz\"#\nvar x5 : Bool = isPalindrome(text : arg50)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"xywzx\"#\nvar x6 : Bool = isPalindrome(text : arg60)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "بررسی می‌کند که رشته داده شده یک پالیندروم است یا خیر.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/17", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * remove_vowels یک تابع است که یک رشته را دریافت کرده و رشته‌ای بدون حروف صدادار برمی‌گرداند.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n *\n */\nfunc removeVowels(text : String) -> String {\n", "entry_point": "removeVowels", "test": "\n\nvar arg00 : String = #\"\"#\nvar x0 : String = removeVowels(text : arg00)\nvar v0 : String = #\"\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"abcdef\\nghijklm\"#\nvar x1 : String = removeVowels(text : arg10)\nvar v1 : String = #\"bcdf\\nghjklm\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"fedcba\"#\nvar x2 : String = removeVowels(text : arg20)\nvar v2 : String = #\"fdcb\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"eeeee\"#\nvar x3 : String = removeVowels(text : arg30)\nvar v3 : String = #\"\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"acBAA\"#\nvar x4 : String = removeVowels(text : arg40)\nvar v4 : String = #\"cB\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"EcBOO\"#\nvar x5 : String = removeVowels(text : arg50)\nvar v5 : String = #\"cB\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"ybcd\"#\nvar x6 : String = removeVowels(text : arg60)\nvar v6 : String = #\"ybcd\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "remove_vowels یک تابع است که یک رشته را دریافت کرده و رشته‌ای بدون حروف صدادار برمی‌گرداند.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/18", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * اگر همه اعداد در لیست l کمتر از آستانه t باشند، True برگردانید.\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n *\n */\nfunc belowThreshold(l : [Int], t : Int) -> Bool {\n", "entry_point": "belowThreshold", "test": "\n\nvar arg00 : [Int] = [1, 2, 4, 10]\nvar arg01 : Int = 100\nvar x0 : Bool = belowThreshold(l : arg00, t : arg01)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 20, 4, 10]\nvar arg11 : Int = 5\nvar x1 : Bool = belowThreshold(l : arg10, t : arg11)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [1, 20, 4, 10]\nvar arg21 : Int = 21\nvar x2 : Bool = belowThreshold(l : arg20, t : arg21)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [1, 20, 4, 10]\nvar arg31 : Int = 22\nvar x3 : Bool = belowThreshold(l : arg30, t : arg31)\nvar v3 : Bool = true\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [1, 8, 4, 10]\nvar arg41 : Int = 11\nvar x4 : Bool = belowThreshold(l : arg40, t : arg41)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [1, 8, 4, 10]\nvar arg51 : Int = 10\nvar x5 : Bool = belowThreshold(l : arg50, t : arg51)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "اگر همه اعداد در لیست l کمتر از آستانه t باشند، True برگردانید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/19", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * افزودن دو عدد x و y\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n *\n */\nfunc add(x : Int, y : Int) -> Int {\n", "entry_point": "add", "test": "\n\nvar arg00 : Int = 0\nvar arg01 : Int = 1\nvar x0 : Int = add(x : arg00, y : arg01)\nvar v0 : Int = 1\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 1\nvar arg11 : Int = 0\nvar x1 : Int = add(x : arg10, y : arg11)\nvar v1 : Int = 1\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 2\nvar arg21 : Int = 3\nvar x2 : Int = add(x : arg20, y : arg21)\nvar v2 : Int = 5\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 5\nvar arg31 : Int = 7\nvar x3 : Int = add(x : arg30, y : arg31)\nvar v3 : Int = 12\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 7\nvar arg41 : Int = 5\nvar x4 : Int = add(x : arg40, y : arg41)\nvar v4 : Int = 12\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 572\nvar arg51 : Int = 725\nvar x5 : Int = add(x : arg50, y : arg51)\nvar v5 : Int = 1297\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 51\nvar arg61 : Int = 804\nvar x6 : Int = add(x : arg60, y : arg61)\nvar v6 : Int = 855\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 645\nvar arg71 : Int = 96\nvar x7 : Int = add(x : arg70, y : arg71)\nvar v7 : Int = 741\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 712\nvar arg81 : Int = 853\nvar x8 : Int = add(x : arg80, y : arg81)\nvar v8 : Int = 1565\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 223\nvar arg91 : Int = 101\nvar x9 : Int = add(x : arg90, y : arg91)\nvar v9 : Int = 324\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : Int = 76\nvar arg101 : Int = 29\nvar x10 : Int = add(x : arg100, y : arg101)\nvar v10 : Int = 105\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : Int = 416\nvar arg111 : Int = 149\nvar x11 : Int = add(x : arg110, y : arg111)\nvar v11 : Int = 565\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : Int = 145\nvar arg121 : Int = 409\nvar x12 : Int = add(x : arg120, y : arg121)\nvar v12 : Int = 554\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\nvar arg130 : Int = 535\nvar arg131 : Int = 430\nvar x13 : Int = add(x : arg130, y : arg131)\nvar v13 : Int = 965\nassert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \")\n\nvar arg140 : Int = 118\nvar arg141 : Int = 303\nvar x14 : Int = add(x : arg140, y : arg141)\nvar v14 : Int = 421\nassert(x14 == v14, \"Exception -- test case 14 did not pass. x14 = \")\n\nvar arg150 : Int = 287\nvar arg151 : Int = 94\nvar x15 : Int = add(x : arg150, y : arg151)\nvar v15 : Int = 381\nassert(x15 == v15, \"Exception -- test case 15 did not pass. x15 = \")\n\nvar arg160 : Int = 768\nvar arg161 : Int = 257\nvar x16 : Int = add(x : arg160, y : arg161)\nvar v16 : Int = 1025\nassert(x16 == v16, \"Exception -- test case 16 did not pass. x16 = \")\n\nvar arg170 : Int = 421\nvar arg171 : Int = 677\nvar x17 : Int = add(x : arg170, y : arg171)\nvar v17 : Int = 1098\nassert(x17 == v17, \"Exception -- test case 17 did not pass. x17 = \")\n\nvar arg180 : Int = 802\nvar arg181 : Int = 814\nvar x18 : Int = add(x : arg180, y : arg181)\nvar v18 : Int = 1616\nassert(x18 == v18, \"Exception -- test case 18 did not pass. x18 = \")\n\nvar arg190 : Int = 510\nvar arg191 : Int = 922\nvar x19 : Int = add(x : arg190, y : arg191)\nvar v19 : Int = 1432\nassert(x19 == v19, \"Exception -- test case 19 did not pass. x19 = \")\n\nvar arg200 : Int = 345\nvar arg201 : Int = 819\nvar x20 : Int = add(x : arg200, y : arg201)\nvar v20 : Int = 1164\nassert(x20 == v20, \"Exception -- test case 20 did not pass. x20 = \")\n\nvar arg210 : Int = 895\nvar arg211 : Int = 436\nvar x21 : Int = add(x : arg210, y : arg211)\nvar v21 : Int = 1331\nassert(x21 == v21, \"Exception -- test case 21 did not pass. x21 = \")\n\nvar arg220 : Int = 123\nvar arg221 : Int = 424\nvar x22 : Int = add(x : arg220, y : arg221)\nvar v22 : Int = 547\nassert(x22 == v22, \"Exception -- test case 22 did not pass. x22 = \")\n\nvar arg230 : Int = 923\nvar arg231 : Int = 245\nvar x23 : Int = add(x : arg230, y : arg231)\nvar v23 : Int = 1168\nassert(x23 == v23, \"Exception -- test case 23 did not pass. x23 = \")\n\nvar arg240 : Int = 23\nvar arg241 : Int = 438\nvar x24 : Int = add(x : arg240, y : arg241)\nvar v24 : Int = 461\nassert(x24 == v24, \"Exception -- test case 24 did not pass. x24 = \")\n\nvar arg250 : Int = 565\nvar arg251 : Int = 133\nvar x25 : Int = add(x : arg250, y : arg251)\nvar v25 : Int = 698\nassert(x25 == v25, \"Exception -- test case 25 did not pass. x25 = \")\n\nvar arg260 : Int = 945\nvar arg261 : Int = 925\nvar x26 : Int = add(x : arg260, y : arg261)\nvar v26 : Int = 1870\nassert(x26 == v26, \"Exception -- test case 26 did not pass. x26 = \")\n\nvar arg270 : Int = 261\nvar arg271 : Int = 983\nvar x27 : Int = add(x : arg270, y : arg271)\nvar v27 : Int = 1244\nassert(x27 == v27, \"Exception -- test case 27 did not pass. x27 = \")\n\nvar arg280 : Int = 139\nvar arg281 : Int = 577\nvar x28 : Int = add(x : arg280, y : arg281)\nvar v28 : Int = 716\nassert(x28 == v28, \"Exception -- test case 28 did not pass. x28 = \")\n\nvar arg290 : Int = 763\nvar arg291 : Int = 178\nvar x29 : Int = add(x : arg290, y : arg291)\nvar v29 : Int = 941\nassert(x29 == v29, \"Exception -- test case 29 did not pass. x29 = \")\n\nvar arg300 : Int = 147\nvar arg301 : Int = 892\nvar x30 : Int = add(x : arg300, y : arg301)\nvar v30 : Int = 1039\nassert(x30 == v30, \"Exception -- test case 30 did not pass. x30 = \")\n\nvar arg310 : Int = 436\nvar arg311 : Int = 402\nvar x31 : Int = add(x : arg310, y : arg311)\nvar v31 : Int = 838\nassert(x31 == v31, \"Exception -- test case 31 did not pass. x31 = \")\n\nvar arg320 : Int = 610\nvar arg321 : Int = 581\nvar x32 : Int = add(x : arg320, y : arg321)\nvar v32 : Int = 1191\nassert(x32 == v32, \"Exception -- test case 32 did not pass. x32 = \")\n\nvar arg330 : Int = 103\nvar arg331 : Int = 416\nvar x33 : Int = add(x : arg330, y : arg331)\nvar v33 : Int = 519\nassert(x33 == v33, \"Exception -- test case 33 did not pass. x33 = \")\n\nvar arg340 : Int = 339\nvar arg341 : Int = 990\nvar x34 : Int = add(x : arg340, y : arg341)\nvar v34 : Int = 1329\nassert(x34 == v34, \"Exception -- test case 34 did not pass. x34 = \")\n\nvar arg350 : Int = 130\nvar arg351 : Int = 504\nvar x35 : Int = add(x : arg350, y : arg351)\nvar v35 : Int = 634\nassert(x35 == v35, \"Exception -- test case 35 did not pass. x35 = \")\n\nvar arg360 : Int = 242\nvar arg361 : Int = 717\nvar x36 : Int = add(x : arg360, y : arg361)\nvar v36 : Int = 959\nassert(x36 == v36, \"Exception -- test case 36 did not pass. x36 = \")\n\nvar arg370 : Int = 562\nvar arg371 : Int = 110\nvar x37 : Int = add(x : arg370, y : arg371)\nvar v37 : Int = 672\nassert(x37 == v37, \"Exception -- test case 37 did not pass. x37 = \")\n\nvar arg380 : Int = 396\nvar arg381 : Int = 909\nvar x38 : Int = add(x : arg380, y : arg381)\nvar v38 : Int = 1305\nassert(x38 == v38, \"Exception -- test case 38 did not pass. x38 = \")\n\nvar arg390 : Int = 887\nvar arg391 : Int = 703\nvar x39 : Int = add(x : arg390, y : arg391)\nvar v39 : Int = 1590\nassert(x39 == v39, \"Exception -- test case 39 did not pass. x39 = \")\n\nvar arg400 : Int = 870\nvar arg401 : Int = 551\nvar x40 : Int = add(x : arg400, y : arg401)\nvar v40 : Int = 1421\nassert(x40 == v40, \"Exception -- test case 40 did not pass. x40 = \")\n\nvar arg410 : Int = 422\nvar arg411 : Int = 391\nvar x41 : Int = add(x : arg410, y : arg411)\nvar v41 : Int = 813\nassert(x41 == v41, \"Exception -- test case 41 did not pass. x41 = \")\n\nvar arg420 : Int = 299\nvar arg421 : Int = 505\nvar x42 : Int = add(x : arg420, y : arg421)\nvar v42 : Int = 804\nassert(x42 == v42, \"Exception -- test case 42 did not pass. x42 = \")\n\nvar arg430 : Int = 346\nvar arg431 : Int = 56\nvar x43 : Int = add(x : arg430, y : arg431)\nvar v43 : Int = 402\nassert(x43 == v43, \"Exception -- test case 43 did not pass. x43 = \")\n\nvar arg440 : Int = 36\nvar arg441 : Int = 706\nvar x44 : Int = add(x : arg440, y : arg441)\nvar v44 : Int = 742\nassert(x44 == v44, \"Exception -- test case 44 did not pass. x44 = \")\n\nvar arg450 : Int = 738\nvar arg451 : Int = 411\nvar x45 : Int = add(x : arg450, y : arg451)\nvar v45 : Int = 1149\nassert(x45 == v45, \"Exception -- test case 45 did not pass. x45 = \")\n\nvar arg460 : Int = 679\nvar arg461 : Int = 87\nvar x46 : Int = add(x : arg460, y : arg461)\nvar v46 : Int = 766\nassert(x46 == v46, \"Exception -- test case 46 did not pass. x46 = \")\n\nvar arg470 : Int = 25\nvar arg471 : Int = 303\nvar x47 : Int = add(x : arg470, y : arg471)\nvar v47 : Int = 328\nassert(x47 == v47, \"Exception -- test case 47 did not pass. x47 = \")\n\nvar arg480 : Int = 161\nvar arg481 : Int = 612\nvar x48 : Int = add(x : arg480, y : arg481)\nvar v48 : Int = 773\nassert(x48 == v48, \"Exception -- test case 48 did not pass. x48 = \")\n\nvar arg490 : Int = 306\nvar arg491 : Int = 841\nvar x49 : Int = add(x : arg490, y : arg491)\nvar v49 : Int = 1147\nassert(x49 == v49, \"Exception -- test case 49 did not pass. x49 = \")\n\nvar arg500 : Int = 973\nvar arg501 : Int = 411\nvar x50 : Int = add(x : arg500, y : arg501)\nvar v50 : Int = 1384\nassert(x50 == v50, \"Exception -- test case 50 did not pass. x50 = \")\n\nvar arg510 : Int = 711\nvar arg511 : Int = 157\nvar x51 : Int = add(x : arg510, y : arg511)\nvar v51 : Int = 868\nassert(x51 == v51, \"Exception -- test case 51 did not pass. x51 = \")\n\nvar arg520 : Int = 471\nvar arg521 : Int = 27\nvar x52 : Int = add(x : arg520, y : arg521)\nvar v52 : Int = 498\nassert(x52 == v52, \"Exception -- test case 52 did not pass. x52 = \")\n\nvar arg530 : Int = 714\nvar arg531 : Int = 792\nvar x53 : Int = add(x : arg530, y : arg531)\nvar v53 : Int = 1506\nassert(x53 == v53, \"Exception -- test case 53 did not pass. x53 = \")\n\nvar arg540 : Int = 38\nvar arg541 : Int = 206\nvar x54 : Int = add(x : arg540, y : arg541)\nvar v54 : Int = 244\nassert(x54 == v54, \"Exception -- test case 54 did not pass. x54 = \")\n\nvar arg550 : Int = 907\nvar arg551 : Int = 343\nvar x55 : Int = add(x : arg550, y : arg551)\nvar v55 : Int = 1250\nassert(x55 == v55, \"Exception -- test case 55 did not pass. x55 = \")\n\nvar arg560 : Int = 23\nvar arg561 : Int = 760\nvar x56 : Int = add(x : arg560, y : arg561)\nvar v56 : Int = 783\nassert(x56 == v56, \"Exception -- test case 56 did not pass. x56 = \")\n\nvar arg570 : Int = 524\nvar arg571 : Int = 859\nvar x57 : Int = add(x : arg570, y : arg571)\nvar v57 : Int = 1383\nassert(x57 == v57, \"Exception -- test case 57 did not pass. x57 = \")\n\nvar arg580 : Int = 30\nvar arg581 : Int = 529\nvar x58 : Int = add(x : arg580, y : arg581)\nvar v58 : Int = 559\nassert(x58 == v58, \"Exception -- test case 58 did not pass. x58 = \")\n\nvar arg590 : Int = 341\nvar arg591 : Int = 691\nvar x59 : Int = add(x : arg590, y : arg591)\nvar v59 : Int = 1032\nassert(x59 == v59, \"Exception -- test case 59 did not pass. x59 = \")\n\nvar arg600 : Int = 167\nvar arg601 : Int = 729\nvar x60 : Int = add(x : arg600, y : arg601)\nvar v60 : Int = 896\nassert(x60 == v60, \"Exception -- test case 60 did not pass. x60 = \")\n\nvar arg610 : Int = 636\nvar arg611 : Int = 289\nvar x61 : Int = add(x : arg610, y : arg611)\nvar v61 : Int = 925\nassert(x61 == v61, \"Exception -- test case 61 did not pass. x61 = \")\n\nvar arg620 : Int = 503\nvar arg621 : Int = 144\nvar x62 : Int = add(x : arg620, y : arg621)\nvar v62 : Int = 647\nassert(x62 == v62, \"Exception -- test case 62 did not pass. x62 = \")\n\nvar arg630 : Int = 51\nvar arg631 : Int = 985\nvar x63 : Int = add(x : arg630, y : arg631)\nvar v63 : Int = 1036\nassert(x63 == v63, \"Exception -- test case 63 did not pass. x63 = \")\n\nvar arg640 : Int = 287\nvar arg641 : Int = 149\nvar x64 : Int = add(x : arg640, y : arg641)\nvar v64 : Int = 436\nassert(x64 == v64, \"Exception -- test case 64 did not pass. x64 = \")\n\nvar arg650 : Int = 659\nvar arg651 : Int = 75\nvar x65 : Int = add(x : arg650, y : arg651)\nvar v65 : Int = 734\nassert(x65 == v65, \"Exception -- test case 65 did not pass. x65 = \")\n\nvar arg660 : Int = 462\nvar arg661 : Int = 797\nvar x66 : Int = add(x : arg660, y : arg661)\nvar v66 : Int = 1259\nassert(x66 == v66, \"Exception -- test case 66 did not pass. x66 = \")\n\nvar arg670 : Int = 406\nvar arg671 : Int = 141\nvar x67 : Int = add(x : arg670, y : arg671)\nvar v67 : Int = 547\nassert(x67 == v67, \"Exception -- test case 67 did not pass. x67 = \")\n\nvar arg680 : Int = 106\nvar arg681 : Int = 44\nvar x68 : Int = add(x : arg680, y : arg681)\nvar v68 : Int = 150\nassert(x68 == v68, \"Exception -- test case 68 did not pass. x68 = \")\n\nvar arg690 : Int = 300\nvar arg691 : Int = 934\nvar x69 : Int = add(x : arg690, y : arg691)\nvar v69 : Int = 1234\nassert(x69 == v69, \"Exception -- test case 69 did not pass. x69 = \")\n\nvar arg700 : Int = 471\nvar arg701 : Int = 524\nvar x70 : Int = add(x : arg700, y : arg701)\nvar v70 : Int = 995\nassert(x70 == v70, \"Exception -- test case 70 did not pass. x70 = \")\n\nvar arg710 : Int = 122\nvar arg711 : Int = 429\nvar x71 : Int = add(x : arg710, y : arg711)\nvar v71 : Int = 551\nassert(x71 == v71, \"Exception -- test case 71 did not pass. x71 = \")\n\nvar arg720 : Int = 735\nvar arg721 : Int = 195\nvar x72 : Int = add(x : arg720, y : arg721)\nvar v72 : Int = 930\nassert(x72 == v72, \"Exception -- test case 72 did not pass. x72 = \")\n\nvar arg730 : Int = 335\nvar arg731 : Int = 484\nvar x73 : Int = add(x : arg730, y : arg731)\nvar v73 : Int = 819\nassert(x73 == v73, \"Exception -- test case 73 did not pass. x73 = \")\n\nvar arg740 : Int = 28\nvar arg741 : Int = 809\nvar x74 : Int = add(x : arg740, y : arg741)\nvar v74 : Int = 837\nassert(x74 == v74, \"Exception -- test case 74 did not pass. x74 = \")\n\nvar arg750 : Int = 430\nvar arg751 : Int = 20\nvar x75 : Int = add(x : arg750, y : arg751)\nvar v75 : Int = 450\nassert(x75 == v75, \"Exception -- test case 75 did not pass. x75 = \")\n\nvar arg760 : Int = 916\nvar arg761 : Int = 635\nvar x76 : Int = add(x : arg760, y : arg761)\nvar v76 : Int = 1551\nassert(x76 == v76, \"Exception -- test case 76 did not pass. x76 = \")\n\nvar arg770 : Int = 301\nvar arg771 : Int = 999\nvar x77 : Int = add(x : arg770, y : arg771)\nvar v77 : Int = 1300\nassert(x77 == v77, \"Exception -- test case 77 did not pass. x77 = \")\n\nvar arg780 : Int = 454\nvar arg781 : Int = 466\nvar x78 : Int = add(x : arg780, y : arg781)\nvar v78 : Int = 920\nassert(x78 == v78, \"Exception -- test case 78 did not pass. x78 = \")\n\nvar arg790 : Int = 905\nvar arg791 : Int = 259\nvar x79 : Int = add(x : arg790, y : arg791)\nvar v79 : Int = 1164\nassert(x79 == v79, \"Exception -- test case 79 did not pass. x79 = \")\n\nvar arg800 : Int = 168\nvar arg801 : Int = 205\nvar x80 : Int = add(x : arg800, y : arg801)\nvar v80 : Int = 373\nassert(x80 == v80, \"Exception -- test case 80 did not pass. x80 = \")\n\nvar arg810 : Int = 570\nvar arg811 : Int = 434\nvar x81 : Int = add(x : arg810, y : arg811)\nvar v81 : Int = 1004\nassert(x81 == v81, \"Exception -- test case 81 did not pass. x81 = \")\n\nvar arg820 : Int = 64\nvar arg821 : Int = 959\nvar x82 : Int = add(x : arg820, y : arg821)\nvar v82 : Int = 1023\nassert(x82 == v82, \"Exception -- test case 82 did not pass. x82 = \")\n\nvar arg830 : Int = 957\nvar arg831 : Int = 510\nvar x83 : Int = add(x : arg830, y : arg831)\nvar v83 : Int = 1467\nassert(x83 == v83, \"Exception -- test case 83 did not pass. x83 = \")\n\nvar arg840 : Int = 722\nvar arg841 : Int = 598\nvar x84 : Int = add(x : arg840, y : arg841)\nvar v84 : Int = 1320\nassert(x84 == v84, \"Exception -- test case 84 did not pass. x84 = \")\n\nvar arg850 : Int = 770\nvar arg851 : Int = 226\nvar x85 : Int = add(x : arg850, y : arg851)\nvar v85 : Int = 996\nassert(x85 == v85, \"Exception -- test case 85 did not pass. x85 = \")\n\nvar arg860 : Int = 579\nvar arg861 : Int = 66\nvar x86 : Int = add(x : arg860, y : arg861)\nvar v86 : Int = 645\nassert(x86 == v86, \"Exception -- test case 86 did not pass. x86 = \")\n\nvar arg870 : Int = 117\nvar arg871 : Int = 674\nvar x87 : Int = add(x : arg870, y : arg871)\nvar v87 : Int = 791\nassert(x87 == v87, \"Exception -- test case 87 did not pass. x87 = \")\n\nvar arg880 : Int = 530\nvar arg881 : Int = 30\nvar x88 : Int = add(x : arg880, y : arg881)\nvar v88 : Int = 560\nassert(x88 == v88, \"Exception -- test case 88 did not pass. x88 = \")\n\nvar arg890 : Int = 776\nvar arg891 : Int = 345\nvar x89 : Int = add(x : arg890, y : arg891)\nvar v89 : Int = 1121\nassert(x89 == v89, \"Exception -- test case 89 did not pass. x89 = \")\n\nvar arg900 : Int = 327\nvar arg901 : Int = 389\nvar x90 : Int = add(x : arg900, y : arg901)\nvar v90 : Int = 716\nassert(x90 == v90, \"Exception -- test case 90 did not pass. x90 = \")\n\nvar arg910 : Int = 596\nvar arg911 : Int = 12\nvar x91 : Int = add(x : arg910, y : arg911)\nvar v91 : Int = 608\nassert(x91 == v91, \"Exception -- test case 91 did not pass. x91 = \")\n\nvar arg920 : Int = 599\nvar arg921 : Int = 511\nvar x92 : Int = add(x : arg920, y : arg921)\nvar v92 : Int = 1110\nassert(x92 == v92, \"Exception -- test case 92 did not pass. x92 = \")\n\nvar arg930 : Int = 936\nvar arg931 : Int = 476\nvar x93 : Int = add(x : arg930, y : arg931)\nvar v93 : Int = 1412\nassert(x93 == v93, \"Exception -- test case 93 did not pass. x93 = \")\n\nvar arg940 : Int = 461\nvar arg941 : Int = 14\nvar x94 : Int = add(x : arg940, y : arg941)\nvar v94 : Int = 475\nassert(x94 == v94, \"Exception -- test case 94 did not pass. x94 = \")\n\nvar arg950 : Int = 966\nvar arg951 : Int = 157\nvar x95 : Int = add(x : arg950, y : arg951)\nvar v95 : Int = 1123\nassert(x95 == v95, \"Exception -- test case 95 did not pass. x95 = \")\n\nvar arg960 : Int = 326\nvar arg961 : Int = 91\nvar x96 : Int = add(x : arg960, y : arg961)\nvar v96 : Int = 417\nassert(x96 == v96, \"Exception -- test case 96 did not pass. x96 = \")\n\nvar arg970 : Int = 392\nvar arg971 : Int = 455\nvar x97 : Int = add(x : arg970, y : arg971)\nvar v97 : Int = 847\nassert(x97 == v97, \"Exception -- test case 97 did not pass. x97 = \")\n\nvar arg980 : Int = 446\nvar arg981 : Int = 477\nvar x98 : Int = add(x : arg980, y : arg981)\nvar v98 : Int = 923\nassert(x98 == v98, \"Exception -- test case 98 did not pass. x98 = \")\n\nvar arg990 : Int = 324\nvar arg991 : Int = 860\nvar x99 : Int = add(x : arg990, y : arg991)\nvar v99 : Int = 1184\nassert(x99 == v99, \"Exception -- test case 99 did not pass. x99 = \")\n\nvar arg1000 : Int = 945\nvar arg1001 : Int = 85\nvar x100 : Int = add(x : arg1000, y : arg1001)\nvar v100 : Int = 1030\nassert(x100 == v100, \"Exception -- test case 100 did not pass. x100 = \")\n\nvar arg1010 : Int = 886\nvar arg1011 : Int = 582\nvar x101 : Int = add(x : arg1010, y : arg1011)\nvar v101 : Int = 1468\nassert(x101 == v101, \"Exception -- test case 101 did not pass. x101 = \")\n\nvar arg1020 : Int = 886\nvar arg1021 : Int = 712\nvar x102 : Int = add(x : arg1020, y : arg1021)\nvar v102 : Int = 1598\nassert(x102 == v102, \"Exception -- test case 102 did not pass. x102 = \")\n\nvar arg1030 : Int = 842\nvar arg1031 : Int = 953\nvar x103 : Int = add(x : arg1030, y : arg1031)\nvar v103 : Int = 1795\nassert(x103 == v103, \"Exception -- test case 103 did not pass. x103 = \")\n\n", "description": "افزودن دو عدد x و y", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/20", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * بررسی کنید که دو کلمه دارای کاراکترهای یکسان هستند یا خیر.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n *\n */\nfunc sameChars(s0 : String, s1 : String) -> Bool {\n", "entry_point": "sameChars", "test": "\n\nvar arg00 : String = #\"eabcdzzzz\"#\nvar arg01 : String = #\"dddzzzzzzzddeddabc\"#\nvar x0 : Bool = sameChars(s0 : arg00, s1 : arg01)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"abcd\"#\nvar arg11 : String = #\"dddddddabc\"#\nvar x1 : Bool = sameChars(s0 : arg10, s1 : arg11)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"dddddddabc\"#\nvar arg21 : String = #\"abcd\"#\nvar x2 : Bool = sameChars(s0 : arg20, s1 : arg21)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"eabcd\"#\nvar arg31 : String = #\"dddddddabc\"#\nvar x3 : Bool = sameChars(s0 : arg30, s1 : arg31)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"abcd\"#\nvar arg41 : String = #\"dddddddabcf\"#\nvar x4 : Bool = sameChars(s0 : arg40, s1 : arg41)\nvar v4 : Bool = false\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"eabcdzzzz\"#\nvar arg51 : String = #\"dddzzzzzzzddddabc\"#\nvar x5 : Bool = sameChars(s0 : arg50, s1 : arg51)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"aabb\"#\nvar arg61 : String = #\"aaccc\"#\nvar x6 : Bool = sameChars(s0 : arg60, s1 : arg61)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "بررسی کنید که دو کلمه دارای کاراکترهای یکسان هستند یا خیر.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/21", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * بازگشت عدد فیبوناچی n ام.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n *\n */\nfunc fib(n : Int) -> Int {\n", "entry_point": "fib", "test": "\n\nvar arg00 : Int = 10\nvar x0 : Int = fib(n : arg00)\nvar v0 : Int = 55\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 1\nvar x1 : Int = fib(n : arg10)\nvar v1 : Int = 1\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 8\nvar x2 : Int = fib(n : arg20)\nvar v2 : Int = 21\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 11\nvar x3 : Int = fib(n : arg30)\nvar v3 : Int = 89\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 12\nvar x4 : Int = fib(n : arg40)\nvar v4 : Int = 144\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "بازگشت عدد فیبوناچی n ام.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/22", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * بازگشت عناصر مشترک منحصر به فرد مرتب شده برای دو لیست.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n\n *\n */\nfunc common(l1 : [Int], l2 : [AnyHashable]) -> [AnyHashable] {\n", "entry_point": "common", "test": "\n\nvar arg00 : [Int] = [1, 4, 3, 34, 653, 2, 5]\nvar arg01 : [AnyHashable] = [5, 7, 1, 5, 9, 653, 121]\nvar x0 : [AnyHashable] = common(l1 : arg00, l2 : arg01)\nvar v0 : [AnyHashable] = [1, 5, 653]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [5, 3, 2, 8]\nvar arg11 : [AnyHashable] = [3, 2]\nvar x1 : [AnyHashable] = common(l1 : arg10, l2 : arg11)\nvar v1 : [AnyHashable] = [2, 3]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [4, 3, 2, 8]\nvar arg21 : [AnyHashable] = [3, 2, 4]\nvar x2 : [AnyHashable] = common(l1 : arg20, l2 : arg21)\nvar v2 : [AnyHashable] = [2, 3, 4]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [4, 3, 2, 8]\nvar arg31 : [AnyHashable] = []\nvar x3 : [AnyHashable] = common(l1 : arg30, l2 : arg31)\nvar v3 : [AnyHashable] = []\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "بازگشت عناصر مشترک منحصر به فرد مرتب شده برای دو لیست.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/23", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * بزرگترین عامل اول n را بازگردانید. فرض کنید n> 1 و اول نیست.\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n *\n */\nfunc largestPrimeFactor(n : Int) -> Int {\n", "entry_point": "largestPrimeFactor", "test": "\n\nvar arg00 : Int = 15\nvar x0 : Int = largestPrimeFactor(n : arg00)\nvar v0 : Int = 5\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 27\nvar x1 : Int = largestPrimeFactor(n : arg10)\nvar v1 : Int = 3\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 63\nvar x2 : Int = largestPrimeFactor(n : arg20)\nvar v2 : Int = 7\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 330\nvar x3 : Int = largestPrimeFactor(n : arg30)\nvar v3 : Int = 11\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 13195\nvar x4 : Int = largestPrimeFactor(n : arg40)\nvar v4 : Int = 29\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "بزرگترین عامل اول n را بازگردانید. فرض کنید n> 1 و اول نیست.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/24", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * تابع sum_to_n مجموع اعداد از ۱ تا n را محاسبه می‌کند.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n *\n */\nfunc sumToN(n : Int) -> Int {\n", "entry_point": "sumToN", "test": "\n\nvar arg00 : Int = 1\nvar x0 : Int = sumToN(n : arg00)\nvar v0 : Int = 1\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 6\nvar x1 : Int = sumToN(n : arg10)\nvar v1 : Int = 21\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 11\nvar x2 : Int = sumToN(n : arg20)\nvar v2 : Int = 66\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 30\nvar x3 : Int = sumToN(n : arg30)\nvar v3 : Int = 465\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 100\nvar x4 : Int = sumToN(n : arg40)\nvar v4 : Int = 5050\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "تابع sum_to_n مجموع اعداد از ۱ تا n را محاسبه می‌کند.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/25", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * xs ضرایب یک چندجمله‌ای را نشان می‌دهد.\n * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n * مشتق این چندجمله‌ای را با همان فرم برگردانید.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n *\n */\nfunc derivative(xs : [Int]) -> [AnyHashable] {\n", "entry_point": "derivative", "test": "\n\nvar arg00 : [Int] = [3, 1, 2, 4, 5]\nvar x0 : [AnyHashable] = derivative(xs : arg00)\nvar v0 : [AnyHashable] = [1, 4, 12, 20]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 2, 3]\nvar x1 : [AnyHashable] = derivative(xs : arg10)\nvar v1 : [AnyHashable] = [2, 6]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [3, 2, 1]\nvar x2 : [AnyHashable] = derivative(xs : arg20)\nvar v2 : [AnyHashable] = [2, 2]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [3, 2, 1, 0, 4]\nvar x3 : [AnyHashable] = derivative(xs : arg30)\nvar v3 : [AnyHashable] = [2, 2, 0, 16]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [1]\nvar x4 : [AnyHashable] = derivative(xs : arg40)\nvar v4 : [AnyHashable] = []\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "xs ضرایب یک چندجمله‌ای را نشان می‌دهد.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\nمشتق این چندجمله‌ای را با همان فرم برگردانید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/26", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * دنباله اعداد فیبفیب یک دنباله مشابه دنباله فیبوناچی است که به شرح زیر تعریف می‌شود:\n *     fibfib(0) == 0\n *     fibfib(1) == 0\n *     fibfib(2) == 1\n *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n *     لطفا یک تابع برای محاسبه بهینه عنصر nام دنباله اعداد فیبفیب بنویسید.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n *\n */\nfunc fibfib(n : Int) -> Int {\n", "entry_point": "fibfib", "test": "\n\nvar arg00 : Int = 2\nvar x0 : Int = fibfib(n : arg00)\nvar v0 : Int = 1\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 1\nvar x1 : Int = fibfib(n : arg10)\nvar v1 : Int = 0\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 5\nvar x2 : Int = fibfib(n : arg20)\nvar v2 : Int = 4\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 8\nvar x3 : Int = fibfib(n : arg30)\nvar v3 : Int = 24\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 10\nvar x4 : Int = fibfib(n : arg40)\nvar v4 : Int = 81\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 12\nvar x5 : Int = fibfib(n : arg50)\nvar v5 : Int = 274\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 14\nvar x6 : Int = fibfib(n : arg60)\nvar v6 : Int = 927\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "دنباله اعداد فیبفیب یک دنباله مشابه دنباله فیبوناچی است که به شرح زیر تعریف می‌شود:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    لطفا یک تابع برای محاسبه بهینه عنصر nام دنباله اعداد فیبفیب بنویسید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/27", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * تابع vowels_count را بنویسید که یک رشته که یک کلمه را نشان می دهد را به عنوان ورودی می گیرد و تعداد حروف صدادار در رشته را برمی گرداند. حروف صدادار در اینجا 'a'، 'e'، 'i'، 'o'، 'u' هستند. در اینجا، 'y' نیز یک حرف صدادار است، اما فقط زمانی که در انتهای کلمه داده شده باشد.\n * \n *     مثال:\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n *\n */\nfunc vowelsCount(s : String) -> Int {\n", "entry_point": "vowelsCount", "test": "\n\nvar arg00 : String = #\"abcde\"#\nvar x0 : Int = vowelsCount(s : arg00)\nvar v0 : Int = 2\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"Alone\"#\nvar x1 : Int = vowelsCount(s : arg10)\nvar v1 : Int = 3\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"key\"#\nvar x2 : Int = vowelsCount(s : arg20)\nvar v2 : Int = 2\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"bye\"#\nvar x3 : Int = vowelsCount(s : arg30)\nvar v3 : Int = 1\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"keY\"#\nvar x4 : Int = vowelsCount(s : arg40)\nvar v4 : Int = 2\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"bYe\"#\nvar x5 : Int = vowelsCount(s : arg50)\nvar v5 : Int = 1\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"ACEDY\"#\nvar x6 : Int = vowelsCount(s : arg60)\nvar v6 : Int = 3\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "تابع vowels_count را بنویسید که یک رشته که یک کلمه را نشان می دهد را به عنوان ورودی می گیرد و تعداد حروف صدادار در رشته را برمی گرداند. حروف صدادار در اینجا 'a'، 'e'، 'i'، 'o'، 'u' هستند. در اینجا، 'y' نیز یک حرف صدادار است، اما فقط زمانی که در انتهای کلمه داده شده باشد.\n\n    مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/28", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * شما یک لیست غیر خالی از اعداد صحیح مثبت دارید. بزرگترین عدد صحیحی را که بزرگتر از صفر است و فرکانس آن بیشتر یا مساوی با مقدار خود عدد است، برگردانید. فرکانس یک عدد، تعداد بارهایی است که در لیست ظاهر می‌شود. اگر چنین مقداری وجود نداشته باشد، -1 را برگردانید. نمونه‌ها:\n * \n *     search([4, 1, 2, 2, 3, 1]) == 2\n *     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n *     search([5, 5, 4, 4, 4]) == -1\n *\n */\nfunc search(lst : [Int]) -> Int {\n", "entry_point": "search", "test": "\n\nvar arg00 : [Int] = [5, 5, 5, 5, 1]\nvar x0 : Int = search(lst : arg00)\nvar v0 : Int = 1\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [4, 1, 4, 1, 4, 4]\nvar x1 : Int = search(lst : arg10)\nvar v1 : Int = 4\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [3, 3]\nvar x2 : Int = search(lst : arg20)\nvar v2 : Int = -1\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [8, 8, 8, 8, 8, 8, 8, 8]\nvar x3 : Int = search(lst : arg30)\nvar v3 : Int = 8\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [2, 3, 3, 2, 2]\nvar x4 : Int = search(lst : arg40)\nvar v4 : Int = 2\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]\nvar x5 : Int = search(lst : arg50)\nvar v5 : Int = 1\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [3, 2, 8, 2]\nvar x6 : Int = search(lst : arg60)\nvar v6 : Int = 2\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Int] = [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]\nvar x7 : Int = search(lst : arg70)\nvar v7 : Int = 1\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [Int] = [8, 8, 3, 6, 5, 6, 4]\nvar x8 : Int = search(lst : arg80)\nvar v8 : Int = -1\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : [Int] = [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]\nvar x9 : Int = search(lst : arg90)\nvar v9 : Int = 1\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : [Int] = [1, 9, 10, 1, 3]\nvar x10 : Int = search(lst : arg100)\nvar v10 : Int = 1\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : [Int] = [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]\nvar x11 : Int = search(lst : arg110)\nvar v11 : Int = 5\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : [Int] = [1]\nvar x12 : Int = search(lst : arg120)\nvar v12 : Int = 1\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\nvar arg130 : [Int] = [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]\nvar x13 : Int = search(lst : arg130)\nvar v13 : Int = 4\nassert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \")\n\nvar arg140 : [Int] = [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]\nvar x14 : Int = search(lst : arg140)\nvar v14 : Int = 2\nassert(x14 == v14, \"Exception -- test case 14 did not pass. x14 = \")\n\nvar arg150 : [Int] = [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]\nvar x15 : Int = search(lst : arg150)\nvar v15 : Int = 1\nassert(x15 == v15, \"Exception -- test case 15 did not pass. x15 = \")\n\nvar arg160 : [Int] = [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]\nvar x16 : Int = search(lst : arg160)\nvar v16 : Int = 4\nassert(x16 == v16, \"Exception -- test case 16 did not pass. x16 = \")\n\nvar arg170 : [Int] = [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]\nvar x17 : Int = search(lst : arg170)\nvar v17 : Int = 4\nassert(x17 == v17, \"Exception -- test case 17 did not pass. x17 = \")\n\nvar arg180 : [Int] = [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]\nvar x18 : Int = search(lst : arg180)\nvar v18 : Int = 2\nassert(x18 == v18, \"Exception -- test case 18 did not pass. x18 = \")\n\nvar arg190 : [Int] = [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]\nvar x19 : Int = search(lst : arg190)\nvar v19 : Int = -1\nassert(x19 == v19, \"Exception -- test case 19 did not pass. x19 = \")\n\nvar arg200 : [Int] = [10]\nvar x20 : Int = search(lst : arg200)\nvar v20 : Int = -1\nassert(x20 == v20, \"Exception -- test case 20 did not pass. x20 = \")\n\nvar arg210 : [Int] = [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]\nvar x21 : Int = search(lst : arg210)\nvar v21 : Int = 2\nassert(x21 == v21, \"Exception -- test case 21 did not pass. x21 = \")\n\nvar arg220 : [Int] = [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]\nvar x22 : Int = search(lst : arg220)\nvar v22 : Int = 1\nassert(x22 == v22, \"Exception -- test case 22 did not pass. x22 = \")\n\nvar arg230 : [Int] = [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]\nvar x23 : Int = search(lst : arg230)\nvar v23 : Int = 1\nassert(x23 == v23, \"Exception -- test case 23 did not pass. x23 = \")\n\nvar arg240 : [Int] = [3, 10, 10, 9, 2]\nvar x24 : Int = search(lst : arg240)\nvar v24 : Int = -1\nassert(x24 == v24, \"Exception -- test case 24 did not pass. x24 = \")\n\n", "description": "شما یک لیست غیر خالی از اعداد صحیح مثبت دارید. بزرگترین عدد صحیحی را که بزرگتر از صفر است و فرکانس آن بیشتر یا مساوی با مقدار خود عدد است، برگردانید. فرکانس یک عدد، تعداد بارهایی است که در لیست ظاهر می‌شود. اگر چنین مقداری وجود نداشته باشد، -1 را برگردانید. نمونه‌ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/29", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * با دریافت طول سه ضلع مثلث، مساحت مثلث را با دو رقم اعشار گرد کرده و در صورتی که سه ضلع یک مثلث معتبر را تشکیل دهند، آن را برگردانید. در غیر این صورت، -1 را برگردانید. سه ضلع یک مثلث معتبر را زمانی تشکیل می دهند که مجموع هر دو ضلع بزرگتر از ضلع سوم باشد. مثال:\n * \n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n *\n */\nfunc triangleArea(a : Int, b : Int, c : Int) -> Double {\n", "entry_point": "triangleArea", "test": "\n\nvar arg00 : Int = 3\nvar arg01 : Int = 4\nvar arg02 : Int = 5\nvar x0 : Double = triangleArea(a : arg00, b : arg01, c : arg02)\nvar v0 : Double = 6.0\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 1\nvar arg11 : Int = 2\nvar arg12 : Int = 10\nvar x1 : Double = triangleArea(a : arg10, b : arg11, c : arg12)\nvar v1 : Double = -1\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 4\nvar arg21 : Int = 8\nvar arg22 : Int = 5\nvar x2 : Double = triangleArea(a : arg20, b : arg21, c : arg22)\nvar v2 : Double = 8.18\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 2\nvar arg31 : Int = 2\nvar arg32 : Int = 2\nvar x3 : Double = triangleArea(a : arg30, b : arg31, c : arg32)\nvar v3 : Double = 1.73\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 1\nvar arg41 : Int = 2\nvar arg42 : Int = 3\nvar x4 : Double = triangleArea(a : arg40, b : arg41, c : arg42)\nvar v4 : Double = -1\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 10\nvar arg51 : Int = 5\nvar arg52 : Int = 7\nvar x5 : Double = triangleArea(a : arg50, b : arg51, c : arg52)\nvar v5 : Double = 16.25\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 2\nvar arg61 : Int = 6\nvar arg62 : Int = 3\nvar x6 : Double = triangleArea(a : arg60, b : arg61, c : arg62)\nvar v6 : Double = -1\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 1\nvar arg71 : Int = 1\nvar arg72 : Int = 1\nvar x7 : Double = triangleArea(a : arg70, b : arg71, c : arg72)\nvar v7 : Double = 0.43\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 2\nvar arg81 : Int = 2\nvar arg82 : Int = 10\nvar x8 : Double = triangleArea(a : arg80, b : arg81, c : arg82)\nvar v8 : Double = -1\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\n", "description": "با دریافت طول سه ضلع مثلث، مساحت مثلث را با دو رقم اعشار گرد کرده و در صورتی که سه ضلع یک مثلث معتبر را تشکیل دهند، آن را برگردانید. در غیر این صورت، -1 را برگردانید. سه ضلع یک مثلث معتبر را زمانی تشکیل می دهند که مجموع هر دو ضلع بزرگتر از ضلع سوم باشد. مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/30", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * تابعی بنویسید که در صورتی که شیء q پرواز کند، True برمی گرداند و در غیر این صورت False.\n * شیء q در صورتی پرواز می کند که متعادل باشد (یک لیست پالیندرومیک است) و مجموع عناصر آن کمتر یا مساوی حداکثر وزن ممکن w باشد.\n * \n * مثال:\n * will_it_fly([1، 2]، 5) ➞ False\n * # 1 + 2 کمتر از حداکثر وزن ممکن است، اما متعادل نیست.\n * \n * will_it_fly([3، 2، 3]، 1) ➞ False\n * # متعادل است، اما 3 + 2 + 3 بیشتر از حداکثر وزن ممکن است.\n * \n * will_it_fly([3، 2، 3]، 9) ➞ True\n * # 3 + 2 + 3 کمتر از حداکثر وزن ممکن است و متعادل است.\n * \n * will_it_fly([3]، 5) ➞ True\n * # 3 کمتر از حداکثر وزن ممکن است و متعادل است.\n * \n *\n */\nfunc willItFly(q : [Int], w : Int) -> Bool {\n", "entry_point": "willItFly", "test": "\n\nvar arg00 : [Int] = [3, 2, 3]\nvar arg01 : Int = 9\nvar x0 : Bool = willItFly(q : arg00, w : arg01)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 2]\nvar arg11 : Int = 5\nvar x1 : Bool = willItFly(q : arg10, w : arg11)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [3]\nvar arg21 : Int = 5\nvar x2 : Bool = willItFly(q : arg20, w : arg21)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [3, 2, 3]\nvar arg31 : Int = 1\nvar x3 : Bool = willItFly(q : arg30, w : arg31)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [1, 2, 3]\nvar arg41 : Int = 6\nvar x4 : Bool = willItFly(q : arg40, w : arg41)\nvar v4 : Bool = false\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [5]\nvar arg51 : Int = 5\nvar x5 : Bool = willItFly(q : arg50, w : arg51)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "تابعی بنویسید که در صورتی که شیء q پرواز کند، True برمی گرداند و در غیر این صورت False.\nشیء q در صورتی پرواز می کند که متعادل باشد (یک لیست پالیندرومیک است) و مجموع عناصر آن کمتر یا مساوی حداکثر وزن ممکن w باشد.\n\nمثال:\nwill_it_fly([1، 2]، 5) ➞ False\n# 1 + 2 کمتر از حداکثر وزن ممکن است، اما متعادل نیست.\n\nwill_it_fly([3، 2، 3]، 1) ➞ False\n# متعادل است، اما 3 + 2 + 3 بیشتر از حداکثر وزن ممکن است.\n\nwill_it_fly([3، 2، 3]، 9) ➞ True\n# 3 + 2 + 3 کمتر از حداکثر وزن ممکن است و متعادل است.\n\nwill_it_fly([3]، 5) ➞ True\n# 3 کمتر از حداکثر وزن ممکن است و متعادل است.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/31", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * یک تابع بنویسید که در صورتی که عدد داده شده حاصلضرب 3 عدد اول باشد، مقدار درست را برگرداند و در غیر این صورت، مقدار نادرست را برگرداند.\n *     با دانستن اینکه (a) کمتر از 100 است.\n *     مثال:\n * \n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n *\n */\nfunc isMultiplyPrime(a : Int) -> Bool {\n", "entry_point": "isMultiplyPrime", "test": "\n\nvar arg00 : Int = 5\nvar x0 : Bool = isMultiplyPrime(a : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 30\nvar x1 : Bool = isMultiplyPrime(a : arg10)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 8\nvar x2 : Bool = isMultiplyPrime(a : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 10\nvar x3 : Bool = isMultiplyPrime(a : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 125\nvar x4 : Bool = isMultiplyPrime(a : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 105\nvar x5 : Bool = isMultiplyPrime(a : arg50)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 126\nvar x6 : Bool = isMultiplyPrime(a : arg60)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 729\nvar x7 : Bool = isMultiplyPrime(a : arg70)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 891\nvar x8 : Bool = isMultiplyPrime(a : arg80)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 1001\nvar x9 : Bool = isMultiplyPrime(a : arg90)\nvar v9 : Bool = true\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\n", "description": "یک تابع بنویسید که در صورتی که عدد داده شده حاصلضرب 3 عدد اول باشد، مقدار درست را برگرداند و در غیر این صورت، مقدار نادرست را برگرداند.\n    با دانستن اینکه (a) کمتر از 100 است.\n    مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/32", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * شما یک عدد به صورت دهدهی دریافت خواهید کرد و وظیفه شما تبدیل آن به فرمت دودویی است. تابع باید یک رشته بازگرداند که هر کاراکتر آن یک عدد دودویی را نشان می‌دهد. هر کاراکتر در رشته '0' یا '1' خواهد بود.\n * \n * در ابتدا و انتهای رشته، چند کاراکتر اضافی 'db' وجود دارد. این کاراکترهای اضافی برای کمک به فرمت‌بندی است.\n * \n * مثال‌ها:\n * \n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n *\n */\nfunc decimalToBinary(decimal : Int) -> String {\n", "entry_point": "decimalToBinary", "test": "\n\nvar arg00 : Int = 0\nvar x0 : String = decimalToBinary(decimal : arg00)\nvar v0 : String = #\"db0db\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 32\nvar x1 : String = decimalToBinary(decimal : arg10)\nvar v1 : String = #\"db100000db\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 103\nvar x2 : String = decimalToBinary(decimal : arg20)\nvar v2 : String = #\"db1100111db\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 15\nvar x3 : String = decimalToBinary(decimal : arg30)\nvar v3 : String = #\"db1111db\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "شما یک عدد به صورت دهدهی دریافت خواهید کرد و وظیفه شما تبدیل آن به فرمت دودویی است. تابع باید یک رشته بازگرداند که هر کاراکتر آن یک عدد دودویی را نشان می‌دهد. هر کاراکتر در رشته '0' یا '1' خواهد بود.\n\nدر ابتدا و انتهای رشته، چند کاراکتر اضافی 'db' وجود دارد. این کاراکترهای اضافی برای کمک به فرمت‌بندی است.\n\nمثال‌ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/33", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * شما یک رشته s دریافت می کنید.\n *     وظیفه شما بررسی این است که رشته خوشحال است یا خیر.\n *     یک رشته خوشحال است اگر طول آن حداقل 3 باشد و هر 3 حرف متوالی آن متفاوت باشد.\n *     به عنوان مثال:\n * \n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n *\n */\nfunc isHappy(s : String) -> Bool {\n", "entry_point": "isHappy", "test": "\n\nvar arg00 : String = #\"a\"#\nvar x0 : Bool = isHappy(s : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"aa\"#\nvar x1 : Bool = isHappy(s : arg10)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"abcd\"#\nvar x2 : Bool = isHappy(s : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"aabb\"#\nvar x3 : Bool = isHappy(s : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"adb\"#\nvar x4 : Bool = isHappy(s : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"xyy\"#\nvar x5 : Bool = isHappy(s : arg50)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"iopaxpoi\"#\nvar x6 : Bool = isHappy(s : arg60)\nvar v6 : Bool = true\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"iopaxioi\"#\nvar x7 : Bool = isHappy(s : arg70)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\n", "description": "شما یک رشته s دریافت می کنید.\n    وظیفه شما بررسی این است که رشته خوشحال است یا خیر.\n    یک رشته خوشحال است اگر طول آن حداقل 3 باشد و هر 3 حرف متوالی آن متفاوت باشد.\n    به عنوان مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/34", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * در هفته آخر ترم، معلم باید نمرات را به دانش آموزان بدهد. معلم الگوریتم خود را برای نمره دادن ارائه داده است. تنها مشکل این است که او کدی که برای نمره دادن استفاده کرده است را از دست داده است. او لیستی از معدل های برخی از دانش آموزان به شما داده است و شما باید یک تابع بنویسید که با استفاده از جدول زیر، لیستی از نمرات حروفی را خروجی دهد:\n * \n *              GPA       |    Letter grade\n *               4.0                A+\n *             > 3.7                A \n *             > 3.3                A- \n *             > 3.0                B+\n *             > 2.7                B \n *             > 2.3                B-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                E\n *     \n * \n *     مثال:\n * \n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n *\n */\nfunc numericalLetterGrade(grades : [Double]) -> [String] {\n", "entry_point": "numericalLetterGrade", "test": "\n\nvar arg00 : [Double] = [4.0, 3, 1.7, 2, 3.5]\nvar x0 : [String] = numericalLetterGrade(grades : arg00)\nvar v0 : [String] = [#\"A+\"#, #\"B\"#, #\"C-\"#, #\"C\"#, #\"A-\"#]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Double] = [1.2]\nvar x1 : [String] = numericalLetterGrade(grades : arg10)\nvar v1 : [String] = [#\"D+\"#]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Double] = [0.5]\nvar x2 : [String] = numericalLetterGrade(grades : arg20)\nvar v2 : [String] = [#\"D-\"#]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Double] = [0.0]\nvar x3 : [String] = numericalLetterGrade(grades : arg30)\nvar v3 : [String] = [#\"E\"#]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Double] = [1, 0.3, 1.5, 2.8, 3.3]\nvar x4 : [String] = numericalLetterGrade(grades : arg40)\nvar v4 : [String] = [#\"D\"#, #\"D-\"#, #\"C-\"#, #\"B\"#, #\"B+\"#]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Double] = [0, 0.7]\nvar x5 : [String] = numericalLetterGrade(grades : arg50)\nvar v5 : [String] = [#\"E\"#, #\"D-\"#]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "در هفته آخر ترم، معلم باید نمرات را به دانش آموزان بدهد. معلم الگوریتم خود را برای نمره دادن ارائه داده است. تنها مشکل این است که او کدی که برای نمره دادن استفاده کرده است را از دست داده است. او لیستی از معدل های برخی از دانش آموزان به شما داده است و شما باید یک تابع بنویسید که با استفاده از جدول زیر، لیستی از نمرات حروفی را خروجی دهد:\n\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/35", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * یک تابع بنویسید که یک رشته را دریافت کرده و در صورتی که طول رشته یک عدد اول باشد، True و در غیر این صورت False برگرداند.\n * مثال ها:\n * \n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n *\n */\nfunc primeLength(string : String) -> Bool {\n", "entry_point": "primeLength", "test": "\n\nvar arg00 : String = #\"Hello\"#\nvar x0 : Bool = primeLength(string : arg00)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"abcdcba\"#\nvar x1 : Bool = primeLength(string : arg10)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"kittens\"#\nvar x2 : Bool = primeLength(string : arg20)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"orange\"#\nvar x3 : Bool = primeLength(string : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"wow\"#\nvar x4 : Bool = primeLength(string : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"world\"#\nvar x5 : Bool = primeLength(string : arg50)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"MadaM\"#\nvar x6 : Bool = primeLength(string : arg60)\nvar v6 : Bool = true\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"Wow\"#\nvar x7 : Bool = primeLength(string : arg70)\nvar v7 : Bool = true\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : String = #\"\"#\nvar x8 : Bool = primeLength(string : arg80)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : String = #\"HI\"#\nvar x9 : Bool = primeLength(string : arg90)\nvar v9 : Bool = true\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : String = #\"go\"#\nvar x10 : Bool = primeLength(string : arg100)\nvar v10 : Bool = true\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : String = #\"gogo\"#\nvar x11 : Bool = primeLength(string : arg110)\nvar v11 : Bool = false\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : String = #\"aaaaaaaaaaaaaaa\"#\nvar x12 : Bool = primeLength(string : arg120)\nvar v12 : Bool = false\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\nvar arg130 : String = #\"Madam\"#\nvar x13 : Bool = primeLength(string : arg130)\nvar v13 : Bool = true\nassert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \")\n\nvar arg140 : String = #\"M\"#\nvar x14 : Bool = primeLength(string : arg140)\nvar v14 : Bool = false\nassert(x14 == v14, \"Exception -- test case 14 did not pass. x14 = \")\n\nvar arg150 : String = #\"0\"#\nvar x15 : Bool = primeLength(string : arg150)\nvar v15 : Bool = false\nassert(x15 == v15, \"Exception -- test case 15 did not pass. x15 = \")\n\n", "description": "یک تابع بنویسید که یک رشته را دریافت کرده و در صورتی که طول رشته یک عدد اول باشد، True و در غیر این صورت False برگرداند.\nمثال ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/36", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * با دادن یک عدد صحیح مثبت N، مجموع کل رقم های آن در سیستم دو برگردانده می شود.\n * \n *     مثال:\n *         برای N = 1000، مجموع ارقام برابر با 1 خواهد بود و خروجی \"1\" خواهد بود.\n *         برای N = 150، مجموع ارقام برابر با 6 خواهد بود و خروجی \"110\" خواهد بود.\n *         برای N = 147، مجموع ارقام برابر با 12 خواهد بود و خروجی \"1100\" خواهد بود.\n *     \n *     متغیرها:\n *         @N عدد صحیح\n *              محدودیت ها: 0 ≤ N ≤ 10000.\n *     خروجی:\n *          یک رشته از عدد دودویی.\n * \n *\n */\nfunc solve(n : Int) -> String {\n", "entry_point": "solve", "test": "\n\nvar arg00 : Int = 1000\nvar x0 : String = solve(n : arg00)\nvar v0 : String = #\"1\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 150\nvar x1 : String = solve(n : arg10)\nvar v1 : String = #\"110\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 147\nvar x2 : String = solve(n : arg20)\nvar v2 : String = #\"1100\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 333\nvar x3 : String = solve(n : arg30)\nvar v3 : String = #\"1001\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 963\nvar x4 : String = solve(n : arg40)\nvar v4 : String = #\"10010\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "با دادن یک عدد صحیح مثبت N، مجموع کل رقم های آن در سیستم دو برگردانده می شود.\n\n    مثال:\n        برای N = 1000، مجموع ارقام برابر با 1 خواهد بود و خروجی \"1\" خواهد بود.\n        برای N = 150، مجموع ارقام برابر با 6 خواهد بود و خروجی \"110\" خواهد بود.\n        برای N = 147، مجموع ارقام برابر با 12 خواهد بود و خروجی \"1100\" خواهد بود.\n    \n    متغیرها:\n        @N عدد صحیح\n             محدودیت ها: 0 ≤ N ≤ 10000.\n    خروجی:\n         یک رشته از عدد دودویی.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/37", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * شما یک داده دو بعدی به عنوان لیست های تو در تو دریافت می کنید که شبیه به ماتریس است، با این حال، برخلاف ماتریس ها، هر ردیف ممکن است شامل تعداد مختلفی ستون باشد. با دادن lst و عدد صحیح x، اعداد صحیح x را در لیست پیدا کرده و لیستی از تاپل ها، [(x1، y1)، (x2، y2) ...] را برگردانید که هر تاپل یک مختصات - (ردیف، ستون)، با شروع از 0 است. مختصات را در ابتدا بر اساس ردیف ها به ترتیب صعودی مرتب کنید. همچنین، مختصات ردیف را بر اساس ستون ها به ترتیب نزولی مرتب کنید.\n * \n * مثال ها:\n * \n * get_row([\n *   [1,2,3,4,5,6],\n *   [1,2,3,4,1,6],\n *   [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n *\n */\nfunc getRow(lst : [AnyHashable], x : Int) -> [AnyHashable] {\n", "entry_point": "getRow", "test": "\n\nvar arg00 : [AnyHashable] = []\nvar arg01 : Int = 1\nvar x0 : [AnyHashable] = getRow(lst : arg00, x : arg01)\nvar v0 : [AnyHashable] = []\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [[1]]\nvar arg11 : Int = 2\nvar x1 : [AnyHashable] = getRow(lst : arg10, x : arg11)\nvar v1 : [AnyHashable] = []\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [[], [1], [1, 2, 3]]\nvar arg21 : Int = 3\nvar x2 : [AnyHashable] = getRow(lst : arg20, x : arg21)\nvar v2 : [AnyHashable] = [[2, 2]]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\n", "description": "شما یک داده دو بعدی به عنوان لیست های تو در تو دریافت می کنید که شبیه به ماتریس است، با این حال، برخلاف ماتریس ها، هر ردیف ممکن است شامل تعداد مختلفی ستون باشد. با دادن lst و عدد صحیح x، اعداد صحیح x را در لیست پیدا کرده و لیستی از تاپل ها، [(x1، y1)، (x2، y2) ...] را برگردانید که هر تاپل یک مختصات - (ردیف، ستون)، با شروع از 0 است. مختصات را در ابتدا بر اساس ردیف ها به ترتیب صعودی مرتب کنید. همچنین، مختصات ردیف را بر اساس ستون ها به ترتیب نزولی مرتب کنید.\n\nمثال ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/38", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * شما یک لیست اعداد صحیح دارید.\n * تابع next_smallest() را بنویسید که دومین کوچکترین عنصر لیست را برمی‌گرداند.\n * اگر چنین عنصری وجود نداشته باشد، null برگردانید.\n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n *\n */\nfunc nextSmallest(lst : [AnyHashable]) -> AnyHashable {\n", "entry_point": "nextSmallest", "test": "\n\nvar arg00 : [AnyHashable] = [1, 2, 3, 4, 5]\nvar x0 : AnyHashable = nextSmallest(lst : arg00)\nvar v0 : AnyHashable = 2\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [5, 1, 4, 3, 2]\nvar x1 : AnyHashable = nextSmallest(lst : arg10)\nvar v1 : AnyHashable = 2\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = []\nvar x2 : AnyHashable = nextSmallest(lst : arg20)\nvar v2 : AnyHashable = \"none\"\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [1, 1]\nvar x3 : AnyHashable = nextSmallest(lst : arg30)\nvar v3 : AnyHashable = \"none\"\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [1, 1, 1, 1, 0]\nvar x4 : AnyHashable = nextSmallest(lst : arg40)\nvar v4 : AnyHashable = 1\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable] = [1, 1]\nvar x5 : AnyHashable = nextSmallest(lst : arg50)\nvar v5 : AnyHashable = \"none\"\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [AnyHashable] = [-35, 34, 12, -45]\nvar x6 : AnyHashable = nextSmallest(lst : arg60)\nvar v6 : AnyHashable = -35\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "شما یک لیست اعداد صحیح دارید.\nتابع next_smallest() را بنویسید که دومین کوچکترین عنصر لیست را برمی‌گرداند.\nاگر چنین عنصری وجود نداشته باشد، null برگردانید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/39", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * شما یک رشته از کلمات دریافت خواهید کرد و وظیفه شما شمارش تعداد خستگی ها است. خستگی یک جمله است که با کلمه \"من\" شروع می شود. جملات با '.'، '?' یا '!' محدود می شوند.\n * \n *     به عنوان مثال:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n *\n */\nfunc isBored(s : String) -> Int {\n", "entry_point": "isBored", "test": "\n\nvar arg00 : String = #\"Hello world\"#\nvar x0 : Int = isBored(s : arg00)\nvar v0 : Int = 0\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"Is the sky blue?\"#\nvar x1 : Int = isBored(s : arg10)\nvar v1 : Int = 0\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"I love It !\"#\nvar x2 : Int = isBored(s : arg20)\nvar v2 : Int = 1\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"bIt\"#\nvar x3 : Int = isBored(s : arg30)\nvar v3 : Int = 0\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"I feel good today. I will be productive. will kill It\"#\nvar x4 : Int = isBored(s : arg40)\nvar v4 : Int = 2\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"You and I are going for a walk\"#\nvar x5 : Int = isBored(s : arg50)\nvar v5 : Int = 0\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "شما یک رشته از کلمات دریافت خواهید کرد و وظیفه شما شمارش تعداد خستگی ها است. خستگی یک جمله است که با کلمه \"من\" شروع می شود. جملات با '.'، '?' یا '!' محدود می شوند.\n\n    به عنوان مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/40", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * شما یک لیست اعداد صحیح دارید.\n * شما باید بزرگترین مقدار اولیه را پیدا کرده و مجموع ارقام آن را برگردانید.\n * \n * مثال ها:\n * \n * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n * For lst = [0,81,12,3,1,21] the output should be 3\n * For lst = [0,8,1,2,1,7] the output should be 7\n *\n */\nfunc skjkasdkd(lst : [Int]) -> Int {\n", "entry_point": "skjkasdkd", "test": "\n\nvar arg00 : [Int] = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]\nvar x0 : Int = skjkasdkd(lst : arg00)\nvar v0 : Int = 10\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]\nvar x1 : Int = skjkasdkd(lst : arg10)\nvar v1 : Int = 25\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]\nvar x2 : Int = skjkasdkd(lst : arg20)\nvar v2 : Int = 13\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]\nvar x3 : Int = skjkasdkd(lst : arg30)\nvar v3 : Int = 11\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [0, 81, 12, 3, 1, 21]\nvar x4 : Int = skjkasdkd(lst : arg40)\nvar v4 : Int = 3\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [0, 8, 1, 2, 1, 7]\nvar x5 : Int = skjkasdkd(lst : arg50)\nvar v5 : Int = 7\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [8191]\nvar x6 : Int = skjkasdkd(lst : arg60)\nvar v6 : Int = 19\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Int] = [8191, 123456, 127, 7]\nvar x7 : Int = skjkasdkd(lst : arg70)\nvar v7 : Int = 19\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [Int] = [127, 97, 8192]\nvar x8 : Int = skjkasdkd(lst : arg80)\nvar v8 : Int = 10\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\n", "description": "شما یک لیست اعداد صحیح دارید.\nشما باید بزرگترین مقدار اولیه را پیدا کرده و مجموع ارقام آن را برگردانید.\n\nمثال ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/41", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * با توجه به یک فرهنگ لغت، در صورتی که همه کلیدها رشته‌هایی با حروف کوچک باشند یا همه کلیدها رشته‌هایی با حروف بزرگ باشند، True را برگردانید. در غیر این صورت، False را برگردانید. اگر فرهنگ لغت داده شده خالی باشد، تابع باید False را برگرداند. مثال‌ها:\n * \n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n *\n */\nfunc checkDictCase(dict : [AnyHashable: AnyHashable]) -> Bool {\n", "entry_point": "checkDictCase", "test": "\n\nvar arg00 : [AnyHashable: AnyHashable] = [#\"p\"# : #\"pineapple\"#, #\"b\"# : #\"banana\"#]\nvar x0 : Bool = checkDictCase(dict : arg00)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable: AnyHashable] = [#\"p\"# : #\"pineapple\"#, #\"A\"# : #\"banana\"#, #\"B\"# : #\"banana\"#]\nvar x1 : Bool = checkDictCase(dict : arg10)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable: AnyHashable] = [#\"p\"# : #\"pineapple\"#, 5 : #\"banana\"#, #\"a\"# : #\"apple\"#]\nvar x2 : Bool = checkDictCase(dict : arg20)\nvar v2 : Bool = false\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable: AnyHashable] = [#\"Name\"# : #\"John\"#, #\"Age\"# : #\"36\"#, #\"City\"# : #\"Houston\"#]\nvar x3 : Bool = checkDictCase(dict : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable: AnyHashable] = [#\"STATE\"# : #\"NC\"#, #\"ZIP\"# : #\"12345\"#]\nvar x4 : Bool = checkDictCase(dict : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable: AnyHashable] = [#\"fruit\"# : #\"Orange\"#, #\"taste\"# : #\"Sweet\"#]\nvar x5 : Bool = checkDictCase(dict : arg50)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [AnyHashable: AnyHashable] = []\nvar x6 : Bool = checkDictCase(dict : arg60)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "با توجه به یک فرهنگ لغت، در صورتی که همه کلیدها رشته‌هایی با حروف کوچک باشند یا همه کلیدها رشته‌هایی با حروف بزرگ باشند، True را برگردانید. در غیر این صورت، False را برگردانید. اگر فرهنگ لغت داده شده خالی باشد، تابع باید False را برگرداند. مثال‌ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/42", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * تابعی بسازید که یک مقدار (رشته) که یک عدد را نشان می‌دهد را بگیرد و نزدیک‌ترین عدد صحیح به آن را برگرداند. اگر عدد از دو عدد صحیح به یک فاصله باشد، آن را به سمت دور از صفر گرد کنید.\n * \n *     مثال‌ها\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n\n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n *\n */\nfunc closestInteger(value : String) -> Int {\n", "entry_point": "closestInteger", "test": "\n\nvar arg00 : String = #\"10\"#\nvar x0 : Int = closestInteger(value : arg00)\nvar v0 : Int = 10\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"14.5\"#\nvar x1 : Int = closestInteger(value : arg10)\nvar v1 : Int = 15\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"-15.5\"#\nvar x2 : Int = closestInteger(value : arg20)\nvar v2 : Int = -16\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"15.3\"#\nvar x3 : Int = closestInteger(value : arg30)\nvar v3 : Int = 15\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"0\"#\nvar x4 : Int = closestInteger(value : arg40)\nvar v4 : Int = 0\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "تابعی بسازید که یک مقدار (رشته) که یک عدد را نشان می‌دهد را بگیرد و نزدیک‌ترین عدد صحیح به آن را برگرداند. اگر عدد از دو عدد صحیح به یک فاصله باشد، آن را به سمت دور از صفر گرد کنید.\n\n    مثال‌ها", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/43", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * با دریافت یک عدد صحیح مثبت n، باید یک توده از n سطح سنگ بسازید.\n *     سطح اول دارای n سنگ است.\n *     تعداد سنگ در سطح بعدی به شرح زیر است:\n *         - اگر n فرد باشد، تعداد سنگ بعدی برابر با بعد بعدی فرد خواهد بود.\n *         - اگر n زوج باشد، تعداد سنگ بعدی برابر با بعد بعدی زوج خواهد بود.\n *     تعداد سنگ در هر سطح را در یک لیست بازگردانید، به طوری که المان در اندیس\n *     i تعداد سنگ در سطح (i+1) را نشان می دهد.\n * \n *     مثال ها:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n *\n */\nfunc makeAPile(n : Int) -> [Int] {\n", "entry_point": "makeAPile", "test": "\n\nvar arg00 : Int = 3\nvar x0 : [Int] = makeAPile(n : arg00)\nvar v0 : [Int] = [3, 5, 7]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 4\nvar x1 : [Int] = makeAPile(n : arg10)\nvar v1 : [Int] = [4, 6, 8, 10]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 5\nvar x2 : [Int] = makeAPile(n : arg20)\nvar v2 : [Int] = [5, 7, 9, 11, 13]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 6\nvar x3 : [Int] = makeAPile(n : arg30)\nvar v3 : [Int] = [6, 8, 10, 12, 14, 16]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 8\nvar x4 : [Int] = makeAPile(n : arg40)\nvar v4 : [Int] = [8, 10, 12, 14, 16, 18, 20, 22]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "با دریافت یک عدد صحیح مثبت n، باید یک توده از n سطح سنگ بسازید.\n    سطح اول دارای n سنگ است.\n    تعداد سنگ در سطح بعدی به شرح زیر است:\n        - اگر n فرد باشد، تعداد سنگ بعدی برابر با بعد بعدی فرد خواهد بود.\n        - اگر n زوج باشد، تعداد سنگ بعدی برابر با بعد بعدی زوج خواهد بود.\n    تعداد سنگ در هر سطح را در یک لیست بازگردانید، به طوری که المان در اندیس\n    i تعداد سنگ در سطح (i+1) را نشان می دهد.\n\n    مثال ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/44", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * شما یک رشته از کلمات جدا شده توسط کاما یا فاصله دریافت خواهید کرد. وظیفه شما این است که رشته را به کلمات تقسیم کرده و یک آرایه از کلمات برگردانید.\n * \n *     به عنوان مثال:\n * \n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n *\n */\nfunc wordsString(s : String) -> [AnyHashable] {\n", "entry_point": "wordsString", "test": "\n\nvar arg00 : String = #\"Hi, my name is John\"#\nvar x0 : [AnyHashable] = wordsString(s : arg00)\nvar v0 : [AnyHashable] = [#\"Hi\"#, #\"my\"#, #\"name\"#, #\"is\"#, #\"John\"#]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"One, two, three, four, five, six\"#\nvar x1 : [AnyHashable] = wordsString(s : arg10)\nvar v1 : [AnyHashable] = [#\"One\"#, #\"two\"#, #\"three\"#, #\"four\"#, #\"five\"#, #\"six\"#]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"Hi, my name\"#\nvar x2 : [AnyHashable] = wordsString(s : arg20)\nvar v2 : [AnyHashable] = [#\"Hi\"#, #\"my\"#, #\"name\"#]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"One,, two, three, four, five, six,\"#\nvar x3 : [AnyHashable] = wordsString(s : arg30)\nvar v3 : [AnyHashable] = [#\"One\"#, #\"two\"#, #\"three\"#, #\"four\"#, #\"five\"#, #\"six\"#]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"\"#\nvar x4 : [AnyHashable] = wordsString(s : arg40)\nvar v4 : [AnyHashable] = []\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"ahmed     , gamal\"#\nvar x5 : [AnyHashable] = wordsString(s : arg50)\nvar v5 : [AnyHashable] = [#\"ahmed\"#, #\"gamal\"#]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "شما یک رشته از کلمات جدا شده توسط کاما یا فاصله دریافت خواهید کرد. وظیفه شما این است که رشته را به کلمات تقسیم کرده و یک آرایه از کلمات برگردانید.\n\n    به عنوان مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/45", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * این تابع دو عدد مثبت x و y را می‌گیرد و بزرگترین عدد صحیح زوجی را که در بازه [x، y] قرار دارد، برمی‌گرداند. اگر چنین عددی وجود نداشته باشد، تابع باید -1 را برگرداند.\n * \n *     به عنوان مثال:\n * \n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n *\n */\nfunc chooseNum(x : Int, y : Int) -> Int {\n", "entry_point": "chooseNum", "test": "\n\nvar arg00 : Int = 12\nvar arg01 : Int = 15\nvar x0 : Int = chooseNum(x : arg00, y : arg01)\nvar v0 : Int = 14\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 13\nvar arg11 : Int = 12\nvar x1 : Int = chooseNum(x : arg10, y : arg11)\nvar v1 : Int = -1\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 33\nvar arg21 : Int = 12354\nvar x2 : Int = chooseNum(x : arg20, y : arg21)\nvar v2 : Int = 12354\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 5234\nvar arg31 : Int = 5233\nvar x3 : Int = chooseNum(x : arg30, y : arg31)\nvar v3 : Int = -1\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 6\nvar arg41 : Int = 29\nvar x4 : Int = chooseNum(x : arg40, y : arg41)\nvar v4 : Int = 28\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 27\nvar arg51 : Int = 10\nvar x5 : Int = chooseNum(x : arg50, y : arg51)\nvar v5 : Int = -1\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 7\nvar arg61 : Int = 7\nvar x6 : Int = chooseNum(x : arg60, y : arg61)\nvar v6 : Int = -1\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 546\nvar arg71 : Int = 546\nvar x7 : Int = chooseNum(x : arg70, y : arg71)\nvar v7 : Int = 546\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\n", "description": "این تابع دو عدد مثبت x و y را می‌گیرد و بزرگترین عدد صحیح زوجی را که در بازه [x، y] قرار دارد، برمی‌گرداند. اگر چنین عددی وجود نداشته باشد، تابع باید -1 را برگرداند.\n\n    به عنوان مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/46", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * شما دو عدد صحیح مثبت n و m را دریافت می‌کنید و وظیفه شما محاسبه میانگین اعداد صحیح از n تا m (شامل n و m) است. پاسخ را به نزدیک‌ترین عدد صحیح گرد کرده و آن را به دودویی تبدیل کنید. اگر n بزرگتر از m باشد، -1 را برگردانید.\n * مثال:\n * \n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n *\n */\nfunc roundedAvg(n : Int, m : Int) -> AnyHashable {\n", "entry_point": "roundedAvg", "test": "\n\nvar arg00 : Int = 1\nvar arg01 : Int = 5\nvar x0 : AnyHashable = roundedAvg(n : arg00, m : arg01)\nvar v0 : AnyHashable = #\"0b11\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 7\nvar arg11 : Int = 13\nvar x1 : AnyHashable = roundedAvg(n : arg10, m : arg11)\nvar v1 : AnyHashable = #\"0b1010\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 964\nvar arg21 : Int = 977\nvar x2 : AnyHashable = roundedAvg(n : arg20, m : arg21)\nvar v2 : AnyHashable = #\"0b1111001010\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 996\nvar arg31 : Int = 997\nvar x3 : AnyHashable = roundedAvg(n : arg30, m : arg31)\nvar v3 : AnyHashable = #\"0b1111100100\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 560\nvar arg41 : Int = 851\nvar x4 : AnyHashable = roundedAvg(n : arg40, m : arg41)\nvar v4 : AnyHashable = #\"0b1011000010\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 185\nvar arg51 : Int = 546\nvar x5 : AnyHashable = roundedAvg(n : arg50, m : arg51)\nvar v5 : AnyHashable = #\"0b101101110\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 362\nvar arg61 : Int = 496\nvar x6 : AnyHashable = roundedAvg(n : arg60, m : arg61)\nvar v6 : AnyHashable = #\"0b110101101\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 350\nvar arg71 : Int = 902\nvar x7 : AnyHashable = roundedAvg(n : arg70, m : arg71)\nvar v7 : AnyHashable = #\"0b1001110010\"#\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 197\nvar arg81 : Int = 233\nvar x8 : AnyHashable = roundedAvg(n : arg80, m : arg81)\nvar v8 : AnyHashable = #\"0b11010111\"#\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 7\nvar arg91 : Int = 5\nvar x9 : AnyHashable = roundedAvg(n : arg90, m : arg91)\nvar v9 : AnyHashable = -1\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : Int = 5\nvar arg101 : Int = 1\nvar x10 : AnyHashable = roundedAvg(n : arg100, m : arg101)\nvar v10 : AnyHashable = -1\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : Int = 5\nvar arg111 : Int = 5\nvar x11 : AnyHashable = roundedAvg(n : arg110, m : arg111)\nvar v11 : AnyHashable = #\"0b101\"#\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\n", "description": "شما دو عدد صحیح مثبت n و m را دریافت می‌کنید و وظیفه شما محاسبه میانگین اعداد صحیح از n تا m (شامل n و m) است. پاسخ را به نزدیک‌ترین عدد صحیح گرد کرده و آن را به دودویی تبدیل کنید. اگر n بزرگتر از m باشد، -1 را برگردانید.\nمثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/47", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * تابع f را پیاده سازی کنید که n را به عنوان پارامتر دریافت می کند،\n * و یک لیست به اندازه n برمی گرداند، به گونه ای که مقدار المان در اندیس i برابر با فاکتوریل i است اگر i زوج باشد\n * و در غیر این صورت مجموع اعداد از 1 تا i است.\n * i از 1 شروع می شود.\n * فاکتوریل i ضرب اعداد از 1 تا i است (1 * 2 * ... * i).\n * مثال:\n * \n * f(5) == [1, 2, 6, 24, 15]\n *\n */\nfunc f(n : Int) -> [Int] {\n", "entry_point": "f", "test": "\n\nvar arg00 : Int = 5\nvar x0 : [Int] = f(n : arg00)\nvar v0 : [Int] = [1, 2, 6, 24, 15]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 7\nvar x1 : [Int] = f(n : arg10)\nvar v1 : [Int] = [1, 2, 6, 24, 15, 720, 28]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 1\nvar x2 : [Int] = f(n : arg20)\nvar v2 : [Int] = [1]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 3\nvar x3 : [Int] = f(n : arg30)\nvar v3 : [Int] = [1, 2, 6]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "تابع f را پیاده سازی کنید که n را به عنوان پارامتر دریافت می کند،\nو یک لیست به اندازه n برمی گرداند، به گونه ای که مقدار المان در اندیس i برابر با فاکتوریل i است اگر i زوج باشد\nو در غیر این صورت مجموع اعداد از 1 تا i است.\ni از 1 شروع می شود.\nفاکتوریل i ضرب اعداد از 1 تا i است (1 * 2 * ... * i).\nمثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/48", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * با توجه به یک عدد صحیح مثبت n، یک tuple را برگردانید که شامل تعداد اعداد پالیندروم زوج و فردی است که در بازه (1، n)، شامل هستند.\n * \n *     مثال 1:\n * \n *         ورودی: 3\n *         خروجی: (1، 2)\n *         توضیحات:\n *         اعداد پالیندروم شامل 1، 2، 3 هستند. یکی از آن‌ها زوج و دوتای دیگر فرد هستند.\n * \n *     مثال 2:\n * \n *         ورودی: 12\n *         خروجی: (4، 6)\n *         توضیحات:\n *         اعداد پالیندروم شامل 1، 2، 3، 4، 5، 6، 7، 8، 9، 11 هستند. چهارتای آن‌ها زوج و 6 تای دیگر فرد هستند.\n * \n *     توجه:\n *         1. 1 <= n <= 10^3\n *         2. توپل برگشتی تعداد اعداد پالیندروم زوج و فردی را به ترتیب دارد.\n * \n *\n */\nfunc evenOddPalindrome(n : Int) -> [Int] {\n", "entry_point": "evenOddPalindrome", "test": "\n\nvar arg00 : Int = 123\nvar x0 : [Int] = evenOddPalindrome(n : arg00)\nvar v0 : [Int] = [8, 13]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 12\nvar x1 : [Int] = evenOddPalindrome(n : arg10)\nvar v1 : [Int] = [4, 6]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 3\nvar x2 : [Int] = evenOddPalindrome(n : arg20)\nvar v2 : [Int] = [1, 2]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 63\nvar x3 : [Int] = evenOddPalindrome(n : arg30)\nvar v3 : [Int] = [6, 8]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 25\nvar x4 : [Int] = evenOddPalindrome(n : arg40)\nvar v4 : [Int] = [5, 6]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 19\nvar x5 : [Int] = evenOddPalindrome(n : arg50)\nvar v5 : [Int] = [4, 6]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 9\nvar x6 : [Int] = evenOddPalindrome(n : arg60)\nvar v6 : [Int] = [4, 5]\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 1\nvar x7 : [Int] = evenOddPalindrome(n : arg70)\nvar v7 : [Int] = [0, 1]\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\n", "description": "با توجه به یک عدد صحیح مثبت n، یک tuple را برگردانید که شامل تعداد اعداد پالیندروم زوج و فردی است که در بازه (1، n)، شامل هستند.\n\n    مثال 1:\n\n        ورودی: 3\n        خروجی: (1، 2)\n        توضیحات:\n        اعداد پالیندروم شامل 1، 2، 3 هستند. یکی از آن‌ها زوج و دوتای دیگر فرد هستند.\n\n    مثال 2:\n\n        ورودی: 12\n        خروجی: (4، 6)\n        توضیحات:\n        اعداد پالیندروم شامل 1، 2، 3، 4، 5، 6، 7، 8، 9، 11 هستند. چهارتای آن‌ها زوج و 6 تای دیگر فرد هستند.\n\n    توجه:\n        1. 1 <= n <= 10^3\n        2. توپل برگشتی تعداد اعداد پالیندروم زوج و فردی را به ترتیب دارد.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/49", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * ما یک آرایه به نام 'arr' از N عدد صحیح arr [1]، arr [2]، ...، arr [N] داریم. اعداد در آرایه به صورت تصادفی مرتب شده اند. وظیفه شما تعیین این است که آیا می توان با انجام عملیات shift به راست بر روی آرایه داده شده آرایه ای را در ترتیب صعودی غیر صعودی بدست آورد یا خیر:\n * \n *     شما مجاز به انجام عملیات shift به راست به تعداد دلخواه هستید.\n *     \n *     یک عملیات shift به راست به معنی جابجایی تمام عناصر آرایه به یک موقعیت به سمت راست است. آخرین عنصر آرایه به موقعیت شروع آرایه یعنی فهرست 0 اندیس منتقل می شود.\n * \n *     اگر با انجام عملیات فوق می توان آرایه مرتب شده را بدست آورد ، آنگاه True را برگردانید در غیر این صورت False را برگردانید.\n *     اگر آرایه داده شده خالی باشد ، True را برگردانید.\n * \n *     توجه: لیست داده شده تضمین می کند که عناصر منحصر به فردی دارد.\n * \n *     به عنوان مثال:\n * \n *     move_one_ball([3، 4، 5، 1، 2]) ==> True\n *     توضیح: با انجام 2 عملیات shift به راست ، می توان برای آرایه داده شده ترتیب صعودی غیر صعودی را بدست آورد.\n *     move_one_ball([3، 5، 4، 1، 2]) ==> False\n *     توضیح: با انجام هر تعداد عملیات shift به راست ، نمی توان برای آرایه داده شده ترتیب صعودی غیر صعودی را بدست آورد.\n * \n *             \n *\n */\nfunc moveOneBall(arr : [AnyHashable]) -> Bool {\n", "entry_point": "moveOneBall", "test": "\n\nvar arg00 : [AnyHashable] = [3, 4, 5, 1, 2]\nvar x0 : Bool = moveOneBall(arr : arg00)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [3, 5, 10, 1, 2]\nvar x1 : Bool = moveOneBall(arr : arg10)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [4, 3, 1, 2]\nvar x2 : Bool = moveOneBall(arr : arg20)\nvar v2 : Bool = false\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [3, 5, 4, 1, 2]\nvar x3 : Bool = moveOneBall(arr : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = []\nvar x4 : Bool = moveOneBall(arr : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "ما یک آرایه به نام 'arr' از N عدد صحیح arr [1]، arr [2]، ...، arr [N] داریم. اعداد در آرایه به صورت تصادفی مرتب شده اند. وظیفه شما تعیین این است که آیا می توان با انجام عملیات shift به راست بر روی آرایه داده شده آرایه ای را در ترتیب صعودی غیر صعودی بدست آورد یا خیر:\n\n    شما مجاز به انجام عملیات shift به راست به تعداد دلخواه هستید.\n    \n    یک عملیات shift به راست به معنی جابجایی تمام عناصر آرایه به یک موقعیت به سمت راست است. آخرین عنصر آرایه به موقعیت شروع آرایه یعنی فهرست 0 اندیس منتقل می شود.\n\n    اگر با انجام عملیات فوق می توان آرایه مرتب شده را بدست آورد ، آنگاه True را برگردانید در غیر این صورت False را برگردانید.\n    اگر آرایه داده شده خالی باشد ، True را برگردانید.\n\n    توجه: لیست داده شده تضمین می کند که عناصر منحصر به فردی دارد.\n\n    به عنوان مثال:\n\n    move_one_ball([3، 4، 5، 1، 2]) ==> True\n    توضیح: با انجام 2 عملیات shift به راست ، می توان برای آرایه داده شده ترتیب صعودی غیر صعودی را بدست آورد.\n    move_one_ball([3، 5، 4، 1، 2]) ==> False\n    توضیح: با انجام هر تعداد عملیات shift به راست ، نمی توان برای آرایه داده شده ترتیب صعودی غیر صعودی را بدست آورد.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/50", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * در این مسئله، شما باید یک تابع پیاده سازی کنید که دو لیست از اعداد را دریافت کرده، تعیین می کند که آیا امکان تعویض عناصر بین آنها وجود دارد تا lst1 یک لیست از اعداد زوج باشد یا خیر. هیچ محدودیتی برای تعویض عناصر بین lst1 و lst2 وجود ندارد. اگر امکان تعویض عناصر بین lst1 و lst2 برای تبدیل تمام عناصر lst1 به اعداد زوج وجود داشت، \"YES\" را برگردانید. در غیر این صورت، \"NO\" را برگردانید. به عنوان مثال: exchange([1، 2، 3، 4]، [1، 2، 3، 4]) => \"YES\" exchange([1، 2، 3، 4]، [1، 5، 3، 4]) => \"NO\" فرض می شود که لیست های ورودی خالی نخواهند بود.\n * \n *\n */\nfunc exchange(lst1 : [Int], lst2 : [Int]) -> String {\n", "entry_point": "exchange", "test": "\n\nvar arg00 : [Int] = [1, 2, 3, 4]\nvar arg01 : [Int] = [1, 2, 3, 4]\nvar x0 : String = exchange(lst1 : arg00, lst2 : arg01)\nvar v0 : String = #\"YES\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [1, 2, 3, 4]\nvar arg11 : [Int] = [1, 5, 3, 4]\nvar x1 : String = exchange(lst1 : arg10, lst2 : arg11)\nvar v1 : String = #\"NO\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [1, 2, 3, 4]\nvar arg21 : [Int] = [2, 1, 4, 3]\nvar x2 : String = exchange(lst1 : arg20, lst2 : arg21)\nvar v2 : String = #\"YES\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [5, 7, 3]\nvar arg31 : [Int] = [2, 6, 4]\nvar x3 : String = exchange(lst1 : arg30, lst2 : arg31)\nvar v3 : String = #\"YES\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [5, 7, 3]\nvar arg41 : [Int] = [2, 6, 3]\nvar x4 : String = exchange(lst1 : arg40, lst2 : arg41)\nvar v4 : String = #\"NO\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [3, 2, 6, 1, 8, 9]\nvar arg51 : [Int] = [3, 5, 5, 1, 1, 1]\nvar x5 : String = exchange(lst1 : arg50, lst2 : arg51)\nvar v5 : String = #\"NO\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [100, 200]\nvar arg61 : [Int] = [200, 200]\nvar x6 : String = exchange(lst1 : arg60, lst2 : arg61)\nvar v6 : String = #\"YES\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "در این مسئله، شما باید یک تابع پیاده سازی کنید که دو لیست از اعداد را دریافت کرده، تعیین می کند که آیا امکان تعویض عناصر بین آنها وجود دارد تا lst1 یک لیست از اعداد زوج باشد یا خیر. هیچ محدودیتی برای تعویض عناصر بین lst1 و lst2 وجود ندارد. اگر امکان تعویض عناصر بین lst1 و lst2 برای تبدیل تمام عناصر lst1 به اعداد زوج وجود داشت، \"YES\" را برگردانید. در غیر این صورت، \"NO\" را برگردانید. به عنوان مثال: exchange([1، 2، 3، 4]، [1، 2، 3، 4]) => \"YES\" exchange([1، 2، 3، 4]، [1، 5، 3، 4]) => \"NO\" فرض می شود که لیست های ورودی خالی نخواهند بود.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/51", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * وظیفه\n *     دو رشته s و c داده شده است، شما باید تمامی حروفی را که در s با هر حرفی در c برابر است، حذف کنید\n *     سپس بررسی کنید که رشته نتیجه شده یک پالیندروم است یا خیر.\n *     یک رشته پالیندروم نامیده می شود اگر به صورت معکوس با خودش برابر باشد.\n *     شما باید یک تاپل شامل رشته نتیجه و True/False برای بررسی برگردانید.\n *     مثال\n *     برای s = \"abcde\"، c = \"ae\"، نتیجه باید ('bcd'،False) باشد\n *     برای s = \"abcdef\"، c = \"b\"، نتیجه باید ('acdef'،False) باشد\n *     برای s = \"abcdedcba\"، c = \"ab\"، نتیجه باید ('cdedc'،True) باشد\n * \n *\n */\nfunc reverseDelete(s : String, c : String) -> [AnyHashable] {\n", "entry_point": "reverseDelete", "test": "\n\nvar arg00 : String = #\"abcde\"#\nvar arg01 : String = #\"ae\"#\nvar x0 : [AnyHashable] = reverseDelete(s : arg00, c : arg01)\nvar v0 : [AnyHashable] = [#\"bcd\"#, false]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"abcdef\"#\nvar arg11 : String = #\"b\"#\nvar x1 : [AnyHashable] = reverseDelete(s : arg10, c : arg11)\nvar v1 : [AnyHashable] = [#\"acdef\"#, false]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"abcdedcba\"#\nvar arg21 : String = #\"ab\"#\nvar x2 : [AnyHashable] = reverseDelete(s : arg20, c : arg21)\nvar v2 : [AnyHashable] = [#\"cdedc\"#, true]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"dwik\"#\nvar arg31 : String = #\"w\"#\nvar x3 : [AnyHashable] = reverseDelete(s : arg30, c : arg31)\nvar v3 : [AnyHashable] = [#\"dik\"#, false]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"a\"#\nvar arg41 : String = #\"a\"#\nvar x4 : [AnyHashable] = reverseDelete(s : arg40, c : arg41)\nvar v4 : [AnyHashable] = [#\"\"#, true]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"abcdedcba\"#\nvar arg51 : String = #\"\"#\nvar x5 : [AnyHashable] = reverseDelete(s : arg50, c : arg51)\nvar v5 : [AnyHashable] = [#\"abcdedcba\"#, true]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"abcdedcba\"#\nvar arg61 : String = #\"v\"#\nvar x6 : [AnyHashable] = reverseDelete(s : arg60, c : arg61)\nvar v6 : [AnyHashable] = [#\"abcdedcba\"#, true]\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"vabba\"#\nvar arg71 : String = #\"v\"#\nvar x7 : [AnyHashable] = reverseDelete(s : arg70, c : arg71)\nvar v7 : [AnyHashable] = [#\"abba\"#, true]\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : String = #\"mamma\"#\nvar arg81 : String = #\"mia\"#\nvar x8 : [AnyHashable] = reverseDelete(s : arg80, c : arg81)\nvar v8 : [AnyHashable] = [#\"\"#, true]\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\n", "description": "وظیفه\n    دو رشته s و c داده شده است، شما باید تمامی حروفی را که در s با هر حرفی در c برابر است، حذف کنید\n    سپس بررسی کنید که رشته نتیجه شده یک پالیندروم است یا خیر.\n    یک رشته پالیندروم نامیده می شود اگر به صورت معکوس با خودش برابر باشد.\n    شما باید یک تاپل شامل رشته نتیجه و True/False برای بررسی برگردانید.\n    مثال\n    برای s = \"abcde\"، c = \"ae\"، نتیجه باید ('bcd'،False) باشد\n    برای s = \"abcdef\"، c = \"b\"، نتیجه باید ('acdef'،False) باشد\n    برای s = \"abcdedcba\"، c = \"ab\"، نتیجه باید ('cdedc'،True) باشد", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/52", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * شما یک شبکه مستطیلی از چاه ها دارید. هر ردیف یک چاه را نشان می دهد و هر 1 در یک ردیف یک واحد آب را نشان می دهد. هر چاه دارای یک سطل متناظر است که می توان از آن برای استخراج آب استفاده کرد و تمام سطل ها دارای ظرفیت یکسان هستند. وظیفه شما استفاده از سطل ها برای خالی کردن چاه ها است. تعداد بارهایی که باید سطل ها را پایین بیاورید را خروجی دهید.\n * \n * مثال ۱:\n *     ورودی:\n *         شبکه: [[0،0،1،0]، [0،1،0،0]، [1،1،1،1]]\n *         ظرفیت سطل: ۱\n *     خروجی: ۶\n * \n * مثال ۲:\n *     ورودی:\n *         شبکه: [[0،0،1،1]، [0،0،0،0]، [1،1،1،1]، [0،1،1،1]]\n *         ظرفیت سطل: ۲\n *     خروجی: ۵\n * \n * مثال ۳:\n *     ورودی:\n *         شبکه: [[0،0،0]، [0،0،0]]\n *         ظرفیت سطل: ۵\n *     خروجی: ۰\n * \n * محدودیت ها:\n *     * تمام چاه ها طول یکسانی دارند\n *     * ۱ <= طول شبکه <= ۱۰^۲\n *     * ۱ <= طول grid [:، ۱] <= ۱۰^۲\n *     * grid [i] [j] -> ۰ | ۱\n *     * ۱ <= ظرفیت <= ۱۰\n * \n *\n */\nfunc maxFill(grid : [[Int]], capacity : Int) -> Int {\n", "entry_point": "maxFill", "test": "\n\nvar arg00 : [[Int]] = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\nvar arg01 : Int = 1\nvar x0 : Int = maxFill(grid : arg00, capacity : arg01)\nvar v0 : Int = 6\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [[Int]] = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\nvar arg11 : Int = 2\nvar x1 : Int = maxFill(grid : arg10, capacity : arg11)\nvar v1 : Int = 5\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [[Int]] = [[0, 0, 0], [0, 0, 0]]\nvar arg21 : Int = 5\nvar x2 : Int = maxFill(grid : arg20, capacity : arg21)\nvar v2 : Int = 0\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [[Int]] = [[1, 1, 1, 1], [1, 1, 1, 1]]\nvar arg31 : Int = 2\nvar x3 : Int = maxFill(grid : arg30, capacity : arg31)\nvar v3 : Int = 4\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [[Int]] = [[1, 1, 1, 1], [1, 1, 1, 1]]\nvar arg41 : Int = 9\nvar x4 : Int = maxFill(grid : arg40, capacity : arg41)\nvar v4 : Int = 2\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "شما یک شبکه مستطیلی از چاه ها دارید. هر ردیف یک چاه را نشان می دهد و هر 1 در یک ردیف یک واحد آب را نشان می دهد. هر چاه دارای یک سطل متناظر است که می توان از آن برای استخراج آب استفاده کرد و تمام سطل ها دارای ظرفیت یکسان هستند. وظیفه شما استفاده از سطل ها برای خالی کردن چاه ها است. تعداد بارهایی که باید سطل ها را پایین بیاورید را خروجی دهید.\n\nمثال ۱:\n    ورودی:\n        شبکه: [[0،0،1،0]، [0،1،0،0]، [1،1،1،1]]\n        ظرفیت سطل: ۱\n    خروجی: ۶\n\nمثال ۲:\n    ورودی:\n        شبکه: [[0،0،1،1]، [0،0،0،0]، [1،1،1،1]، [0،1،1،1]]\n        ظرفیت سطل: ۲\n    خروجی: ۵\n\nمثال ۳:\n    ورودی:\n        شبکه: [[0،0،0]، [0،0،0]]\n        ظرفیت سطل: ۵\n    خروجی: ۰\n\nمحدودیت ها:\n    * تمام چاه ها طول یکسانی دارند\n    * ۱ <= طول شبکه <= ۱۰^۲\n    * ۱ <= طول grid [:، ۱] <= ۱۰^۲\n    * grid [i] [j] -> ۰ | ۱\n    * ۱ <= ظرفیت <= ۱۰", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/53", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * با دادن یک رشته s و یک عدد طبیعی n، شما مسئولیت پیاده سازی یک تابع را دارید که لیستی از تمام کلمات رشته s را که دقیقاً n حرف بی صدا دارند، به ترتیبی که این کلمات در رشته s ظاهر می شوند، برمی گرداند. اگر رشته s خالی باشد، تابع باید یک لیست خالی برگرداند. توجه: شما می توانید فرض کنید رشته ورودی فقط شامل حروف و فضاها است.\n *     مثال ها:\n * \n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n *\n */\nfunc selectWords(s : String, n : Int) -> [AnyHashable] {\n", "entry_point": "selectWords", "test": "\n\nvar arg00 : String = #\"Mary had a little lamb\"#\nvar arg01 : Int = 4\nvar x0 : [AnyHashable] = selectWords(s : arg00, n : arg01)\nvar v0 : [AnyHashable] = [#\"little\"#]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"Mary had a little lamb\"#\nvar arg11 : Int = 3\nvar x1 : [AnyHashable] = selectWords(s : arg10, n : arg11)\nvar v1 : [AnyHashable] = [#\"Mary\"#, #\"lamb\"#]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"simple white space\"#\nvar arg21 : Int = 2\nvar x2 : [AnyHashable] = selectWords(s : arg20, n : arg21)\nvar v2 : [AnyHashable] = []\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"Hello world\"#\nvar arg31 : Int = 4\nvar x3 : [AnyHashable] = selectWords(s : arg30, n : arg31)\nvar v3 : [AnyHashable] = [#\"world\"#]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"Uncle sam\"#\nvar arg41 : Int = 3\nvar x4 : [AnyHashable] = selectWords(s : arg40, n : arg41)\nvar v4 : [AnyHashable] = [#\"Uncle\"#]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"\"#\nvar arg51 : Int = 4\nvar x5 : [AnyHashable] = selectWords(s : arg50, n : arg51)\nvar v5 : [AnyHashable] = []\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"a b c d e f\"#\nvar arg61 : Int = 1\nvar x6 : [AnyHashable] = selectWords(s : arg60, n : arg61)\nvar v6 : [AnyHashable] = [#\"b\"#, #\"c\"#, #\"d\"#, #\"f\"#]\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "با دادن یک رشته s و یک عدد طبیعی n، شما مسئولیت پیاده سازی یک تابع را دارید که لیستی از تمام کلمات رشته s را که دقیقاً n حرف بی صدا دارند، به ترتیبی که این کلمات در رشته s ظاهر می شوند، برمی گرداند. اگر رشته s خالی باشد، تابع باید یک لیست خالی برگرداند. توجه: شما می توانید فرض کنید رشته ورودی فقط شامل حروف و فضاها است.\n    مثال ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/54", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * با دادن یک آرایه از اعداد صحیح و یک عدد صحیح مثبت k، یک لیست مرتب شده با طول k حاوی بزرگترین k عدد در آرایه برگردانید.\n * \n * مثال ۱:\n * \n * ورودی: arr = [-3، -4، 5]، k = 3\n * خروجی: [-4، -3، 5]\n * \n * مثال ۲:\n * \n * ورودی: arr = [4، -4، 4]، k = 2\n * خروجی: [4، 4]\n * \n * مثال ۳:\n * \n * ورودی: arr = [-3، 2، 1، 2، -1، -2، 1]، k = 1\n * خروجی: [2]\n * \n * توجه:\n * ۱. طول آرایه در محدوده [1، 1000] خواهد بود.\n * ۲. عناصر آرایه در محدوده [-1000، 1000] خواهند بود.\n * ۳. 0 <= k <= len(arr)\n * \n *\n */\nfunc maximum(arr : [Int], k : Int) -> [AnyHashable] {\n", "entry_point": "maximum", "test": "\n\nvar arg00 : [Int] = [-3, -4, 5]\nvar arg01 : Int = 3\nvar x0 : [AnyHashable] = maximum(arr : arg00, k : arg01)\nvar v0 : [AnyHashable] = [-4, -3, 5]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [4, -4, 4]\nvar arg11 : Int = 2\nvar x1 : [AnyHashable] = maximum(arr : arg10, k : arg11)\nvar v1 : [AnyHashable] = [4, 4]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [-3, 2, 1, 2, -1, -2, 1]\nvar arg21 : Int = 1\nvar x2 : [AnyHashable] = maximum(arr : arg20, k : arg21)\nvar v2 : [AnyHashable] = [2]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [123, -123, 20, 0, 1, 2, -3]\nvar arg31 : Int = 3\nvar x3 : [AnyHashable] = maximum(arr : arg30, k : arg31)\nvar v3 : [AnyHashable] = [2, 20, 123]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [-123, 20, 0, 1, 2, -3]\nvar arg41 : Int = 4\nvar x4 : [AnyHashable] = maximum(arr : arg40, k : arg41)\nvar v4 : [AnyHashable] = [0, 1, 2, 20]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [5, 15, 0, 3, -13, -8, 0]\nvar arg51 : Int = 7\nvar x5 : [AnyHashable] = maximum(arr : arg50, k : arg51)\nvar v5 : [AnyHashable] = [-13, -8, 0, 0, 3, 5, 15]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [-1, 0, 2, 5, 3, -10]\nvar arg61 : Int = 2\nvar x6 : [AnyHashable] = maximum(arr : arg60, k : arg61)\nvar v6 : [AnyHashable] = [3, 5]\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Int] = [1, 0, 5, -7]\nvar arg71 : Int = 1\nvar x7 : [AnyHashable] = maximum(arr : arg70, k : arg71)\nvar v7 : [AnyHashable] = [5]\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [Int] = [4, -4]\nvar arg81 : Int = 2\nvar x8 : [AnyHashable] = maximum(arr : arg80, k : arg81)\nvar v8 : [AnyHashable] = [-4, 4]\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : [Int] = [-10, 10]\nvar arg91 : Int = 2\nvar x9 : [AnyHashable] = maximum(arr : arg90, k : arg91)\nvar v9 : [AnyHashable] = [-10, 10]\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : [Int] = [1, 2, 3, -23, 243, -400, 0]\nvar arg101 : Int = 0\nvar x10 : [AnyHashable] = maximum(arr : arg100, k : arg101)\nvar v10 : [AnyHashable] = []\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\n", "description": "با دادن یک آرایه از اعداد صحیح و یک عدد صحیح مثبت k، یک لیست مرتب شده با طول k حاوی بزرگترین k عدد در آرایه برگردانید.\n\nمثال ۱:\n\nورودی: arr = [-3، -4، 5]، k = 3\nخروجی: [-4، -3، 5]\n\nمثال ۲:\n\nورودی: arr = [4، -4، 4]، k = 2\nخروجی: [4، 4]\n\nمثال ۳:\n\nورودی: arr = [-3، 2، 1، 2، -1، -2، 1]، k = 1\nخروجی: [2]\n\nتوجه:\n۱. طول آرایه در محدوده [1، 1000] خواهد بود.\n۲. عناصر آرایه در محدوده [-1000، 1000] خواهند بود.\n۳. 0 <= k <= len(arr)", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/55", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * با دریافت یک آرایه غیر خالی از اعداد صحیح arr و یک عدد صحیح k، مجموع عناصر با حداکثر دو رقم از اولین k عنصر از arr را برگردانید.\n * \n * مثال:\n * \n *     ورودی: arr = [111، 21، 3، 4000، 5، 6، 7، 8، 9]، k = 4\n *     خروجی: 24 # مجموع 21 + 3\n * \n * محدودیت ها:\n *     1. 1 <= len(arr) <= 100\n *     2. 1 <= k <= len(arr)\n * \n *\n */\nfunc addElements(arr : [Int], k : Int) -> Int {\n", "entry_point": "addElements", "test": "\n\nvar arg00 : [Int] = [1, -2, -3, 41, 57, 76, 87, 88, 99]\nvar arg01 : Int = 3\nvar x0 : Int = addElements(arr : arg00, k : arg01)\nvar v0 : Int = -4\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [111, 121, 3, 4000, 5, 6]\nvar arg11 : Int = 2\nvar x1 : Int = addElements(arr : arg10, k : arg11)\nvar v1 : Int = 0\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [11, 21, 3, 90, 5, 6, 7, 8, 9]\nvar arg21 : Int = 4\nvar x2 : Int = addElements(arr : arg20, k : arg21)\nvar v2 : Int = 125\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [111, 21, 3, 4000, 5, 6, 7, 8, 9]\nvar arg31 : Int = 4\nvar x3 : Int = addElements(arr : arg30, k : arg31)\nvar v3 : Int = 24\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [1]\nvar arg41 : Int = 1\nvar x4 : Int = addElements(arr : arg40, k : arg41)\nvar v4 : Int = 1\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "با دریافت یک آرایه غیر خالی از اعداد صحیح arr و یک عدد صحیح k، مجموع عناصر با حداکثر دو رقم از اولین k عنصر از arr را برگردانید.\n\nمثال:\n\n    ورودی: arr = [111، 21، 3، 4000، 5، 6، 7، 8، 9]، k = 4\n    خروجی: 24 # مجموع 21 + 3\n\nمحدودیت ها:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/56", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * شما دو بازه داده شده دارید،\n *     که هر بازه شامل یک جفت عدد صحیح است. به عنوان مثال، بازه = (شروع، پایان) = (1، 2).\n *     بازه های داده شده بسته هستند که به این معنی است که بازه (شروع، پایان)\n *     شامل هر دو شروع و پایان است.\n *     برای هر بازه داده شده، فرض می شود که شروع آن کمتر یا مساوی پایان آن است.\n *     وظیفه شما تعیین این است که طول تقاطع این دو بازه\n *     یک عدد اول است یا خیر.\n *     به عنوان مثال، تقاطع بازه ها (1، 3)، (2، 4) (2، 3) است\n *     که طول آن 1 است، که یک عدد اول نیست.\n *     اگر طول تقاطع یک عدد اول باشد، \"YES\" را برگردانید،\n *     در غیر این صورت، \"NO\" را برگردانید.\n *     اگر دو بازه با هم تداخل ندارند، \"NO\" را برگردانید.\n * \n * \n *     [ورودی / خروجی] نمونه:\n * \n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n *\n */\nfunc intersection(interval1 : [Int], interval2 : [Int]) -> String {\n", "entry_point": "intersection", "test": "\n\nvar arg00 : [Int] = [1, 2]\nvar arg01 : [Int] = [2, 3]\nvar x0 : String = intersection(interval1 : arg00, interval2 : arg01)\nvar v0 : String = #\"NO\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Int] = [-1, 1]\nvar arg11 : [Int] = [0, 4]\nvar x1 : String = intersection(interval1 : arg10, interval2 : arg11)\nvar v1 : String = #\"NO\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Int] = [-3, -1]\nvar arg21 : [Int] = [-5, 5]\nvar x2 : String = intersection(interval1 : arg20, interval2 : arg21)\nvar v2 : String = #\"YES\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Int] = [-2, 2]\nvar arg31 : [Int] = [-4, 0]\nvar x3 : String = intersection(interval1 : arg30, interval2 : arg31)\nvar v3 : String = #\"YES\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Int] = [-11, 2]\nvar arg41 : [Int] = [-1, -1]\nvar x4 : String = intersection(interval1 : arg40, interval2 : arg41)\nvar v4 : String = #\"NO\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Int] = [1, 2]\nvar arg51 : [Int] = [3, 5]\nvar x5 : String = intersection(interval1 : arg50, interval2 : arg51)\nvar v5 : String = #\"NO\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Int] = [1, 2]\nvar arg61 : [Int] = [1, 2]\nvar x6 : String = intersection(interval1 : arg60, interval2 : arg61)\nvar v6 : String = #\"NO\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Int] = [-2, -2]\nvar arg71 : [Int] = [-3, -2]\nvar x7 : String = intersection(interval1 : arg70, interval2 : arg71)\nvar v7 : String = #\"NO\"#\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\n", "description": "شما دو بازه داده شده دارید،\n    که هر بازه شامل یک جفت عدد صحیح است. به عنوان مثال، بازه = (شروع، پایان) = (1، 2).\n    بازه های داده شده بسته هستند که به این معنی است که بازه (شروع، پایان)\n    شامل هر دو شروع و پایان است.\n    برای هر بازه داده شده، فرض می شود که شروع آن کمتر یا مساوی پایان آن است.\n    وظیفه شما تعیین این است که طول تقاطع این دو بازه\n    یک عدد اول است یا خیر.\n    به عنوان مثال، تقاطع بازه ها (1، 3)، (2، 4) (2، 3) است\n    که طول آن 1 است، که یک عدد اول نیست.\n    اگر طول تقاطع یک عدد اول باشد، \"YES\" را برگردانید،\n    در غیر این صورت، \"NO\" را برگردانید.\n    اگر دو بازه با هم تداخل ندارند، \"NO\" را برگردانید.\n\n\n    [ورودی / خروجی] نمونه:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/57", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * همه می‌دانند دنباله فیبوناچی، که در چند قرن گذشته توسط ریاضی‌دانان عمیقاً مورد بررسی قرار گرفته است. با این حال، آنچه مردم نمی‌دانند دنباله تریبوناچی است. دنباله تریبوناچی توسط بازگشتی تعریف می‌شود:\n *     tri(1) = 3\n *     tri(n) = 1 + n / 2، اگر n زوج باشد.\n *     tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، اگر n فرد باشد.\n *     به عنوان مثال:\n *     tri(2) = 1 + (2 / 2) = 2\n *     tri(4) = 3\n *     tri(3) = tri(2) + tri(1) + tri(4)\n *            = 2 + 3 + 3 = 8 \n *     شما یک عدد صحیح غیر منفی n را دریافت می‌کنید، شما باید یک لیست از اولین n + 1 عدد دنباله تریبوناچی را برگردانید.\n *     مثال:\n *     tri(3) = [1، 3، 2، 8]\n * \n *\n */\nfunc tri(n : Int) -> [Double] {\n", "entry_point": "tri", "test": "\n\nvar arg00 : Int = 3\nvar x0 : [Double] = tri(n : arg00)\nvar v0 : [Double] = [1, 3, 2.0, 8.0]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 4\nvar x1 : [Double] = tri(n : arg10)\nvar v1 : [Double] = [1, 3, 2.0, 8.0, 3.0]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 5\nvar x2 : [Double] = tri(n : arg20)\nvar v2 : [Double] = [1, 3, 2.0, 8.0, 3.0, 15.0]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 6\nvar x3 : [Double] = tri(n : arg30)\nvar v3 : [Double] = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 7\nvar x4 : [Double] = tri(n : arg40)\nvar v4 : [Double] = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 8\nvar x5 : [Double] = tri(n : arg50)\nvar v5 : [Double] = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 9\nvar x6 : [Double] = tri(n : arg60)\nvar v6 : [Double] = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 20\nvar x7 : [Double] = tri(n : arg70)\nvar v7 : [Double] = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 0\nvar x8 : [Double] = tri(n : arg80)\nvar v8 : [Double] = [1]\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 1\nvar x9 : [Double] = tri(n : arg90)\nvar v9 : [Double] = [1, 3]\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\n", "description": "همه می‌دانند دنباله فیبوناچی، که در چند قرن گذشته توسط ریاضی‌دانان عمیقاً مورد بررسی قرار گرفته است. با این حال، آنچه مردم نمی‌دانند دنباله تریبوناچی است. دنباله تریبوناچی توسط بازگشتی تعریف می‌شود:\n    tri(1) = 3\n    tri(n) = 1 + n / 2، اگر n زوج باشد.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، اگر n فرد باشد.\n    به عنوان مثال:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    شما یک عدد صحیح غیر منفی n را دریافت می‌کنید، شما باید یک لیست از اولین n + 1 عدد دنباله تریبوناچی را برگردانید.\n    مثال:\n    tri(3) = [1، 3، 2، 8]", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/58", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * با دادن یک عدد صحیح مثبت n، حاصلضرب ارقام فرد را برگردانید.\n *     اگر همه ارقام زوج باشند، 0 را برگردانید.\n *     به عنوان مثال:\n * \n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n *\n */\nfunc digits(n : Int) -> Int {\n", "entry_point": "digits", "test": "\n\nvar arg00 : Int = 5\nvar x0 : Int = digits(n : arg00)\nvar v0 : Int = 5\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 54\nvar x1 : Int = digits(n : arg10)\nvar v1 : Int = 5\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 120\nvar x2 : Int = digits(n : arg20)\nvar v2 : Int = 1\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 5014\nvar x3 : Int = digits(n : arg30)\nvar v3 : Int = 5\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 98765\nvar x4 : Int = digits(n : arg40)\nvar v4 : Int = 315\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 5576543\nvar x5 : Int = digits(n : arg50)\nvar v5 : Int = 2625\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 2468\nvar x6 : Int = digits(n : arg60)\nvar v6 : Int = 0\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "با دادن یک عدد صحیح مثبت n، حاصلضرب ارقام فرد را برگردانید.\n    اگر همه ارقام زوج باشند، 0 را برگردانید.\n    به عنوان مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/59", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * یک تابع ایجاد کنید که یک رشته را به عنوان ورودی دریافت می کند که فقط شامل براکت های مربعی است.\n * این تابع باید در صورت وجود زیردنباله معتبری از براکت ها که حداقل یک براکت درونی در آن وجود دارد، True را برگرداند.\n * is_nested('[[]]') ➞ True\n * is_nested('[]]]]]]][[[[[]') ➞ False\n * is_nested('[][]') ➞ False\n * is_nested('[]') ➞ False\n * is_nested('[[][]]') ➞ True\n * is_nested('[[]][[') ➞ True\n *\n */\nfunc isNested(string : String) -> Bool {\n", "entry_point": "isNested", "test": "\n\nvar arg00 : String = #\"[[]]\"#\nvar x0 : Bool = isNested(string : arg00)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"[]]]]]]][[[[[]\"#\nvar x1 : Bool = isNested(string : arg10)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"[][]\"#\nvar x2 : Bool = isNested(string : arg20)\nvar v2 : Bool = false\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"[]\"#\nvar x3 : Bool = isNested(string : arg30)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"[[[[]]]]\"#\nvar x4 : Bool = isNested(string : arg40)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"[]]]]]]]]]]\"#\nvar x5 : Bool = isNested(string : arg50)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"[][][[]]\"#\nvar x6 : Bool = isNested(string : arg60)\nvar v6 : Bool = true\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"[[]\"#\nvar x7 : Bool = isNested(string : arg70)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : String = #\"[]]\"#\nvar x8 : Bool = isNested(string : arg80)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : String = #\"[[]][[\"#\nvar x9 : Bool = isNested(string : arg90)\nvar v9 : Bool = true\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : String = #\"[[][]]\"#\nvar x10 : Bool = isNested(string : arg100)\nvar v10 : Bool = true\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : String = #\"\"#\nvar x11 : Bool = isNested(string : arg110)\nvar v11 : Bool = false\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : String = #\"[[[[[[[[\"#\nvar x12 : Bool = isNested(string : arg120)\nvar v12 : Bool = false\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\nvar arg130 : String = #\"]]]]]]]]\"#\nvar x13 : Bool = isNested(string : arg130)\nvar v13 : Bool = false\nassert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \")\n\n", "description": "یک تابع ایجاد کنید که یک رشته را به عنوان ورودی دریافت می کند که فقط شامل براکت های مربعی است.\nاین تابع باید در صورت وجود زیردنباله معتبری از براکت ها که حداقل یک براکت درونی در آن وجود دارد، True را برگرداند.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/60", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * شما یک لیست اعداد دارید.\n * شما باید مجموع اعداد مربع شده در لیست داده شده را برگردانید،\n * هر عنصر در لیست را ابتدا به بالاترین عدد صحیح (سقف) گرد کنید.\n * مثال:\n * برای lst = [1،2،3] خروجی باید 14 باشد\n * برای lst = [1،4،9] خروجی باید 98 باشد\n * برای lst = [1،3،5،7] خروجی باید 84 باشد\n * برای lst = [1.4،4.2،0] خروجی باید 29 باشد\n * برای lst = [-2.4،1،1] خروجی باید 6 باشد\n * \n * \n\n *\n */\nfunc sumSquares(lst : [Double]) -> Int {\n", "entry_point": "sumSquares", "test": "\n\nvar arg00 : [Double] = [1, 2, 3]\nvar x0 : Int = sumSquares(lst : arg00)\nvar v0 : Int = 14\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [Double] = [1.0, 2, 3]\nvar x1 : Int = sumSquares(lst : arg10)\nvar v1 : Int = 14\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [Double] = [1, 3, 5, 7]\nvar x2 : Int = sumSquares(lst : arg20)\nvar v2 : Int = 84\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [Double] = [1.4, 4.2, 0]\nvar x3 : Int = sumSquares(lst : arg30)\nvar v3 : Int = 29\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [Double] = [-2.4, 1, 1]\nvar x4 : Int = sumSquares(lst : arg40)\nvar v4 : Int = 6\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [Double] = [100, 1, 15, 2]\nvar x5 : Int = sumSquares(lst : arg50)\nvar v5 : Int = 10230\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [Double] = [10000, 10000]\nvar x6 : Int = sumSquares(lst : arg60)\nvar v6 : Int = 200000000\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [Double] = [-1.4, 4.6, 6.3]\nvar x7 : Int = sumSquares(lst : arg70)\nvar v7 : Int = 75\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [Double] = [-1.4, 17.9, 18.9, 19.9]\nvar x8 : Int = sumSquares(lst : arg80)\nvar v8 : Int = 1086\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : [Double] = [0]\nvar x9 : Int = sumSquares(lst : arg90)\nvar v9 : Int = 0\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : [Double] = [-1]\nvar x10 : Int = sumSquares(lst : arg100)\nvar v10 : Int = 1\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : [Double] = [-1, 1, 0]\nvar x11 : Int = sumSquares(lst : arg110)\nvar v11 : Int = 2\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\n", "description": "شما یک لیست اعداد دارید.\nشما باید مجموع اعداد مربع شده در لیست داده شده را برگردانید،\nهر عنصر در لیست را ابتدا به بالاترین عدد صحیح (سقف) گرد کنید.\nمثال:\nبرای lst = [1،2،3] خروجی باید 14 باشد\nبرای lst = [1،4،9] خروجی باید 98 باشد\nبرای lst = [1،3،5،7] خروجی باید 84 باشد\nبرای lst = [1.4،4.2،0] خروجی باید 29 باشد\nبرای lst = [-2.4،1،1] خروجی باید 6 باشد", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/61", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * تابعی بسازید که در صورتی که آخرین حرف رشته داده شده یک حرف الفبایی باشد و بخشی از یک کلمه نباشد، True برگرداند و در غیر این صورت False.\n * توجه: \"کلمه\" یک گروه از حروف جدا شده توسط فاصله است.\n * \n * مثال ها:\n * \n * check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n * check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n * check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n * check_if_last_char_is_a_letter(\"\") ➞ False \n *\n */\nfunc checkIfLastCharIsALetter(txt : String) -> Bool {\n", "entry_point": "checkIfLastCharIsALetter", "test": "\n\nvar arg00 : String = #\"apple\"#\nvar x0 : Bool = checkIfLastCharIsALetter(txt : arg00)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"apple pi e\"#\nvar x1 : Bool = checkIfLastCharIsALetter(txt : arg10)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"eeeee\"#\nvar x2 : Bool = checkIfLastCharIsALetter(txt : arg20)\nvar v2 : Bool = false\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"A\"#\nvar x3 : Bool = checkIfLastCharIsALetter(txt : arg30)\nvar v3 : Bool = true\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"Pumpkin pie \"#\nvar x4 : Bool = checkIfLastCharIsALetter(txt : arg40)\nvar v4 : Bool = false\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"Pumpkin pie 1\"#\nvar x5 : Bool = checkIfLastCharIsALetter(txt : arg50)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"\"#\nvar x6 : Bool = checkIfLastCharIsALetter(txt : arg60)\nvar v6 : Bool = false\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"eeeee e \"#\nvar x7 : Bool = checkIfLastCharIsALetter(txt : arg70)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : String = #\"apple pie\"#\nvar x8 : Bool = checkIfLastCharIsALetter(txt : arg80)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : String = #\"apple pi e \"#\nvar x9 : Bool = checkIfLastCharIsALetter(txt : arg90)\nvar v9 : Bool = false\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\n", "description": "تابعی بسازید که در صورتی که آخرین حرف رشته داده شده یک حرف الفبایی باشد و بخشی از یک کلمه نباشد، True برگرداند و در غیر این صورت False.\nتوجه: \"کلمه\" یک گروه از حروف جدا شده توسط فاصله است.\n\nمثال ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/62", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * تابعی بسازید که بزرگترین شاخص یک عنصر را که بزرگتر یا مساوی عنصر قبلی آن نیست، برگرداند. اگر چنین عنصری وجود نداشته باشد، -1 را برگردانید. آرایه داده شده شامل مقادیر تکراری نخواهد بود.\n * \n * مثال ها:\n * \n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n *\n */\nfunc canArrange(arr : [AnyHashable]) -> Int {\n", "entry_point": "canArrange", "test": "\n\nvar arg00 : [AnyHashable] = [1, 2, 4, 3, 5]\nvar x0 : Int = canArrange(arr : arg00)\nvar v0 : Int = 3\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [1, 2, 4, 5]\nvar x1 : Int = canArrange(arr : arg10)\nvar v1 : Int = -1\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [1, 4, 2, 5, 6, 7, 8, 9, 10]\nvar x2 : Int = canArrange(arr : arg20)\nvar v2 : Int = 2\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [4, 8, 5, 7, 3]\nvar x3 : Int = canArrange(arr : arg30)\nvar v3 : Int = 4\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = []\nvar x4 : Int = canArrange(arr : arg40)\nvar v4 : Int = -1\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\n", "description": "تابعی بسازید که بزرگترین شاخص یک عنصر را که بزرگتر یا مساوی عنصر قبلی آن نیست، برگرداند. اگر چنین عنصری وجود نداشته باشد، -1 را برگردانید. آرایه داده شده شامل مقادیر تکراری نخواهد بود.\n\nمثال ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/63", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * تابعی بسازید که یک تاپل (a، b) را برمی گرداند، جایی که 'a' بزرگترین اعداد منفی و 'b' کوچکترین اعداد مثبت در یک لیست است. اگر هیچ عدد منفی یا مثبتی وجود نداشته باشد، آنها را به عنوان None برگردانید.\n * \n * مثال ها:\n * \n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n *\n */\nfunc largestSmallestIntegers(lst : [AnyHashable]) -> [AnyHashable] {\n", "entry_point": "largestSmallestIntegers", "test": "\n\nvar arg00 : [AnyHashable] = [2, 4, 1, 3, 5, 7]\nvar x0 : [AnyHashable] = largestSmallestIntegers(lst : arg00)\nvar v0 : [AnyHashable] = [\"none\", 1]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [2, 4, 1, 3, 5, 7, 0]\nvar x1 : [AnyHashable] = largestSmallestIntegers(lst : arg10)\nvar v1 : [AnyHashable] = [\"none\", 1]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [1, 3, 2, 4, 5, 6, -2]\nvar x2 : [AnyHashable] = largestSmallestIntegers(lst : arg20)\nvar v2 : [AnyHashable] = [-2, 1]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [4, 5, 3, 6, 2, 7, -7]\nvar x3 : [AnyHashable] = largestSmallestIntegers(lst : arg30)\nvar v3 : [AnyHashable] = [-7, 2]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [7, 3, 8, 4, 9, 2, 5, -9]\nvar x4 : [AnyHashable] = largestSmallestIntegers(lst : arg40)\nvar v4 : [AnyHashable] = [-9, 2]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable] = []\nvar x5 : [AnyHashable] = largestSmallestIntegers(lst : arg50)\nvar v5 : [AnyHashable] = [\"none\", \"none\"]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [AnyHashable] = [0]\nvar x6 : [AnyHashable] = largestSmallestIntegers(lst : arg60)\nvar v6 : [AnyHashable] = [\"none\", \"none\"]\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : [AnyHashable] = [-1, -3, -5, -6]\nvar x7 : [AnyHashable] = largestSmallestIntegers(lst : arg70)\nvar v7 : [AnyHashable] = [-1, \"none\"]\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : [AnyHashable] = [-1, -3, -5, -6, 0]\nvar x8 : [AnyHashable] = largestSmallestIntegers(lst : arg80)\nvar v8 : [AnyHashable] = [-1, \"none\"]\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : [AnyHashable] = [-6, -4, -4, -3, 1]\nvar x9 : [AnyHashable] = largestSmallestIntegers(lst : arg90)\nvar v9 : [AnyHashable] = [-3, 1]\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : [AnyHashable] = [-6, -4, -4, -3, -100, 1]\nvar x10 : [AnyHashable] = largestSmallestIntegers(lst : arg100)\nvar v10 : [AnyHashable] = [-3, 1]\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\n", "description": "تابعی بسازید که یک تاپل (a، b) را برمی گرداند، جایی که 'a' بزرگترین اعداد منفی و 'b' کوچکترین اعداد مثبت در یک لیست است. اگر هیچ عدد منفی یا مثبتی وجود نداشته باشد، آنها را به عنوان None برگردانید.\n\nمثال ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/64", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * فاکتوریل برزیلی به شکل زیر تعریف می‌شود:\n *     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     که در آن n > 0\n * \n *     به عنوان مثال:\n * >>> special_factorial(4)\n * 288\n\n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n *\n */\nfunc specialFactorial(n : Int) -> Int {\n", "entry_point": "specialFactorial", "test": "\n\nvar arg00 : Int = 4\nvar x0 : Int = specialFactorial(n : arg00)\nvar v0 : Int = 288\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 5\nvar x1 : Int = specialFactorial(n : arg10)\nvar v1 : Int = 34560\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 7\nvar x2 : Int = specialFactorial(n : arg20)\nvar v2 : Int = 125411328000\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 1\nvar x3 : Int = specialFactorial(n : arg30)\nvar v3 : Int = 1\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "فاکتوریل برزیلی به شکل زیر تعریف می‌شود:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    که در آن n > 0\n\n    به عنوان مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/65", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * شما یک رشته به عنوان جمله دریافت می‌کنید،\n *     جمله شامل برخی کلمات جدا شده با یک فضا است،\n *     و شما باید یک رشته برگردانید که شامل کلمات از جمله اصلی باشد،\n *     که طول آن‌ها اعداد اول هستند،\n *     ترتیب کلمات در رشته جدید باید همانند اصلی باشد.\n * \n *     مثال ۱:\n *         ورودی: جمله = \"This is a test\"\n *         خروجی: \"is\"\n * \n *     مثال ۲:\n *         ورودی: جمله = \"lets go for swimming\"\n *         خروجی: \"go for\"\n * \n *     محدودیت‌ها:\n *         * ۱ <= len(sentence) <= ۱۰۰\n *         * جمله فقط شامل حروف است.\n * \n *\n */\nfunc wordsInSentence(sentence : String) -> String {\n", "entry_point": "wordsInSentence", "test": "\n\nvar arg00 : String = #\"This is a test\"#\nvar x0 : String = wordsInSentence(sentence : arg00)\nvar v0 : String = #\"is\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"lets go for swimming\"#\nvar x1 : String = wordsInSentence(sentence : arg10)\nvar v1 : String = #\"go for\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"there is no place available here\"#\nvar x2 : String = wordsInSentence(sentence : arg20)\nvar v2 : String = #\"there is no place\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"Hi I am Hussein\"#\nvar x3 : String = wordsInSentence(sentence : arg30)\nvar v3 : String = #\"Hi am Hussein\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"go for it\"#\nvar x4 : String = wordsInSentence(sentence : arg40)\nvar v4 : String = #\"go for it\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"here\"#\nvar x5 : String = wordsInSentence(sentence : arg50)\nvar v5 : String = #\"\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"here is\"#\nvar x6 : String = wordsInSentence(sentence : arg60)\nvar v6 : String = #\"is\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "شما یک رشته به عنوان جمله دریافت می‌کنید،\n    جمله شامل برخی کلمات جدا شده با یک فضا است،\n    و شما باید یک رشته برگردانید که شامل کلمات از جمله اصلی باشد،\n    که طول آن‌ها اعداد اول هستند،\n    ترتیب کلمات در رشته جدید باید همانند اصلی باشد.\n\n    مثال ۱:\n        ورودی: جمله = \"This is a test\"\n        خروجی: \"is\"\n\n    مثال ۲:\n        ورودی: جمله = \"lets go for swimming\"\n        خروجی: \"go for\"\n\n    محدودیت‌ها:\n        * ۱ <= len(sentence) <= ۱۰۰\n        * جمله فقط شامل حروف است.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/66", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * وظیفه شما پیاده سازی یک تابع است که عبارت x * n را ساده سازی می کند. اگر x * n به یک عدد صحیح تبدیل شود، تابع True را برمی گرداند و در غیر این صورت False. هر دو x و n، نمایش رشته ای یک کسر هستند و فرمت آنها به شرح زیر است، <شمارنده>/<مخرج> که هر دو شمارنده و مخرج اعداد صحیح مثبت هستند.\n * \n * می توانید فرض کنید که x و n کسرهای معتبری هستند و صفر به عنوان مخرج ندارند.\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n *\n */\nfunc simplify(x : String, n : String) -> Bool {\n", "entry_point": "simplify", "test": "\n\nvar arg00 : String = #\"1/5\"#\nvar arg01 : String = #\"5/1\"#\nvar x0 : Bool = simplify(x : arg00, n : arg01)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"1/6\"#\nvar arg11 : String = #\"2/1\"#\nvar x1 : Bool = simplify(x : arg10, n : arg11)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"5/1\"#\nvar arg21 : String = #\"3/1\"#\nvar x2 : Bool = simplify(x : arg20, n : arg21)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"7/10\"#\nvar arg31 : String = #\"10/2\"#\nvar x3 : Bool = simplify(x : arg30, n : arg31)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"2/10\"#\nvar arg41 : String = #\"50/10\"#\nvar x4 : Bool = simplify(x : arg40, n : arg41)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"7/2\"#\nvar arg51 : String = #\"4/2\"#\nvar x5 : Bool = simplify(x : arg50, n : arg51)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"11/6\"#\nvar arg61 : String = #\"6/1\"#\nvar x6 : Bool = simplify(x : arg60, n : arg61)\nvar v6 : Bool = true\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"2/3\"#\nvar arg71 : String = #\"5/2\"#\nvar x7 : Bool = simplify(x : arg70, n : arg71)\nvar v7 : Bool = false\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : String = #\"5/2\"#\nvar arg81 : String = #\"3/5\"#\nvar x8 : Bool = simplify(x : arg80, n : arg81)\nvar v8 : Bool = false\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : String = #\"2/4\"#\nvar arg91 : String = #\"8/4\"#\nvar x9 : Bool = simplify(x : arg90, n : arg91)\nvar v9 : Bool = true\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : String = #\"2/4\"#\nvar arg101 : String = #\"4/2\"#\nvar x10 : Bool = simplify(x : arg100, n : arg101)\nvar v10 : Bool = true\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : String = #\"1/5\"#\nvar arg111 : String = #\"5/1\"#\nvar x11 : Bool = simplify(x : arg110, n : arg111)\nvar v11 : Bool = true\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : String = #\"1/5\"#\nvar arg121 : String = #\"1/5\"#\nvar x12 : Bool = simplify(x : arg120, n : arg121)\nvar v12 : Bool = false\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\n", "description": "وظیفه شما پیاده سازی یک تابع است که عبارت x * n را ساده سازی می کند. اگر x * n به یک عدد صحیح تبدیل شود، تابع True را برمی گرداند و در غیر این صورت False. هر دو x و n، نمایش رشته ای یک کسر هستند و فرمت آنها به شرح زیر است، <شمارنده>/<مخرج> که هر دو شمارنده و مخرج اعداد صحیح مثبت هستند.\n\nمی توانید فرض کنید که x و n کسرهای معتبری هستند و صفر به عنوان مخرج ندارند.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/67", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * یک تابع بنویسید که لیست داده شده از اعداد صحیح را بر اساس مجموع ارقام آنها به ترتیب صعودی مرتب کند. توجه: اگر چند مورد با مجموع مشابه از ارقام آنها وجود داشته باشد، آنها را بر اساس شاخص آنها در لیست اصلی مرتب کنید.\n * \n *     به عنوان مثال:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n *\n */\nfunc orderByPoints(nums : [AnyHashable]) -> [AnyHashable] {\n", "entry_point": "orderByPoints", "test": "\n\nvar arg00 : [AnyHashable] = [1, 11, -1, -11, -12]\nvar x0 : [AnyHashable] = orderByPoints(nums : arg00)\nvar v0 : [AnyHashable] = [-1, -11, 1, -12, 11]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\nvar x1 : [AnyHashable] = orderByPoints(nums : arg10)\nvar v1 : [AnyHashable] = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = []\nvar x2 : [AnyHashable] = orderByPoints(nums : arg20)\nvar v2 : [AnyHashable] = []\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [1, -11, -32, 43, 54, -98, 2, -3]\nvar x3 : [AnyHashable] = orderByPoints(nums : arg30)\nvar v3 : [AnyHashable] = [-3, -32, -98, -11, 1, 2, 43, 54]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\nvar x4 : [AnyHashable] = orderByPoints(nums : arg40)\nvar v4 : [AnyHashable] = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable] = [0, 6, 6, -76, -21, 23, 4]\nvar x5 : [AnyHashable] = orderByPoints(nums : arg50)\nvar v5 : [AnyHashable] = [-76, -21, 0, 4, 23, 6, 6]\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "یک تابع بنویسید که لیست داده شده از اعداد صحیح را بر اساس مجموع ارقام آنها به ترتیب صعودی مرتب کند. توجه: اگر چند مورد با مجموع مشابه از ارقام آنها وجود داشته باشد، آنها را بر اساس شاخص آنها در لیست اصلی مرتب کنید.\n\n    به عنوان مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/68", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * یک تابع بنویسید که یک آرایه از اعداد را به عنوان ورودی دریافت کرده و تعداد عناصر آرایه را که بزرگتر از 10 هستند و هر دو رقم اول و آخر یک عدد فرد هستند (1، 3، 5، 7، 9) برمی گرداند. به عنوان مثال:\n * \n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n *\n */\nfunc specialfilter(nums : [AnyHashable]) -> Int {\n", "entry_point": "specialfilter", "test": "\n\nvar arg00 : [AnyHashable] = [5, -2, 1, -5]\nvar x0 : Int = specialfilter(nums : arg00)\nvar v0 : Int = 0\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [15, -73, 14, -15]\nvar x1 : Int = specialfilter(nums : arg10)\nvar v1 : Int = 1\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [33, -2, -3, 45, 21, 109]\nvar x2 : Int = specialfilter(nums : arg20)\nvar v2 : Int = 2\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [43, -12, 93, 125, 121, 109]\nvar x3 : Int = specialfilter(nums : arg30)\nvar v3 : Int = 4\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [71, -2, -33, 75, 21, 19]\nvar x4 : Int = specialfilter(nums : arg40)\nvar v4 : Int = 3\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable] = [1]\nvar x5 : Int = specialfilter(nums : arg50)\nvar v5 : Int = 0\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [AnyHashable] = []\nvar x6 : Int = specialfilter(nums : arg60)\nvar v6 : Int = 0\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "یک تابع بنویسید که یک آرایه از اعداد را به عنوان ورودی دریافت کرده و تعداد عناصر آرایه را که بزرگتر از 10 هستند و هر دو رقم اول و آخر یک عدد فرد هستند (1، 3، 5، 7، 9) برمی گرداند. به عنوان مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/69", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * شما یک عدد صحیح مثبت n داده شده است. شما باید یک آرایه صحیح a با طول n ایجاد کنید.\n *         برای هر i (1 ≤ i ≤ n)، مقدار a[i] = i * i - i + 1 است.\n *         تعداد سه تایی (a[i]، a[j]، a[k]) از a را که i < j < k و a[i] + a[j] + a[k] بخشی از 3 است، برگردانید.\n * \n *     مثال:\n *         ورودی: n = 5\n *         خروجی: 1\n *         توضیحات:\n *         a = [1، 3، 7، 13، 21]\n *         تنها سه تایی معتبر (1، 7، 13) است.\n * \n *\n */\nfunc getMaxTriples(n : Int) -> Int {\n", "entry_point": "getMaxTriples", "test": "\n\nvar arg00 : Int = 5\nvar x0 : Int = getMaxTriples(n : arg00)\nvar v0 : Int = 1\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 6\nvar x1 : Int = getMaxTriples(n : arg10)\nvar v1 : Int = 4\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 10\nvar x2 : Int = getMaxTriples(n : arg20)\nvar v2 : Int = 36\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 100\nvar x3 : Int = getMaxTriples(n : arg30)\nvar v3 : Int = 53361\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "شما یک عدد صحیح مثبت n داده شده است. شما باید یک آرایه صحیح a با طول n ایجاد کنید.\n        برای هر i (1 ≤ i ≤ n)، مقدار a[i] = i * i - i + 1 است.\n        تعداد سه تایی (a[i]، a[j]، a[k]) از a را که i < j < k و a[i] + a[j] + a[k] بخشی از 3 است، برگردانید.\n\n    مثال:\n        ورودی: n = 5\n        خروجی: 1\n        توضیحات:\n        a = [1، 3، 7، 13، 21]\n        تنها سه تایی معتبر (1، 7، 13) است.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/70", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * در سیستم شمسی ما هشت سیاره وجود دارد: نزدیک‌ترین سیاره به خورشید \n *     مریخ است، سپس ونوس، زمین، مریخ، مشتری، زحل، \n *     اورانوس و نپتون.\n *     یک تابع بنویسید که دو نام سیاره به عنوان رشته‌های planet1 و planet2 را دریافت کند. \n *     تابع باید یک تاپل حاوی تمام سیاره‌هایی که مدار آن‌ها بین مدار سیاره 1 و مدار سیاره 2 قرار دارد را برگرداند، مرتب شده بر اساس نزدیکی به خورشید. \n *     اگر planet1 یا planet2 نام سیاره صحیح نباشد، تابع باید یک تاپل خالی برگرداند. \n *     مثال‌ها:\n * \n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n *\n */\nfunc bf(planet1 : String, planet2 : String) -> [AnyHashable] {\n", "entry_point": "bf", "test": "\n\nvar arg00 : String = #\"Jupiter\"#\nvar arg01 : String = #\"Neptune\"#\nvar x0 : [AnyHashable] = bf(planet1 : arg00, planet2 : arg01)\nvar v0 : [AnyHashable] = [#\"Saturn\"#, #\"Uranus\"#]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"Earth\"#\nvar arg11 : String = #\"Mercury\"#\nvar x1 : [AnyHashable] = bf(planet1 : arg10, planet2 : arg11)\nvar v1 : [AnyHashable] = [#\"Venus\"#]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"Mercury\"#\nvar arg21 : String = #\"Uranus\"#\nvar x2 : [AnyHashable] = bf(planet1 : arg20, planet2 : arg21)\nvar v2 : [AnyHashable] = [#\"Venus\"#, #\"Earth\"#, #\"Mars\"#, #\"Jupiter\"#, #\"Saturn\"#]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"Neptune\"#\nvar arg31 : String = #\"Venus\"#\nvar x3 : [AnyHashable] = bf(planet1 : arg30, planet2 : arg31)\nvar v3 : [AnyHashable] = [#\"Earth\"#, #\"Mars\"#, #\"Jupiter\"#, #\"Saturn\"#, #\"Uranus\"#]\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"Earth\"#\nvar arg41 : String = #\"Earth\"#\nvar x4 : [AnyHashable] = bf(planet1 : arg40, planet2 : arg41)\nvar v4 : [AnyHashable] = []\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"Mars\"#\nvar arg51 : String = #\"Earth\"#\nvar x5 : [AnyHashable] = bf(planet1 : arg50, planet2 : arg51)\nvar v5 : [AnyHashable] = []\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"Jupiter\"#\nvar arg61 : String = #\"Makemake\"#\nvar x6 : [AnyHashable] = bf(planet1 : arg60, planet2 : arg61)\nvar v6 : [AnyHashable] = []\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "در سیستم شمسی ما هشت سیاره وجود دارد: نزدیک‌ترین سیاره به خورشید \n    مریخ است، سپس ونوس، زمین، مریخ، مشتری، زحل، \n    اورانوس و نپتون.\n    یک تابع بنویسید که دو نام سیاره به عنوان رشته‌های planet1 و planet2 را دریافت کند. \n    تابع باید یک تاپل حاوی تمام سیاره‌هایی که مدار آن‌ها بین مدار سیاره 1 و مدار سیاره 2 قرار دارد را برگرداند، مرتب شده بر اساس نزدیکی به خورشید. \n    اگر planet1 یا planet2 نام سیاره صحیح نباشد، تابع باید یک تاپل خالی برگرداند. \n    مثال‌ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/71", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * یک برنامه ساده که باید مقدار x را برگرداند اگر n یک عدد اول باشد و در غیر این صورت باید مقدار y را برگرداند.\n * \n *     مثال ها:\n * \n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n *\n */\nfunc xOrY(n : Int, x : Int, y : Int) -> Int {\n", "entry_point": "xOrY", "test": "\n\nvar arg00 : Int = 7\nvar arg01 : Int = 34\nvar arg02 : Int = 12\nvar x0 : Int = xOrY(n : arg00, x : arg01, y : arg02)\nvar v0 : Int = 34\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 15\nvar arg11 : Int = 8\nvar arg12 : Int = 5\nvar x1 : Int = xOrY(n : arg10, x : arg11, y : arg12)\nvar v1 : Int = 5\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 3\nvar arg21 : Int = 33\nvar arg22 : Int = 5212\nvar x2 : Int = xOrY(n : arg20, x : arg21, y : arg22)\nvar v2 : Int = 33\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 1259\nvar arg31 : Int = 3\nvar arg32 : Int = 52\nvar x3 : Int = xOrY(n : arg30, x : arg31, y : arg32)\nvar v3 : Int = 3\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 7919\nvar arg41 : Int = -1\nvar arg42 : Int = 12\nvar x4 : Int = xOrY(n : arg40, x : arg41, y : arg42)\nvar v4 : Int = -1\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 3609\nvar arg51 : Int = 1245\nvar arg52 : Int = 583\nvar x5 : Int = xOrY(n : arg50, x : arg51, y : arg52)\nvar v5 : Int = 583\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 91\nvar arg61 : Int = 56\nvar arg62 : Int = 129\nvar x6 : Int = xOrY(n : arg60, x : arg61, y : arg62)\nvar v6 : Int = 129\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 6\nvar arg71 : Int = 34\nvar arg72 : Int = 1234\nvar x7 : Int = xOrY(n : arg70, x : arg71, y : arg72)\nvar v7 : Int = 1234\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 1\nvar arg81 : Int = 2\nvar arg82 : Int = 0\nvar x8 : Int = xOrY(n : arg80, x : arg81, y : arg82)\nvar v8 : Int = 0\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 2\nvar arg91 : Int = 2\nvar arg92 : Int = 0\nvar x9 : Int = xOrY(n : arg90, x : arg91, y : arg92)\nvar v9 : Int = 2\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\n", "description": "یک برنامه ساده که باید مقدار x را برگرداند اگر n یک عدد اول باشد و در غیر این صورت باید مقدار y را برگرداند.\n\n    مثال ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/72", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * با دادن یک لیست از اعداد، مجموع مربعات اعداد فرد در لیست را برگردانید. اعداد منفی یا غیرصحیح را نادیده بگیرید.\n * \n * double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n * double_the_difference([-1, -2, 0]) == 0\n * double_the_difference([9, -2]) == 81\n * double_the_difference([0]) == 0\n * \n * اگر لیست ورودی خالی باشد، 0 را برگردانید.\n * \n *\n */\nfunc doubleTheDifference(lst : [AnyHashable]) -> Int {\n", "entry_point": "doubleTheDifference", "test": "\n\nvar arg00 : [AnyHashable] = []\nvar x0 : Int = doubleTheDifference(lst : arg00)\nvar v0 : Int = 0\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : [AnyHashable] = [5, 4]\nvar x1 : Int = doubleTheDifference(lst : arg10)\nvar v1 : Int = 25\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : [AnyHashable] = [0.1, 0.2, 0.3]\nvar x2 : Int = doubleTheDifference(lst : arg20)\nvar v2 : Int = 0\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : [AnyHashable] = [-10, -20, -30]\nvar x3 : Int = doubleTheDifference(lst : arg30)\nvar v3 : Int = 0\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : [AnyHashable] = [-1, -2, 8]\nvar x4 : Int = doubleTheDifference(lst : arg40)\nvar v4 : Int = 0\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : [AnyHashable] = [0.2, 3, 5]\nvar x5 : Int = doubleTheDifference(lst : arg50)\nvar v5 : Int = 34\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : [AnyHashable] = [-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]\nvar x6 : Int = doubleTheDifference(lst : arg60)\nvar v6 : Int = 166650\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\n", "description": "با دادن یک لیست از اعداد، مجموع مربعات اعداد فرد در لیست را برگردانید. اعداد منفی یا غیرصحیح را نادیده بگیرید.\n\ndouble_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0\n\nاگر لیست ورودی خالی باشد، 0 را برگردانید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/73", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * شما نام یک کلاس (رشته ای) و یک لیست از افزونه ها را دریافت خواهید کرد.\n *     افزونه ها برای بارگذاری کلاس های اضافی به کلاس استفاده می شوند. قدرت افزونه به شرح زیر است: CAP شماره حروف بزرگ در نام افزونه باشد و SM شماره حروف کوچک در نام افزونه باشد، قدرت با کسر CAP - SM داده می شود.\n *     شما باید قوی ترین افزونه را پیدا کرده و یک رشته در این بازه برگردانید: ClassName.StrongestExtensionName.\n *     اگر دو یا بیشتر از دو افزونه با قدرت یکسان وجود داشته باشد، باید آن را انتخاب کنید که اولین در لیست باشد.\n *     به عنوان مثال، اگر به عنوان کلاس \"Slices\" و لیستی از افزونه ها را به شما داده شود: ['SErviNGSliCes', 'Cheese', 'StuFfed'] ، باید 'Slices.SErviNGSliCes' را برگردانید زیرا 'SErviNGSliCes' قوی ترین افزونه است (قدرت آن -1 است).\n *     مثال:\n * \n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n *\n */\nfunc strongestExtension(className : String, extensions : [String]) -> String {\n", "entry_point": "strongestExtension", "test": "\n\nvar arg00 : String = #\"Watashi\"#\nvar arg01 : [String] = [#\"tEN\"#, #\"niNE\"#, #\"eIGHt8OKe\"#]\nvar x0 : String = strongestExtension(className : arg00, extensions : arg01)\nvar v0 : String = #\"Watashi.eIGHt8OKe\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"Boku123\"#\nvar arg11 : [String] = [#\"nani\"#, #\"NazeDa\"#, #\"YEs.WeCaNe\"#, #\"32145tggg\"#]\nvar x1 : String = strongestExtension(className : arg10, extensions : arg11)\nvar v1 : String = #\"Boku123.YEs.WeCaNe\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"__YESIMHERE\"#\nvar arg21 : [String] = [#\"t\"#, #\"eMptY\"#, #\"nothing\"#, #\"zeR00\"#, #\"NuLl__\"#, #\"123NoooneB321\"#]\nvar x2 : String = strongestExtension(className : arg20, extensions : arg21)\nvar v2 : String = #\"__YESIMHERE.NuLl__\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"K\"#\nvar arg31 : [String] = [#\"Ta\"#, #\"TAR\"#, #\"t234An\"#, #\"cosSo\"#]\nvar x3 : String = strongestExtension(className : arg30, extensions : arg31)\nvar v3 : String = #\"K.TAR\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"__HAHA\"#\nvar arg41 : [String] = [#\"Tab\"#, #\"123\"#, #\"781345\"#, #\"-_-\"#]\nvar x4 : String = strongestExtension(className : arg40, extensions : arg41)\nvar v4 : String = #\"__HAHA.123\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"YameRore\"#\nvar arg51 : [String] = [#\"HhAas\"#, #\"okIWILL123\"#, #\"WorkOut\"#, #\"Fails\"#, #\"-_-\"#]\nvar x5 : String = strongestExtension(className : arg50, extensions : arg51)\nvar v5 : String = #\"YameRore.okIWILL123\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"finNNalLLly\"#\nvar arg61 : [String] = [#\"Die\"#, #\"NowW\"#, #\"Wow\"#, #\"WoW\"#]\nvar x6 : String = strongestExtension(className : arg60, extensions : arg61)\nvar v6 : String = #\"finNNalLLly.WoW\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"_\"#\nvar arg71 : [String] = [#\"Bb\"#, #\"91245\"#]\nvar x7 : String = strongestExtension(className : arg70, extensions : arg71)\nvar v7 : String = #\"_.Bb\"#\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : String = #\"Sp\"#\nvar arg81 : [String] = [#\"671235\"#, #\"Bb\"#]\nvar x8 : String = strongestExtension(className : arg80, extensions : arg81)\nvar v8 : String = #\"Sp.671235\"#\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\n", "description": "شما نام یک کلاس (رشته ای) و یک لیست از افزونه ها را دریافت خواهید کرد.\n    افزونه ها برای بارگذاری کلاس های اضافی به کلاس استفاده می شوند. قدرت افزونه به شرح زیر است: CAP شماره حروف بزرگ در نام افزونه باشد و SM شماره حروف کوچک در نام افزونه باشد، قدرت با کسر CAP - SM داده می شود.\n    شما باید قوی ترین افزونه را پیدا کرده و یک رشته در این بازه برگردانید: ClassName.StrongestExtensionName.\n    اگر دو یا بیشتر از دو افزونه با قدرت یکسان وجود داشته باشد، باید آن را انتخاب کنید که اولین در لیست باشد.\n    به عنوان مثال، اگر به عنوان کلاس \"Slices\" و لیستی از افزونه ها را به شما داده شود: ['SErviNGSliCes', 'Cheese', 'StuFfed'] ، باید 'Slices.SErviNGSliCes' را برگردانید زیرا 'SErviNGSliCes' قوی ترین افزونه است (قدرت آن -1 است).\n    مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/74", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * شما دو کلمه داده شده است. شما باید در صورتی که کلمه دوم یا هر یک از چرخش های آن به عنوان زیررشته در کلمه اول وجود داشته باشد، True را برگردانید.\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n\n *\n */\nfunc cycpatternCheck(a : String, b : String) -> Bool {\n", "entry_point": "cycpatternCheck", "test": "\n\nvar arg00 : String = #\"xyzw\"#\nvar arg01 : String = #\"xyw\"#\nvar x0 : Bool = cycpatternCheck(a : arg00, b : arg01)\nvar v0 : Bool = false\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"yello\"#\nvar arg11 : String = #\"ell\"#\nvar x1 : Bool = cycpatternCheck(a : arg10, b : arg11)\nvar v1 : Bool = true\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"whattup\"#\nvar arg21 : String = #\"ptut\"#\nvar x2 : Bool = cycpatternCheck(a : arg20, b : arg21)\nvar v2 : Bool = false\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"efef\"#\nvar arg31 : String = #\"fee\"#\nvar x3 : Bool = cycpatternCheck(a : arg30, b : arg31)\nvar v3 : Bool = true\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"abab\"#\nvar arg41 : String = #\"aabb\"#\nvar x4 : Bool = cycpatternCheck(a : arg40, b : arg41)\nvar v4 : Bool = false\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"winemtt\"#\nvar arg51 : String = #\"tinem\"#\nvar x5 : Bool = cycpatternCheck(a : arg50, b : arg51)\nvar v5 : Bool = true\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\n", "description": "شما دو کلمه داده شده است. شما باید در صورتی که کلمه دوم یا هر یک از چرخش های آن به عنوان زیررشته در کلمه اول وجود داشته باشد، True را برگردانید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/75", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * با دریافت یک عدد مثبت، معادل عدد رومی آن را به صورت رشته‌ای بدست آورده، و آن را به حروف کوچک برگردانید.\n * محدودیت‌ها: 1 <= num <= 1000\n * \n * مثال‌ها:\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n *\n */\nfunc intToMiniRoman(number : Int) -> String {\n", "entry_point": "intToMiniRoman", "test": "\n\nvar arg00 : Int = 19\nvar x0 : String = intToMiniRoman(number : arg00)\nvar v0 : String = #\"xix\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 152\nvar x1 : String = intToMiniRoman(number : arg10)\nvar v1 : String = #\"clii\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 251\nvar x2 : String = intToMiniRoman(number : arg20)\nvar v2 : String = #\"ccli\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 426\nvar x3 : String = intToMiniRoman(number : arg30)\nvar v3 : String = #\"cdxxvi\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 500\nvar x4 : String = intToMiniRoman(number : arg40)\nvar v4 : String = #\"d\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 1\nvar x5 : String = intToMiniRoman(number : arg50)\nvar v5 : String = #\"i\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 4\nvar x6 : String = intToMiniRoman(number : arg60)\nvar v6 : String = #\"iv\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 43\nvar x7 : String = intToMiniRoman(number : arg70)\nvar v7 : String = #\"xliii\"#\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 90\nvar x8 : String = intToMiniRoman(number : arg80)\nvar v8 : String = #\"xc\"#\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 94\nvar x9 : String = intToMiniRoman(number : arg90)\nvar v9 : String = #\"xciv\"#\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : Int = 532\nvar x10 : String = intToMiniRoman(number : arg100)\nvar v10 : String = #\"dxxxii\"#\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\nvar arg110 : Int = 900\nvar x11 : String = intToMiniRoman(number : arg110)\nvar v11 : String = #\"cm\"#\nassert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \")\n\nvar arg120 : Int = 994\nvar x12 : String = intToMiniRoman(number : arg120)\nvar v12 : String = #\"cmxciv\"#\nassert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \")\n\nvar arg130 : Int = 1000\nvar x13 : String = intToMiniRoman(number : arg130)\nvar v13 : String = #\"m\"#\nassert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \")\n\n", "description": "با دریافت یک عدد مثبت، معادل عدد رومی آن را به صورت رشته‌ای بدست آورده، و آن را به حروف کوچک برگردانید.\nمحدودیت‌ها: 1 <= num <= 1000\n\nمثال‌ها:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/76", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * با توجه به طول سه ضلع مثلث، اگر سه ضلع یک مثلث قائم‌الزاویه را تشکیل دهند، True برگردانده شود و در غیر این صورت False. یک مثلث قائم‌الزاویه، مثلثی است که یکی از زوایای آن زاویه قائمه یا ۹۰ درجه است. مثال:\n * \n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n *\n */\nfunc rightAngleTriangle(a : Int, b : Int, c : Int) -> Bool {\n", "entry_point": "rightAngleTriangle", "test": "\n\nvar arg00 : Int = 3\nvar arg01 : Int = 4\nvar arg02 : Int = 5\nvar x0 : Bool = rightAngleTriangle(a : arg00, b : arg01, c : arg02)\nvar v0 : Bool = true\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 1\nvar arg11 : Int = 2\nvar arg12 : Int = 3\nvar x1 : Bool = rightAngleTriangle(a : arg10, b : arg11, c : arg12)\nvar v1 : Bool = false\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 10\nvar arg21 : Int = 6\nvar arg22 : Int = 8\nvar x2 : Bool = rightAngleTriangle(a : arg20, b : arg21, c : arg22)\nvar v2 : Bool = true\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 2\nvar arg31 : Int = 2\nvar arg32 : Int = 2\nvar x3 : Bool = rightAngleTriangle(a : arg30, b : arg31, c : arg32)\nvar v3 : Bool = false\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : Int = 7\nvar arg41 : Int = 24\nvar arg42 : Int = 25\nvar x4 : Bool = rightAngleTriangle(a : arg40, b : arg41, c : arg42)\nvar v4 : Bool = true\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : Int = 10\nvar arg51 : Int = 5\nvar arg52 : Int = 7\nvar x5 : Bool = rightAngleTriangle(a : arg50, b : arg51, c : arg52)\nvar v5 : Bool = false\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : Int = 5\nvar arg61 : Int = 12\nvar arg62 : Int = 13\nvar x6 : Bool = rightAngleTriangle(a : arg60, b : arg61, c : arg62)\nvar v6 : Bool = true\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : Int = 15\nvar arg71 : Int = 8\nvar arg72 : Int = 17\nvar x7 : Bool = rightAngleTriangle(a : arg70, b : arg71, c : arg72)\nvar v7 : Bool = true\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\nvar arg80 : Int = 48\nvar arg81 : Int = 55\nvar arg82 : Int = 73\nvar x8 : Bool = rightAngleTriangle(a : arg80, b : arg81, c : arg82)\nvar v8 : Bool = true\nassert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \")\n\nvar arg90 : Int = 1\nvar arg91 : Int = 1\nvar arg92 : Int = 1\nvar x9 : Bool = rightAngleTriangle(a : arg90, b : arg91, c : arg92)\nvar v9 : Bool = false\nassert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \")\n\nvar arg100 : Int = 2\nvar arg101 : Int = 2\nvar arg102 : Int = 10\nvar x10 : Bool = rightAngleTriangle(a : arg100, b : arg101, c : arg102)\nvar v10 : Bool = false\nassert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \")\n\n", "description": "با توجه به طول سه ضلع مثلث، اگر سه ضلع یک مثلث قائم‌الزاویه را تشکیل دهند، True برگردانده شود و در غیر این صورت False. یک مثلث قائم‌الزاویه، مثلثی است که یکی از زوایای آن زاویه قائمه یا ۹۰ درجه است. مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/77", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * شما یک رشته s دریافت می‌کنید.\n *     اگر s[i] یک حرف باشد، حالت آن را از کوچک به بزرگ یا برعکس تغییر دهید،\n *     در غیر این صورت آن را به عنوان آن باقی بگذارید.\n *     اگر رشته حاوی هیچ حرفی نباشد، رشته را برعکس کنید.\n *     تابع باید رشته حاصل را برگرداند.\n *     مثالها\n * \n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n *\n */\nfunc solve(s : String) -> String {\n", "entry_point": "solve", "test": "\n\nvar arg00 : String = #\"AsDf\"#\nvar x0 : String = solve(s : arg00)\nvar v0 : String = #\"aSdF\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"1234\"#\nvar x1 : String = solve(s : arg10)\nvar v1 : String = #\"4321\"#\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"ab\"#\nvar x2 : String = solve(s : arg20)\nvar v2 : String = #\"AB\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"#a@C\"#\nvar x3 : String = solve(s : arg30)\nvar v3 : String = #\"#A@c\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\nvar arg40 : String = #\"#AsdfW^45\"#\nvar x4 : String = solve(s : arg40)\nvar v4 : String = #\"#aSDFw^45\"#\nassert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \")\n\nvar arg50 : String = #\"#6@2\"#\nvar x5 : String = solve(s : arg50)\nvar v5 : String = #\"2@6#\"#\nassert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \")\n\nvar arg60 : String = #\"#\\$a^D\"#\nvar x6 : String = solve(s : arg60)\nvar v6 : String = #\"#\\$A^d\"#\nassert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \")\n\nvar arg70 : String = #\"#ccc\"#\nvar x7 : String = solve(s : arg70)\nvar v7 : String = #\"#CCC\"#\nassert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \")\n\n", "description": "شما یک رشته s دریافت می‌کنید.\n    اگر s[i] یک حرف باشد، حالت آن را از کوچک به بزرگ یا برعکس تغییر دهید،\n    در غیر این صورت آن را به عنوان آن باقی بگذارید.\n    اگر رشته حاوی هیچ حرفی نباشد، رشته را برعکس کنید.\n    تابع باید رشته حاصل را برگرداند.\n    مثالها", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/78", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * با دادن یک رشته 'text'، رشته معادل هش md5 آن را برگردانید. اگر 'text' یک رشته خالی است، null را برگردانید.\n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n *\n */\nfunc stringToMd5(text : String) -> String {\n", "entry_point": "stringToMd5", "test": "\n\nvar arg00 : String = #\"Hello world\"#\nvar x0 : String = stringToMd5(text : arg00)\nvar v0 : String = #\"3e25960a79dbc69b674cd4ec67a72c62\"#\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : String = #\"\"#\nvar x1 : String = stringToMd5(text : arg10)\nvar v1 : String = \"none\"\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : String = #\"A B C\"#\nvar x2 : String = stringToMd5(text : arg20)\nvar v2 : String = #\"0ef78513b0cb8cef12743f5aeb35f888\"#\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : String = #\"password\"#\nvar x3 : String = stringToMd5(text : arg30)\nvar v3 : String = #\"5f4dcc3b5aa765d61d8327deb882cf99\"#\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "با دادن یک رشته 'text'، رشته معادل هش md5 آن را برگردانید. اگر 'text' یک رشته خالی است، null را برگردانید.", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "swift/79", "prompt": "/**\n * شما یک برنامه نویس حرفه ای Swift هستید و وظیفه شما در اینجا این است.\n * * با داشتن دو عدد مثبت a و b، ارقام زوج بین a و b را به ترتیب صعودی برگردانید.\n * \n *     به عنوان مثال:\n * \n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n *\n */\nfunc generateIntegers(a : Int, b : Int) -> [AnyHashable] {\n", "entry_point": "generateIntegers", "test": "\n\nvar arg00 : Int = 2\nvar arg01 : Int = 10\nvar x0 : [AnyHashable] = generateIntegers(a : arg00, b : arg01)\nvar v0 : [AnyHashable] = [2, 4, 6, 8]\nassert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \")\n\nvar arg10 : Int = 10\nvar arg11 : Int = 2\nvar x1 : [AnyHashable] = generateIntegers(a : arg10, b : arg11)\nvar v1 : [AnyHashable] = [2, 4, 6, 8]\nassert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \")\n\nvar arg20 : Int = 132\nvar arg21 : Int = 2\nvar x2 : [AnyHashable] = generateIntegers(a : arg20, b : arg21)\nvar v2 : [AnyHashable] = [2, 4, 6, 8]\nassert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \")\n\nvar arg30 : Int = 17\nvar arg31 : Int = 89\nvar x3 : [AnyHashable] = generateIntegers(a : arg30, b : arg31)\nvar v3 : [AnyHashable] = []\nassert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \")\n\n", "description": "با داشتن دو عدد مثبت a و b، ارقام زوج بین a و b را به ترتیب صعودی برگردانید.\n\n    به عنوان مثال:", "language": "swift", "canonical_solution": NaN, "natural_language": "Persian"}
