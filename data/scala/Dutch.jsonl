{"task_id": "scala/0", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Je krijgt een lijst met stortingen en opnames op een bankrekening die begint met een saldo van nul. Je taak is om te detecteren of op enig moment het saldo van de rekening onder nul valt, en op dat moment moet de functie True retourneren. Anders moet het False retourneren.\n     * >>> below_zero([1, 2, 3])\n     * False\n     * >>> below_zero([1, 2, -4, 5])\n     * True\n     *\n     */\n    def belowZero(operations : List[Any]) : Boolean = {\n", "entry_point": "belowZero", "test": "\n\n    var arg00 : List[Any] = List()\n    var x0 : Boolean = belowZero(arg00)\n    var v0 : Boolean = false\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Any] = List(1, 2, -3, 1, 2, -3)\n    var x1 : Boolean = belowZero(arg10)\n    var v1 : Boolean = false\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Any] = List(1, 2, -4, 5, 6)\n    var x2 : Boolean = belowZero(arg20)\n    var v2 : Boolean = true\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Any] = List(1, -1, 2, -2, 5, -5, 4, -4)\n    var x3 : Boolean = belowZero(arg30)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Any] = List(1, -1, 2, -2, 5, -5, 4, -5)\n    var x4 : Boolean = belowZero(arg40)\n    var v4 : Boolean = true\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Any] = List(1, -2, 2, -2, 5, -5, 4, -4)\n    var x5 : Boolean = belowZero(arg50)\n    var v5 : Boolean = true\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n\n}\n", "description": "Je krijgt een lijst met stortingen en opnames op een bankrekening die begint met een saldo van nul. Je taak is om te detecteren of op enig moment het saldo van de rekening onder nul valt, en op dat moment moet de functie True retourneren. Anders moet het False retourneren.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/1", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Voor een gegeven lijst van gehele getallen, retourneer een tuple bestaande uit de som en het product van alle getallen in de lijst.\n     * Een lege som moet gelijk zijn aan 0 en een leeg product moet gelijk zijn aan 1.\n     * >>> sum_product([])\n     * (0, 1)\n     * >>> sum_product([1, 2, 3, 4])\n     * (10, 24)\n     *\n     */\n    def sumProduct(numbers : List[Any]) : List[Int] = {\n", "entry_point": "sumProduct", "test": "\n\n    var arg00 : List[Any] = List()\n    var x0 : List[Int] = sumProduct(arg00)\n    var v0 : List[Int] = List(0, 1)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Any] = List(1, 1, 1)\n    var x1 : List[Int] = sumProduct(arg10)\n    var v1 : List[Int] = List(3, 1)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Any] = List(100, 0)\n    var x2 : List[Int] = sumProduct(arg20)\n    var v2 : List[Int] = List(100, 0)\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Any] = List(3, 5, 7)\n    var x3 : List[Int] = sumProduct(arg30)\n    var v3 : List[Int] = List(15, 105)\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Any] = List(10)\n    var x4 : List[Int] = sumProduct(arg40)\n    var v4 : List[Int] = List(10, 10)\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "Voor een gegeven lijst van gehele getallen, retourneer een tuple bestaande uit de som en het product van alle getallen in de lijst.\nEen lege som moet gelijk zijn aan 0 en een leeg product moet gelijk zijn aan 1.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/2", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * De input zijn twee strings a en b die alleen bestaan uit 1s en 0s.\n     * Voer een binaire XOR uit op deze inputs en retourneer het resultaat ook als een string.\n     * >>> string_xor('010', '110')\n     * '100'\n     *\n     */\n    def stringXor(a : String, b : String) : String = {\n", "entry_point": "stringXor", "test": "\n\n    var arg00 : String = \"\"\"111000\"\"\"\n    var arg01 : String = \"\"\"101010\"\"\"\n    var x0 : String = stringXor(arg00, arg01)\n    var v0 : String = \"\"\"010010\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"1\"\"\"\n    var arg11 : String = \"\"\"1\"\"\"\n    var x1 : String = stringXor(arg10, arg11)\n    var v1 : String = \"\"\"0\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"0101\"\"\"\n    var arg21 : String = \"\"\"0000\"\"\"\n    var x2 : String = stringXor(arg20, arg21)\n    var v2 : String = \"\"\"0101\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n\n}\n", "description": "De input zijn twee strings a en b die alleen bestaan uit 1s en 0s.\nVoer een binaire XOR uit op deze inputs en retourneer het resultaat ook als een string.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/3", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Uit een lijst van strings, retourneer de langste. Retourneer de eerste als er meerdere strings zijn van dezelfde lengte. Retourneer null als de invoerlijst leeg is.\n     * >>> longest([])\n\n     * >>> longest(['a', 'b', 'c'])\n     * 'a'\n     * >>> longest(['a', 'bb', 'ccc'])\n     * 'ccc'\n     *\n     */\n    def longest(strings : List[Any]) : Any = {\n", "entry_point": "longest", "test": "\n\n    var arg00 : List[Any] = List()\n    var x0 : Any = longest(arg00)\n    var v0 : Any = \"none\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Any] = List(\"\"\"x\"\"\", \"\"\"y\"\"\", \"\"\"z\"\"\")\n    var x1 : Any = longest(arg10)\n    var v1 : Any = \"\"\"x\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Any] = List(\"\"\"x\"\"\", \"\"\"yyy\"\"\", \"\"\"zzzz\"\"\", \"\"\"www\"\"\", \"\"\"kkkk\"\"\", \"\"\"abc\"\"\")\n    var x2 : Any = longest(arg20)\n    var v2 : Any = \"\"\"zzzz\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n\n}\n", "description": "Uit een lijst van strings, retourneer de langste. Retourneer de eerste als er meerdere strings zijn van dezelfde lengte. Retourneer null als de invoerlijst leeg is.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/4", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Geef de grootste gemene deler van twee gehele getallen a en b terug.\n     * >>> greatest_common_divisor(3, 5)\n     * 1\n     * >>> greatest_common_divisor(25, 15)\n     * 5\n     *\n     */\n    def greatestCommonDivisor(a : Int, b : Int) : Int = {\n", "entry_point": "greatestCommonDivisor", "test": "\n\n    var arg00 : Int = 3\n    var arg01 : Int = 7\n    var x0 : Int = greatestCommonDivisor(arg00, arg01)\n    var v0 : Int = 1\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 10\n    var arg11 : Int = 15\n    var x1 : Int = greatestCommonDivisor(arg10, arg11)\n    var v1 : Int = 5\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 49\n    var arg21 : Int = 14\n    var x2 : Int = greatestCommonDivisor(arg20, arg21)\n    var v2 : Int = 7\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 144\n    var arg31 : Int = 60\n    var x3 : Int = greatestCommonDivisor(arg30, arg31)\n    var v3 : Int = 12\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n\n}\n", "description": "Geef de grootste gemene deler van twee gehele getallen a en b terug.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/5", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * De input is een string van getallen gescheiden door spaties, van 'nul' tot 'negen'.\n     *     Geldige keuzes zijn 'nul', 'een', 'twee', 'drie', 'vier', 'vijf', 'zes', 'zeven', 'acht' en 'negen'.\n     *     Geef de string terug met de getallen gesorteerd van klein naar groot.\n     * >>> sort_numbers('three one five')\n     * 'one three five'\n     *\n     */\n    def sortNumbers(numbers : String) : String = {\n", "entry_point": "sortNumbers", "test": "\n\n    var arg00 : String = \"\"\"\"\"\"\n    var x0 : String = sortNumbers(arg00)\n    var v0 : String = \"\"\"\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"three\"\"\"\n    var x1 : String = sortNumbers(arg10)\n    var v1 : String = \"\"\"three\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"three five nine\"\"\"\n    var x2 : String = sortNumbers(arg20)\n    var v2 : String = \"\"\"three five nine\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"five zero four seven nine eight\"\"\"\n    var x3 : String = sortNumbers(arg30)\n    var v3 : String = \"\"\"zero four five seven eight nine\"\"\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"six five four three two one zero\"\"\"\n    var x4 : String = sortNumbers(arg40)\n    var v4 : String = \"\"\"zero one two three four five six\"\"\"\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "De input is een string van getallen gescheiden door spaties, van 'nul' tot 'negen'.\n    Geldige keuzes zijn 'nul', 'een', 'twee', 'drie', 'vier', 'vijf', 'zes', 'zeven', 'acht' en 'negen'.\n    Geef de string terug met de getallen gesorteerd van klein naar groot.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/6", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Gegeven een lijst van getallen (van ten minste twee elementen), pas een lineaire transformatie toe op die lijst, zodat het kleinste getal 0 wordt en het grootste getal 1 wordt.\n     * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n     * [0.0, 0.25, 0.5, 0.75, 1.0]\n     *\n     */\n    def rescaleToUnit(numbers : List[Double]) : List[Double] = {\n", "entry_point": "rescaleToUnit", "test": "\n\n    var arg00 : List[Double] = List(2.0, 49.9)\n    var x0 : List[Double] = rescaleToUnit(arg00)\n    var v0 : List[Double] = List(0.0, 1.0)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Double] = List(100.0, 49.9)\n    var x1 : List[Double] = rescaleToUnit(arg10)\n    var v1 : List[Double] = List(1.0, 0.0)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Double] = List(1.0, 2.0, 3.0, 4.0, 5.0)\n    var x2 : List[Double] = rescaleToUnit(arg20)\n    var v2 : List[Double] = List(0.0, 0.25, 0.5, 0.75, 1.0)\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Double] = List(2.0, 1.0, 5.0, 3.0, 4.0)\n    var x3 : List[Double] = rescaleToUnit(arg30)\n    var v3 : List[Double] = List(0.25, 0.0, 1.0, 0.5, 0.75)\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Double] = List(12.0, 11.0, 15.0, 13.0, 14.0)\n    var x4 : List[Double] = rescaleToUnit(arg40)\n    var v4 : List[Double] = List(0.25, 0.0, 1.0, 0.5, 0.75)\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "Gegeven een lijst van getallen (van ten minste twee elementen), pas een lineaire transformatie toe op die lijst, zodat het kleinste getal 0 wordt en het grootste getal 1 wordt.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/7", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Voor een gegeven string, verander kleine letters naar hoofdletters en hoofdletters naar kleine letters.\n     * >>> flip_case('Hello')\n     * 'hELLO'\n     *\n     */\n    def flipCase(string : String) : String = {\n", "entry_point": "flipCase", "test": "\n\n    var arg00 : String = \"\"\"\"\"\"\n    var x0 : String = flipCase(arg00)\n    var v0 : String = \"\"\"\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"Hello!\"\"\"\n    var x1 : String = flipCase(arg10)\n    var v1 : String = \"\"\"hELLO!\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"These violent delights have violent ends\"\"\"\n    var x2 : String = flipCase(arg20)\n    var v2 : String = \"\"\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n\n}\n", "description": "Voor een gegeven string, verander kleine letters naar hoofdletters en hoofdletters naar kleine letters.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/8", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Geef alleen positieve getallen terug in de lijst.\n     * >>> get_positive([-1, 2, -4, 5, 6])\n     * [2, 5, 6]\n     * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n     * [5, 3, 2, 3, 9, 123, 1]\n     *\n     */\n    def getPositive(l : List[Any]) : List[Any] = {\n", "entry_point": "getPositive", "test": "\n\n    var arg00 : List[Any] = List(-1, -2, 4, 5, 6)\n    var x0 : List[Any] = getPositive(arg00)\n    var v0 : List[Any] = List(4, 5, 6)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Any] = List(5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10)\n    var x1 : List[Any] = getPositive(arg10)\n    var v1 : List[Any] = List(5, 3, 2, 3, 3, 9, 123, 1)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Any] = List(-1, -2)\n    var x2 : List[Any] = getPositive(arg20)\n    var v2 : List[Any] = List()\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Any] = List()\n    var x3 : List[Any] = getPositive(arg30)\n    var v3 : List[Any] = List()\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n\n}\n", "description": "Geef alleen positieve getallen terug in de lijst.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/9", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Geef waar terug als een gegeven getal priem is, en anders onwaar.\n     * >>> is_prime(6)\n     * False\n     * >>> is_prime(101)\n     * True\n     * >>> is_prime(11)\n     * True\n     * >>> is_prime(13441)\n     * True\n     * >>> is_prime(61)\n     * True\n     * >>> is_prime(4)\n     * False\n     * >>> is_prime(1)\n     * False\n     *\n     */\n    def isPrime(n : Int) : Boolean = {\n", "entry_point": "isPrime", "test": "\n\n    var arg00 : Int = 6\n    var x0 : Boolean = isPrime(arg00)\n    var v0 : Boolean = false\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 101\n    var x1 : Boolean = isPrime(arg10)\n    var v1 : Boolean = true\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 11\n    var x2 : Boolean = isPrime(arg20)\n    var v2 : Boolean = true\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 13441\n    var x3 : Boolean = isPrime(arg30)\n    var v3 : Boolean = true\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 61\n    var x4 : Boolean = isPrime(arg40)\n    var v4 : Boolean = true\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 4\n    var x5 : Boolean = isPrime(arg50)\n    var v5 : Boolean = false\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 1\n    var x6 : Boolean = isPrime(arg60)\n    var v6 : Boolean = false\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : Int = 5\n    var x7 : Boolean = isPrime(arg70)\n    var v7 : Boolean = true\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : Int = 11\n    var x8 : Boolean = isPrime(arg80)\n    var v8 : Boolean = true\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : Int = 17\n    var x9 : Boolean = isPrime(arg90)\n    var v9 : Boolean = true\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n    var arg100 : Int = 85\n    var x10 : Boolean = isPrime(arg100)\n    var v10 : Boolean = false\n    assert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \" + x10)\n\n    var arg110 : Int = 77\n    var x11 : Boolean = isPrime(arg110)\n    var v11 : Boolean = false\n    assert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \" + x11)\n\n    var arg120 : Int = 255379\n    var x12 : Boolean = isPrime(arg120)\n    var v12 : Boolean = false\n    assert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \" + x12)\n\n\n}\n", "description": "Geef waar terug als een gegeven getal priem is, en anders onwaar.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/10", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Geef gesorteerde unieke elementen terug in een lijst.\n     * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n     * [0, 2, 3, 5, 9, 123]\n     *\n     */\n    def unique(l : List[Int]) : List[Int] = {\n", "entry_point": "unique", "test": "\n\n    var arg00 : List[Int] = List(5, 3, 5, 2, 3, 3, 9, 0, 123)\n    var x0 : List[Int] = unique(arg00)\n    var v0 : List[Int] = List(0, 2, 3, 5, 9, 123)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n\n}\n", "description": "Geef gesorteerde unieke elementen terug in een lijst.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/11", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * prime_fib geeft het n-de getal terug dat zowel een Fibonacci-getal als een priemgetal is.\n     * >>> prime_fib(1)\n     * 2\n     * >>> prime_fib(2)\n     * 3\n     * >>> prime_fib(3)\n     * 5\n     * >>> prime_fib(4)\n     * 13\n     * >>> prime_fib(5)\n     * 89\n     *\n     */\n    def primeFib(n : Int) : Int = {\n", "entry_point": "primeFib", "test": "\n\n    var arg00 : Int = 1\n    var x0 : Int = primeFib(arg00)\n    var v0 : Int = 2\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 2\n    var x1 : Int = primeFib(arg10)\n    var v1 : Int = 3\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 3\n    var x2 : Int = primeFib(arg20)\n    var v2 : Int = 5\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 4\n    var x3 : Int = primeFib(arg30)\n    var v3 : Int = 13\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 5\n    var x4 : Int = primeFib(arg40)\n    var v4 : Int = 89\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 6\n    var x5 : Int = primeFib(arg50)\n    var v5 : Int = 233\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 7\n    var x6 : Int = primeFib(arg60)\n    var v6 : Int = 1597\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : Int = 8\n    var x7 : Int = primeFib(arg70)\n    var v7 : Int = 28657\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : Int = 9\n    var x8 : Int = primeFib(arg80)\n    var v8 : Int = 514229\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : Int = 10\n    var x9 : Int = primeFib(arg90)\n    var v9 : Int = 433494437\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n\n}\n", "description": "prime_fib geeft het n-de getal terug dat zowel een Fibonacci-getal als een priemgetal is.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/12", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * triples_sum_to_zero neemt een lijst van gehele getallen als invoer.\n     * Het retourneert True als er drie verschillende elementen in de lijst zijn die bij elkaar opgeteld nul zijn, en anders False.\n     * >>> triples_sum_to_zero([1, 3, 5, 0])\n     * False\n     * >>> triples_sum_to_zero([1, 3, -2, 1])\n     * True\n     * >>> triples_sum_to_zero([1, 2, 3, 7])\n     * False\n     * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n     * True\n     * >>> triples_sum_to_zero([1])\n     * False\n     *\n     */\n    def triplesSumToZero(l : List[Int]) : Boolean = {\n", "entry_point": "triplesSumToZero", "test": "\n\n    var arg00 : List[Int] = List(1, 3, 5, 0)\n    var x0 : Boolean = triplesSumToZero(arg00)\n    var v0 : Boolean = false\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(1, 3, 5, -1)\n    var x1 : Boolean = triplesSumToZero(arg10)\n    var v1 : Boolean = false\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(1, 3, -2, 1)\n    var x2 : Boolean = triplesSumToZero(arg20)\n    var v2 : Boolean = true\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(1, 2, 3, 7)\n    var x3 : Boolean = triplesSumToZero(arg30)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Int] = List(1, 2, 5, 7)\n    var x4 : Boolean = triplesSumToZero(arg40)\n    var v4 : Boolean = false\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Int] = List(2, 4, -5, 3, 9, 7)\n    var x5 : Boolean = triplesSumToZero(arg50)\n    var v5 : Boolean = true\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : List[Int] = List(1)\n    var x6 : Boolean = triplesSumToZero(arg60)\n    var v6 : Boolean = false\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : List[Int] = List(1, 3, 5, -100)\n    var x7 : Boolean = triplesSumToZero(arg70)\n    var v7 : Boolean = false\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : List[Int] = List(100, 3, 5, -100)\n    var x8 : Boolean = triplesSumToZero(arg80)\n    var v8 : Boolean = false\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n\n}\n", "description": "triples_sum_to_zero neemt een lijst van gehele getallen als invoer.\nHet retourneert True als er drie verschillende elementen in de lijst zijn die bij elkaar opgeteld nul zijn, en anders False.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/13", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * pairs_sum_to_zero neemt een lijst van gehele getallen als invoer.\n     *     Het retourneert True als er twee verschillende elementen in de lijst zijn die\n     *     opgeteld nul zijn, en anders False.\n     * >>> pairs_sum_to_zero([1, 3, 5, 0])\n     * False\n     * >>> pairs_sum_to_zero([1, 3, -2, 1])\n     * False\n     * >>> pairs_sum_to_zero([1, 2, 3, 7])\n     * False\n     * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n     * True\n     * >>> pairs_sum_to_zero([1])\n     * False\n     *\n     */\n    def pairsSumToZero(l : List[Int]) : Boolean = {\n", "entry_point": "pairsSumToZero", "test": "\n\n    var arg00 : List[Int] = List(1, 3, 5, 0)\n    var x0 : Boolean = pairsSumToZero(arg00)\n    var v0 : Boolean = false\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(1, 3, -2, 1)\n    var x1 : Boolean = pairsSumToZero(arg10)\n    var v1 : Boolean = false\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(1, 2, 3, 7)\n    var x2 : Boolean = pairsSumToZero(arg20)\n    var v2 : Boolean = false\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(2, 4, -5, 3, 5, 7)\n    var x3 : Boolean = pairsSumToZero(arg30)\n    var v3 : Boolean = true\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Int] = List(1)\n    var x4 : Boolean = pairsSumToZero(arg40)\n    var v4 : Boolean = false\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Int] = List(-3, 9, -1, 3, 2, 30)\n    var x5 : Boolean = pairsSumToZero(arg50)\n    var v5 : Boolean = true\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : List[Int] = List(-3, 9, -1, 3, 2, 31)\n    var x6 : Boolean = pairsSumToZero(arg60)\n    var v6 : Boolean = true\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : List[Int] = List(-3, 9, -1, 4, 2, 30)\n    var x7 : Boolean = pairsSumToZero(arg70)\n    var v7 : Boolean = false\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : List[Int] = List(-3, 9, -1, 4, 2, 31)\n    var x8 : Boolean = pairsSumToZero(arg80)\n    var v8 : Boolean = false\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n\n}\n", "description": "pairs_sum_to_zero neemt een lijst van gehele getallen als invoer.\n    Het retourneert True als er twee verschillende elementen in de lijst zijn die\n    opgeteld nul zijn, en anders False.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/14", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * De Fib4-nummerreeks is een reeks vergelijkbaar met de Fibbonacci-reeks die als volgt wordt gedefinieerd:\n     *     fib4(0) -> 0\n     *     fib4(1) -> 0\n     *     fib4(2) -> 2\n     *     fib4(3) -> 0\n     *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n     *     Schrijf alstublieft een functie om efficiënt het n-de element van de Fib4-nummerreeks te berekenen. Gebruik geen recursie.\n     * >>> fib4(5)\n     * 4\n     * >>> fib4(6)\n     * 8\n     * >>> fib4(7)\n     * 14\n     *\n     */\n    def fib4(n : Int) : Int = {\n", "entry_point": "fib4", "test": "\n\n    var arg00 : Int = 5\n    var x0 : Int = fib4(arg00)\n    var v0 : Int = 4\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 8\n    var x1 : Int = fib4(arg10)\n    var v1 : Int = 28\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 10\n    var x2 : Int = fib4(arg20)\n    var v2 : Int = 104\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 12\n    var x3 : Int = fib4(arg30)\n    var v3 : Int = 386\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n\n}\n", "description": "De Fib4-nummerreeks is een reeks vergelijkbaar met de Fibbonacci-reeks die als volgt wordt gedefinieerd:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Schrijf alstublieft een functie om efficiënt het n-de element van de Fib4-nummerreeks te berekenen. Gebruik geen recursie.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/15", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Geef de mediaan terug van de elementen in de lijst l.\n     * >>> median([3, 1, 2, 4, 5])\n     * 3\n     * >>> median([-10, 4, 6, 1000, 10, 20])\n     * 15.0\n     *\n     */\n    def median(l : List[Int]) : Double = {\n", "entry_point": "median", "test": "\n\n    var arg00 : List[Int] = List(3, 1, 2, 4, 5)\n    var x0 : Double = median(arg00)\n    var v0 : Double = 3\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(-10, 4, 6, 1000, 10, 20)\n    var x1 : Double = median(arg10)\n    var v1 : Double = 8.0\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(5)\n    var x2 : Double = median(arg20)\n    var v2 : Double = 5\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(6, 5)\n    var x3 : Double = median(arg30)\n    var v3 : Double = 5.5\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Int] = List(8, 1, 3, 9, 9, 2, 7)\n    var x4 : Double = median(arg40)\n    var v4 : Double = 7\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "Geef de mediaan terug van de elementen in de lijst l.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/16", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Controleert of de gegeven string een palindroom is.\n     * >>> is_palindrome('')\n     * True\n     * >>> is_palindrome('aba')\n     * True\n     * >>> is_palindrome('aaaaa')\n     * True\n     * >>> is_palindrome('zbcd')\n     * False\n     *\n     */\n    def isPalindrome(text : String) : Boolean = {\n", "entry_point": "isPalindrome", "test": "\n\n    var arg00 : String = \"\"\"\"\"\"\n    var x0 : Boolean = isPalindrome(arg00)\n    var v0 : Boolean = true\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"aba\"\"\"\n    var x1 : Boolean = isPalindrome(arg10)\n    var v1 : Boolean = true\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"aaaaa\"\"\"\n    var x2 : Boolean = isPalindrome(arg20)\n    var v2 : Boolean = true\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"zbcd\"\"\"\n    var x3 : Boolean = isPalindrome(arg30)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"xywyx\"\"\"\n    var x4 : Boolean = isPalindrome(arg40)\n    var v4 : Boolean = true\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"xywyz\"\"\"\n    var x5 : Boolean = isPalindrome(arg50)\n    var v5 : Boolean = false\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"xywzx\"\"\"\n    var x6 : Boolean = isPalindrome(arg60)\n    var v6 : Boolean = false\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "Controleert of de gegeven string een palindroom is.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/17", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * remove_vowels is een functie die een string als input neemt en een string teruggeeft zonder klinkers.\n     * >>> remove_vowels('')\n     * ''\n     * >>> remove_vowels(\"abcdef\\nghijklm\")\n     * 'bcdf\\nghjklm'\n     * >>> remove_vowels('abcdef')\n     * 'bcdf'\n     * >>> remove_vowels('aaaaa')\n     * ''\n     * >>> remove_vowels('aaBAA')\n     * 'B'\n     * >>> remove_vowels('zbcd')\n     * 'zbcd'\n     *\n     */\n    def removeVowels(text : String) : String = {\n", "entry_point": "removeVowels", "test": "\n\n    var arg00 : String = \"\"\"\"\"\"\n    var x0 : String = removeVowels(arg00)\n    var v0 : String = \"\"\"\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"abcdef\\nghijklm\"\"\"\n    var x1 : String = removeVowels(arg10)\n    var v1 : String = \"\"\"bcdf\\nghjklm\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"fedcba\"\"\"\n    var x2 : String = removeVowels(arg20)\n    var v2 : String = \"\"\"fdcb\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"eeeee\"\"\"\n    var x3 : String = removeVowels(arg30)\n    var v3 : String = \"\"\"\"\"\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"acBAA\"\"\"\n    var x4 : String = removeVowels(arg40)\n    var v4 : String = \"\"\"cB\"\"\"\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"EcBOO\"\"\"\n    var x5 : String = removeVowels(arg50)\n    var v5 : String = \"\"\"cB\"\"\"\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"ybcd\"\"\"\n    var x6 : String = removeVowels(arg60)\n    var v6 : String = \"\"\"ybcd\"\"\"\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "remove_vowels is een functie die een string als input neemt en een string teruggeeft zonder klinkers.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/18", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Geef True terug als alle getallen in de lijst l onder de drempelwaarde t liggen.\n     * >>> below_threshold([1, 2, 4, 10], 100)\n     * True\n     * >>> below_threshold([1, 20, 4, 10], 5)\n     * False\n     *\n     */\n    def belowThreshold(l : List[Int], t : Int) : Boolean = {\n", "entry_point": "belowThreshold", "test": "\n\n    var arg00 : List[Int] = List(1, 2, 4, 10)\n    var arg01 : Int = 100\n    var x0 : Boolean = belowThreshold(arg00, arg01)\n    var v0 : Boolean = true\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(1, 20, 4, 10)\n    var arg11 : Int = 5\n    var x1 : Boolean = belowThreshold(arg10, arg11)\n    var v1 : Boolean = false\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(1, 20, 4, 10)\n    var arg21 : Int = 21\n    var x2 : Boolean = belowThreshold(arg20, arg21)\n    var v2 : Boolean = true\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(1, 20, 4, 10)\n    var arg31 : Int = 22\n    var x3 : Boolean = belowThreshold(arg30, arg31)\n    var v3 : Boolean = true\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Int] = List(1, 8, 4, 10)\n    var arg41 : Int = 11\n    var x4 : Boolean = belowThreshold(arg40, arg41)\n    var v4 : Boolean = true\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Int] = List(1, 8, 4, 10)\n    var arg51 : Int = 10\n    var x5 : Boolean = belowThreshold(arg50, arg51)\n    var v5 : Boolean = false\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n\n}\n", "description": "Geef True terug als alle getallen in de lijst l onder de drempelwaarde t liggen.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/19", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Tel twee getallen x en y bij elkaar op.\n     * >>> add(2, 3)\n     * 5\n     * >>> add(5, 7)\n     * 12\n     *\n     */\n    def add(x : Int, y : Int) : Int = {\n", "entry_point": "add", "test": "\n\n    var arg00 : Int = 0\n    var arg01 : Int = 1\n    var x0 : Int = add(arg00, arg01)\n    var v0 : Int = 1\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 1\n    var arg11 : Int = 0\n    var x1 : Int = add(arg10, arg11)\n    var v1 : Int = 1\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 2\n    var arg21 : Int = 3\n    var x2 : Int = add(arg20, arg21)\n    var v2 : Int = 5\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 5\n    var arg31 : Int = 7\n    var x3 : Int = add(arg30, arg31)\n    var v3 : Int = 12\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 7\n    var arg41 : Int = 5\n    var x4 : Int = add(arg40, arg41)\n    var v4 : Int = 12\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 572\n    var arg51 : Int = 725\n    var x5 : Int = add(arg50, arg51)\n    var v5 : Int = 1297\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 51\n    var arg61 : Int = 804\n    var x6 : Int = add(arg60, arg61)\n    var v6 : Int = 855\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : Int = 645\n    var arg71 : Int = 96\n    var x7 : Int = add(arg70, arg71)\n    var v7 : Int = 741\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : Int = 712\n    var arg81 : Int = 853\n    var x8 : Int = add(arg80, arg81)\n    var v8 : Int = 1565\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : Int = 223\n    var arg91 : Int = 101\n    var x9 : Int = add(arg90, arg91)\n    var v9 : Int = 324\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n    var arg100 : Int = 76\n    var arg101 : Int = 29\n    var x10 : Int = add(arg100, arg101)\n    var v10 : Int = 105\n    assert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \" + x10)\n\n    var arg110 : Int = 416\n    var arg111 : Int = 149\n    var x11 : Int = add(arg110, arg111)\n    var v11 : Int = 565\n    assert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \" + x11)\n\n    var arg120 : Int = 145\n    var arg121 : Int = 409\n    var x12 : Int = add(arg120, arg121)\n    var v12 : Int = 554\n    assert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \" + x12)\n\n    var arg130 : Int = 535\n    var arg131 : Int = 430\n    var x13 : Int = add(arg130, arg131)\n    var v13 : Int = 965\n    assert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \" + x13)\n\n    var arg140 : Int = 118\n    var arg141 : Int = 303\n    var x14 : Int = add(arg140, arg141)\n    var v14 : Int = 421\n    assert(x14 == v14, \"Exception -- test case 14 did not pass. x14 = \" + x14)\n\n    var arg150 : Int = 287\n    var arg151 : Int = 94\n    var x15 : Int = add(arg150, arg151)\n    var v15 : Int = 381\n    assert(x15 == v15, \"Exception -- test case 15 did not pass. x15 = \" + x15)\n\n    var arg160 : Int = 768\n    var arg161 : Int = 257\n    var x16 : Int = add(arg160, arg161)\n    var v16 : Int = 1025\n    assert(x16 == v16, \"Exception -- test case 16 did not pass. x16 = \" + x16)\n\n    var arg170 : Int = 421\n    var arg171 : Int = 677\n    var x17 : Int = add(arg170, arg171)\n    var v17 : Int = 1098\n    assert(x17 == v17, \"Exception -- test case 17 did not pass. x17 = \" + x17)\n\n    var arg180 : Int = 802\n    var arg181 : Int = 814\n    var x18 : Int = add(arg180, arg181)\n    var v18 : Int = 1616\n    assert(x18 == v18, \"Exception -- test case 18 did not pass. x18 = \" + x18)\n\n    var arg190 : Int = 510\n    var arg191 : Int = 922\n    var x19 : Int = add(arg190, arg191)\n    var v19 : Int = 1432\n    assert(x19 == v19, \"Exception -- test case 19 did not pass. x19 = \" + x19)\n\n    var arg200 : Int = 345\n    var arg201 : Int = 819\n    var x20 : Int = add(arg200, arg201)\n    var v20 : Int = 1164\n    assert(x20 == v20, \"Exception -- test case 20 did not pass. x20 = \" + x20)\n\n    var arg210 : Int = 895\n    var arg211 : Int = 436\n    var x21 : Int = add(arg210, arg211)\n    var v21 : Int = 1331\n    assert(x21 == v21, \"Exception -- test case 21 did not pass. x21 = \" + x21)\n\n    var arg220 : Int = 123\n    var arg221 : Int = 424\n    var x22 : Int = add(arg220, arg221)\n    var v22 : Int = 547\n    assert(x22 == v22, \"Exception -- test case 22 did not pass. x22 = \" + x22)\n\n    var arg230 : Int = 923\n    var arg231 : Int = 245\n    var x23 : Int = add(arg230, arg231)\n    var v23 : Int = 1168\n    assert(x23 == v23, \"Exception -- test case 23 did not pass. x23 = \" + x23)\n\n    var arg240 : Int = 23\n    var arg241 : Int = 438\n    var x24 : Int = add(arg240, arg241)\n    var v24 : Int = 461\n    assert(x24 == v24, \"Exception -- test case 24 did not pass. x24 = \" + x24)\n\n    var arg250 : Int = 565\n    var arg251 : Int = 133\n    var x25 : Int = add(arg250, arg251)\n    var v25 : Int = 698\n    assert(x25 == v25, \"Exception -- test case 25 did not pass. x25 = \" + x25)\n\n    var arg260 : Int = 945\n    var arg261 : Int = 925\n    var x26 : Int = add(arg260, arg261)\n    var v26 : Int = 1870\n    assert(x26 == v26, \"Exception -- test case 26 did not pass. x26 = \" + x26)\n\n    var arg270 : Int = 261\n    var arg271 : Int = 983\n    var x27 : Int = add(arg270, arg271)\n    var v27 : Int = 1244\n    assert(x27 == v27, \"Exception -- test case 27 did not pass. x27 = \" + x27)\n\n    var arg280 : Int = 139\n    var arg281 : Int = 577\n    var x28 : Int = add(arg280, arg281)\n    var v28 : Int = 716\n    assert(x28 == v28, \"Exception -- test case 28 did not pass. x28 = \" + x28)\n\n    var arg290 : Int = 763\n    var arg291 : Int = 178\n    var x29 : Int = add(arg290, arg291)\n    var v29 : Int = 941\n    assert(x29 == v29, \"Exception -- test case 29 did not pass. x29 = \" + x29)\n\n    var arg300 : Int = 147\n    var arg301 : Int = 892\n    var x30 : Int = add(arg300, arg301)\n    var v30 : Int = 1039\n    assert(x30 == v30, \"Exception -- test case 30 did not pass. x30 = \" + x30)\n\n    var arg310 : Int = 436\n    var arg311 : Int = 402\n    var x31 : Int = add(arg310, arg311)\n    var v31 : Int = 838\n    assert(x31 == v31, \"Exception -- test case 31 did not pass. x31 = \" + x31)\n\n    var arg320 : Int = 610\n    var arg321 : Int = 581\n    var x32 : Int = add(arg320, arg321)\n    var v32 : Int = 1191\n    assert(x32 == v32, \"Exception -- test case 32 did not pass. x32 = \" + x32)\n\n    var arg330 : Int = 103\n    var arg331 : Int = 416\n    var x33 : Int = add(arg330, arg331)\n    var v33 : Int = 519\n    assert(x33 == v33, \"Exception -- test case 33 did not pass. x33 = \" + x33)\n\n    var arg340 : Int = 339\n    var arg341 : Int = 990\n    var x34 : Int = add(arg340, arg341)\n    var v34 : Int = 1329\n    assert(x34 == v34, \"Exception -- test case 34 did not pass. x34 = \" + x34)\n\n    var arg350 : Int = 130\n    var arg351 : Int = 504\n    var x35 : Int = add(arg350, arg351)\n    var v35 : Int = 634\n    assert(x35 == v35, \"Exception -- test case 35 did not pass. x35 = \" + x35)\n\n    var arg360 : Int = 242\n    var arg361 : Int = 717\n    var x36 : Int = add(arg360, arg361)\n    var v36 : Int = 959\n    assert(x36 == v36, \"Exception -- test case 36 did not pass. x36 = \" + x36)\n\n    var arg370 : Int = 562\n    var arg371 : Int = 110\n    var x37 : Int = add(arg370, arg371)\n    var v37 : Int = 672\n    assert(x37 == v37, \"Exception -- test case 37 did not pass. x37 = \" + x37)\n\n    var arg380 : Int = 396\n    var arg381 : Int = 909\n    var x38 : Int = add(arg380, arg381)\n    var v38 : Int = 1305\n    assert(x38 == v38, \"Exception -- test case 38 did not pass. x38 = \" + x38)\n\n    var arg390 : Int = 887\n    var arg391 : Int = 703\n    var x39 : Int = add(arg390, arg391)\n    var v39 : Int = 1590\n    assert(x39 == v39, \"Exception -- test case 39 did not pass. x39 = \" + x39)\n\n    var arg400 : Int = 870\n    var arg401 : Int = 551\n    var x40 : Int = add(arg400, arg401)\n    var v40 : Int = 1421\n    assert(x40 == v40, \"Exception -- test case 40 did not pass. x40 = \" + x40)\n\n    var arg410 : Int = 422\n    var arg411 : Int = 391\n    var x41 : Int = add(arg410, arg411)\n    var v41 : Int = 813\n    assert(x41 == v41, \"Exception -- test case 41 did not pass. x41 = \" + x41)\n\n    var arg420 : Int = 299\n    var arg421 : Int = 505\n    var x42 : Int = add(arg420, arg421)\n    var v42 : Int = 804\n    assert(x42 == v42, \"Exception -- test case 42 did not pass. x42 = \" + x42)\n\n    var arg430 : Int = 346\n    var arg431 : Int = 56\n    var x43 : Int = add(arg430, arg431)\n    var v43 : Int = 402\n    assert(x43 == v43, \"Exception -- test case 43 did not pass. x43 = \" + x43)\n\n    var arg440 : Int = 36\n    var arg441 : Int = 706\n    var x44 : Int = add(arg440, arg441)\n    var v44 : Int = 742\n    assert(x44 == v44, \"Exception -- test case 44 did not pass. x44 = \" + x44)\n\n    var arg450 : Int = 738\n    var arg451 : Int = 411\n    var x45 : Int = add(arg450, arg451)\n    var v45 : Int = 1149\n    assert(x45 == v45, \"Exception -- test case 45 did not pass. x45 = \" + x45)\n\n    var arg460 : Int = 679\n    var arg461 : Int = 87\n    var x46 : Int = add(arg460, arg461)\n    var v46 : Int = 766\n    assert(x46 == v46, \"Exception -- test case 46 did not pass. x46 = \" + x46)\n\n    var arg470 : Int = 25\n    var arg471 : Int = 303\n    var x47 : Int = add(arg470, arg471)\n    var v47 : Int = 328\n    assert(x47 == v47, \"Exception -- test case 47 did not pass. x47 = \" + x47)\n\n    var arg480 : Int = 161\n    var arg481 : Int = 612\n    var x48 : Int = add(arg480, arg481)\n    var v48 : Int = 773\n    assert(x48 == v48, \"Exception -- test case 48 did not pass. x48 = \" + x48)\n\n    var arg490 : Int = 306\n    var arg491 : Int = 841\n    var x49 : Int = add(arg490, arg491)\n    var v49 : Int = 1147\n    assert(x49 == v49, \"Exception -- test case 49 did not pass. x49 = \" + x49)\n\n    var arg500 : Int = 973\n    var arg501 : Int = 411\n    var x50 : Int = add(arg500, arg501)\n    var v50 : Int = 1384\n    assert(x50 == v50, \"Exception -- test case 50 did not pass. x50 = \" + x50)\n\n    var arg510 : Int = 711\n    var arg511 : Int = 157\n    var x51 : Int = add(arg510, arg511)\n    var v51 : Int = 868\n    assert(x51 == v51, \"Exception -- test case 51 did not pass. x51 = \" + x51)\n\n    var arg520 : Int = 471\n    var arg521 : Int = 27\n    var x52 : Int = add(arg520, arg521)\n    var v52 : Int = 498\n    assert(x52 == v52, \"Exception -- test case 52 did not pass. x52 = \" + x52)\n\n    var arg530 : Int = 714\n    var arg531 : Int = 792\n    var x53 : Int = add(arg530, arg531)\n    var v53 : Int = 1506\n    assert(x53 == v53, \"Exception -- test case 53 did not pass. x53 = \" + x53)\n\n    var arg540 : Int = 38\n    var arg541 : Int = 206\n    var x54 : Int = add(arg540, arg541)\n    var v54 : Int = 244\n    assert(x54 == v54, \"Exception -- test case 54 did not pass. x54 = \" + x54)\n\n    var arg550 : Int = 907\n    var arg551 : Int = 343\n    var x55 : Int = add(arg550, arg551)\n    var v55 : Int = 1250\n    assert(x55 == v55, \"Exception -- test case 55 did not pass. x55 = \" + x55)\n\n    var arg560 : Int = 23\n    var arg561 : Int = 760\n    var x56 : Int = add(arg560, arg561)\n    var v56 : Int = 783\n    assert(x56 == v56, \"Exception -- test case 56 did not pass. x56 = \" + x56)\n\n    var arg570 : Int = 524\n    var arg571 : Int = 859\n    var x57 : Int = add(arg570, arg571)\n    var v57 : Int = 1383\n    assert(x57 == v57, \"Exception -- test case 57 did not pass. x57 = \" + x57)\n\n    var arg580 : Int = 30\n    var arg581 : Int = 529\n    var x58 : Int = add(arg580, arg581)\n    var v58 : Int = 559\n    assert(x58 == v58, \"Exception -- test case 58 did not pass. x58 = \" + x58)\n\n    var arg590 : Int = 341\n    var arg591 : Int = 691\n    var x59 : Int = add(arg590, arg591)\n    var v59 : Int = 1032\n    assert(x59 == v59, \"Exception -- test case 59 did not pass. x59 = \" + x59)\n\n    var arg600 : Int = 167\n    var arg601 : Int = 729\n    var x60 : Int = add(arg600, arg601)\n    var v60 : Int = 896\n    assert(x60 == v60, \"Exception -- test case 60 did not pass. x60 = \" + x60)\n\n    var arg610 : Int = 636\n    var arg611 : Int = 289\n    var x61 : Int = add(arg610, arg611)\n    var v61 : Int = 925\n    assert(x61 == v61, \"Exception -- test case 61 did not pass. x61 = \" + x61)\n\n    var arg620 : Int = 503\n    var arg621 : Int = 144\n    var x62 : Int = add(arg620, arg621)\n    var v62 : Int = 647\n    assert(x62 == v62, \"Exception -- test case 62 did not pass. x62 = \" + x62)\n\n    var arg630 : Int = 51\n    var arg631 : Int = 985\n    var x63 : Int = add(arg630, arg631)\n    var v63 : Int = 1036\n    assert(x63 == v63, \"Exception -- test case 63 did not pass. x63 = \" + x63)\n\n    var arg640 : Int = 287\n    var arg641 : Int = 149\n    var x64 : Int = add(arg640, arg641)\n    var v64 : Int = 436\n    assert(x64 == v64, \"Exception -- test case 64 did not pass. x64 = \" + x64)\n\n    var arg650 : Int = 659\n    var arg651 : Int = 75\n    var x65 : Int = add(arg650, arg651)\n    var v65 : Int = 734\n    assert(x65 == v65, \"Exception -- test case 65 did not pass. x65 = \" + x65)\n\n    var arg660 : Int = 462\n    var arg661 : Int = 797\n    var x66 : Int = add(arg660, arg661)\n    var v66 : Int = 1259\n    assert(x66 == v66, \"Exception -- test case 66 did not pass. x66 = \" + x66)\n\n    var arg670 : Int = 406\n    var arg671 : Int = 141\n    var x67 : Int = add(arg670, arg671)\n    var v67 : Int = 547\n    assert(x67 == v67, \"Exception -- test case 67 did not pass. x67 = \" + x67)\n\n    var arg680 : Int = 106\n    var arg681 : Int = 44\n    var x68 : Int = add(arg680, arg681)\n    var v68 : Int = 150\n    assert(x68 == v68, \"Exception -- test case 68 did not pass. x68 = \" + x68)\n\n    var arg690 : Int = 300\n    var arg691 : Int = 934\n    var x69 : Int = add(arg690, arg691)\n    var v69 : Int = 1234\n    assert(x69 == v69, \"Exception -- test case 69 did not pass. x69 = \" + x69)\n\n    var arg700 : Int = 471\n    var arg701 : Int = 524\n    var x70 : Int = add(arg700, arg701)\n    var v70 : Int = 995\n    assert(x70 == v70, \"Exception -- test case 70 did not pass. x70 = \" + x70)\n\n    var arg710 : Int = 122\n    var arg711 : Int = 429\n    var x71 : Int = add(arg710, arg711)\n    var v71 : Int = 551\n    assert(x71 == v71, \"Exception -- test case 71 did not pass. x71 = \" + x71)\n\n    var arg720 : Int = 735\n    var arg721 : Int = 195\n    var x72 : Int = add(arg720, arg721)\n    var v72 : Int = 930\n    assert(x72 == v72, \"Exception -- test case 72 did not pass. x72 = \" + x72)\n\n    var arg730 : Int = 335\n    var arg731 : Int = 484\n    var x73 : Int = add(arg730, arg731)\n    var v73 : Int = 819\n    assert(x73 == v73, \"Exception -- test case 73 did not pass. x73 = \" + x73)\n\n    var arg740 : Int = 28\n    var arg741 : Int = 809\n    var x74 : Int = add(arg740, arg741)\n    var v74 : Int = 837\n    assert(x74 == v74, \"Exception -- test case 74 did not pass. x74 = \" + x74)\n\n    var arg750 : Int = 430\n    var arg751 : Int = 20\n    var x75 : Int = add(arg750, arg751)\n    var v75 : Int = 450\n    assert(x75 == v75, \"Exception -- test case 75 did not pass. x75 = \" + x75)\n\n    var arg760 : Int = 916\n    var arg761 : Int = 635\n    var x76 : Int = add(arg760, arg761)\n    var v76 : Int = 1551\n    assert(x76 == v76, \"Exception -- test case 76 did not pass. x76 = \" + x76)\n\n    var arg770 : Int = 301\n    var arg771 : Int = 999\n    var x77 : Int = add(arg770, arg771)\n    var v77 : Int = 1300\n    assert(x77 == v77, \"Exception -- test case 77 did not pass. x77 = \" + x77)\n\n    var arg780 : Int = 454\n    var arg781 : Int = 466\n    var x78 : Int = add(arg780, arg781)\n    var v78 : Int = 920\n    assert(x78 == v78, \"Exception -- test case 78 did not pass. x78 = \" + x78)\n\n    var arg790 : Int = 905\n    var arg791 : Int = 259\n    var x79 : Int = add(arg790, arg791)\n    var v79 : Int = 1164\n    assert(x79 == v79, \"Exception -- test case 79 did not pass. x79 = \" + x79)\n\n    var arg800 : Int = 168\n    var arg801 : Int = 205\n    var x80 : Int = add(arg800, arg801)\n    var v80 : Int = 373\n    assert(x80 == v80, \"Exception -- test case 80 did not pass. x80 = \" + x80)\n\n    var arg810 : Int = 570\n    var arg811 : Int = 434\n    var x81 : Int = add(arg810, arg811)\n    var v81 : Int = 1004\n    assert(x81 == v81, \"Exception -- test case 81 did not pass. x81 = \" + x81)\n\n    var arg820 : Int = 64\n    var arg821 : Int = 959\n    var x82 : Int = add(arg820, arg821)\n    var v82 : Int = 1023\n    assert(x82 == v82, \"Exception -- test case 82 did not pass. x82 = \" + x82)\n\n    var arg830 : Int = 957\n    var arg831 : Int = 510\n    var x83 : Int = add(arg830, arg831)\n    var v83 : Int = 1467\n    assert(x83 == v83, \"Exception -- test case 83 did not pass. x83 = \" + x83)\n\n    var arg840 : Int = 722\n    var arg841 : Int = 598\n    var x84 : Int = add(arg840, arg841)\n    var v84 : Int = 1320\n    assert(x84 == v84, \"Exception -- test case 84 did not pass. x84 = \" + x84)\n\n    var arg850 : Int = 770\n    var arg851 : Int = 226\n    var x85 : Int = add(arg850, arg851)\n    var v85 : Int = 996\n    assert(x85 == v85, \"Exception -- test case 85 did not pass. x85 = \" + x85)\n\n    var arg860 : Int = 579\n    var arg861 : Int = 66\n    var x86 : Int = add(arg860, arg861)\n    var v86 : Int = 645\n    assert(x86 == v86, \"Exception -- test case 86 did not pass. x86 = \" + x86)\n\n    var arg870 : Int = 117\n    var arg871 : Int = 674\n    var x87 : Int = add(arg870, arg871)\n    var v87 : Int = 791\n    assert(x87 == v87, \"Exception -- test case 87 did not pass. x87 = \" + x87)\n\n    var arg880 : Int = 530\n    var arg881 : Int = 30\n    var x88 : Int = add(arg880, arg881)\n    var v88 : Int = 560\n    assert(x88 == v88, \"Exception -- test case 88 did not pass. x88 = \" + x88)\n\n    var arg890 : Int = 776\n    var arg891 : Int = 345\n    var x89 : Int = add(arg890, arg891)\n    var v89 : Int = 1121\n    assert(x89 == v89, \"Exception -- test case 89 did not pass. x89 = \" + x89)\n\n    var arg900 : Int = 327\n    var arg901 : Int = 389\n    var x90 : Int = add(arg900, arg901)\n    var v90 : Int = 716\n    assert(x90 == v90, \"Exception -- test case 90 did not pass. x90 = \" + x90)\n\n    var arg910 : Int = 596\n    var arg911 : Int = 12\n    var x91 : Int = add(arg910, arg911)\n    var v91 : Int = 608\n    assert(x91 == v91, \"Exception -- test case 91 did not pass. x91 = \" + x91)\n\n    var arg920 : Int = 599\n    var arg921 : Int = 511\n    var x92 : Int = add(arg920, arg921)\n    var v92 : Int = 1110\n    assert(x92 == v92, \"Exception -- test case 92 did not pass. x92 = \" + x92)\n\n    var arg930 : Int = 936\n    var arg931 : Int = 476\n    var x93 : Int = add(arg930, arg931)\n    var v93 : Int = 1412\n    assert(x93 == v93, \"Exception -- test case 93 did not pass. x93 = \" + x93)\n\n    var arg940 : Int = 461\n    var arg941 : Int = 14\n    var x94 : Int = add(arg940, arg941)\n    var v94 : Int = 475\n    assert(x94 == v94, \"Exception -- test case 94 did not pass. x94 = \" + x94)\n\n    var arg950 : Int = 966\n    var arg951 : Int = 157\n    var x95 : Int = add(arg950, arg951)\n    var v95 : Int = 1123\n    assert(x95 == v95, \"Exception -- test case 95 did not pass. x95 = \" + x95)\n\n    var arg960 : Int = 326\n    var arg961 : Int = 91\n    var x96 : Int = add(arg960, arg961)\n    var v96 : Int = 417\n    assert(x96 == v96, \"Exception -- test case 96 did not pass. x96 = \" + x96)\n\n    var arg970 : Int = 392\n    var arg971 : Int = 455\n    var x97 : Int = add(arg970, arg971)\n    var v97 : Int = 847\n    assert(x97 == v97, \"Exception -- test case 97 did not pass. x97 = \" + x97)\n\n    var arg980 : Int = 446\n    var arg981 : Int = 477\n    var x98 : Int = add(arg980, arg981)\n    var v98 : Int = 923\n    assert(x98 == v98, \"Exception -- test case 98 did not pass. x98 = \" + x98)\n\n    var arg990 : Int = 324\n    var arg991 : Int = 860\n    var x99 : Int = add(arg990, arg991)\n    var v99 : Int = 1184\n    assert(x99 == v99, \"Exception -- test case 99 did not pass. x99 = \" + x99)\n\n    var arg1000 : Int = 945\n    var arg1001 : Int = 85\n    var x100 : Int = add(arg1000, arg1001)\n    var v100 : Int = 1030\n    assert(x100 == v100, \"Exception -- test case 100 did not pass. x100 = \" + x100)\n\n    var arg1010 : Int = 886\n    var arg1011 : Int = 582\n    var x101 : Int = add(arg1010, arg1011)\n    var v101 : Int = 1468\n    assert(x101 == v101, \"Exception -- test case 101 did not pass. x101 = \" + x101)\n\n    var arg1020 : Int = 886\n    var arg1021 : Int = 712\n    var x102 : Int = add(arg1020, arg1021)\n    var v102 : Int = 1598\n    assert(x102 == v102, \"Exception -- test case 102 did not pass. x102 = \" + x102)\n\n    var arg1030 : Int = 842\n    var arg1031 : Int = 953\n    var x103 : Int = add(arg1030, arg1031)\n    var v103 : Int = 1795\n    assert(x103 == v103, \"Exception -- test case 103 did not pass. x103 = \" + x103)\n\n\n}\n", "description": "Tel twee getallen x en y bij elkaar op.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/20", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Controleer of twee woorden dezelfde karakters hebben.\n     * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n     * True\n     * >>> same_chars('abcd', 'dddddddabc')\n     * True\n     * >>> same_chars('dddddddabc', 'abcd')\n     * True\n     * >>> same_chars('eabcd', 'dddddddabc')\n     * False\n     * >>> same_chars('abcd', 'dddddddabce')\n     * False\n     * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n     * False\n     *\n     */\n    def sameChars(s0 : String, s1 : String) : Boolean = {\n", "entry_point": "sameChars", "test": "\n\n    var arg00 : String = \"\"\"eabcdzzzz\"\"\"\n    var arg01 : String = \"\"\"dddzzzzzzzddeddabc\"\"\"\n    var x0 : Boolean = sameChars(arg00, arg01)\n    var v0 : Boolean = true\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"abcd\"\"\"\n    var arg11 : String = \"\"\"dddddddabc\"\"\"\n    var x1 : Boolean = sameChars(arg10, arg11)\n    var v1 : Boolean = true\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"dddddddabc\"\"\"\n    var arg21 : String = \"\"\"abcd\"\"\"\n    var x2 : Boolean = sameChars(arg20, arg21)\n    var v2 : Boolean = true\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"eabcd\"\"\"\n    var arg31 : String = \"\"\"dddddddabc\"\"\"\n    var x3 : Boolean = sameChars(arg30, arg31)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"abcd\"\"\"\n    var arg41 : String = \"\"\"dddddddabcf\"\"\"\n    var x4 : Boolean = sameChars(arg40, arg41)\n    var v4 : Boolean = false\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"eabcdzzzz\"\"\"\n    var arg51 : String = \"\"\"dddzzzzzzzddddabc\"\"\"\n    var x5 : Boolean = sameChars(arg50, arg51)\n    var v5 : Boolean = false\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"aabb\"\"\"\n    var arg61 : String = \"\"\"aaccc\"\"\"\n    var x6 : Boolean = sameChars(arg60, arg61)\n    var v6 : Boolean = false\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "Controleer of twee woorden dezelfde karakters hebben.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/21", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Geef het n-de Fibonacci-getal terug.\n     * >>> fib(10)\n     * 55\n     * >>> fib(1)\n     * 1\n     * >>> fib(8)\n     * 21\n     *\n     */\n    def fib(n : Int) : Int = {\n", "entry_point": "fib", "test": "\n\n    var arg00 : Int = 10\n    var x0 : Int = fib(arg00)\n    var v0 : Int = 55\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 1\n    var x1 : Int = fib(arg10)\n    var v1 : Int = 1\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 8\n    var x2 : Int = fib(arg20)\n    var v2 : Int = 21\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 11\n    var x3 : Int = fib(arg30)\n    var v3 : Int = 89\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 12\n    var x4 : Int = fib(arg40)\n    var v4 : Int = 144\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "Geef het n-de Fibonacci-getal terug.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/22", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Geef gesorteerde unieke gemeenschappelijke elementen terug voor twee lijsten.\n     * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n     * [1, 5, 653]\n     * >>> common([5, 3, 2, 8], [3, 2])\n     * [2, 3]\n\n     *\n     */\n    def common(l1 : List[Int], l2 : List[Any]) : List[Any] = {\n", "entry_point": "common", "test": "\n\n    var arg00 : List[Int] = List(1, 4, 3, 34, 653, 2, 5)\n    var arg01 : List[Any] = List(5, 7, 1, 5, 9, 653, 121)\n    var x0 : List[Any] = common(arg00, arg01)\n    var v0 : List[Any] = List(1, 5, 653)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(5, 3, 2, 8)\n    var arg11 : List[Any] = List(3, 2)\n    var x1 : List[Any] = common(arg10, arg11)\n    var v1 : List[Any] = List(2, 3)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(4, 3, 2, 8)\n    var arg21 : List[Any] = List(3, 2, 4)\n    var x2 : List[Any] = common(arg20, arg21)\n    var v2 : List[Any] = List(2, 3, 4)\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(4, 3, 2, 8)\n    var arg31 : List[Any] = List()\n    var x3 : List[Any] = common(arg30, arg31)\n    var v3 : List[Any] = List()\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n\n}\n", "description": "Geef gesorteerde unieke gemeenschappelijke elementen terug voor twee lijsten.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/23", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Geef de grootste priemfactor van n terug. Ga ervan uit dat n > 1 is en geen priemgetal is.\n     * >>> largest_prime_factor(13195)\n     * 29\n     * >>> largest_prime_factor(2048)\n     * 2\n     *\n     */\n    def largestPrimeFactor(n : Int) : Int = {\n", "entry_point": "largestPrimeFactor", "test": "\n\n    var arg00 : Int = 15\n    var x0 : Int = largestPrimeFactor(arg00)\n    var v0 : Int = 5\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 27\n    var x1 : Int = largestPrimeFactor(arg10)\n    var v1 : Int = 3\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 63\n    var x2 : Int = largestPrimeFactor(arg20)\n    var v2 : Int = 7\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 330\n    var x3 : Int = largestPrimeFactor(arg30)\n    var v3 : Int = 11\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 13195\n    var x4 : Int = largestPrimeFactor(arg40)\n    var v4 : Int = 29\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "Geef de grootste priemfactor van n terug. Ga ervan uit dat n > 1 is en geen priemgetal is.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/24", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * sum_to_n is een functie die getallen optelt van 1 tot n.\n     * >>> sum_to_n(30)\n     * 465\n     * >>> sum_to_n(100)\n     * 5050\n     * >>> sum_to_n(5)\n     * 15\n     * >>> sum_to_n(10)\n     * 55\n     * >>> sum_to_n(1)\n     * 1\n     *\n     */\n    def sumToN(n : Int) : Int = {\n", "entry_point": "sumToN", "test": "\n\n    var arg00 : Int = 1\n    var x0 : Int = sumToN(arg00)\n    var v0 : Int = 1\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 6\n    var x1 : Int = sumToN(arg10)\n    var v1 : Int = 21\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 11\n    var x2 : Int = sumToN(arg20)\n    var v2 : Int = 66\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 30\n    var x3 : Int = sumToN(arg30)\n    var v3 : Int = 465\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 100\n    var x4 : Int = sumToN(arg40)\n    var v4 : Int = 5050\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "sum_to_n is een functie die getallen optelt van 1 tot n.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/25", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * xs vertegenwoordigen de coëfficiënten van een polynoom.\n     *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     *      Geef de afgeleide van deze polynoom terug in dezelfde vorm.\n     * >>> derivative([3, 1, 2, 4, 5])\n     * [1, 4, 12, 20]\n     * >>> derivative([1, 2, 3])\n     * [2, 6]\n     *\n     */\n    def derivative(xs : List[Int]) : List[Any] = {\n", "entry_point": "derivative", "test": "\n\n    var arg00 : List[Int] = List(3, 1, 2, 4, 5)\n    var x0 : List[Any] = derivative(arg00)\n    var v0 : List[Any] = List(1, 4, 12, 20)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(1, 2, 3)\n    var x1 : List[Any] = derivative(arg10)\n    var v1 : List[Any] = List(2, 6)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(3, 2, 1)\n    var x2 : List[Any] = derivative(arg20)\n    var v2 : List[Any] = List(2, 2)\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(3, 2, 1, 0, 4)\n    var x3 : List[Any] = derivative(arg30)\n    var v3 : List[Any] = List(2, 2, 0, 16)\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Int] = List(1)\n    var x4 : List[Any] = derivative(arg40)\n    var v4 : List[Any] = List()\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "xs vertegenwoordigen de coëfficiënten van een polynoom.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Geef de afgeleide van deze polynoom terug in dezelfde vorm.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/26", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * De FibFib-reeks is een reeks getallen vergelijkbaar met de Fibbonacci-reeks die als volgt wordt gedefinieerd:\n     *     fibfib(0) == 0\n     *     fibfib(1) == 0\n     *     fibfib(2) == 1\n     *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     *     Schrijf alstublieft een functie om het n-de element van de FibFib-reeks efficiënt te berekenen.\n     * >>> fibfib(1)\n     * 0\n     * >>> fibfib(5)\n     * 4\n     * >>> fibfib(8)\n     * 24\n     *\n     */\n    def fibfib(n : Int) : Int = {\n", "entry_point": "fibfib", "test": "\n\n    var arg00 : Int = 2\n    var x0 : Int = fibfib(arg00)\n    var v0 : Int = 1\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 1\n    var x1 : Int = fibfib(arg10)\n    var v1 : Int = 0\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 5\n    var x2 : Int = fibfib(arg20)\n    var v2 : Int = 4\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 8\n    var x3 : Int = fibfib(arg30)\n    var v3 : Int = 24\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 10\n    var x4 : Int = fibfib(arg40)\n    var v4 : Int = 81\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 12\n    var x5 : Int = fibfib(arg50)\n    var v5 : Int = 274\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 14\n    var x6 : Int = fibfib(arg60)\n    var v6 : Int = 927\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "De FibFib-reeks is een reeks getallen vergelijkbaar met de Fibbonacci-reeks die als volgt wordt gedefinieerd:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Schrijf alstublieft een functie om het n-de element van de FibFib-reeks efficiënt te berekenen.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/27", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Schrijf een functie genaamd vowels_count die een string als input neemt die een woord voorstelt en het aantal klinkers in de string teruggeeft. Klinkers in dit geval zijn 'a', 'e', 'i', 'o', 'u'. Hierbij is 'y' ook een klinker, maar alleen wanneer het aan het einde van het gegeven woord staat.\n     * \n     * Voorbeeld:\n     * >>> vowels_count(\"abcde\")\n     * 2\n     * >>> vowels_count(\"ACEDY\")\n     * 3\n     *\n     */\n    def vowelsCount(s : String) : Int = {\n", "entry_point": "vowelsCount", "test": "\n\n    var arg00 : String = \"\"\"abcde\"\"\"\n    var x0 : Int = vowelsCount(arg00)\n    var v0 : Int = 2\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"Alone\"\"\"\n    var x1 : Int = vowelsCount(arg10)\n    var v1 : Int = 3\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"key\"\"\"\n    var x2 : Int = vowelsCount(arg20)\n    var v2 : Int = 2\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"bye\"\"\"\n    var x3 : Int = vowelsCount(arg30)\n    var v3 : Int = 1\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"keY\"\"\"\n    var x4 : Int = vowelsCount(arg40)\n    var v4 : Int = 2\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"bYe\"\"\"\n    var x5 : Int = vowelsCount(arg50)\n    var v5 : Int = 1\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"ACEDY\"\"\"\n    var x6 : Int = vowelsCount(arg60)\n    var v6 : Int = 3\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "Schrijf een functie genaamd vowels_count die een string als input neemt die een woord voorstelt en het aantal klinkers in de string teruggeeft. Klinkers in dit geval zijn 'a', 'e', 'i', 'o', 'u'. Hierbij is 'y' ook een klinker, maar alleen wanneer het aan het einde van het gegeven woord staat.\n\nVoorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/28", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Je krijgt een niet-lege lijst van positieve integers. Geef de grootste integer terug die groter is dan nul en een frequentie heeft die groter is dan of gelijk is aan de waarde van de integer zelf. De frequentie van een integer is het aantal keren dat het voorkomt in de lijst. Als er geen dergelijke waarde bestaat, geef dan -1 terug. Voorbeelden:\n     * \n     *     search([4, 1, 2, 2, 3, 1]) == 2\n     *     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n     *     search([5, 5, 4, 4, 4]) == -1\n     *\n     */\n    def search(lst : List[Int]) : Int = {\n", "entry_point": "search", "test": "\n\n    var arg00 : List[Int] = List(5, 5, 5, 5, 1)\n    var x0 : Int = search(arg00)\n    var v0 : Int = 1\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(4, 1, 4, 1, 4, 4)\n    var x1 : Int = search(arg10)\n    var v1 : Int = 4\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(3, 3)\n    var x2 : Int = search(arg20)\n    var v2 : Int = -1\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(8, 8, 8, 8, 8, 8, 8, 8)\n    var x3 : Int = search(arg30)\n    var v3 : Int = 8\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Int] = List(2, 3, 3, 2, 2)\n    var x4 : Int = search(arg40)\n    var v4 : Int = 2\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Int] = List(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1)\n    var x5 : Int = search(arg50)\n    var v5 : Int = 1\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : List[Int] = List(3, 2, 8, 2)\n    var x6 : Int = search(arg60)\n    var v6 : Int = 2\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : List[Int] = List(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10)\n    var x7 : Int = search(arg70)\n    var v7 : Int = 1\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : List[Int] = List(8, 8, 3, 6, 5, 6, 4)\n    var x8 : Int = search(arg80)\n    var v8 : Int = -1\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : List[Int] = List(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9)\n    var x9 : Int = search(arg90)\n    var v9 : Int = 1\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n    var arg100 : List[Int] = List(1, 9, 10, 1, 3)\n    var x10 : Int = search(arg100)\n    var v10 : Int = 1\n    assert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \" + x10)\n\n    var arg110 : List[Int] = List(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10)\n    var x11 : Int = search(arg110)\n    var v11 : Int = 5\n    assert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \" + x11)\n\n    var arg120 : List[Int] = List(1)\n    var x12 : Int = search(arg120)\n    var v12 : Int = 1\n    assert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \" + x12)\n\n    var arg130 : List[Int] = List(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5)\n    var x13 : Int = search(arg130)\n    var v13 : Int = 4\n    assert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \" + x13)\n\n    var arg140 : List[Int] = List(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10)\n    var x14 : Int = search(arg140)\n    var v14 : Int = 2\n    assert(x14 == v14, \"Exception -- test case 14 did not pass. x14 = \" + x14)\n\n    var arg150 : List[Int] = List(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3)\n    var x15 : Int = search(arg150)\n    var v15 : Int = 1\n    assert(x15 == v15, \"Exception -- test case 15 did not pass. x15 = \" + x15)\n\n    var arg160 : List[Int] = List(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4)\n    var x16 : Int = search(arg160)\n    var v16 : Int = 4\n    assert(x16 == v16, \"Exception -- test case 16 did not pass. x16 = \" + x16)\n\n    var arg170 : List[Int] = List(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7)\n    var x17 : Int = search(arg170)\n    var v17 : Int = 4\n    assert(x17 == v17, \"Exception -- test case 17 did not pass. x17 = \" + x17)\n\n    var arg180 : List[Int] = List(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1)\n    var x18 : Int = search(arg180)\n    var v18 : Int = 2\n    assert(x18 == v18, \"Exception -- test case 18 did not pass. x18 = \" + x18)\n\n    var arg190 : List[Int] = List(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8)\n    var x19 : Int = search(arg190)\n    var v19 : Int = -1\n    assert(x19 == v19, \"Exception -- test case 19 did not pass. x19 = \" + x19)\n\n    var arg200 : List[Int] = List(10)\n    var x20 : Int = search(arg200)\n    var v20 : Int = -1\n    assert(x20 == v20, \"Exception -- test case 20 did not pass. x20 = \" + x20)\n\n    var arg210 : List[Int] = List(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2)\n    var x21 : Int = search(arg210)\n    var v21 : Int = 2\n    assert(x21 == v21, \"Exception -- test case 21 did not pass. x21 = \" + x21)\n\n    var arg220 : List[Int] = List(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8)\n    var x22 : Int = search(arg220)\n    var v22 : Int = 1\n    assert(x22 == v22, \"Exception -- test case 22 did not pass. x22 = \" + x22)\n\n    var arg230 : List[Int] = List(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6)\n    var x23 : Int = search(arg230)\n    var v23 : Int = 1\n    assert(x23 == v23, \"Exception -- test case 23 did not pass. x23 = \" + x23)\n\n    var arg240 : List[Int] = List(3, 10, 10, 9, 2)\n    var x24 : Int = search(arg240)\n    var v24 : Int = -1\n    assert(x24 == v24, \"Exception -- test case 24 did not pass. x24 = \" + x24)\n\n\n}\n", "description": "Je krijgt een niet-lege lijst van positieve integers. Geef de grootste integer terug die groter is dan nul en een frequentie heeft die groter is dan of gelijk is aan de waarde van de integer zelf. De frequentie van een integer is het aantal keren dat het voorkomt in de lijst. Als er geen dergelijke waarde bestaat, geef dan -1 terug. Voorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/29", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Gegeven de lengtes van de drie zijden van een driehoek. Geef het oppervlak van de driehoek terug afgerond op 2 decimalen als de drie zijden een geldige driehoek vormen. Anders geef -1 terug. Drie zijden vormen een geldige driehoek wanneer de som van elke twee zijden groter is dan de derde zijde. Voorbeeld:\n     * \n     * triangle_area(3, 4, 5) == 6.00\n     * triangle_area(1, 2, 10) == -1\n     *\n     */\n    def triangleArea(a : Int, b : Int, c : Int) : Double = {\n", "entry_point": "triangleArea", "test": "\n\n    var arg00 : Int = 3\n    var arg01 : Int = 4\n    var arg02 : Int = 5\n    var x0 : Double = triangleArea(arg00, arg01, arg02)\n    var v0 : Double = 6.0\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 1\n    var arg11 : Int = 2\n    var arg12 : Int = 10\n    var x1 : Double = triangleArea(arg10, arg11, arg12)\n    var v1 : Double = -1\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 4\n    var arg21 : Int = 8\n    var arg22 : Int = 5\n    var x2 : Double = triangleArea(arg20, arg21, arg22)\n    var v2 : Double = 8.18\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 2\n    var arg31 : Int = 2\n    var arg32 : Int = 2\n    var x3 : Double = triangleArea(arg30, arg31, arg32)\n    var v3 : Double = 1.73\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 1\n    var arg41 : Int = 2\n    var arg42 : Int = 3\n    var x4 : Double = triangleArea(arg40, arg41, arg42)\n    var v4 : Double = -1\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 10\n    var arg51 : Int = 5\n    var arg52 : Int = 7\n    var x5 : Double = triangleArea(arg50, arg51, arg52)\n    var v5 : Double = 16.25\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 2\n    var arg61 : Int = 6\n    var arg62 : Int = 3\n    var x6 : Double = triangleArea(arg60, arg61, arg62)\n    var v6 : Double = -1\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : Int = 1\n    var arg71 : Int = 1\n    var arg72 : Int = 1\n    var x7 : Double = triangleArea(arg70, arg71, arg72)\n    var v7 : Double = 0.43\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : Int = 2\n    var arg81 : Int = 2\n    var arg82 : Int = 10\n    var x8 : Double = triangleArea(arg80, arg81, arg82)\n    var v8 : Double = -1\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n\n}\n", "description": "Gegeven de lengtes van de drie zijden van een driehoek. Geef het oppervlak van de driehoek terug afgerond op 2 decimalen als de drie zijden een geldige driehoek vormen. Anders geef -1 terug. Drie zijden vormen een geldige driehoek wanneer de som van elke twee zijden groter is dan de derde zijde. Voorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/30", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Schrijf een functie die True teruggeeft als het object q zal vliegen, en False andersom.\n     * Het object q zal vliegen als het in balans is (het is een palindromische lijst) en de som van de elementen kleiner is dan of gelijk aan het maximale mogelijke gewicht w.\n     * \n     * Voorbeeld:\n     * will_it_fly([1, 2], 5) ➞ False\n     * # 1+2 is minder dan het maximale mogelijke gewicht, maar het is niet in balans.\n     * \n     * will_it_fly([3, 2, 3], 1) ➞ False\n     * # het is in balans, maar 3+2+3 is meer dan het maximale mogelijke gewicht.\n     * \n     * will_it_fly([3, 2, 3], 9) ➞ True\n     * # 3+2+3 is minder dan het maximale mogelijke gewicht, en het is in balans.\n     * \n     * will_it_fly([3], 5) ➞ True\n     * # 3 is minder dan het maximale mogelijke gewicht, en het is in balans.\n     * \n     *\n     */\n    def willItFly(q : List[Int], w : Int) : Boolean = {\n", "entry_point": "willItFly", "test": "\n\n    var arg00 : List[Int] = List(3, 2, 3)\n    var arg01 : Int = 9\n    var x0 : Boolean = willItFly(arg00, arg01)\n    var v0 : Boolean = true\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(1, 2)\n    var arg11 : Int = 5\n    var x1 : Boolean = willItFly(arg10, arg11)\n    var v1 : Boolean = false\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(3)\n    var arg21 : Int = 5\n    var x2 : Boolean = willItFly(arg20, arg21)\n    var v2 : Boolean = true\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(3, 2, 3)\n    var arg31 : Int = 1\n    var x3 : Boolean = willItFly(arg30, arg31)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Int] = List(1, 2, 3)\n    var arg41 : Int = 6\n    var x4 : Boolean = willItFly(arg40, arg41)\n    var v4 : Boolean = false\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Int] = List(5)\n    var arg51 : Int = 5\n    var x5 : Boolean = willItFly(arg50, arg51)\n    var v5 : Boolean = true\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n\n}\n", "description": "Schrijf een functie die True teruggeeft als het object q zal vliegen, en False andersom.\nHet object q zal vliegen als het in balans is (het is een palindromische lijst) en de som van de elementen kleiner is dan of gelijk aan het maximale mogelijke gewicht w.\n\nVoorbeeld:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 is minder dan het maximale mogelijke gewicht, maar het is niet in balans.\n\nwill_it_fly([3, 2, 3], 1) ➞ False\n# het is in balans, maar 3+2+3 is meer dan het maximale mogelijke gewicht.\n\nwill_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 is minder dan het maximale mogelijke gewicht, en het is in balans.\n\nwill_it_fly([3], 5) ➞ True\n# 3 is minder dan het maximale mogelijke gewicht, en het is in balans.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/31", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Schrijf een functie die waar teruggeeft als het gegeven getal het product is van 3 priemgetallen en anders onwaar. Wetende dat (a) kleiner is dan 100. Voorbeeld:\n     * \n     * is_multiply_prime(30) == True\n     * 30 = 2 * 3 * 5\n     *\n     */\n    def isMultiplyPrime(a : Int) : Boolean = {\n", "entry_point": "isMultiplyPrime", "test": "\n\n    var arg00 : Int = 5\n    var x0 : Boolean = isMultiplyPrime(arg00)\n    var v0 : Boolean = false\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 30\n    var x1 : Boolean = isMultiplyPrime(arg10)\n    var v1 : Boolean = true\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 8\n    var x2 : Boolean = isMultiplyPrime(arg20)\n    var v2 : Boolean = true\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 10\n    var x3 : Boolean = isMultiplyPrime(arg30)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 125\n    var x4 : Boolean = isMultiplyPrime(arg40)\n    var v4 : Boolean = true\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 105\n    var x5 : Boolean = isMultiplyPrime(arg50)\n    var v5 : Boolean = true\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 126\n    var x6 : Boolean = isMultiplyPrime(arg60)\n    var v6 : Boolean = false\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : Int = 729\n    var x7 : Boolean = isMultiplyPrime(arg70)\n    var v7 : Boolean = false\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : Int = 891\n    var x8 : Boolean = isMultiplyPrime(arg80)\n    var v8 : Boolean = false\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : Int = 1001\n    var x9 : Boolean = isMultiplyPrime(arg90)\n    var v9 : Boolean = true\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n\n}\n", "description": "Schrijf een functie die waar teruggeeft als het gegeven getal het product is van 3 priemgetallen en anders onwaar. Wetende dat (a) kleiner is dan 100. Voorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/32", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Je krijgt een getal in decimale vorm en jouw taak is om het om te zetten naar binaire vorm. De functie moet een string retourneren, waarbij elk karakter een binair getal vertegenwoordigt. Elk karakter in de string zal '0' of '1' zijn.\n     * \n     * Er zullen een paar extra karakters 'db' aan het begin en aan het einde van de string zijn. De extra karakters zijn er om te helpen met de opmaak.\n     * \n     * Voorbeelden:\n     * \n     * decimal_to_binary(15)   # returns \"db1111db\"\n     * decimal_to_binary(32)   # returns \"db100000db\"\n     *\n     */\n    def decimalToBinary(decimal : Int) : String = {\n", "entry_point": "decimalToBinary", "test": "\n\n    var arg00 : Int = 0\n    var x0 : String = decimalToBinary(arg00)\n    var v0 : String = \"\"\"db0db\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 32\n    var x1 : String = decimalToBinary(arg10)\n    var v1 : String = \"\"\"db100000db\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 103\n    var x2 : String = decimalToBinary(arg20)\n    var v2 : String = \"\"\"db1100111db\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 15\n    var x3 : String = decimalToBinary(arg30)\n    var v3 : String = \"\"\"db1111db\"\"\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n\n}\n", "description": "Je krijgt een getal in decimale vorm en jouw taak is om het om te zetten naar binaire vorm. De functie moet een string retourneren, waarbij elk karakter een binair getal vertegenwoordigt. Elk karakter in de string zal '0' of '1' zijn.\n\nEr zullen een paar extra karakters 'db' aan het begin en aan het einde van de string zijn. De extra karakters zijn er om te helpen met de opmaak.\n\nVoorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/33", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Je krijgt een string s.\n     * Je taak is om te controleren of de string gelukkig is of niet.\n     * Een string is gelukkig als de lengte ten minste 3 is en elke 3 opeenvolgende letters verschillend zijn.\n     * Bijvoorbeeld:\n     * \n     * is_happy(a) => False\n     * is_happy(aa) => False\n     * is_happy(abcd) => True\n     * is_happy(aabb) => False\n     * is_happy(adb) => True\n     * is_happy(xyy) => False\n     *\n     */\n    def isHappy(s : String) : Boolean = {\n", "entry_point": "isHappy", "test": "\n\n    var arg00 : String = \"\"\"a\"\"\"\n    var x0 : Boolean = isHappy(arg00)\n    var v0 : Boolean = false\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"aa\"\"\"\n    var x1 : Boolean = isHappy(arg10)\n    var v1 : Boolean = false\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"abcd\"\"\"\n    var x2 : Boolean = isHappy(arg20)\n    var v2 : Boolean = true\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"aabb\"\"\"\n    var x3 : Boolean = isHappy(arg30)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"adb\"\"\"\n    var x4 : Boolean = isHappy(arg40)\n    var v4 : Boolean = true\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"xyy\"\"\"\n    var x5 : Boolean = isHappy(arg50)\n    var v5 : Boolean = false\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"iopaxpoi\"\"\"\n    var x6 : Boolean = isHappy(arg60)\n    var v6 : Boolean = true\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : String = \"\"\"iopaxioi\"\"\"\n    var x7 : Boolean = isHappy(arg70)\n    var v7 : Boolean = false\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n\n}\n", "description": "Je krijgt een string s.\nJe taak is om te controleren of de string gelukkig is of niet.\nEen string is gelukkig als de lengte ten minste 3 is en elke 3 opeenvolgende letters verschillend zijn.\nBijvoorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/34", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Het is de laatste week van het semester en de leraar moet de cijfers aan de studenten geven. De leraar heeft haar eigen algoritme voor het beoordelen gemaakt. Het enige probleem is dat ze de code die ze voor het beoordelen heeft gebruikt, is kwijtgeraakt. Ze heeft je een lijst met GPAs voor sommige studenten gegeven en je moet een functie schrijven die een lijst met lettercijfers kan produceren met behulp van de volgende tabel:\n     *              GPA       |    Letter grade\n     *               4.0                A+\n     *             > 3.7                A \n     *             > 3.3                A- \n     *             > 3.0                B+\n     *             > 2.7                B \n     *             > 2.3                B-\n     *             > 2.0                C+\n     *             > 1.7                C\n     *             > 1.3                C-\n     *             > 1.0                D+ \n     *             > 0.7                D \n     *             > 0.0                D-\n     *               0.0                E\n     *     \n     * \n     *     Voorbeeld:\n     * \n     * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n     *\n     */\n    def numericalLetterGrade(grades : List[Double]) : List[String] = {\n", "entry_point": "numericalLetterGrade", "test": "\n\n    var arg00 : List[Double] = List(4.0, 3, 1.7, 2, 3.5)\n    var x0 : List[String] = numericalLetterGrade(arg00)\n    var v0 : List[String] = List(\"\"\"A+\"\"\", \"\"\"B\"\"\", \"\"\"C-\"\"\", \"\"\"C\"\"\", \"\"\"A-\"\"\")\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Double] = List(1.2)\n    var x1 : List[String] = numericalLetterGrade(arg10)\n    var v1 : List[String] = List(\"\"\"D+\"\"\")\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Double] = List(0.5)\n    var x2 : List[String] = numericalLetterGrade(arg20)\n    var v2 : List[String] = List(\"\"\"D-\"\"\")\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Double] = List(0.0)\n    var x3 : List[String] = numericalLetterGrade(arg30)\n    var v3 : List[String] = List(\"\"\"E\"\"\")\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Double] = List(1, 0.3, 1.5, 2.8, 3.3)\n    var x4 : List[String] = numericalLetterGrade(arg40)\n    var v4 : List[String] = List(\"\"\"D\"\"\", \"\"\"D-\"\"\", \"\"\"C-\"\"\", \"\"\"B\"\"\", \"\"\"B+\"\"\")\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Double] = List(0, 0.7)\n    var x5 : List[String] = numericalLetterGrade(arg50)\n    var v5 : List[String] = List(\"\"\"E\"\"\", \"\"\"D-\"\"\")\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n\n}\n", "description": "Het is de laatste week van het semester en de leraar moet de cijfers aan de studenten geven. De leraar heeft haar eigen algoritme voor het beoordelen gemaakt. Het enige probleem is dat ze de code die ze voor het beoordelen heeft gebruikt, is kwijtgeraakt. Ze heeft je een lijst met GPAs voor sommige studenten gegeven en je moet een functie schrijven die een lijst met lettercijfers kan produceren met behulp van de volgende tabel:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Voorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/35", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Schrijf een functie die een string als argument neemt en True teruggeeft als de lengte van de string een priemgetal is, anders False.\n     * Voorbeelden\n     * \n     * prime_length('Hello') == True\n     * prime_length('abcdcba') == True\n     * prime_length('kittens') == True\n     * prime_length('orange') == False\n     *\n     */\n    def primeLength(string : String) : Boolean = {\n", "entry_point": "primeLength", "test": "\n\n    var arg00 : String = \"\"\"Hello\"\"\"\n    var x0 : Boolean = primeLength(arg00)\n    var v0 : Boolean = true\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"abcdcba\"\"\"\n    var x1 : Boolean = primeLength(arg10)\n    var v1 : Boolean = true\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"kittens\"\"\"\n    var x2 : Boolean = primeLength(arg20)\n    var v2 : Boolean = true\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"orange\"\"\"\n    var x3 : Boolean = primeLength(arg30)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"wow\"\"\"\n    var x4 : Boolean = primeLength(arg40)\n    var v4 : Boolean = true\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"world\"\"\"\n    var x5 : Boolean = primeLength(arg50)\n    var v5 : Boolean = true\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"MadaM\"\"\"\n    var x6 : Boolean = primeLength(arg60)\n    var v6 : Boolean = true\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : String = \"\"\"Wow\"\"\"\n    var x7 : Boolean = primeLength(arg70)\n    var v7 : Boolean = true\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : String = \"\"\"\"\"\"\n    var x8 : Boolean = primeLength(arg80)\n    var v8 : Boolean = false\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : String = \"\"\"HI\"\"\"\n    var x9 : Boolean = primeLength(arg90)\n    var v9 : Boolean = true\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n    var arg100 : String = \"\"\"go\"\"\"\n    var x10 : Boolean = primeLength(arg100)\n    var v10 : Boolean = true\n    assert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \" + x10)\n\n    var arg110 : String = \"\"\"gogo\"\"\"\n    var x11 : Boolean = primeLength(arg110)\n    var v11 : Boolean = false\n    assert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \" + x11)\n\n    var arg120 : String = \"\"\"aaaaaaaaaaaaaaa\"\"\"\n    var x12 : Boolean = primeLength(arg120)\n    var v12 : Boolean = false\n    assert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \" + x12)\n\n    var arg130 : String = \"\"\"Madam\"\"\"\n    var x13 : Boolean = primeLength(arg130)\n    var v13 : Boolean = true\n    assert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \" + x13)\n\n    var arg140 : String = \"\"\"M\"\"\"\n    var x14 : Boolean = primeLength(arg140)\n    var v14 : Boolean = false\n    assert(x14 == v14, \"Exception -- test case 14 did not pass. x14 = \" + x14)\n\n    var arg150 : String = \"\"\"0\"\"\"\n    var x15 : Boolean = primeLength(arg150)\n    var v15 : Boolean = false\n    assert(x15 == v15, \"Exception -- test case 15 did not pass. x15 = \" + x15)\n\n\n}\n", "description": "Schrijf een functie die een string als argument neemt en True teruggeeft als de lengte van de string een priemgetal is, anders False.\nVoorbeelden", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/36", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Gegeven een positief geheel getal N, retourneer de totale som van zijn cijfers in binair formaat.\n     * \n     *     Voorbeeld\n     *         Voor N = 1000, zal de som van de cijfers 1 zijn en de output moet \"1\" zijn.\n     *         Voor N = 150, zal de som van de cijfers 6 zijn en de output moet \"110\" zijn.\n     *         Voor N = 147, zal de som van de cijfers 12 zijn en de output moet \"1100\" zijn.\n     *     \n     *     Variabelen:\n     *         @N integer\n     *              Beperkingen: 0 ≤ N ≤ 10000.\n     *     Output:\n     *          een string van binair getal\n     * \n     *\n     */\n    def solve(n : Int) : String = {\n", "entry_point": "solve", "test": "\n\n    var arg00 : Int = 1000\n    var x0 : String = solve(arg00)\n    var v0 : String = \"\"\"1\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 150\n    var x1 : String = solve(arg10)\n    var v1 : String = \"\"\"110\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 147\n    var x2 : String = solve(arg20)\n    var v2 : String = \"\"\"1100\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 333\n    var x3 : String = solve(arg30)\n    var v3 : String = \"\"\"1001\"\"\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 963\n    var x4 : String = solve(arg40)\n    var v4 : String = \"\"\"10010\"\"\"\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "Gegeven een positief geheel getal N, retourneer de totale som van zijn cijfers in binair formaat.\n\n    Voorbeeld\n        Voor N = 1000, zal de som van de cijfers 1 zijn en de output moet \"1\" zijn.\n        Voor N = 150, zal de som van de cijfers 6 zijn en de output moet \"110\" zijn.\n        Voor N = 147, zal de som van de cijfers 12 zijn en de output moet \"1100\" zijn.\n    \n    Variabelen:\n        @N integer\n             Beperkingen: 0 ≤ N ≤ 10000.\n    Output:\n         een string van binair getal", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/37", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Je krijgt een 2-dimensionale dataset als geneste lijsten, vergelijkbaar met een matrix, maar in tegenstelling tot matrices kan elke rij een ander aantal kolommen bevatten. Gegeven lst en een geheel getal x, zoek je de gehele getallen x in de lijst en retourneer je een lijst van tuples, [(x1, y1), (x2, y2) ...] zodat elke tuple een coördinaat is - (rij, kolommen), beginnend bij 0. Sorteer de coördinaten aanvankelijk op rijen in oplopende volgorde. Sorteer ook de coördinaten van de rij op kolommen in aflopende volgorde.\n     * \n     * Voorbeelden:\n     * \n     * get_row([\n     *   [1,2,3,4,5,6],\n     *   [1,2,3,4,1,6],\n     *   [1,2,3,4,5,1]\n     * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n     * get_row([], 1) == []\n     * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n     *\n     */\n    def getRow(lst : List[Any], x : Int) : List[Any] = {\n", "entry_point": "getRow", "test": "\n\n    var arg00 : List[Any] = List()\n    var arg01 : Int = 1\n    var x0 : List[Any] = getRow(arg00, arg01)\n    var v0 : List[Any] = List()\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Any] = List(List(1))\n    var arg11 : Int = 2\n    var x1 : List[Any] = getRow(arg10, arg11)\n    var v1 : List[Any] = List()\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Any] = List(List(), List(1), List(1, 2, 3))\n    var arg21 : Int = 3\n    var x2 : List[Any] = getRow(arg20, arg21)\n    var v2 : List[Any] = List(List(2, 2))\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n\n}\n", "description": "Je krijgt een 2-dimensionale dataset als geneste lijsten, vergelijkbaar met een matrix, maar in tegenstelling tot matrices kan elke rij een ander aantal kolommen bevatten. Gegeven lst en een geheel getal x, zoek je de gehele getallen x in de lijst en retourneer je een lijst van tuples, [(x1, y1), (x2, y2) ...] zodat elke tuple een coördinaat is - (rij, kolommen), beginnend bij 0. Sorteer de coördinaten aanvankelijk op rijen in oplopende volgorde. Sorteer ook de coördinaten van de rij op kolommen in aflopende volgorde.\n\nVoorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/38", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Je krijgt een lijst van integers.\n     * Schrijf een functie next_smallest() die het op één na kleinste element van de lijst teruggeeft.\n     * Geef null terug als er geen dergelijk element is.\n     * next_smallest([1, 2, 3, 4, 5]) == 2\n     * next_smallest([5, 1, 4, 3, 2]) == 2\n     * next_smallest([]) == None\n     * next_smallest([1, 1]) == None\n     *\n     */\n    def nextSmallest(lst : List[Any]) : Any = {\n", "entry_point": "nextSmallest", "test": "\n\n    var arg00 : List[Any] = List(1, 2, 3, 4, 5)\n    var x0 : Any = nextSmallest(arg00)\n    var v0 : Any = 2\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Any] = List(5, 1, 4, 3, 2)\n    var x1 : Any = nextSmallest(arg10)\n    var v1 : Any = 2\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Any] = List()\n    var x2 : Any = nextSmallest(arg20)\n    var v2 : Any = \"none\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Any] = List(1, 1)\n    var x3 : Any = nextSmallest(arg30)\n    var v3 : Any = \"none\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Any] = List(1, 1, 1, 1, 0)\n    var x4 : Any = nextSmallest(arg40)\n    var v4 : Any = 1\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Any] = List(1, 1)\n    var x5 : Any = nextSmallest(arg50)\n    var v5 : Any = \"none\"\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : List[Any] = List(-35, 34, 12, -45)\n    var x6 : Any = nextSmallest(arg60)\n    var v6 : Any = -35\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "Je krijgt een lijst van integers.\nSchrijf een functie next_smallest() die het op één na kleinste element van de lijst teruggeeft.\nGeef null terug als er geen dergelijk element is.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/39", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Je krijgt een reeks woorden en jouw taak is om het aantal saaiheden te tellen. Een saaiheid is een zin die begint met het woord \"Ik\". Zinnen worden begrensd door '.', '?' of '!'.\n     * \n     * Bijvoorbeeld:\n     * >>> is_bored(\"Hello world\")\n     * 0\n     * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n     * 1\n     *\n     */\n    def isBored(s : String) : Int = {\n", "entry_point": "isBored", "test": "\n\n    var arg00 : String = \"\"\"Hello world\"\"\"\n    var x0 : Int = isBored(arg00)\n    var v0 : Int = 0\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"Is the sky blue?\"\"\"\n    var x1 : Int = isBored(arg10)\n    var v1 : Int = 0\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"I love It !\"\"\"\n    var x2 : Int = isBored(arg20)\n    var v2 : Int = 1\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"bIt\"\"\"\n    var x3 : Int = isBored(arg30)\n    var v3 : Int = 0\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"I feel good today. I will be productive. will kill It\"\"\"\n    var x4 : Int = isBored(arg40)\n    var v4 : Int = 2\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"You and I are going for a walk\"\"\"\n    var x5 : Int = isBored(arg50)\n    var v5 : Int = 0\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n\n}\n", "description": "Je krijgt een reeks woorden en jouw taak is om het aantal saaiheden te tellen. Een saaiheid is een zin die begint met het woord \"Ik\". Zinnen worden begrensd door '.', '?' of '!'.\n\nBijvoorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/40", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Je krijgt een lijst met gehele getallen.\n     *     Je moet het grootste priemgetal vinden en de som van zijn cijfers teruggeven.\n     * \n     *     Voorbeelden:\n     * \n     * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n     * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n     * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n     * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n     * For lst = [0,81,12,3,1,21] the output should be 3\n     * For lst = [0,8,1,2,1,7] the output should be 7\n     *\n     */\n    def skjkasdkd(lst : List[Int]) : Int = {\n", "entry_point": "skjkasdkd", "test": "\n\n    var arg00 : List[Int] = List(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3)\n    var x0 : Int = skjkasdkd(arg00)\n    var v0 : Int = 10\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1)\n    var x1 : Int = skjkasdkd(arg10)\n    var v1 : Int = 25\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3)\n    var x2 : Int = skjkasdkd(arg20)\n    var v2 : Int = 13\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6)\n    var x3 : Int = skjkasdkd(arg30)\n    var v3 : Int = 11\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Int] = List(0, 81, 12, 3, 1, 21)\n    var x4 : Int = skjkasdkd(arg40)\n    var v4 : Int = 3\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Int] = List(0, 8, 1, 2, 1, 7)\n    var x5 : Int = skjkasdkd(arg50)\n    var v5 : Int = 7\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : List[Int] = List(8191)\n    var x6 : Int = skjkasdkd(arg60)\n    var v6 : Int = 19\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : List[Int] = List(8191, 123456, 127, 7)\n    var x7 : Int = skjkasdkd(arg70)\n    var v7 : Int = 19\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : List[Int] = List(127, 97, 8192)\n    var x8 : Int = skjkasdkd(arg80)\n    var v8 : Int = 10\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n\n}\n", "description": "Je krijgt een lijst met gehele getallen.\n    Je moet het grootste priemgetal vinden en de som van zijn cijfers teruggeven.\n\n    Voorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/41", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Gegeven een woordenboek, retourneer True als alle sleutels strings zijn in kleine letters of alle sleutels strings zijn in hoofdletters, anders retourneer False. De functie moet False retourneren als het gegeven woordenboek leeg is. Voorbeelden:\n     * \n     * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n     * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n     * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n     * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n     * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n     *\n     */\n    def checkDictCase(dict : Map[Any, Any]) : Boolean = {\n", "entry_point": "checkDictCase", "test": "\n\n    var arg00 : Map[Any, Any] = Map(\"\"\"p\"\"\" -> \"\"\"pineapple\"\"\", \"\"\"b\"\"\" -> \"\"\"banana\"\"\")\n    var x0 : Boolean = checkDictCase(arg00)\n    var v0 : Boolean = true\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Map[Any, Any] = Map(\"\"\"p\"\"\" -> \"\"\"pineapple\"\"\", \"\"\"A\"\"\" -> \"\"\"banana\"\"\", \"\"\"B\"\"\" -> \"\"\"banana\"\"\")\n    var x1 : Boolean = checkDictCase(arg10)\n    var v1 : Boolean = false\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Map[Any, Any] = Map(\"\"\"p\"\"\" -> \"\"\"pineapple\"\"\", 5 -> \"\"\"banana\"\"\", \"\"\"a\"\"\" -> \"\"\"apple\"\"\")\n    var x2 : Boolean = checkDictCase(arg20)\n    var v2 : Boolean = false\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Map[Any, Any] = Map(\"\"\"Name\"\"\" -> \"\"\"John\"\"\", \"\"\"Age\"\"\" -> \"\"\"36\"\"\", \"\"\"City\"\"\" -> \"\"\"Houston\"\"\")\n    var x3 : Boolean = checkDictCase(arg30)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Map[Any, Any] = Map(\"\"\"STATE\"\"\" -> \"\"\"NC\"\"\", \"\"\"ZIP\"\"\" -> \"\"\"12345\"\"\")\n    var x4 : Boolean = checkDictCase(arg40)\n    var v4 : Boolean = true\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Map[Any, Any] = Map(\"\"\"fruit\"\"\" -> \"\"\"Orange\"\"\", \"\"\"taste\"\"\" -> \"\"\"Sweet\"\"\")\n    var x5 : Boolean = checkDictCase(arg50)\n    var v5 : Boolean = true\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Map[Any, Any] = Map()\n    var x6 : Boolean = checkDictCase(arg60)\n    var v6 : Boolean = false\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "Gegeven een woordenboek, retourneer True als alle sleutels strings zijn in kleine letters of alle sleutels strings zijn in hoofdletters, anders retourneer False. De functie moet False retourneren als het gegeven woordenboek leeg is. Voorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/42", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Maak een functie die een waarde (string) vertegenwoordigt als een getal aanneemt en het dichtstbijzijnde gehele getal teruggeeft. Als het getal even ver van twee gehele getallen af ligt, rond dan af vanaf nul.\n     * \n     * Voorbeelden\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n\n     * Note:\n     * Rounding away from zero means that if the given number is equidistant\n     * from two integers, the one you should return is the one that is the\n     * farthest from zero. For example closest_integer(\"14.5\") should\n     * return 15 and closest_integer(\"-14.5\") should return -15.\n     *\n     */\n    def closestInteger(value : String) : Int = {\n", "entry_point": "closestInteger", "test": "\n\n    var arg00 : String = \"\"\"10\"\"\"\n    var x0 : Int = closestInteger(arg00)\n    var v0 : Int = 10\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"14.5\"\"\"\n    var x1 : Int = closestInteger(arg10)\n    var v1 : Int = 15\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"-15.5\"\"\"\n    var x2 : Int = closestInteger(arg20)\n    var v2 : Int = -16\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"15.3\"\"\"\n    var x3 : Int = closestInteger(arg30)\n    var v3 : Int = 15\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"0\"\"\"\n    var x4 : Int = closestInteger(arg40)\n    var v4 : Int = 0\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "Maak een functie die een waarde (string) vertegenwoordigt als een getal aanneemt en het dichtstbijzijnde gehele getal teruggeeft. Als het getal even ver van twee gehele getallen af ligt, rond dan af vanaf nul.\n\nVoorbeelden", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/43", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Gegeven een positief geheel getal n, moet je een stapel van n niveaus stenen maken.\n     *     Het eerste niveau heeft n stenen.\n     *     Het aantal stenen in het volgende niveau is:\n     *         - het volgende oneven getal als n oneven is.\n     *         - het volgende even getal als n even is.\n     *     Geef het aantal stenen in elk niveau terug in een lijst, waarbij het element op index\n     *     i het aantal stenen in niveau (i+1) vertegenwoordigt.\n     * \n     *     Voorbeelden:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     *\n     */\n    def makeAPile(n : Int) : List[Int] = {\n", "entry_point": "makeAPile", "test": "\n\n    var arg00 : Int = 3\n    var x0 : List[Int] = makeAPile(arg00)\n    var v0 : List[Int] = List(3, 5, 7)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 4\n    var x1 : List[Int] = makeAPile(arg10)\n    var v1 : List[Int] = List(4, 6, 8, 10)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 5\n    var x2 : List[Int] = makeAPile(arg20)\n    var v2 : List[Int] = List(5, 7, 9, 11, 13)\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 6\n    var x3 : List[Int] = makeAPile(arg30)\n    var v3 : List[Int] = List(6, 8, 10, 12, 14, 16)\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 8\n    var x4 : List[Int] = makeAPile(arg40)\n    var v4 : List[Int] = List(8, 10, 12, 14, 16, 18, 20, 22)\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "Gegeven een positief geheel getal n, moet je een stapel van n niveaus stenen maken.\n    Het eerste niveau heeft n stenen.\n    Het aantal stenen in het volgende niveau is:\n        - het volgende oneven getal als n oneven is.\n        - het volgende even getal als n even is.\n    Geef het aantal stenen in elk niveau terug in een lijst, waarbij het element op index\n    i het aantal stenen in niveau (i+1) vertegenwoordigt.\n\n    Voorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/44", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Je krijgt een string van woorden gescheiden door komma's of spaties. Je taak is om de string in woorden te splitsen en een array van de woorden terug te geven.\n     * \n     * Bijvoorbeeld:\n     * \n     * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n     * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n     *\n     */\n    def wordsString(s : String) : List[Any] = {\n", "entry_point": "wordsString", "test": "\n\n    var arg00 : String = \"\"\"Hi, my name is John\"\"\"\n    var x0 : List[Any] = wordsString(arg00)\n    var v0 : List[Any] = List(\"\"\"Hi\"\"\", \"\"\"my\"\"\", \"\"\"name\"\"\", \"\"\"is\"\"\", \"\"\"John\"\"\")\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"One, two, three, four, five, six\"\"\"\n    var x1 : List[Any] = wordsString(arg10)\n    var v1 : List[Any] = List(\"\"\"One\"\"\", \"\"\"two\"\"\", \"\"\"three\"\"\", \"\"\"four\"\"\", \"\"\"five\"\"\", \"\"\"six\"\"\")\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"Hi, my name\"\"\"\n    var x2 : List[Any] = wordsString(arg20)\n    var v2 : List[Any] = List(\"\"\"Hi\"\"\", \"\"\"my\"\"\", \"\"\"name\"\"\")\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"One,, two, three, four, five, six,\"\"\"\n    var x3 : List[Any] = wordsString(arg30)\n    var v3 : List[Any] = List(\"\"\"One\"\"\", \"\"\"two\"\"\", \"\"\"three\"\"\", \"\"\"four\"\"\", \"\"\"five\"\"\", \"\"\"six\"\"\")\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"\"\"\"\n    var x4 : List[Any] = wordsString(arg40)\n    var v4 : List[Any] = List()\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"ahmed     , gamal\"\"\"\n    var x5 : List[Any] = wordsString(arg50)\n    var v5 : List[Any] = List(\"\"\"ahmed\"\"\", \"\"\"gamal\"\"\")\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n\n}\n", "description": "Je krijgt een string van woorden gescheiden door komma's of spaties. Je taak is om de string in woorden te splitsen en een array van de woorden terug te geven.\n\nBijvoorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/45", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Deze functie neemt twee positieve getallen x en y en retourneert het grootste even gehele getal dat in het bereik [x, y] ligt. Als er geen dergelijk getal is, moet de functie -1 retourneren.\n     * \n     * Bijvoorbeeld:\n     * \n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     *\n     */\n    def chooseNum(x : Int, y : Int) : Int = {\n", "entry_point": "chooseNum", "test": "\n\n    var arg00 : Int = 12\n    var arg01 : Int = 15\n    var x0 : Int = chooseNum(arg00, arg01)\n    var v0 : Int = 14\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 13\n    var arg11 : Int = 12\n    var x1 : Int = chooseNum(arg10, arg11)\n    var v1 : Int = -1\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 33\n    var arg21 : Int = 12354\n    var x2 : Int = chooseNum(arg20, arg21)\n    var v2 : Int = 12354\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 5234\n    var arg31 : Int = 5233\n    var x3 : Int = chooseNum(arg30, arg31)\n    var v3 : Int = -1\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 6\n    var arg41 : Int = 29\n    var x4 : Int = chooseNum(arg40, arg41)\n    var v4 : Int = 28\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 27\n    var arg51 : Int = 10\n    var x5 : Int = chooseNum(arg50, arg51)\n    var v5 : Int = -1\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 7\n    var arg61 : Int = 7\n    var x6 : Int = chooseNum(arg60, arg61)\n    var v6 : Int = -1\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : Int = 546\n    var arg71 : Int = 546\n    var x7 : Int = chooseNum(arg70, arg71)\n    var v7 : Int = 546\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n\n}\n", "description": "Deze functie neemt twee positieve getallen x en y en retourneert het grootste even gehele getal dat in het bereik [x, y] ligt. Als er geen dergelijk getal is, moet de functie -1 retourneren.\n\nBijvoorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/46", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Je krijgt twee positieve gehele getallen n en m, en jouw taak is om het gemiddelde te berekenen van de gehele getallen van n tot en met m (inclusief n en m). Rond het antwoord af naar het dichtstbijzijnde gehele getal en converteer dat naar binair. Als n groter is dan m, geef dan -1 terug. Voorbeeld:\n     * \n     * rounded_avg(1, 5) => \"0b11\"\n     * rounded_avg(7, 5) => -1\n     * rounded_avg(10, 20) => \"0b1111\"\n     * rounded_avg(20, 33) => \"0b11010\"\n     *\n     */\n    def roundedAvg(n : Int, m : Int) : Any = {\n", "entry_point": "roundedAvg", "test": "\n\n    var arg00 : Int = 1\n    var arg01 : Int = 5\n    var x0 : Any = roundedAvg(arg00, arg01)\n    var v0 : Any = \"\"\"0b11\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 7\n    var arg11 : Int = 13\n    var x1 : Any = roundedAvg(arg10, arg11)\n    var v1 : Any = \"\"\"0b1010\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 964\n    var arg21 : Int = 977\n    var x2 : Any = roundedAvg(arg20, arg21)\n    var v2 : Any = \"\"\"0b1111001010\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 996\n    var arg31 : Int = 997\n    var x3 : Any = roundedAvg(arg30, arg31)\n    var v3 : Any = \"\"\"0b1111100100\"\"\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 560\n    var arg41 : Int = 851\n    var x4 : Any = roundedAvg(arg40, arg41)\n    var v4 : Any = \"\"\"0b1011000010\"\"\"\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 185\n    var arg51 : Int = 546\n    var x5 : Any = roundedAvg(arg50, arg51)\n    var v5 : Any = \"\"\"0b101101110\"\"\"\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 362\n    var arg61 : Int = 496\n    var x6 : Any = roundedAvg(arg60, arg61)\n    var v6 : Any = \"\"\"0b110101101\"\"\"\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : Int = 350\n    var arg71 : Int = 902\n    var x7 : Any = roundedAvg(arg70, arg71)\n    var v7 : Any = \"\"\"0b1001110010\"\"\"\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : Int = 197\n    var arg81 : Int = 233\n    var x8 : Any = roundedAvg(arg80, arg81)\n    var v8 : Any = \"\"\"0b11010111\"\"\"\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : Int = 7\n    var arg91 : Int = 5\n    var x9 : Any = roundedAvg(arg90, arg91)\n    var v9 : Any = -1\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n    var arg100 : Int = 5\n    var arg101 : Int = 1\n    var x10 : Any = roundedAvg(arg100, arg101)\n    var v10 : Any = -1\n    assert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \" + x10)\n\n    var arg110 : Int = 5\n    var arg111 : Int = 5\n    var x11 : Any = roundedAvg(arg110, arg111)\n    var v11 : Any = \"\"\"0b101\"\"\"\n    assert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \" + x11)\n\n\n}\n", "description": "Je krijgt twee positieve gehele getallen n en m, en jouw taak is om het gemiddelde te berekenen van de gehele getallen van n tot en met m (inclusief n en m). Rond het antwoord af naar het dichtstbijzijnde gehele getal en converteer dat naar binair. Als n groter is dan m, geef dan -1 terug. Voorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/47", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Implementeer de functie f die n als parameter neemt en een lijst van grootte n retourneert, waarbij de waarde van het element op index i de faculteit van i is als i even is, of anders de som van getallen van 1 tot i. i begint bij 1. De faculteit van i is de vermenigvuldiging van de getallen van 1 tot i (1 * 2 * ... * i). Voorbeeld:\n     * \n     * f(5) == [1, 2, 6, 24, 15]\n     *\n     */\n    def f(n : Int) : List[Int] = {\n", "entry_point": "f", "test": "\n\n    var arg00 : Int = 5\n    var x0 : List[Int] = f(arg00)\n    var v0 : List[Int] = List(1, 2, 6, 24, 15)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 7\n    var x1 : List[Int] = f(arg10)\n    var v1 : List[Int] = List(1, 2, 6, 24, 15, 720, 28)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 1\n    var x2 : List[Int] = f(arg20)\n    var v2 : List[Int] = List(1)\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 3\n    var x3 : List[Int] = f(arg30)\n    var v3 : List[Int] = List(1, 2, 6)\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n\n}\n", "description": "Implementeer de functie f die n als parameter neemt en een lijst van grootte n retourneert, waarbij de waarde van het element op index i de faculteit van i is als i even is, of anders de som van getallen van 1 tot i. i begint bij 1. De faculteit van i is de vermenigvuldiging van de getallen van 1 tot i (1 * 2 * ... * i). Voorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/48", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Gegeven een positief geheel getal n, retourneer een tuple met het aantal even en oneven gehele palindromen die vallen binnen het bereik (1, n), inclusief.\n     * \n     * Voorbeeld 1:\n     * \n     *     Input: 3\n     *     Output: (1, 2)\n     *     Uitleg:\n     *     Gehele palindromen zijn 1, 2, 3. Eén daarvan is even en twee daarvan zijn oneven.\n     * \n     * Voorbeeld 2:\n     * \n     *     Input: 12\n     *     Output: (4, 6)\n     *     Uitleg:\n     *     Gehele palindromen zijn 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier daarvan zijn even en zes daarvan zijn oneven.\n     * \n     * Opmerking:\n     *     1. 1 <= n <= 10^3\n     *     2. De geretourneerde tuple heeft respectievelijk het aantal even en oneven gehele palindromen.\n     * \n     *\n     */\n    def evenOddPalindrome(n : Int) : List[Int] = {\n", "entry_point": "evenOddPalindrome", "test": "\n\n    var arg00 : Int = 123\n    var x0 : List[Int] = evenOddPalindrome(arg00)\n    var v0 : List[Int] = List(8, 13)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 12\n    var x1 : List[Int] = evenOddPalindrome(arg10)\n    var v1 : List[Int] = List(4, 6)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 3\n    var x2 : List[Int] = evenOddPalindrome(arg20)\n    var v2 : List[Int] = List(1, 2)\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 63\n    var x3 : List[Int] = evenOddPalindrome(arg30)\n    var v3 : List[Int] = List(6, 8)\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 25\n    var x4 : List[Int] = evenOddPalindrome(arg40)\n    var v4 : List[Int] = List(5, 6)\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 19\n    var x5 : List[Int] = evenOddPalindrome(arg50)\n    var v5 : List[Int] = List(4, 6)\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 9\n    var x6 : List[Int] = evenOddPalindrome(arg60)\n    var v6 : List[Int] = List(4, 5)\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : Int = 1\n    var x7 : List[Int] = evenOddPalindrome(arg70)\n    var v7 : List[Int] = List(0, 1)\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n\n}\n", "description": "Gegeven een positief geheel getal n, retourneer een tuple met het aantal even en oneven gehele palindromen die vallen binnen het bereik (1, n), inclusief.\n\nVoorbeeld 1:\n\n    Input: 3\n    Output: (1, 2)\n    Uitleg:\n    Gehele palindromen zijn 1, 2, 3. Eén daarvan is even en twee daarvan zijn oneven.\n\nVoorbeeld 2:\n\n    Input: 12\n    Output: (4, 6)\n    Uitleg:\n    Gehele palindromen zijn 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier daarvan zijn even en zes daarvan zijn oneven.\n\nOpmerking:\n    1. 1 <= n <= 10^3\n    2. De geretourneerde tuple heeft respectievelijk het aantal even en oneven gehele palindromen.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/49", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * We hebben een array 'arr' van N integers arr[1], arr[2], ..., arr[N]. De getallen in de array zullen willekeurig geordend zijn. Jouw taak is om te bepalen of het mogelijk is om een array gesorteerd in niet-afnemende volgorde te krijgen door de volgende operatie uit te voeren op de gegeven array:\n     * \n     * Je mag een rechtsverschuivingsoperatie zo vaak uitvoeren als je wilt.\n     * \n     * Eén rechtsverschuivingsoperatie betekent dat alle elementen van de array één positie naar rechts worden verschoven. Het laatste element van de array wordt verplaatst naar de startpositie in de array, d.w.z. index 0.\n     * \n     * Als het mogelijk is om de gesorteerde array te verkrijgen door de bovenstaande operatie uit te voeren, retourneer dan True, anders retourneer False. Als de gegeven array leeg is, retourneer dan True.\n     * \n     * Opmerking: De gegeven lijst heeft gegarandeerd unieke elementen.\n     * \n     * Bijvoorbeeld:\n     * \n     * move_one_ball([3, 4, 5, 1, 2])==>True\n     * Uitleg: Door 2 rechtsverschuivingsoperaties uit te voeren, kan niet-afnemende volgorde worden bereikt voor de gegeven array.\n     * \n     * move_one_ball([3, 5, 4, 1, 2])==>False\n     * Uitleg: Het is niet mogelijk om niet-afnemende volgorde te krijgen voor de gegeven array door een willekeurig aantal rechtsverschuivingsoperaties uit te voeren.\n     * \n     *             \n     *\n     */\n    def moveOneBall(arr : List[Any]) : Boolean = {\n", "entry_point": "moveOneBall", "test": "\n\n    var arg00 : List[Any] = List(3, 4, 5, 1, 2)\n    var x0 : Boolean = moveOneBall(arg00)\n    var v0 : Boolean = true\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Any] = List(3, 5, 10, 1, 2)\n    var x1 : Boolean = moveOneBall(arg10)\n    var v1 : Boolean = true\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Any] = List(4, 3, 1, 2)\n    var x2 : Boolean = moveOneBall(arg20)\n    var v2 : Boolean = false\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Any] = List(3, 5, 4, 1, 2)\n    var x3 : Boolean = moveOneBall(arg30)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Any] = List()\n    var x4 : Boolean = moveOneBall(arg40)\n    var v4 : Boolean = true\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "We hebben een array 'arr' van N integers arr[1], arr[2], ..., arr[N]. De getallen in de array zullen willekeurig geordend zijn. Jouw taak is om te bepalen of het mogelijk is om een array gesorteerd in niet-afnemende volgorde te krijgen door de volgende operatie uit te voeren op de gegeven array:\n\nJe mag een rechtsverschuivingsoperatie zo vaak uitvoeren als je wilt.\n\nEén rechtsverschuivingsoperatie betekent dat alle elementen van de array één positie naar rechts worden verschoven. Het laatste element van de array wordt verplaatst naar de startpositie in de array, d.w.z. index 0.\n\nAls het mogelijk is om de gesorteerde array te verkrijgen door de bovenstaande operatie uit te voeren, retourneer dan True, anders retourneer False. Als de gegeven array leeg is, retourneer dan True.\n\nOpmerking: De gegeven lijst heeft gegarandeerd unieke elementen.\n\nBijvoorbeeld:\n\nmove_one_ball([3, 4, 5, 1, 2])==>True\nUitleg: Door 2 rechtsverschuivingsoperaties uit te voeren, kan niet-afnemende volgorde worden bereikt voor de gegeven array.\n\nmove_one_ball([3, 5, 4, 1, 2])==>False\nUitleg: Het is niet mogelijk om niet-afnemende volgorde te krijgen voor de gegeven array door een willekeurig aantal rechtsverschuivingsoperaties uit te voeren.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/50", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * In dit probleem implementeer je een functie die twee lijsten van getallen neemt en bepaalt of het mogelijk is om een uitwisseling van elementen tussen hen uit te voeren om lst1 een lijst van alleen even getallen te maken. Er is geen limiet aan het aantal uitgewisselde elementen tussen lst1 en lst2. Als het mogelijk is om elementen uit te wisselen tussen lst1 en lst2 om alle elementen van lst1 even te maken, retourneer dan \"JA\". Anders retourneer \"NEE\". Bijvoorbeeld: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"JA\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NEE\" Er wordt aangenomen dat de invoerlijsten niet leeg zullen zijn.\n     * \n     *\n     */\n    def exchange(lst1 : List[Int], lst2 : List[Int]) : String = {\n", "entry_point": "exchange", "test": "\n\n    var arg00 : List[Int] = List(1, 2, 3, 4)\n    var arg01 : List[Int] = List(1, 2, 3, 4)\n    var x0 : String = exchange(arg00, arg01)\n    var v0 : String = \"\"\"YES\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(1, 2, 3, 4)\n    var arg11 : List[Int] = List(1, 5, 3, 4)\n    var x1 : String = exchange(arg10, arg11)\n    var v1 : String = \"\"\"NO\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(1, 2, 3, 4)\n    var arg21 : List[Int] = List(2, 1, 4, 3)\n    var x2 : String = exchange(arg20, arg21)\n    var v2 : String = \"\"\"YES\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(5, 7, 3)\n    var arg31 : List[Int] = List(2, 6, 4)\n    var x3 : String = exchange(arg30, arg31)\n    var v3 : String = \"\"\"YES\"\"\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Int] = List(5, 7, 3)\n    var arg41 : List[Int] = List(2, 6, 3)\n    var x4 : String = exchange(arg40, arg41)\n    var v4 : String = \"\"\"NO\"\"\"\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Int] = List(3, 2, 6, 1, 8, 9)\n    var arg51 : List[Int] = List(3, 5, 5, 1, 1, 1)\n    var x5 : String = exchange(arg50, arg51)\n    var v5 : String = \"\"\"NO\"\"\"\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : List[Int] = List(100, 200)\n    var arg61 : List[Int] = List(200, 200)\n    var x6 : String = exchange(arg60, arg61)\n    var v6 : String = \"\"\"YES\"\"\"\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "In dit probleem implementeer je een functie die twee lijsten van getallen neemt en bepaalt of het mogelijk is om een uitwisseling van elementen tussen hen uit te voeren om lst1 een lijst van alleen even getallen te maken. Er is geen limiet aan het aantal uitgewisselde elementen tussen lst1 en lst2. Als het mogelijk is om elementen uit te wisselen tussen lst1 en lst2 om alle elementen van lst1 even te maken, retourneer dan \"JA\". Anders retourneer \"NEE\". Bijvoorbeeld: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"JA\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NEE\" Er wordt aangenomen dat de invoerlijsten niet leeg zullen zijn.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/51", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Taak\n     *     We krijgen twee strings s en c, je moet alle karakters in s verwijderen die gelijk zijn aan een karakter in c\n     *     en vervolgens controleren of de resulterende string een palindroom is.\n     *     Een string wordt een palindroom genoemd als het achterstevoren hetzelfde leest als vooruit.\n     *     Je moet een tuple retourneren met de resulterende string en True/False voor de controle.\n     *     Voorbeeld\n     *     Voor s = \"abcde\", c = \"ae\", moet het resultaat zijn ('bcd',False)\n     *     Voor s = \"abcdef\", c = \"b\" moet het resultaat zijn ('acdef',False)\n     *     Voor s = \"abcdedcba\", c = \"ab\", moet het resultaat zijn ('cdedc',True)\n     * \n     *\n     */\n    def reverseDelete(s : String, c : String) : List[Any] = {\n", "entry_point": "reverseDelete", "test": "\n\n    var arg00 : String = \"\"\"abcde\"\"\"\n    var arg01 : String = \"\"\"ae\"\"\"\n    var x0 : List[Any] = reverseDelete(arg00, arg01)\n    var v0 : List[Any] = List(\"\"\"bcd\"\"\", false)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"abcdef\"\"\"\n    var arg11 : String = \"\"\"b\"\"\"\n    var x1 : List[Any] = reverseDelete(arg10, arg11)\n    var v1 : List[Any] = List(\"\"\"acdef\"\"\", false)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"abcdedcba\"\"\"\n    var arg21 : String = \"\"\"ab\"\"\"\n    var x2 : List[Any] = reverseDelete(arg20, arg21)\n    var v2 : List[Any] = List(\"\"\"cdedc\"\"\", true)\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"dwik\"\"\"\n    var arg31 : String = \"\"\"w\"\"\"\n    var x3 : List[Any] = reverseDelete(arg30, arg31)\n    var v3 : List[Any] = List(\"\"\"dik\"\"\", false)\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"a\"\"\"\n    var arg41 : String = \"\"\"a\"\"\"\n    var x4 : List[Any] = reverseDelete(arg40, arg41)\n    var v4 : List[Any] = List(\"\"\"\"\"\", true)\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"abcdedcba\"\"\"\n    var arg51 : String = \"\"\"\"\"\"\n    var x5 : List[Any] = reverseDelete(arg50, arg51)\n    var v5 : List[Any] = List(\"\"\"abcdedcba\"\"\", true)\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"abcdedcba\"\"\"\n    var arg61 : String = \"\"\"v\"\"\"\n    var x6 : List[Any] = reverseDelete(arg60, arg61)\n    var v6 : List[Any] = List(\"\"\"abcdedcba\"\"\", true)\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : String = \"\"\"vabba\"\"\"\n    var arg71 : String = \"\"\"v\"\"\"\n    var x7 : List[Any] = reverseDelete(arg70, arg71)\n    var v7 : List[Any] = List(\"\"\"abba\"\"\", true)\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : String = \"\"\"mamma\"\"\"\n    var arg81 : String = \"\"\"mia\"\"\"\n    var x8 : List[Any] = reverseDelete(arg80, arg81)\n    var v8 : List[Any] = List(\"\"\"\"\"\", true)\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n\n}\n", "description": "Taak\n    We krijgen twee strings s en c, je moet alle karakters in s verwijderen die gelijk zijn aan een karakter in c\n    en vervolgens controleren of de resulterende string een palindroom is.\n    Een string wordt een palindroom genoemd als het achterstevoren hetzelfde leest als vooruit.\n    Je moet een tuple retourneren met de resulterende string en True/False voor de controle.\n    Voorbeeld\n    Voor s = \"abcde\", c = \"ae\", moet het resultaat zijn ('bcd',False)\n    Voor s = \"abcdef\", c = \"b\" moet het resultaat zijn ('acdef',False)\n    Voor s = \"abcdedcba\", c = \"ab\", moet het resultaat zijn ('cdedc',True)", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/52", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Je krijgt een rechthoekig raster van putten. Elke rij vertegenwoordigt een enkele put, en elke 1 in een rij vertegenwoordigt een enkele eenheid water. Elke put heeft een bijbehorende emmer die kan worden gebruikt om water eruit te halen, en alle emmers hebben dezelfde capaciteit. Jouw taak is om de emmers te gebruiken om de putten leeg te maken. Geef als output het aantal keren dat je de emmers moet laten zakken.\n     * \n     * Voorbeeld 1:\n     *     Input:\n     *         grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n     *         emmer_capaciteit: 1\n     *     Output: 6\n     * \n     * Voorbeeld 2:\n     *     Input:\n     *         grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n     *         emmer_capaciteit: 2\n     *     Output: 5\n     * \n     * Voorbeeld 3:\n     *     Input:\n     *         grid: [[0,0,0], [0,0,0]]\n     *         emmer_capaciteit: 5\n     *     Output: 0\n     * \n     * Beperkingen:\n     *     * alle putten hebben dezelfde lengte\n     *     * 1 <= grid.lengte <= 10^2\n     *     * 1 <= grid[:,1].lengte <= 10^2\n     *     * grid[i][j] -> 0 | 1\n     *     * 1 <= capaciteit <= 10\n     * \n     *\n     */\n    def maxFill(grid : List[List[Int]], capacity : Int) : Int = {\n", "entry_point": "maxFill", "test": "\n\n    var arg00 : List[List[Int]] = List(List(0, 0, 1, 0), List(0, 1, 0, 0), List(1, 1, 1, 1))\n    var arg01 : Int = 1\n    var x0 : Int = maxFill(arg00, arg01)\n    var v0 : Int = 6\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[List[Int]] = List(List(0, 0, 1, 1), List(0, 0, 0, 0), List(1, 1, 1, 1), List(0, 1, 1, 1))\n    var arg11 : Int = 2\n    var x1 : Int = maxFill(arg10, arg11)\n    var v1 : Int = 5\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[List[Int]] = List(List(0, 0, 0), List(0, 0, 0))\n    var arg21 : Int = 5\n    var x2 : Int = maxFill(arg20, arg21)\n    var v2 : Int = 0\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[List[Int]] = List(List(1, 1, 1, 1), List(1, 1, 1, 1))\n    var arg31 : Int = 2\n    var x3 : Int = maxFill(arg30, arg31)\n    var v3 : Int = 4\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[List[Int]] = List(List(1, 1, 1, 1), List(1, 1, 1, 1))\n    var arg41 : Int = 9\n    var x4 : Int = maxFill(arg40, arg41)\n    var v4 : Int = 2\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "Je krijgt een rechthoekig raster van putten. Elke rij vertegenwoordigt een enkele put, en elke 1 in een rij vertegenwoordigt een enkele eenheid water. Elke put heeft een bijbehorende emmer die kan worden gebruikt om water eruit te halen, en alle emmers hebben dezelfde capaciteit. Jouw taak is om de emmers te gebruiken om de putten leeg te maken. Geef als output het aantal keren dat je de emmers moet laten zakken.\n\nVoorbeeld 1:\n    Input:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        emmer_capaciteit: 1\n    Output: 6\n\nVoorbeeld 2:\n    Input:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        emmer_capaciteit: 2\n    Output: 5\n\nVoorbeeld 3:\n    Input:\n        grid: [[0,0,0], [0,0,0]]\n        emmer_capaciteit: 5\n    Output: 0\n\nBeperkingen:\n    * alle putten hebben dezelfde lengte\n    * 1 <= grid.lengte <= 10^2\n    * 1 <= grid[:,1].lengte <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= capaciteit <= 10", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/53", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Gegeven een string s en een natuurlijk getal n, is het jouw taak om een functie te implementeren die een lijst teruggeeft van alle woorden uit string s die precies n medeklinkers bevatten, in de volgorde waarin deze woorden voorkomen in string s. Als de string s leeg is, moet de functie een lege lijst retourneren. Let op: je mag ervan uitgaan dat de invoerstring alleen letters en spaties bevat. Voorbeelden:\n     * \n     * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n     * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n     * select_words(\"simple white space\", 2) ==> []\n     * select_words(\"Hello world\", 4) ==> [\"world\"]\n     * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n     *\n     */\n    def selectWords(s : String, n : Int) : List[Any] = {\n", "entry_point": "selectWords", "test": "\n\n    var arg00 : String = \"\"\"Mary had a little lamb\"\"\"\n    var arg01 : Int = 4\n    var x0 : List[Any] = selectWords(arg00, arg01)\n    var v0 : List[Any] = List(\"\"\"little\"\"\")\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"Mary had a little lamb\"\"\"\n    var arg11 : Int = 3\n    var x1 : List[Any] = selectWords(arg10, arg11)\n    var v1 : List[Any] = List(\"\"\"Mary\"\"\", \"\"\"lamb\"\"\")\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"simple white space\"\"\"\n    var arg21 : Int = 2\n    var x2 : List[Any] = selectWords(arg20, arg21)\n    var v2 : List[Any] = List()\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"Hello world\"\"\"\n    var arg31 : Int = 4\n    var x3 : List[Any] = selectWords(arg30, arg31)\n    var v3 : List[Any] = List(\"\"\"world\"\"\")\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"Uncle sam\"\"\"\n    var arg41 : Int = 3\n    var x4 : List[Any] = selectWords(arg40, arg41)\n    var v4 : List[Any] = List(\"\"\"Uncle\"\"\")\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"\"\"\"\n    var arg51 : Int = 4\n    var x5 : List[Any] = selectWords(arg50, arg51)\n    var v5 : List[Any] = List()\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"a b c d e f\"\"\"\n    var arg61 : Int = 1\n    var x6 : List[Any] = selectWords(arg60, arg61)\n    var v6 : List[Any] = List(\"\"\"b\"\"\", \"\"\"c\"\"\", \"\"\"d\"\"\", \"\"\"f\"\"\")\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "Gegeven een string s en een natuurlijk getal n, is het jouw taak om een functie te implementeren die een lijst teruggeeft van alle woorden uit string s die precies n medeklinkers bevatten, in de volgorde waarin deze woorden voorkomen in string s. Als de string s leeg is, moet de functie een lege lijst retourneren. Let op: je mag ervan uitgaan dat de invoerstring alleen letters en spaties bevat. Voorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/54", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Gegeven een array arr van integers en een positief integer k, retourneer een gesorteerde lijst van lengte k met de k grootste getallen in arr.\n     * \n     * Voorbeeld 1:\n     * \n     *     Input: arr = [-3, -4, 5], k = 3\n     *     Output: [-4, -3, 5]\n     * \n     * Voorbeeld 2:\n     * \n     *     Input: arr = [4, -4, 4], k = 2\n     *     Output: [4, 4]\n     * \n     * Voorbeeld 3:\n     * \n     *     Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n     *     Output: [2]\n     * \n     * Opmerkingen:\n     *     1. De lengte van de array zal in het bereik van [1, 1000] zijn.\n     *     2. De elementen in de array zullen in het bereik van [-1000, 1000] zijn.\n     *     3. 0 <= k <= len(arr)\n     * \n     *\n     */\n    def maximum(arr : List[Int], k : Int) : List[Any] = {\n", "entry_point": "maximum", "test": "\n\n    var arg00 : List[Int] = List(-3, -4, 5)\n    var arg01 : Int = 3\n    var x0 : List[Any] = maximum(arg00, arg01)\n    var v0 : List[Any] = List(-4, -3, 5)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(4, -4, 4)\n    var arg11 : Int = 2\n    var x1 : List[Any] = maximum(arg10, arg11)\n    var v1 : List[Any] = List(4, 4)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(-3, 2, 1, 2, -1, -2, 1)\n    var arg21 : Int = 1\n    var x2 : List[Any] = maximum(arg20, arg21)\n    var v2 : List[Any] = List(2)\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(123, -123, 20, 0, 1, 2, -3)\n    var arg31 : Int = 3\n    var x3 : List[Any] = maximum(arg30, arg31)\n    var v3 : List[Any] = List(2, 20, 123)\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Int] = List(-123, 20, 0, 1, 2, -3)\n    var arg41 : Int = 4\n    var x4 : List[Any] = maximum(arg40, arg41)\n    var v4 : List[Any] = List(0, 1, 2, 20)\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Int] = List(5, 15, 0, 3, -13, -8, 0)\n    var arg51 : Int = 7\n    var x5 : List[Any] = maximum(arg50, arg51)\n    var v5 : List[Any] = List(-13, -8, 0, 0, 3, 5, 15)\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : List[Int] = List(-1, 0, 2, 5, 3, -10)\n    var arg61 : Int = 2\n    var x6 : List[Any] = maximum(arg60, arg61)\n    var v6 : List[Any] = List(3, 5)\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : List[Int] = List(1, 0, 5, -7)\n    var arg71 : Int = 1\n    var x7 : List[Any] = maximum(arg70, arg71)\n    var v7 : List[Any] = List(5)\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : List[Int] = List(4, -4)\n    var arg81 : Int = 2\n    var x8 : List[Any] = maximum(arg80, arg81)\n    var v8 : List[Any] = List(-4, 4)\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : List[Int] = List(-10, 10)\n    var arg91 : Int = 2\n    var x9 : List[Any] = maximum(arg90, arg91)\n    var v9 : List[Any] = List(-10, 10)\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n    var arg100 : List[Int] = List(1, 2, 3, -23, 243, -400, 0)\n    var arg101 : Int = 0\n    var x10 : List[Any] = maximum(arg100, arg101)\n    var v10 : List[Any] = List()\n    assert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \" + x10)\n\n\n}\n", "description": "Gegeven een array arr van integers en een positief integer k, retourneer een gesorteerde lijst van lengte k met de k grootste getallen in arr.\n\nVoorbeeld 1:\n\n    Input: arr = [-3, -4, 5], k = 3\n    Output: [-4, -3, 5]\n\nVoorbeeld 2:\n\n    Input: arr = [4, -4, 4], k = 2\n    Output: [4, 4]\n\nVoorbeeld 3:\n\n    Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Output: [2]\n\nOpmerkingen:\n    1. De lengte van de array zal in het bereik van [1, 1000] zijn.\n    2. De elementen in de array zullen in het bereik van [-1000, 1000] zijn.\n    3. 0 <= k <= len(arr)", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/55", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Gegeven een niet-lege array van integers arr en een integer k, retourneer de som van de elementen met hoogstens twee cijfers van de eerste k elementen van arr.\n     * \n     * Voorbeeld:\n     * \n     *     Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n     *     Output: 24 # som van 21 + 3\n     * \n     * Beperkingen:\n     *     1. 1 <= len(arr) <= 100\n     *     2. 1 <= k <= len(arr)\n     * \n     *\n     */\n    def addElements(arr : List[Int], k : Int) : Int = {\n", "entry_point": "addElements", "test": "\n\n    var arg00 : List[Int] = List(1, -2, -3, 41, 57, 76, 87, 88, 99)\n    var arg01 : Int = 3\n    var x0 : Int = addElements(arg00, arg01)\n    var v0 : Int = -4\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(111, 121, 3, 4000, 5, 6)\n    var arg11 : Int = 2\n    var x1 : Int = addElements(arg10, arg11)\n    var v1 : Int = 0\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(11, 21, 3, 90, 5, 6, 7, 8, 9)\n    var arg21 : Int = 4\n    var x2 : Int = addElements(arg20, arg21)\n    var v2 : Int = 125\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(111, 21, 3, 4000, 5, 6, 7, 8, 9)\n    var arg31 : Int = 4\n    var x3 : Int = addElements(arg30, arg31)\n    var v3 : Int = 24\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Int] = List(1)\n    var arg41 : Int = 1\n    var x4 : Int = addElements(arg40, arg41)\n    var v4 : Int = 1\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "Gegeven een niet-lege array van integers arr en een integer k, retourneer de som van de elementen met hoogstens twee cijfers van de eerste k elementen van arr.\n\nVoorbeeld:\n\n    Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Output: 24 # som van 21 + 3\n\nBeperkingen:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/56", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Je krijgt twee intervallen,\n     *     waarbij elk interval een paar van gehele getallen is. Bijvoorbeeld, interval = (start, end) = (1, 2).\n     *     De gegeven intervallen zijn gesloten, wat betekent dat het interval (start, end)\n     *     zowel start als end bevat.\n     *     Voor elk gegeven interval wordt aangenomen dat de start kleiner of gelijk is aan de end.\n     *     Je taak is om te bepalen of de lengte van de intersectie van deze twee\n     *     intervallen een priemgetal is.\n     *     Bijvoorbeeld, de intersectie van de intervallen (1, 3), (2, 4) is (2, 3)\n     *     waarvan de lengte 1 is, wat geen priemgetal is.\n     *     Als de lengte van de intersectie een priemgetal is, retourneer dan \"YES\",\n     *     anders retourneer \"NO\".\n     *     Als de twee intervallen elkaar niet overlappen, retourneer dan \"NO\".\n     * \n     * \n     *     [invoer/uitvoer] voorbeelden:\n     * \n     * intersection((1, 2), (2, 3)) ==> \"NO\"\n     * intersection((-1, 1), (0, 4)) ==> \"NO\"\n     * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n     *\n     */\n    def intersection(interval1 : List[Int], interval2 : List[Int]) : String = {\n", "entry_point": "intersection", "test": "\n\n    var arg00 : List[Int] = List(1, 2)\n    var arg01 : List[Int] = List(2, 3)\n    var x0 : String = intersection(arg00, arg01)\n    var v0 : String = \"\"\"NO\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Int] = List(-1, 1)\n    var arg11 : List[Int] = List(0, 4)\n    var x1 : String = intersection(arg10, arg11)\n    var v1 : String = \"\"\"NO\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Int] = List(-3, -1)\n    var arg21 : List[Int] = List(-5, 5)\n    var x2 : String = intersection(arg20, arg21)\n    var v2 : String = \"\"\"YES\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Int] = List(-2, 2)\n    var arg31 : List[Int] = List(-4, 0)\n    var x3 : String = intersection(arg30, arg31)\n    var v3 : String = \"\"\"YES\"\"\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Int] = List(-11, 2)\n    var arg41 : List[Int] = List(-1, -1)\n    var x4 : String = intersection(arg40, arg41)\n    var v4 : String = \"\"\"NO\"\"\"\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Int] = List(1, 2)\n    var arg51 : List[Int] = List(3, 5)\n    var x5 : String = intersection(arg50, arg51)\n    var v5 : String = \"\"\"NO\"\"\"\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : List[Int] = List(1, 2)\n    var arg61 : List[Int] = List(1, 2)\n    var x6 : String = intersection(arg60, arg61)\n    var v6 : String = \"\"\"NO\"\"\"\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : List[Int] = List(-2, -2)\n    var arg71 : List[Int] = List(-3, -2)\n    var x7 : String = intersection(arg70, arg71)\n    var v7 : String = \"\"\"NO\"\"\"\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n\n}\n", "description": "Je krijgt twee intervallen,\n    waarbij elk interval een paar van gehele getallen is. Bijvoorbeeld, interval = (start, end) = (1, 2).\n    De gegeven intervallen zijn gesloten, wat betekent dat het interval (start, end)\n    zowel start als end bevat.\n    Voor elk gegeven interval wordt aangenomen dat de start kleiner of gelijk is aan de end.\n    Je taak is om te bepalen of de lengte van de intersectie van deze twee\n    intervallen een priemgetal is.\n    Bijvoorbeeld, de intersectie van de intervallen (1, 3), (2, 4) is (2, 3)\n    waarvan de lengte 1 is, wat geen priemgetal is.\n    Als de lengte van de intersectie een priemgetal is, retourneer dan \"YES\",\n    anders retourneer \"NO\".\n    Als de twee intervallen elkaar niet overlappen, retourneer dan \"NO\".\n\n\n    [invoer/uitvoer] voorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/57", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Iedereen kent de Fibonacci-reeks, die diep is bestudeerd door wiskundigen in de afgelopen eeuwen. Wat mensen echter niet weten, is de Tribonacci-reeks. De Tribonacci-reeks wordt gedefinieerd door de recursie:\n     * tri(1) = 3\n     * tri(n) = 1 + n / 2, als n even is.\n     * tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), als n oneven is.\n     * Bijvoorbeeld:\n     * tri(2) = 1 + (2 / 2) = 2\n     * tri(4) = 3\n     * tri(3) = tri(2) + tri(1) + tri(4)\n     * = 2 + 3 + 3 = 8\n     * Je krijgt een niet-negatief geheel getal n, je moet een lijst retourneren van de eerste n + 1 getallen van de Tribonacci-reeks.\n     * Voorbeelden:\n     * tri(3) = [1, 3, 2, 8]\n     * \n     *\n     */\n    def tri(n : Int) : List[Double] = {\n", "entry_point": "tri", "test": "\n\n    var arg00 : Int = 3\n    var x0 : List[Double] = tri(arg00)\n    var v0 : List[Double] = List(1, 3, 2.0, 8.0)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 4\n    var x1 : List[Double] = tri(arg10)\n    var v1 : List[Double] = List(1, 3, 2.0, 8.0, 3.0)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 5\n    var x2 : List[Double] = tri(arg20)\n    var v2 : List[Double] = List(1, 3, 2.0, 8.0, 3.0, 15.0)\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 6\n    var x3 : List[Double] = tri(arg30)\n    var v3 : List[Double] = List(1, 3, 2.0, 8.0, 3.0, 15.0, 4.0)\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 7\n    var x4 : List[Double] = tri(arg40)\n    var v4 : List[Double] = List(1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0)\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 8\n    var x5 : List[Double] = tri(arg50)\n    var v5 : List[Double] = List(1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0)\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 9\n    var x6 : List[Double] = tri(arg60)\n    var v6 : List[Double] = List(1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0)\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : Int = 20\n    var x7 : List[Double] = tri(arg70)\n    var v7 : List[Double] = List(1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0)\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : Int = 0\n    var x8 : List[Double] = tri(arg80)\n    var v8 : List[Double] = List(1)\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : Int = 1\n    var x9 : List[Double] = tri(arg90)\n    var v9 : List[Double] = List(1, 3)\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n\n}\n", "description": "Iedereen kent de Fibonacci-reeks, die diep is bestudeerd door wiskundigen in de afgelopen eeuwen. Wat mensen echter niet weten, is de Tribonacci-reeks. De Tribonacci-reeks wordt gedefinieerd door de recursie:\ntri(1) = 3\ntri(n) = 1 + n / 2, als n even is.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), als n oneven is.\nBijvoorbeeld:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nJe krijgt een niet-negatief geheel getal n, je moet een lijst retourneren van de eerste n + 1 getallen van de Tribonacci-reeks.\nVoorbeelden:\ntri(3) = [1, 3, 2, 8]", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/58", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Gegeven een positief geheel getal n, retourneer het product van de oneven cijfers.\n     *     Retourneer 0 als alle cijfers even zijn.\n     *     Bijvoorbeeld:\n     * \n     * digits(1)  == 1\n     * digits(4)  == 0\n     * digits(235) == 15\n     *\n     */\n    def digits(n : Int) : Int = {\n", "entry_point": "digits", "test": "\n\n    var arg00 : Int = 5\n    var x0 : Int = digits(arg00)\n    var v0 : Int = 5\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 54\n    var x1 : Int = digits(arg10)\n    var v1 : Int = 5\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 120\n    var x2 : Int = digits(arg20)\n    var v2 : Int = 1\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 5014\n    var x3 : Int = digits(arg30)\n    var v3 : Int = 5\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 98765\n    var x4 : Int = digits(arg40)\n    var v4 : Int = 315\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 5576543\n    var x5 : Int = digits(arg50)\n    var v5 : Int = 2625\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 2468\n    var x6 : Int = digits(arg60)\n    var v6 : Int = 0\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "Gegeven een positief geheel getal n, retourneer het product van de oneven cijfers.\n    Retourneer 0 als alle cijfers even zijn.\n    Bijvoorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/59", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Maak een functie die een string als invoer neemt die alleen vierkante haken bevat. De functie moet True retourneren als en alleen als er een geldige deelsequentie van haken is waar ten minste één haak in de deelsequentie genest is.\n     * is_nested('[[]]') ➞ True\n     * is_nested('[]]]]]]][[[[[]') ➞ False\n     * is_nested('[][]') ➞ False\n     * is_nested('[]') ➞ False\n     * is_nested('[[][]]') ➞ True\n     * is_nested('[[]][[') ➞ True\n     *\n     */\n    def isNested(string : String) : Boolean = {\n", "entry_point": "isNested", "test": "\n\n    var arg00 : String = \"\"\"[[]]\"\"\"\n    var x0 : Boolean = isNested(arg00)\n    var v0 : Boolean = true\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"[]]]]]]][[[[[]\"\"\"\n    var x1 : Boolean = isNested(arg10)\n    var v1 : Boolean = false\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"[][]\"\"\"\n    var x2 : Boolean = isNested(arg20)\n    var v2 : Boolean = false\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"[]\"\"\"\n    var x3 : Boolean = isNested(arg30)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"[[[[]]]]\"\"\"\n    var x4 : Boolean = isNested(arg40)\n    var v4 : Boolean = true\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"[]]]]]]]]]]\"\"\"\n    var x5 : Boolean = isNested(arg50)\n    var v5 : Boolean = false\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"[][][[]]\"\"\"\n    var x6 : Boolean = isNested(arg60)\n    var v6 : Boolean = true\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : String = \"\"\"[[]\"\"\"\n    var x7 : Boolean = isNested(arg70)\n    var v7 : Boolean = false\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : String = \"\"\"[]]\"\"\"\n    var x8 : Boolean = isNested(arg80)\n    var v8 : Boolean = false\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : String = \"\"\"[[]][[\"\"\"\n    var x9 : Boolean = isNested(arg90)\n    var v9 : Boolean = true\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n    var arg100 : String = \"\"\"[[][]]\"\"\"\n    var x10 : Boolean = isNested(arg100)\n    var v10 : Boolean = true\n    assert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \" + x10)\n\n    var arg110 : String = \"\"\"\"\"\"\n    var x11 : Boolean = isNested(arg110)\n    var v11 : Boolean = false\n    assert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \" + x11)\n\n    var arg120 : String = \"\"\"[[[[[[[[\"\"\"\n    var x12 : Boolean = isNested(arg120)\n    var v12 : Boolean = false\n    assert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \" + x12)\n\n    var arg130 : String = \"\"\"]]]]]]]]\"\"\"\n    var x13 : Boolean = isNested(arg130)\n    var v13 : Boolean = false\n    assert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \" + x13)\n\n\n}\n", "description": "Maak een functie die een string als invoer neemt die alleen vierkante haken bevat. De functie moet True retourneren als en alleen als er een geldige deelsequentie van haken is waar ten minste één haak in de deelsequentie genest is.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/60", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Je krijgt een lijst met getallen.\n     * Je moet de som van de gekwadrateerde getallen in de gegeven lijst teruggeven,\n     * rond elk element in de lijst eerst af naar het bovenste gehele getal (Ceiling).\n     * Voorbeelden:\n     * Voor lst = [1,2,3] is de output 14\n     * Voor lst = [1,4,9] is de output 98\n     * Voor lst = [1,3,5,7] is de output 84\n     * Voor lst = [1.4,4.2,0] is de output 29\n     * Voor lst = [-2.4,1,1] is de output 6\n     * \n     * \n\n     *\n     */\n    def sumSquares(lst : List[Double]) : Int = {\n", "entry_point": "sumSquares", "test": "\n\n    var arg00 : List[Double] = List(1, 2, 3)\n    var x0 : Int = sumSquares(arg00)\n    var v0 : Int = 14\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Double] = List(1.0, 2, 3)\n    var x1 : Int = sumSquares(arg10)\n    var v1 : Int = 14\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Double] = List(1, 3, 5, 7)\n    var x2 : Int = sumSquares(arg20)\n    var v2 : Int = 84\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Double] = List(1.4, 4.2, 0)\n    var x3 : Int = sumSquares(arg30)\n    var v3 : Int = 29\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Double] = List(-2.4, 1, 1)\n    var x4 : Int = sumSquares(arg40)\n    var v4 : Int = 6\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Double] = List(100, 1, 15, 2)\n    var x5 : Int = sumSquares(arg50)\n    var v5 : Int = 10230\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : List[Double] = List(10000, 10000)\n    var x6 : Int = sumSquares(arg60)\n    var v6 : Int = 200000000\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : List[Double] = List(-1.4, 4.6, 6.3)\n    var x7 : Int = sumSquares(arg70)\n    var v7 : Int = 75\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : List[Double] = List(-1.4, 17.9, 18.9, 19.9)\n    var x8 : Int = sumSquares(arg80)\n    var v8 : Int = 1086\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : List[Double] = List(0)\n    var x9 : Int = sumSquares(arg90)\n    var v9 : Int = 0\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n    var arg100 : List[Double] = List(-1)\n    var x10 : Int = sumSquares(arg100)\n    var v10 : Int = 1\n    assert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \" + x10)\n\n    var arg110 : List[Double] = List(-1, 1, 0)\n    var x11 : Int = sumSquares(arg110)\n    var v11 : Int = 2\n    assert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \" + x11)\n\n\n}\n", "description": "Je krijgt een lijst met getallen.\nJe moet de som van de gekwadrateerde getallen in de gegeven lijst teruggeven,\nrond elk element in de lijst eerst af naar het bovenste gehele getal (Ceiling).\nVoorbeelden:\nVoor lst = [1,2,3] is de output 14\nVoor lst = [1,4,9] is de output 98\nVoor lst = [1,3,5,7] is de output 84\nVoor lst = [1.4,4.2,0] is de output 29\nVoor lst = [-2.4,1,1] is de output 6", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/61", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Maak een functie die True retourneert als het laatste karakter van een gegeven string een alfabetisch karakter is en geen deel uitmaakt van een woord, en anders False retourneert.\n     * Opmerking: \"woord\" is een groep tekens gescheiden door spaties.\n     * \n     * Voorbeelden:\n     * \n     * check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n     * check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n     * check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n     * check_if_last_char_is_a_letter(\"\") ➞ False \n     *\n     */\n    def checkIfLastCharIsALetter(txt : String) : Boolean = {\n", "entry_point": "checkIfLastCharIsALetter", "test": "\n\n    var arg00 : String = \"\"\"apple\"\"\"\n    var x0 : Boolean = checkIfLastCharIsALetter(arg00)\n    var v0 : Boolean = false\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"apple pi e\"\"\"\n    var x1 : Boolean = checkIfLastCharIsALetter(arg10)\n    var v1 : Boolean = true\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"eeeee\"\"\"\n    var x2 : Boolean = checkIfLastCharIsALetter(arg20)\n    var v2 : Boolean = false\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"A\"\"\"\n    var x3 : Boolean = checkIfLastCharIsALetter(arg30)\n    var v3 : Boolean = true\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"Pumpkin pie \"\"\"\n    var x4 : Boolean = checkIfLastCharIsALetter(arg40)\n    var v4 : Boolean = false\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"Pumpkin pie 1\"\"\"\n    var x5 : Boolean = checkIfLastCharIsALetter(arg50)\n    var v5 : Boolean = false\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"\"\"\"\n    var x6 : Boolean = checkIfLastCharIsALetter(arg60)\n    var v6 : Boolean = false\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : String = \"\"\"eeeee e \"\"\"\n    var x7 : Boolean = checkIfLastCharIsALetter(arg70)\n    var v7 : Boolean = false\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : String = \"\"\"apple pie\"\"\"\n    var x8 : Boolean = checkIfLastCharIsALetter(arg80)\n    var v8 : Boolean = false\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : String = \"\"\"apple pi e \"\"\"\n    var x9 : Boolean = checkIfLastCharIsALetter(arg90)\n    var v9 : Boolean = false\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n\n}\n", "description": "Maak een functie die True retourneert als het laatste karakter van een gegeven string een alfabetisch karakter is en geen deel uitmaakt van een woord, en anders False retourneert.\nOpmerking: \"woord\" is een groep tekens gescheiden door spaties.\n\nVoorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/62", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Maak een functie die het grootste indexnummer retourneert van een element dat niet groter is dan het element direct ervoor. Als er geen dergelijk element bestaat, retourneer dan -1. De gegeven array bevat geen dubbele waarden.\n     * \n     * Voorbeelden:\n     * \n     * can_arrange([1,2,4,3,5]) = 3\n     * can_arrange([1,2,3]) = -1\n     *\n     */\n    def canArrange(arr : List[Any]) : Int = {\n", "entry_point": "canArrange", "test": "\n\n    var arg00 : List[Any] = List(1, 2, 4, 3, 5)\n    var x0 : Int = canArrange(arg00)\n    var v0 : Int = 3\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Any] = List(1, 2, 4, 5)\n    var x1 : Int = canArrange(arg10)\n    var v1 : Int = -1\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Any] = List(1, 4, 2, 5, 6, 7, 8, 9, 10)\n    var x2 : Int = canArrange(arg20)\n    var v2 : Int = 2\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Any] = List(4, 8, 5, 7, 3)\n    var x3 : Int = canArrange(arg30)\n    var v3 : Int = 4\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Any] = List()\n    var x4 : Int = canArrange(arg40)\n    var v4 : Int = -1\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n\n}\n", "description": "Maak een functie die het grootste indexnummer retourneert van een element dat niet groter is dan het element direct ervoor. Als er geen dergelijk element bestaat, retourneer dan -1. De gegeven array bevat geen dubbele waarden.\n\nVoorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/63", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Maak een functie die een tuple (a, b) retourneert, waarbij 'a' het grootste negatieve gehele getal is en 'b' het kleinste positieve gehele getal in een lijst is. Als er geen negatieve of positieve gehele getallen zijn, retourneer ze dan als None.\n     * \n     * Voorbeelden:\n     * \n     * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n     * largest_smallest_integers([]) == (None, None)\n     * largest_smallest_integers([0]) == (None, None)\n     *\n     */\n    def largestSmallestIntegers(lst : List[Any]) : List[Any] = {\n", "entry_point": "largestSmallestIntegers", "test": "\n\n    var arg00 : List[Any] = List(2, 4, 1, 3, 5, 7)\n    var x0 : List[Any] = largestSmallestIntegers(arg00)\n    var v0 : List[Any] = List(\"none\", 1)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Any] = List(2, 4, 1, 3, 5, 7, 0)\n    var x1 : List[Any] = largestSmallestIntegers(arg10)\n    var v1 : List[Any] = List(\"none\", 1)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Any] = List(1, 3, 2, 4, 5, 6, -2)\n    var x2 : List[Any] = largestSmallestIntegers(arg20)\n    var v2 : List[Any] = List(-2, 1)\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Any] = List(4, 5, 3, 6, 2, 7, -7)\n    var x3 : List[Any] = largestSmallestIntegers(arg30)\n    var v3 : List[Any] = List(-7, 2)\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Any] = List(7, 3, 8, 4, 9, 2, 5, -9)\n    var x4 : List[Any] = largestSmallestIntegers(arg40)\n    var v4 : List[Any] = List(-9, 2)\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Any] = List()\n    var x5 : List[Any] = largestSmallestIntegers(arg50)\n    var v5 : List[Any] = List(\"none\", \"none\")\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : List[Any] = List(0)\n    var x6 : List[Any] = largestSmallestIntegers(arg60)\n    var v6 : List[Any] = List(\"none\", \"none\")\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : List[Any] = List(-1, -3, -5, -6)\n    var x7 : List[Any] = largestSmallestIntegers(arg70)\n    var v7 : List[Any] = List(-1, \"none\")\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : List[Any] = List(-1, -3, -5, -6, 0)\n    var x8 : List[Any] = largestSmallestIntegers(arg80)\n    var v8 : List[Any] = List(-1, \"none\")\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : List[Any] = List(-6, -4, -4, -3, 1)\n    var x9 : List[Any] = largestSmallestIntegers(arg90)\n    var v9 : List[Any] = List(-3, 1)\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n    var arg100 : List[Any] = List(-6, -4, -4, -3, -100, 1)\n    var x10 : List[Any] = largestSmallestIntegers(arg100)\n    var v10 : List[Any] = List(-3, 1)\n    assert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \" + x10)\n\n\n}\n", "description": "Maak een functie die een tuple (a, b) retourneert, waarbij 'a' het grootste negatieve gehele getal is en 'b' het kleinste positieve gehele getal in een lijst is. Als er geen negatieve of positieve gehele getallen zijn, retourneer ze dan als None.\n\nVoorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/64", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * De Braziliaanse faculteit is gedefinieerd als:\n     *     braziliaanse_faculteit(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     *     waarbij n > 0\n     * \n     *     Bijvoorbeeld:\n     * >>> special_factorial(4)\n     * 288\n\n     * The function will receive an integer as input and should return the special\n     * factorial of this integer.\n     *\n     */\n    def specialFactorial(n : Int) : Int = {\n", "entry_point": "specialFactorial", "test": "\n\n    var arg00 : Int = 4\n    var x0 : Int = specialFactorial(arg00)\n    var v0 : Int = 288\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 5\n    var x1 : Int = specialFactorial(arg10)\n    var v1 : Int = 34560\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 7\n    var x2 : Int = specialFactorial(arg20)\n    var v2 : Int = 125411328000\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 1\n    var x3 : Int = specialFactorial(arg30)\n    var v3 : Int = 1\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n\n}\n", "description": "De Braziliaanse faculteit is gedefinieerd als:\n    braziliaanse_faculteit(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    waarbij n > 0\n\n    Bijvoorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/65", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Je krijgt een string die een zin voorstelt,\n     *     de zin bevat enkele woorden gescheiden door een spatie,\n     *     en je moet een string teruggeven die de woorden uit de oorspronkelijke zin bevat,\n     *     waarvan de lengtes priemgetallen zijn,\n     *     de volgorde van de woorden in de nieuwe string moet hetzelfde zijn als in de oorspronkelijke zin.\n     * \n     *     Voorbeeld 1:\n     *         Input: sentence = \"This is a test\"\n     *         Output: \"is\"\n     * \n     *     Voorbeeld 2:\n     *         Input: sentence = \"lets go for swimming\"\n     *         Output: \"go for\"\n     * \n     *     Beperkingen:\n     *         * 1 <= len(sentence) <= 100\n     *         * sentence bevat alleen letters\n     * \n     *\n     */\n    def wordsInSentence(sentence : String) : String = {\n", "entry_point": "wordsInSentence", "test": "\n\n    var arg00 : String = \"\"\"This is a test\"\"\"\n    var x0 : String = wordsInSentence(arg00)\n    var v0 : String = \"\"\"is\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"lets go for swimming\"\"\"\n    var x1 : String = wordsInSentence(arg10)\n    var v1 : String = \"\"\"go for\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"there is no place available here\"\"\"\n    var x2 : String = wordsInSentence(arg20)\n    var v2 : String = \"\"\"there is no place\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"Hi I am Hussein\"\"\"\n    var x3 : String = wordsInSentence(arg30)\n    var v3 : String = \"\"\"Hi am Hussein\"\"\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"go for it\"\"\"\n    var x4 : String = wordsInSentence(arg40)\n    var v4 : String = \"\"\"go for it\"\"\"\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"here\"\"\"\n    var x5 : String = wordsInSentence(arg50)\n    var v5 : String = \"\"\"\"\"\"\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"here is\"\"\"\n    var x6 : String = wordsInSentence(arg60)\n    var v6 : String = \"\"\"is\"\"\"\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "Je krijgt een string die een zin voorstelt,\n    de zin bevat enkele woorden gescheiden door een spatie,\n    en je moet een string teruggeven die de woorden uit de oorspronkelijke zin bevat,\n    waarvan de lengtes priemgetallen zijn,\n    de volgorde van de woorden in de nieuwe string moet hetzelfde zijn als in de oorspronkelijke zin.\n\n    Voorbeeld 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Voorbeeld 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Beperkingen:\n        * 1 <= len(sentence) <= 100\n        * sentence bevat alleen letters", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/66", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Je taak is om een functie te implementeren die de expressie x * n vereenvoudigt. De functie retourneert True als x * n evalueert naar een geheel getal en False anders. Zowel x als n zijn stringrepresentaties van een breuk en hebben het volgende formaat: <teller>/<noemer> waarbij zowel de teller als de noemer positieve gehele getallen zijn.\n     * \n     * Je kunt ervan uitgaan dat x en n geldige breuken zijn en geen nul als noemer hebben.\n     * simplify(\"1/5\", \"5/1\") = True\n     * simplify(\"1/6\", \"2/1\") = False\n     * simplify(\"7/10\", \"10/2\") = False\n     *\n     */\n    def simplify(x : String, n : String) : Boolean = {\n", "entry_point": "simplify", "test": "\n\n    var arg00 : String = \"\"\"1/5\"\"\"\n    var arg01 : String = \"\"\"5/1\"\"\"\n    var x0 : Boolean = simplify(arg00, arg01)\n    var v0 : Boolean = true\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"1/6\"\"\"\n    var arg11 : String = \"\"\"2/1\"\"\"\n    var x1 : Boolean = simplify(arg10, arg11)\n    var v1 : Boolean = false\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"5/1\"\"\"\n    var arg21 : String = \"\"\"3/1\"\"\"\n    var x2 : Boolean = simplify(arg20, arg21)\n    var v2 : Boolean = true\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"7/10\"\"\"\n    var arg31 : String = \"\"\"10/2\"\"\"\n    var x3 : Boolean = simplify(arg30, arg31)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"2/10\"\"\"\n    var arg41 : String = \"\"\"50/10\"\"\"\n    var x4 : Boolean = simplify(arg40, arg41)\n    var v4 : Boolean = true\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"7/2\"\"\"\n    var arg51 : String = \"\"\"4/2\"\"\"\n    var x5 : Boolean = simplify(arg50, arg51)\n    var v5 : Boolean = true\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"11/6\"\"\"\n    var arg61 : String = \"\"\"6/1\"\"\"\n    var x6 : Boolean = simplify(arg60, arg61)\n    var v6 : Boolean = true\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : String = \"\"\"2/3\"\"\"\n    var arg71 : String = \"\"\"5/2\"\"\"\n    var x7 : Boolean = simplify(arg70, arg71)\n    var v7 : Boolean = false\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : String = \"\"\"5/2\"\"\"\n    var arg81 : String = \"\"\"3/5\"\"\"\n    var x8 : Boolean = simplify(arg80, arg81)\n    var v8 : Boolean = false\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : String = \"\"\"2/4\"\"\"\n    var arg91 : String = \"\"\"8/4\"\"\"\n    var x9 : Boolean = simplify(arg90, arg91)\n    var v9 : Boolean = true\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n    var arg100 : String = \"\"\"2/4\"\"\"\n    var arg101 : String = \"\"\"4/2\"\"\"\n    var x10 : Boolean = simplify(arg100, arg101)\n    var v10 : Boolean = true\n    assert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \" + x10)\n\n    var arg110 : String = \"\"\"1/5\"\"\"\n    var arg111 : String = \"\"\"5/1\"\"\"\n    var x11 : Boolean = simplify(arg110, arg111)\n    var v11 : Boolean = true\n    assert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \" + x11)\n\n    var arg120 : String = \"\"\"1/5\"\"\"\n    var arg121 : String = \"\"\"1/5\"\"\"\n    var x12 : Boolean = simplify(arg120, arg121)\n    var v12 : Boolean = false\n    assert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \" + x12)\n\n\n}\n", "description": "Je taak is om een functie te implementeren die de expressie x * n vereenvoudigt. De functie retourneert True als x * n evalueert naar een geheel getal en False anders. Zowel x als n zijn stringrepresentaties van een breuk en hebben het volgende formaat: <teller>/<noemer> waarbij zowel de teller als de noemer positieve gehele getallen zijn.\n\nJe kunt ervan uitgaan dat x en n geldige breuken zijn en geen nul als noemer hebben.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/67", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Schrijf een functie die de gegeven lijst van integers sorteert in oplopende volgorde op basis van de som van hun cijfers. Let op: als er meerdere items zijn met een vergelijkbare som van hun cijfers, sorteer ze dan op basis van hun index in de oorspronkelijke lijst.\n     * \n     * Bijvoorbeeld:\n     * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n     * >>> order_by_points([]) == []\n     *\n     */\n    def orderByPoints(nums : List[Any]) : List[Any] = {\n", "entry_point": "orderByPoints", "test": "\n\n    var arg00 : List[Any] = List(1, 11, -1, -11, -12)\n    var x0 : List[Any] = orderByPoints(arg00)\n    var v0 : List[Any] = List(-1, -11, 1, -12, 11)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Any] = List(1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46)\n    var x1 : List[Any] = orderByPoints(arg10)\n    var v1 : List[Any] = List(0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Any] = List()\n    var x2 : List[Any] = orderByPoints(arg20)\n    var v2 : List[Any] = List()\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Any] = List(1, -11, -32, 43, 54, -98, 2, -3)\n    var x3 : List[Any] = orderByPoints(arg30)\n    var v3 : List[Any] = List(-3, -32, -98, -11, 1, 2, 43, 54)\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Any] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)\n    var x4 : List[Any] = orderByPoints(arg40)\n    var v4 : List[Any] = List(1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9)\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Any] = List(0, 6, 6, -76, -21, 23, 4)\n    var x5 : List[Any] = orderByPoints(arg50)\n    var v5 : List[Any] = List(-76, -21, 0, 4, 23, 6, 6)\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n\n}\n", "description": "Schrijf een functie die de gegeven lijst van integers sorteert in oplopende volgorde op basis van de som van hun cijfers. Let op: als er meerdere items zijn met een vergelijkbare som van hun cijfers, sorteer ze dan op basis van hun index in de oorspronkelijke lijst.\n\nBijvoorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/68", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Schrijf een functie die een array van getallen als invoer neemt en het aantal elementen in de array teruggeeft die groter zijn dan 10 en waarvan zowel het eerste als het laatste cijfer van een getal oneven zijn (1, 3, 5, 7, 9). Bijvoorbeeld:\n     * \n     * specialFilter([15, -73, 14, -15]) => 1 \n     * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n     *\n     */\n    def specialfilter(nums : List[Any]) : Int = {\n", "entry_point": "specialfilter", "test": "\n\n    var arg00 : List[Any] = List(5, -2, 1, -5)\n    var x0 : Int = specialfilter(arg00)\n    var v0 : Int = 0\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Any] = List(15, -73, 14, -15)\n    var x1 : Int = specialfilter(arg10)\n    var v1 : Int = 1\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Any] = List(33, -2, -3, 45, 21, 109)\n    var x2 : Int = specialfilter(arg20)\n    var v2 : Int = 2\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Any] = List(43, -12, 93, 125, 121, 109)\n    var x3 : Int = specialfilter(arg30)\n    var v3 : Int = 4\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Any] = List(71, -2, -33, 75, 21, 19)\n    var x4 : Int = specialfilter(arg40)\n    var v4 : Int = 3\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Any] = List(1)\n    var x5 : Int = specialfilter(arg50)\n    var v5 : Int = 0\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : List[Any] = List()\n    var x6 : Int = specialfilter(arg60)\n    var v6 : Int = 0\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "Schrijf een functie die een array van getallen als invoer neemt en het aantal elementen in de array teruggeeft die groter zijn dan 10 en waarvan zowel het eerste als het laatste cijfer van een getal oneven zijn (1, 3, 5, 7, 9). Bijvoorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/69", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Je krijgt een positief geheel getal n. Je moet een geheel getallen array a maken met een lengte van n.\n     *         Voor elk i (1 ≤ i ≤ n), is de waarde van a[i] = i * i - i + 1.\n     *         Geef het aantal triples (a[i], a[j], a[k]) van a terug waarbij i < j < k, \n     *     en a[i] + a[j] + a[k] een veelvoud is van 3.\n     * \n     *     Voorbeeld:\n     *         Input: n = 5\n     *         Output: 1\n     *         Uitleg: \n     *         a = [1, 3, 7, 13, 21]\n     *         De enige geldige triple is (1, 7, 13).\n     * \n     *\n     */\n    def getMaxTriples(n : Int) : Int = {\n", "entry_point": "getMaxTriples", "test": "\n\n    var arg00 : Int = 5\n    var x0 : Int = getMaxTriples(arg00)\n    var v0 : Int = 1\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 6\n    var x1 : Int = getMaxTriples(arg10)\n    var v1 : Int = 4\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 10\n    var x2 : Int = getMaxTriples(arg20)\n    var v2 : Int = 36\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 100\n    var x3 : Int = getMaxTriples(arg30)\n    var v3 : Int = 53361\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n\n}\n", "description": "Je krijgt een positief geheel getal n. Je moet een geheel getallen array a maken met een lengte van n.\n        Voor elk i (1 ≤ i ≤ n), is de waarde van a[i] = i * i - i + 1.\n        Geef het aantal triples (a[i], a[j], a[k]) van a terug waarbij i < j < k, \n    en a[i] + a[j] + a[k] een veelvoud is van 3.\n\n    Voorbeeld:\n        Input: n = 5\n        Output: 1\n        Uitleg: \n        a = [1, 3, 7, 13, 21]\n        De enige geldige triple is (1, 7, 13).", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/70", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Er zijn acht planeten in ons zonnestelsel: de dichtstbijzijnde bij de zon is Mercurius, de volgende is Venus, dan Aarde, Mars, Jupiter, Saturnus, Uranus, Neptunus. Schrijf een functie die twee planeetnamen als strings planet1 en planet2 neemt. De functie moet een tuple retourneren met alle planeten waarvan de banen zich bevinden tussen de baan van planeet1 en de baan van planeet2, gesorteerd op nabijheid tot de zon. De functie moet een lege tuple retourneren als planet1 of planet2 geen correcte planeetnamen zijn. Voorbeelden\n     * \n     * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n     * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n     * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n     *\n     */\n    def bf(planet1 : String, planet2 : String) : List[Any] = {\n", "entry_point": "bf", "test": "\n\n    var arg00 : String = \"\"\"Jupiter\"\"\"\n    var arg01 : String = \"\"\"Neptune\"\"\"\n    var x0 : List[Any] = bf(arg00, arg01)\n    var v0 : List[Any] = List(\"\"\"Saturn\"\"\", \"\"\"Uranus\"\"\")\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"Earth\"\"\"\n    var arg11 : String = \"\"\"Mercury\"\"\"\n    var x1 : List[Any] = bf(arg10, arg11)\n    var v1 : List[Any] = List(\"\"\"Venus\"\"\")\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"Mercury\"\"\"\n    var arg21 : String = \"\"\"Uranus\"\"\"\n    var x2 : List[Any] = bf(arg20, arg21)\n    var v2 : List[Any] = List(\"\"\"Venus\"\"\", \"\"\"Earth\"\"\", \"\"\"Mars\"\"\", \"\"\"Jupiter\"\"\", \"\"\"Saturn\"\"\")\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"Neptune\"\"\"\n    var arg31 : String = \"\"\"Venus\"\"\"\n    var x3 : List[Any] = bf(arg30, arg31)\n    var v3 : List[Any] = List(\"\"\"Earth\"\"\", \"\"\"Mars\"\"\", \"\"\"Jupiter\"\"\", \"\"\"Saturn\"\"\", \"\"\"Uranus\"\"\")\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"Earth\"\"\"\n    var arg41 : String = \"\"\"Earth\"\"\"\n    var x4 : List[Any] = bf(arg40, arg41)\n    var v4 : List[Any] = List()\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"Mars\"\"\"\n    var arg51 : String = \"\"\"Earth\"\"\"\n    var x5 : List[Any] = bf(arg50, arg51)\n    var v5 : List[Any] = List()\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"Jupiter\"\"\"\n    var arg61 : String = \"\"\"Makemake\"\"\"\n    var x6 : List[Any] = bf(arg60, arg61)\n    var v6 : List[Any] = List()\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "Er zijn acht planeten in ons zonnestelsel: de dichtstbijzijnde bij de zon is Mercurius, de volgende is Venus, dan Aarde, Mars, Jupiter, Saturnus, Uranus, Neptunus. Schrijf een functie die twee planeetnamen als strings planet1 en planet2 neemt. De functie moet een tuple retourneren met alle planeten waarvan de banen zich bevinden tussen de baan van planeet1 en de baan van planeet2, gesorteerd op nabijheid tot de zon. De functie moet een lege tuple retourneren als planet1 of planet2 geen correcte planeetnamen zijn. Voorbeelden", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/71", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Een eenvoudig programma dat de waarde van x moet retourneren als n een priemgetal is en anders de waarde van y moet retourneren.\n     * \n     * Voorbeelden:\n     * \n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     * \n     *\n     */\n    def xOrY(n : Int, x : Int, y : Int) : Int = {\n", "entry_point": "xOrY", "test": "\n\n    var arg00 : Int = 7\n    var arg01 : Int = 34\n    var arg02 : Int = 12\n    var x0 : Int = xOrY(arg00, arg01, arg02)\n    var v0 : Int = 34\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 15\n    var arg11 : Int = 8\n    var arg12 : Int = 5\n    var x1 : Int = xOrY(arg10, arg11, arg12)\n    var v1 : Int = 5\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 3\n    var arg21 : Int = 33\n    var arg22 : Int = 5212\n    var x2 : Int = xOrY(arg20, arg21, arg22)\n    var v2 : Int = 33\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 1259\n    var arg31 : Int = 3\n    var arg32 : Int = 52\n    var x3 : Int = xOrY(arg30, arg31, arg32)\n    var v3 : Int = 3\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 7919\n    var arg41 : Int = -1\n    var arg42 : Int = 12\n    var x4 : Int = xOrY(arg40, arg41, arg42)\n    var v4 : Int = -1\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 3609\n    var arg51 : Int = 1245\n    var arg52 : Int = 583\n    var x5 : Int = xOrY(arg50, arg51, arg52)\n    var v5 : Int = 583\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 91\n    var arg61 : Int = 56\n    var arg62 : Int = 129\n    var x6 : Int = xOrY(arg60, arg61, arg62)\n    var v6 : Int = 129\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : Int = 6\n    var arg71 : Int = 34\n    var arg72 : Int = 1234\n    var x7 : Int = xOrY(arg70, arg71, arg72)\n    var v7 : Int = 1234\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : Int = 1\n    var arg81 : Int = 2\n    var arg82 : Int = 0\n    var x8 : Int = xOrY(arg80, arg81, arg82)\n    var v8 : Int = 0\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : Int = 2\n    var arg91 : Int = 2\n    var arg92 : Int = 0\n    var x9 : Int = xOrY(arg90, arg91, arg92)\n    var v9 : Int = 2\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n\n}\n", "description": "Een eenvoudig programma dat de waarde van x moet retourneren als n een priemgetal is en anders de waarde van y moet retourneren.\n\nVoorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/72", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Gegeven een lijst van getallen, retourneer de som van de kwadraten van de getallen in de lijst die oneven zijn. Negeer getallen die negatief zijn of geen gehele getallen zijn.\n     * \n     *     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n     *     double_the_difference([-1, -2, 0]) == 0\n     *     double_the_difference([9, -2]) == 81\n     *     double_the_difference([0]) == 0\n     * \n     *     Als de invoerlijst leeg is, retourneer dan 0.\n     * \n     *\n     */\n    def doubleTheDifference(lst : List[Any]) : Int = {\n", "entry_point": "doubleTheDifference", "test": "\n\n    var arg00 : List[Any] = List()\n    var x0 : Int = doubleTheDifference(arg00)\n    var v0 : Int = 0\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : List[Any] = List(5, 4)\n    var x1 : Int = doubleTheDifference(arg10)\n    var v1 : Int = 25\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : List[Any] = List(0.1, 0.2, 0.3)\n    var x2 : Int = doubleTheDifference(arg20)\n    var v2 : Int = 0\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : List[Any] = List(-10, -20, -30)\n    var x3 : Int = doubleTheDifference(arg30)\n    var v3 : Int = 0\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : List[Any] = List(-1, -2, 8)\n    var x4 : Int = doubleTheDifference(arg40)\n    var v4 : Int = 0\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : List[Any] = List(0.2, 3, 5)\n    var x5 : Int = doubleTheDifference(arg50)\n    var v5 : Int = 34\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : List[Any] = List(-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99)\n    var x6 : Int = doubleTheDifference(arg60)\n    var v6 : Int = 166650\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n\n}\n", "description": "Gegeven een lijst van getallen, retourneer de som van de kwadraten van de getallen in de lijst die oneven zijn. Negeer getallen die negatief zijn of geen gehele getallen zijn.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    Als de invoerlijst leeg is, retourneer dan 0.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/73", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Je krijgt de naam van een klasse (een string) en een lijst met extensies.\n     *     De extensies worden gebruikt om extra klassen aan de klasse te laden. De sterkte van de extensie is als volgt: Laat CAP het aantal hoofdletters in de naam van de extensie zijn en laat SM het aantal kleine letters zijn in de naam van de extensie, de sterkte wordt gegeven door de breuk CAP - SM. \n     *     Je moet de sterkste extensie vinden en een string retourneren in dit formaat: ClassName.SterksteExtensieNaam.\n     *     Als er twee of meer extensies zijn met dezelfde sterkte, moet je degene kiezen die als eerste in de lijst voorkomt.\n     *     Bijvoorbeeld, als je \"Slices\" als klasse krijgt en een lijst met extensies: ['SErviNGSliCes', 'Cheese', 'StuFfed'], dan moet je 'Slices.SErviNGSliCes' retourneren omdat 'SErviNGSliCes' de sterkste extensie is (zijn sterkte is -1).\n     *     Voorbeeld:\n     * \n     * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n     *\n     */\n    def strongestExtension(className : String, extensions : List[String]) : String = {\n", "entry_point": "strongestExtension", "test": "\n\n    var arg00 : String = \"\"\"Watashi\"\"\"\n    var arg01 : List[String] = List(\"\"\"tEN\"\"\", \"\"\"niNE\"\"\", \"\"\"eIGHt8OKe\"\"\")\n    var x0 : String = strongestExtension(arg00, arg01)\n    var v0 : String = \"\"\"Watashi.eIGHt8OKe\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"Boku123\"\"\"\n    var arg11 : List[String] = List(\"\"\"nani\"\"\", \"\"\"NazeDa\"\"\", \"\"\"YEs.WeCaNe\"\"\", \"\"\"32145tggg\"\"\")\n    var x1 : String = strongestExtension(arg10, arg11)\n    var v1 : String = \"\"\"Boku123.YEs.WeCaNe\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"__YESIMHERE\"\"\"\n    var arg21 : List[String] = List(\"\"\"t\"\"\", \"\"\"eMptY\"\"\", \"\"\"nothing\"\"\", \"\"\"zeR00\"\"\", \"\"\"NuLl__\"\"\", \"\"\"123NoooneB321\"\"\")\n    var x2 : String = strongestExtension(arg20, arg21)\n    var v2 : String = \"\"\"__YESIMHERE.NuLl__\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"K\"\"\"\n    var arg31 : List[String] = List(\"\"\"Ta\"\"\", \"\"\"TAR\"\"\", \"\"\"t234An\"\"\", \"\"\"cosSo\"\"\")\n    var x3 : String = strongestExtension(arg30, arg31)\n    var v3 : String = \"\"\"K.TAR\"\"\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"__HAHA\"\"\"\n    var arg41 : List[String] = List(\"\"\"Tab\"\"\", \"\"\"123\"\"\", \"\"\"781345\"\"\", \"\"\"-_-\"\"\")\n    var x4 : String = strongestExtension(arg40, arg41)\n    var v4 : String = \"\"\"__HAHA.123\"\"\"\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"YameRore\"\"\"\n    var arg51 : List[String] = List(\"\"\"HhAas\"\"\", \"\"\"okIWILL123\"\"\", \"\"\"WorkOut\"\"\", \"\"\"Fails\"\"\", \"\"\"-_-\"\"\")\n    var x5 : String = strongestExtension(arg50, arg51)\n    var v5 : String = \"\"\"YameRore.okIWILL123\"\"\"\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"finNNalLLly\"\"\"\n    var arg61 : List[String] = List(\"\"\"Die\"\"\", \"\"\"NowW\"\"\", \"\"\"Wow\"\"\", \"\"\"WoW\"\"\")\n    var x6 : String = strongestExtension(arg60, arg61)\n    var v6 : String = \"\"\"finNNalLLly.WoW\"\"\"\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : String = \"\"\"_\"\"\"\n    var arg71 : List[String] = List(\"\"\"Bb\"\"\", \"\"\"91245\"\"\")\n    var x7 : String = strongestExtension(arg70, arg71)\n    var v7 : String = \"\"\"_.Bb\"\"\"\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : String = \"\"\"Sp\"\"\"\n    var arg81 : List[String] = List(\"\"\"671235\"\"\", \"\"\"Bb\"\"\")\n    var x8 : String = strongestExtension(arg80, arg81)\n    var v8 : String = \"\"\"Sp.671235\"\"\"\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n\n}\n", "description": "Je krijgt de naam van een klasse (een string) en een lijst met extensies.\n    De extensies worden gebruikt om extra klassen aan de klasse te laden. De sterkte van de extensie is als volgt: Laat CAP het aantal hoofdletters in de naam van de extensie zijn en laat SM het aantal kleine letters zijn in de naam van de extensie, de sterkte wordt gegeven door de breuk CAP - SM. \n    Je moet de sterkste extensie vinden en een string retourneren in dit formaat: ClassName.SterksteExtensieNaam.\n    Als er twee of meer extensies zijn met dezelfde sterkte, moet je degene kiezen die als eerste in de lijst voorkomt.\n    Bijvoorbeeld, als je \"Slices\" als klasse krijgt en een lijst met extensies: ['SErviNGSliCes', 'Cheese', 'StuFfed'], dan moet je 'Slices.SErviNGSliCes' retourneren omdat 'SErviNGSliCes' de sterkste extensie is (zijn sterkte is -1).\n    Voorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/74", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Je krijgt 2 woorden. Je moet True teruggeven als het tweede woord of een van zijn rotaties een substring is in het eerste woord.\n     * cycpattern_check(\"abcd\",\"abd\") => False\n     * cycpattern_check(\"hello\",\"ell\") => True\n     * cycpattern_check(\"whassup\",\"psus\") => False\n     * cycpattern_check(\"abab\",\"baa\") => True\n     * cycpattern_check(\"efef\",\"eeff\") => False\n     * cycpattern_check(\"himenss\",\"simen\") => True\n\n     *\n     */\n    def cycpatternCheck(a : String, b : String) : Boolean = {\n", "entry_point": "cycpatternCheck", "test": "\n\n    var arg00 : String = \"\"\"xyzw\"\"\"\n    var arg01 : String = \"\"\"xyw\"\"\"\n    var x0 : Boolean = cycpatternCheck(arg00, arg01)\n    var v0 : Boolean = false\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"yello\"\"\"\n    var arg11 : String = \"\"\"ell\"\"\"\n    var x1 : Boolean = cycpatternCheck(arg10, arg11)\n    var v1 : Boolean = true\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"whattup\"\"\"\n    var arg21 : String = \"\"\"ptut\"\"\"\n    var x2 : Boolean = cycpatternCheck(arg20, arg21)\n    var v2 : Boolean = false\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"efef\"\"\"\n    var arg31 : String = \"\"\"fee\"\"\"\n    var x3 : Boolean = cycpatternCheck(arg30, arg31)\n    var v3 : Boolean = true\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"abab\"\"\"\n    var arg41 : String = \"\"\"aabb\"\"\"\n    var x4 : Boolean = cycpatternCheck(arg40, arg41)\n    var v4 : Boolean = false\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"winemtt\"\"\"\n    var arg51 : String = \"\"\"tinem\"\"\"\n    var x5 : Boolean = cycpatternCheck(arg50, arg51)\n    var v5 : Boolean = true\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n\n}\n", "description": "Je krijgt 2 woorden. Je moet True teruggeven als het tweede woord of een van zijn rotaties een substring is in het eerste woord.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/75", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Gegeven een positief geheel getal, verkrijg de Romeinse cijfer equivalent als een string en retourneer het in kleine letters.\n     * Beperkingen: 1 <= num <= 1000\n     * \n     * Voorbeelden:\n     * >>> int_to_mini_roman(19) == 'xix'\n     * >>> int_to_mini_roman(152) == 'clii'\n     * >>> int_to_mini_roman(426) == 'cdxxvi'\n     *\n     */\n    def intToMiniRoman(number : Int) : String = {\n", "entry_point": "intToMiniRoman", "test": "\n\n    var arg00 : Int = 19\n    var x0 : String = intToMiniRoman(arg00)\n    var v0 : String = \"\"\"xix\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 152\n    var x1 : String = intToMiniRoman(arg10)\n    var v1 : String = \"\"\"clii\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 251\n    var x2 : String = intToMiniRoman(arg20)\n    var v2 : String = \"\"\"ccli\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 426\n    var x3 : String = intToMiniRoman(arg30)\n    var v3 : String = \"\"\"cdxxvi\"\"\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 500\n    var x4 : String = intToMiniRoman(arg40)\n    var v4 : String = \"\"\"d\"\"\"\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 1\n    var x5 : String = intToMiniRoman(arg50)\n    var v5 : String = \"\"\"i\"\"\"\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 4\n    var x6 : String = intToMiniRoman(arg60)\n    var v6 : String = \"\"\"iv\"\"\"\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : Int = 43\n    var x7 : String = intToMiniRoman(arg70)\n    var v7 : String = \"\"\"xliii\"\"\"\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : Int = 90\n    var x8 : String = intToMiniRoman(arg80)\n    var v8 : String = \"\"\"xc\"\"\"\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : Int = 94\n    var x9 : String = intToMiniRoman(arg90)\n    var v9 : String = \"\"\"xciv\"\"\"\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n    var arg100 : Int = 532\n    var x10 : String = intToMiniRoman(arg100)\n    var v10 : String = \"\"\"dxxxii\"\"\"\n    assert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \" + x10)\n\n    var arg110 : Int = 900\n    var x11 : String = intToMiniRoman(arg110)\n    var v11 : String = \"\"\"cm\"\"\"\n    assert(x11 == v11, \"Exception -- test case 11 did not pass. x11 = \" + x11)\n\n    var arg120 : Int = 994\n    var x12 : String = intToMiniRoman(arg120)\n    var v12 : String = \"\"\"cmxciv\"\"\"\n    assert(x12 == v12, \"Exception -- test case 12 did not pass. x12 = \" + x12)\n\n    var arg130 : Int = 1000\n    var x13 : String = intToMiniRoman(arg130)\n    var v13 : String = \"\"\"m\"\"\"\n    assert(x13 == v13, \"Exception -- test case 13 did not pass. x13 = \" + x13)\n\n\n}\n", "description": "Gegeven een positief geheel getal, verkrijg de Romeinse cijfer equivalent als een string en retourneer het in kleine letters.\nBeperkingen: 1 <= num <= 1000\n\nVoorbeelden:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/76", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Gegeven de lengtes van de drie zijden van een driehoek. Geef True terug als de drie zijden een rechthoekige driehoek vormen, anders False. Een rechthoekige driehoek is een driehoek waarin één hoek een rechte hoek of 90 graden is. Voorbeeld:\n     * \n     * right_angle_triangle(3, 4, 5) == True\n     * right_angle_triangle(1, 2, 3) == False\n     *\n     */\n    def rightAngleTriangle(a : Int, b : Int, c : Int) : Boolean = {\n", "entry_point": "rightAngleTriangle", "test": "\n\n    var arg00 : Int = 3\n    var arg01 : Int = 4\n    var arg02 : Int = 5\n    var x0 : Boolean = rightAngleTriangle(arg00, arg01, arg02)\n    var v0 : Boolean = true\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 1\n    var arg11 : Int = 2\n    var arg12 : Int = 3\n    var x1 : Boolean = rightAngleTriangle(arg10, arg11, arg12)\n    var v1 : Boolean = false\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 10\n    var arg21 : Int = 6\n    var arg22 : Int = 8\n    var x2 : Boolean = rightAngleTriangle(arg20, arg21, arg22)\n    var v2 : Boolean = true\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 2\n    var arg31 : Int = 2\n    var arg32 : Int = 2\n    var x3 : Boolean = rightAngleTriangle(arg30, arg31, arg32)\n    var v3 : Boolean = false\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : Int = 7\n    var arg41 : Int = 24\n    var arg42 : Int = 25\n    var x4 : Boolean = rightAngleTriangle(arg40, arg41, arg42)\n    var v4 : Boolean = true\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : Int = 10\n    var arg51 : Int = 5\n    var arg52 : Int = 7\n    var x5 : Boolean = rightAngleTriangle(arg50, arg51, arg52)\n    var v5 : Boolean = false\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : Int = 5\n    var arg61 : Int = 12\n    var arg62 : Int = 13\n    var x6 : Boolean = rightAngleTriangle(arg60, arg61, arg62)\n    var v6 : Boolean = true\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : Int = 15\n    var arg71 : Int = 8\n    var arg72 : Int = 17\n    var x7 : Boolean = rightAngleTriangle(arg70, arg71, arg72)\n    var v7 : Boolean = true\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n    var arg80 : Int = 48\n    var arg81 : Int = 55\n    var arg82 : Int = 73\n    var x8 : Boolean = rightAngleTriangle(arg80, arg81, arg82)\n    var v8 : Boolean = true\n    assert(x8 == v8, \"Exception -- test case 8 did not pass. x8 = \" + x8)\n\n    var arg90 : Int = 1\n    var arg91 : Int = 1\n    var arg92 : Int = 1\n    var x9 : Boolean = rightAngleTriangle(arg90, arg91, arg92)\n    var v9 : Boolean = false\n    assert(x9 == v9, \"Exception -- test case 9 did not pass. x9 = \" + x9)\n\n    var arg100 : Int = 2\n    var arg101 : Int = 2\n    var arg102 : Int = 10\n    var x10 : Boolean = rightAngleTriangle(arg100, arg101, arg102)\n    var v10 : Boolean = false\n    assert(x10 == v10, \"Exception -- test case 10 did not pass. x10 = \" + x10)\n\n\n}\n", "description": "Gegeven de lengtes van de drie zijden van een driehoek. Geef True terug als de drie zijden een rechthoekige driehoek vormen, anders False. Een rechthoekige driehoek is een driehoek waarin één hoek een rechte hoek of 90 graden is. Voorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/77", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * Je krijgt een string s.\n     *     Als s[i] een letter is, keer dan de hoofdletter om naar kleine letter of andersom,\n     *     anders laat het zoals het is.\n     *     Als de string geen letters bevat, keer dan de string om.\n     *     De functie moet de resulterende string retourneren.\n     *     Voorbeelden\n     * \n     * solve(\"1234\") = \"4321\"\n     * solve(\"ab\") = \"AB\"\n     * solve(\"#a@C\") = \"#A@c\"\n     *\n     */\n    def solve(s : String) : String = {\n", "entry_point": "solve", "test": "\n\n    var arg00 : String = \"\"\"AsDf\"\"\"\n    var x0 : String = solve(arg00)\n    var v0 : String = \"\"\"aSdF\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"1234\"\"\"\n    var x1 : String = solve(arg10)\n    var v1 : String = \"\"\"4321\"\"\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"ab\"\"\"\n    var x2 : String = solve(arg20)\n    var v2 : String = \"\"\"AB\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"#a@C\"\"\"\n    var x3 : String = solve(arg30)\n    var v3 : String = \"\"\"#A@c\"\"\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n    var arg40 : String = \"\"\"#AsdfW^45\"\"\"\n    var x4 : String = solve(arg40)\n    var v4 : String = \"\"\"#aSDFw^45\"\"\"\n    assert(x4 == v4, \"Exception -- test case 4 did not pass. x4 = \" + x4)\n\n    var arg50 : String = \"\"\"#6@2\"\"\"\n    var x5 : String = solve(arg50)\n    var v5 : String = \"\"\"2@6#\"\"\"\n    assert(x5 == v5, \"Exception -- test case 5 did not pass. x5 = \" + x5)\n\n    var arg60 : String = \"\"\"#\\$a^D\"\"\"\n    var x6 : String = solve(arg60)\n    var v6 : String = \"\"\"#\\$A^d\"\"\"\n    assert(x6 == v6, \"Exception -- test case 6 did not pass. x6 = \" + x6)\n\n    var arg70 : String = \"\"\"#ccc\"\"\"\n    var x7 : String = solve(arg70)\n    var v7 : String = \"\"\"#CCC\"\"\"\n    assert(x7 == v7, \"Exception -- test case 7 did not pass. x7 = \" + x7)\n\n\n}\n", "description": "Je krijgt een string s.\n    Als s[i] een letter is, keer dan de hoofdletter om naar kleine letter of andersom,\n    anders laat het zoals het is.\n    Als de string geen letters bevat, keer dan de string om.\n    De functie moet de resulterende string retourneren.\n    Voorbeelden", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/78", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Gegeven een string 'text', retourneer de md5 hash equivalent string.\n     * Als 'text' een lege string is, retourneer dan null.\n     * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n     *\n     */\n    def stringToMd5(text : String) : Any = {\n", "entry_point": "stringToMd5", "test": "\n\n    var arg00 : String = \"\"\"Hello world\"\"\"\n    var x0 : Any = stringToMd5(arg00)\n    var v0 : Any = \"\"\"3e25960a79dbc69b674cd4ec67a72c62\"\"\"\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : String = \"\"\"\"\"\"\n    var x1 : Any = stringToMd5(arg10)\n    var v1 : Any = \"none\"\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : String = \"\"\"A B C\"\"\"\n    var x2 : Any = stringToMd5(arg20)\n    var v2 : Any = \"\"\"0ef78513b0cb8cef12743f5aeb35f888\"\"\"\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : String = \"\"\"password\"\"\"\n    var x3 : Any = stringToMd5(arg30)\n    var v3 : Any = \"\"\"5f4dcc3b5aa765d61d8327deb882cf99\"\"\"\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n\n}\n", "description": "Gegeven een string 'text', retourneer de md5 hash equivalent string.\nAls 'text' een lege string is, retourneer dan null.", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "scala/79", "prompt": "object Main extends App {\n    /**\n     * Je bent een ervaren Scala-programmeur en hier is jouw taak.\n     * * Gegeven twee positieve gehele getallen a en b, retourneer de even cijfers tussen a en b, in oplopende volgorde.\n     * \n     * Bijvoorbeeld:\n     * \n     * generate_integers(2, 8) => [2, 4, 6, 8]\n     * generate_integers(8, 2) => [2, 4, 6, 8]\n     * generate_integers(10, 14) => []\n     *\n     */\n    def generateIntegers(a : Int, b : Int) : List[Any] = {\n", "entry_point": "generateIntegers", "test": "\n\n    var arg00 : Int = 2\n    var arg01 : Int = 10\n    var x0 : List[Any] = generateIntegers(arg00, arg01)\n    var v0 : List[Any] = List(2, 4, 6, 8)\n    assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)\n\n    var arg10 : Int = 10\n    var arg11 : Int = 2\n    var x1 : List[Any] = generateIntegers(arg10, arg11)\n    var v1 : List[Any] = List(2, 4, 6, 8)\n    assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)\n\n    var arg20 : Int = 132\n    var arg21 : Int = 2\n    var x2 : List[Any] = generateIntegers(arg20, arg21)\n    var v2 : List[Any] = List(2, 4, 6, 8)\n    assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)\n\n    var arg30 : Int = 17\n    var arg31 : Int = 89\n    var x3 : List[Any] = generateIntegers(arg30, arg31)\n    var v3 : List[Any] = List()\n    assert(x3 == v3, \"Exception -- test case 3 did not pass. x3 = \" + x3)\n\n\n}\n", "description": "Gegeven twee positieve gehele getallen a en b, retourneer de even cijfers tussen a en b, in oplopende volgorde.\n\nBijvoorbeeld:", "language": "scala", "canonical_solution": NaN, "natural_language": "Dutch"}
