{"task_id": "javascript/0", "prompt": "/**\n * \n * تم تزويدك بقائمة عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفري. مهمتك هي الكشف عما إذا كان رصيد الحساب ينخفض دون الصفر في أي نقطة، وفي ذلك الوقت يجب أن تعيد الدالة True. وإلا يجب أن تعيد False.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n *\n */\nfunction belowZero(operations) {\n", "entry_point": "belowZero", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [];\nvar x0 = belowZero(arg00);\nvar v0 = false;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1, 2, -3, 1, 2, -3];\nvar x1 = belowZero(arg10);\nvar v1 = false;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [1, 2, -4, 5, 6];\nvar x2 = belowZero(arg20);\nvar v2 = true;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [1, -1, 2, -2, 5, -5, 4, -4];\nvar x3 = belowZero(arg30);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [1, -1, 2, -2, 5, -5, 4, -5];\nvar x4 = belowZero(arg40);\nvar v4 = true;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [1, -2, 2, -2, 5, -5, 4, -4];\nvar x5 = belowZero(arg50);\nvar v5 = true;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * تم تزويدك بقائمة عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفري. مهمتك هي الكشف عما إذا كان رصيد الحساب ينخفض دون الصفر في أي نقطة، وفي ذلك الوقت يجب أن تعيد الدالة True. وإلا يجب أن تعيد False.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/1", "prompt": "/**\n * \n * لقائمة معينة من الأعداد الصحيحة، أرجع tuple يتكون من مجموع وضرب جميع الأعداد في القائمة.\n * يجب أن يكون مجموع القائمة الفارغة يساوي 0 وضربها الفارغ يساوي 1.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n *\n */\nfunction sumProduct(numbers) {\n", "entry_point": "sumProduct", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [];\nvar x0 = sumProduct(arg00);\nvar v0 = [0, 1];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1, 1, 1];\nvar x1 = sumProduct(arg10);\nvar v1 = [3, 1];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [100, 0];\nvar x2 = sumProduct(arg20);\nvar v2 = [100, 0];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [3, 5, 7];\nvar x3 = sumProduct(arg30);\nvar v3 = [15, 105];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [10];\nvar x4 = sumProduct(arg40);\nvar v4 = [10, 10];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * لقائمة معينة من الأعداد الصحيحة، أرجع tuple يتكون من مجموع وضرب جميع الأعداد في القائمة.\n * يجب أن يكون مجموع القائمة الفارغة يساوي 0 وضربها الفارغ يساوي 1.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/2", "prompt": "/**\n * \n * المدخلات هي سلسلتان a و b تتكونان فقط من 1 و 0.\n *     قم بتنفيذ عملية XOR الثنائية على هذه المدخلات وإرجاع النتيجة أيضًا كسلسلة.\n * >>> string_xor('010', '110')\n * '100'\n *\n */\nfunction stringXor(a, b) {\n", "entry_point": "stringXor", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"111000\";\nvar arg01 = \"101010\";\nvar x0 = stringXor(arg00, arg01);\nvar v0 = \"010010\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"1\";\nvar arg11 = \"1\";\nvar x1 = stringXor(arg10, arg11);\nvar v1 = \"0\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"0101\";\nvar arg21 = \"0000\";\nvar x2 = stringXor(arg20, arg21);\nvar v2 = \"0101\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * المدخلات هي سلسلتان a و b تتكونان فقط من 1 و 0.\n *     قم بتنفيذ عملية XOR الثنائية على هذه المدخلات وإرجاع النتيجة أيضًا كسلسلة.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/3", "prompt": "/**\n * \n * من بين قائمة السلاسل، ارجع الأطول. ارجع الأولى في حالة وجود عدة سلاسل بنفس الطول. ارجع قيمة فارغة في حالة أن القائمة الدخلية فارغة.\n * >>> longest([])\n\n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n *\n */\nfunction longest(strings) {\n", "entry_point": "longest", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [];\nvar x0 = longest(arg00);\nvar v0 = null;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [\"x\", \"y\", \"z\"];\nvar x1 = longest(arg10);\nvar v1 = \"x\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"];\nvar x2 = longest(arg20);\nvar v2 = \"zzzz\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * من بين قائمة السلاسل، ارجع الأطول. ارجع الأولى في حالة وجود عدة سلاسل بنفس الطول. ارجع قيمة فارغة في حالة أن القائمة الدخلية فارغة.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/4", "prompt": "/**\n * \n * إرجاع أكبر مقسوم مشترك بين عددين a و b\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n *\n */\nfunction greatestCommonDivisor(a, b) {\n", "entry_point": "greatestCommonDivisor", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 3;\nvar arg01 = 7;\nvar x0 = greatestCommonDivisor(arg00, arg01);\nvar v0 = 1;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 10;\nvar arg11 = 15;\nvar x1 = greatestCommonDivisor(arg10, arg11);\nvar v1 = 5;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 49;\nvar arg21 = 14;\nvar x2 = greatestCommonDivisor(arg20, arg21);\nvar v2 = 7;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 144;\nvar arg31 = 60;\nvar x3 = greatestCommonDivisor(arg30, arg31);\nvar v3 = 12;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * إرجاع أكبر مقسوم مشترك بين عددين a و b\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/5", "prompt": "/**\n * \n * المدخلات هي سلسلة من الأرقام المفصولة بمسافة من \"صفر\" إلى \"تسعة\".\n * الخيارات الصالحة هي \"صفر\"، \"واحد\"، \"اثنان\"، \"ثلاثة\"، \"أربعة\"، \"خمسة\"، \"ستة\"، \"سبعة\"، \"ثمانية\" و \"تسعة\".\n * إرجاع السلسلة مع الأرقام مرتبة من الأصغر إلى الأكبر.\n * >>> sort_numbers('three one five')\n * 'one three five'\n *\n */\nfunction sortNumbers(numbers) {\n", "entry_point": "sortNumbers", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"\";\nvar x0 = sortNumbers(arg00);\nvar v0 = \"\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"three\";\nvar x1 = sortNumbers(arg10);\nvar v1 = \"three\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"three five nine\";\nvar x2 = sortNumbers(arg20);\nvar v2 = \"three five nine\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"five zero four seven nine eight\";\nvar x3 = sortNumbers(arg30);\nvar v3 = \"zero four five seven eight nine\";\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"six five four three two one zero\";\nvar x4 = sortNumbers(arg40);\nvar v4 = \"zero one two three four five six\";\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * المدخلات هي سلسلة من الأرقام المفصولة بمسافة من \"صفر\" إلى \"تسعة\".\n * الخيارات الصالحة هي \"صفر\"، \"واحد\"، \"اثنان\"، \"ثلاثة\"، \"أربعة\"، \"خمسة\"، \"ستة\"، \"سبعة\"، \"ثمانية\" و \"تسعة\".\n * إرجاع السلسلة مع الأرقام مرتبة من الأصغر إلى الأكبر.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/6", "prompt": "/**\n * \n * عندما يتم إعطاء قائمة من الأرقام (تحتوي على على الأقل عنصرين)، يتم تطبيق تحويل خطي على تلك القائمة، بحيث يتم جعل العدد الأصغر يصبح 0 والأكبر يصبح 1.\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n *\n */\nfunction rescaleToUnit(numbers) {\n", "entry_point": "rescaleToUnit", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [2.0, 49.9];\nvar x0 = rescaleToUnit(arg00);\nvar v0 = [0.0, 1.0];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [100.0, 49.9];\nvar x1 = rescaleToUnit(arg10);\nvar v1 = [1.0, 0.0];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [1.0, 2.0, 3.0, 4.0, 5.0];\nvar x2 = rescaleToUnit(arg20);\nvar v2 = [0.0, 0.25, 0.5, 0.75, 1.0];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [2.0, 1.0, 5.0, 3.0, 4.0];\nvar x3 = rescaleToUnit(arg30);\nvar v3 = [0.25, 0.0, 1.0, 0.5, 0.75];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [12.0, 11.0, 15.0, 13.0, 14.0];\nvar x4 = rescaleToUnit(arg40);\nvar v4 = [0.25, 0.0, 1.0, 0.5, 0.75];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * عندما يتم إعطاء قائمة من الأرقام (تحتوي على على الأقل عنصرين)، يتم تطبيق تحويل خطي على تلك القائمة، بحيث يتم جعل العدد الأصغر يصبح 0 والأكبر يصبح 1.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/7", "prompt": "/**\n * \n * لسلسلة محددة، قم بتبديل الأحرف الصغيرة إلى أحرف كبيرة والأحرف الكبيرة إلى أحرف صغيرة.\n * >>> flip_case('Hello')\n * 'hELLO'\n *\n */\nfunction flipCase(string) {\n", "entry_point": "flipCase", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"\";\nvar x0 = flipCase(arg00);\nvar v0 = \"\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"Hello!\";\nvar x1 = flipCase(arg10);\nvar v1 = \"hELLO!\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"These violent delights have violent ends\";\nvar x2 = flipCase(arg20);\nvar v2 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * لسلسلة محددة، قم بتبديل الأحرف الصغيرة إلى أحرف كبيرة والأحرف الكبيرة إلى أحرف صغيرة.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/8", "prompt": "/**\n * \n * ارجع فقط الأرقام الإيجابية في القائمة.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n *\n */\nfunction getPositive(l) {\n", "entry_point": "getPositive", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [-1, -2, 4, 5, 6];\nvar x0 = getPositive(arg00);\nvar v0 = [4, 5, 6];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10];\nvar x1 = getPositive(arg10);\nvar v1 = [5, 3, 2, 3, 3, 9, 123, 1];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [-1, -2];\nvar x2 = getPositive(arg20);\nvar v2 = [];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [];\nvar x3 = getPositive(arg30);\nvar v3 = [];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * ارجع فقط الأرقام الإيجابية في القائمة.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/9", "prompt": "/**\n * \n * إرجاع صحيح إذا كان الرقم المعطى هو عدد أولي، وإلا فهو خطأ.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n *\n */\nfunction isPrime(n) {\n", "entry_point": "isPrime", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 6;\nvar x0 = isPrime(arg00);\nvar v0 = false;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 101;\nvar x1 = isPrime(arg10);\nvar v1 = true;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 11;\nvar x2 = isPrime(arg20);\nvar v2 = true;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 13441;\nvar x3 = isPrime(arg30);\nvar v3 = true;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 61;\nvar x4 = isPrime(arg40);\nvar v4 = true;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 4;\nvar x5 = isPrime(arg50);\nvar v5 = false;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 1;\nvar x6 = isPrime(arg60);\nvar v6 = false;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = 5;\nvar x7 = isPrime(arg70);\nvar v7 = true;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = 11;\nvar x8 = isPrime(arg80);\nvar v8 = true;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = 17;\nvar x9 = isPrime(arg90);\nvar v9 = true;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg100 = 85;\nvar x10 = isPrime(arg100);\nvar v10 = false;\nif(!compare(x10, v10)){\n    throw 'Error at 11th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg110 = 77;\nvar x11 = isPrime(arg110);\nvar v11 = false;\nif(!compare(x11, v11)){\n    throw 'Error at 12th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg120 = 255379;\nvar x12 = isPrime(arg120);\nvar v12 = false;\nif(!compare(x12, v12)){\n    throw 'Error at 13th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * إرجاع صحيح إذا كان الرقم المعطى هو عدد أولي، وإلا فهو خطأ.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/10", "prompt": "/**\n * \n * إرجاع عناصر فريدة مرتبة في قائمة\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n *\n */\nfunction unique(l) {\n", "entry_point": "unique", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [5, 3, 5, 2, 3, 3, 9, 0, 123];\nvar x0 = unique(arg00);\nvar v0 = [0, 2, 3, 5, 9, 123];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * إرجاع عناصر فريدة مرتبة في قائمة\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/11", "prompt": "/**\n * * \n * prime_fib يعيد العدد رقم n الذي هو عدد فيبوناتشي وهو أيضًا عدد أولي.\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n *\n */\nfunction primeFib(n) {\n", "entry_point": "primeFib", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 1;\nvar x0 = primeFib(arg00);\nvar v0 = 2;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 2;\nvar x1 = primeFib(arg10);\nvar v1 = 3;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 3;\nvar x2 = primeFib(arg20);\nvar v2 = 5;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 4;\nvar x3 = primeFib(arg30);\nvar v3 = 13;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 5;\nvar x4 = primeFib(arg40);\nvar v4 = 89;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 6;\nvar x5 = primeFib(arg50);\nvar v5 = 233;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 7;\nvar x6 = primeFib(arg60);\nvar v6 = 1597;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = 8;\nvar x7 = primeFib(arg70);\nvar v7 = 28657;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = 9;\nvar x8 = primeFib(arg80);\nvar v8 = 514229;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = 10;\nvar x9 = primeFib(arg90);\nvar v9 = 433494437;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * prime_fib يعيد العدد رقم n الذي هو عدد فيبوناتشي وهو أيضًا عدد أولي.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/12", "prompt": "/**\n * * \n * تأخذ triples_sum_to_zero قائمة من الأعداد الصحيحة كمدخلات.\n *     يعيد True إذا كان هناك ثلاثة عناصر متميزة في القائمة تجمع إلى الصفر ، و False في الحالة الأخرى.\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n *\n */\nfunction triplesSumToZero(l) {\n", "entry_point": "triplesSumToZero", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [1, 3, 5, 0];\nvar x0 = triplesSumToZero(arg00);\nvar v0 = false;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1, 3, 5, -1];\nvar x1 = triplesSumToZero(arg10);\nvar v1 = false;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [1, 3, -2, 1];\nvar x2 = triplesSumToZero(arg20);\nvar v2 = true;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [1, 2, 3, 7];\nvar x3 = triplesSumToZero(arg30);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [1, 2, 5, 7];\nvar x4 = triplesSumToZero(arg40);\nvar v4 = false;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [2, 4, -5, 3, 9, 7];\nvar x5 = triplesSumToZero(arg50);\nvar v5 = true;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = [1];\nvar x6 = triplesSumToZero(arg60);\nvar v6 = false;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = [1, 3, 5, -100];\nvar x7 = triplesSumToZero(arg70);\nvar v7 = false;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = [100, 3, 5, -100];\nvar x8 = triplesSumToZero(arg80);\nvar v8 = false;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * تأخذ triples_sum_to_zero قائمة من الأعداد الصحيحة كمدخلات.\n *     يعيد True إذا كان هناك ثلاثة عناصر متميزة في القائمة تجمع إلى الصفر ، و False في الحالة الأخرى.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/13", "prompt": "/**\n * * \n * يأخذ pairs_sum_to_zero قائمة من الأعداد الصحيحة كمدخلات.\n * يعيد True إذا كان هناك عنصران متميزان في القائمة يجمعان إلى الصفر ، و False في الحالة الأخرى.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n *\n */\nfunction pairsSumToZero(l) {\n", "entry_point": "pairsSumToZero", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [1, 3, 5, 0];\nvar x0 = pairsSumToZero(arg00);\nvar v0 = false;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1, 3, -2, 1];\nvar x1 = pairsSumToZero(arg10);\nvar v1 = false;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [1, 2, 3, 7];\nvar x2 = pairsSumToZero(arg20);\nvar v2 = false;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [2, 4, -5, 3, 5, 7];\nvar x3 = pairsSumToZero(arg30);\nvar v3 = true;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [1];\nvar x4 = pairsSumToZero(arg40);\nvar v4 = false;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [-3, 9, -1, 3, 2, 30];\nvar x5 = pairsSumToZero(arg50);\nvar v5 = true;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = [-3, 9, -1, 3, 2, 31];\nvar x6 = pairsSumToZero(arg60);\nvar v6 = true;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = [-3, 9, -1, 4, 2, 30];\nvar x7 = pairsSumToZero(arg70);\nvar v7 = false;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = [-3, 9, -1, 4, 2, 31];\nvar x8 = pairsSumToZero(arg80);\nvar v8 = false;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * يأخذ pairs_sum_to_zero قائمة من الأعداد الصحيحة كمدخلات.\n * يعيد True إذا كان هناك عنصران متميزان في القائمة يجمعان إلى الصفر ، و False في الحالة الأخرى.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/14", "prompt": "/**\n * \n * تتمثل متتابعة أرقام Fib4 في متتابعة مشابهة لمتتابعة فيبوناتشي والتي تعرف على النحو التالي:\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n *     يرجى كتابة وظيفة لحساب العنصر الثامن من متتابعة أرقام Fib4 بكفاءة. لا تستخدم الاستدعاء العكسي.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n *\n */\nfunction fib4(n) {\n", "entry_point": "fib4", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 5;\nvar x0 = fib4(arg00);\nvar v0 = 4;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 8;\nvar x1 = fib4(arg10);\nvar v1 = 28;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 10;\nvar x2 = fib4(arg20);\nvar v2 = 104;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 12;\nvar x3 = fib4(arg30);\nvar v3 = 386;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * تتمثل متتابعة أرقام Fib4 في متتابعة مشابهة لمتتابعة فيبوناتشي والتي تعرف على النحو التالي:\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n *     يرجى كتابة وظيفة لحساب العنصر الثامن من متتابعة أرقام Fib4 بكفاءة. لا تستخدم الاستدعاء العكسي.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/15", "prompt": "/**\n * \n * إرجاع الوسيط لعناصر القائمة l.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n *\n */\nfunction median(l) {\n", "entry_point": "median", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [3, 1, 2, 4, 5];\nvar x0 = median(arg00);\nvar v0 = 3;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [-10, 4, 6, 1000, 10, 20];\nvar x1 = median(arg10);\nvar v1 = 8.0;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [5];\nvar x2 = median(arg20);\nvar v2 = 5;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [6, 5];\nvar x3 = median(arg30);\nvar v3 = 5.5;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [8, 1, 3, 9, 9, 2, 7];\nvar x4 = median(arg40);\nvar v4 = 7;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * إرجاع الوسيط لعناصر القائمة l.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/16", "prompt": "/**\n * * \n * يتحقق مما إذا كانت السلسلة المعطاة هي باليندروم.\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n *\n */\nfunction isPalindrome(text) {\n", "entry_point": "isPalindrome", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"\";\nvar x0 = isPalindrome(arg00);\nvar v0 = true;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"aba\";\nvar x1 = isPalindrome(arg10);\nvar v1 = true;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"aaaaa\";\nvar x2 = isPalindrome(arg20);\nvar v2 = true;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"zbcd\";\nvar x3 = isPalindrome(arg30);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"xywyx\";\nvar x4 = isPalindrome(arg40);\nvar v4 = true;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"xywyz\";\nvar x5 = isPalindrome(arg50);\nvar v5 = false;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"xywzx\";\nvar x6 = isPalindrome(arg60);\nvar v6 = false;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * يتحقق مما إذا كانت السلسلة المعطاة هي باليندروم.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/17", "prompt": "/**\n * * \n * remove_vowels هي وظيفة تأخذ سلسلة نصية وتعيد سلسلة نصية بدون حروف العلة.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n *\n */\nfunction removeVowels(text) {\n", "entry_point": "removeVowels", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"\";\nvar x0 = removeVowels(arg00);\nvar v0 = \"\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"abcdef\\nghijklm\";\nvar x1 = removeVowels(arg10);\nvar v1 = \"bcdf\\nghjklm\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"fedcba\";\nvar x2 = removeVowels(arg20);\nvar v2 = \"fdcb\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"eeeee\";\nvar x3 = removeVowels(arg30);\nvar v3 = \"\";\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"acBAA\";\nvar x4 = removeVowels(arg40);\nvar v4 = \"cB\";\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"EcBOO\";\nvar x5 = removeVowels(arg50);\nvar v5 = \"cB\";\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"ybcd\";\nvar x6 = removeVowels(arg60);\nvar v6 = \"ybcd\";\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * remove_vowels هي وظيفة تأخذ سلسلة نصية وتعيد سلسلة نصية بدون حروف العلة.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/18", "prompt": "/**\n * \n * \"ارجع صحيح إذا كانت جميع الأرقام في القائمة l أقل من الحد t.\"\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n *\n */\nfunction belowThreshold(l, t) {\n", "entry_point": "belowThreshold", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [1, 2, 4, 10];\nvar arg01 = 100;\nvar x0 = belowThreshold(arg00, arg01);\nvar v0 = true;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1, 20, 4, 10];\nvar arg11 = 5;\nvar x1 = belowThreshold(arg10, arg11);\nvar v1 = false;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [1, 20, 4, 10];\nvar arg21 = 21;\nvar x2 = belowThreshold(arg20, arg21);\nvar v2 = true;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [1, 20, 4, 10];\nvar arg31 = 22;\nvar x3 = belowThreshold(arg30, arg31);\nvar v3 = true;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [1, 8, 4, 10];\nvar arg41 = 11;\nvar x4 = belowThreshold(arg40, arg41);\nvar v4 = true;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [1, 8, 4, 10];\nvar arg51 = 10;\nvar x5 = belowThreshold(arg50, arg51);\nvar v5 = false;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * \"ارجع صحيح إذا كانت جميع الأرقام في القائمة l أقل من الحد t.\"\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/19", "prompt": "/**\n * \n * إضافة رقمين x و y\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n *\n */\nfunction add(x, y) {\n", "entry_point": "add", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 0;\nvar arg01 = 1;\nvar x0 = add(arg00, arg01);\nvar v0 = 1;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 1;\nvar arg11 = 0;\nvar x1 = add(arg10, arg11);\nvar v1 = 1;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 2;\nvar arg21 = 3;\nvar x2 = add(arg20, arg21);\nvar v2 = 5;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 5;\nvar arg31 = 7;\nvar x3 = add(arg30, arg31);\nvar v3 = 12;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 7;\nvar arg41 = 5;\nvar x4 = add(arg40, arg41);\nvar v4 = 12;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 572;\nvar arg51 = 725;\nvar x5 = add(arg50, arg51);\nvar v5 = 1297;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 51;\nvar arg61 = 804;\nvar x6 = add(arg60, arg61);\nvar v6 = 855;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = 645;\nvar arg71 = 96;\nvar x7 = add(arg70, arg71);\nvar v7 = 741;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = 712;\nvar arg81 = 853;\nvar x8 = add(arg80, arg81);\nvar v8 = 1565;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = 223;\nvar arg91 = 101;\nvar x9 = add(arg90, arg91);\nvar v9 = 324;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg100 = 76;\nvar arg101 = 29;\nvar x10 = add(arg100, arg101);\nvar v10 = 105;\nif(!compare(x10, v10)){\n    throw 'Error at 11th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg110 = 416;\nvar arg111 = 149;\nvar x11 = add(arg110, arg111);\nvar v11 = 565;\nif(!compare(x11, v11)){\n    throw 'Error at 12th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg120 = 145;\nvar arg121 = 409;\nvar x12 = add(arg120, arg121);\nvar v12 = 554;\nif(!compare(x12, v12)){\n    throw 'Error at 13th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg130 = 535;\nvar arg131 = 430;\nvar x13 = add(arg130, arg131);\nvar v13 = 965;\nif(!compare(x13, v13)){\n    throw 'Error at 14th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg140 = 118;\nvar arg141 = 303;\nvar x14 = add(arg140, arg141);\nvar v14 = 421;\nif(!compare(x14, v14)){\n    throw 'Error at 15th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg150 = 287;\nvar arg151 = 94;\nvar x15 = add(arg150, arg151);\nvar v15 = 381;\nif(!compare(x15, v15)){\n    throw 'Error at 16th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg160 = 768;\nvar arg161 = 257;\nvar x16 = add(arg160, arg161);\nvar v16 = 1025;\nif(!compare(x16, v16)){\n    throw 'Error at 17th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg170 = 421;\nvar arg171 = 677;\nvar x17 = add(arg170, arg171);\nvar v17 = 1098;\nif(!compare(x17, v17)){\n    throw 'Error at 18th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg180 = 802;\nvar arg181 = 814;\nvar x18 = add(arg180, arg181);\nvar v18 = 1616;\nif(!compare(x18, v18)){\n    throw 'Error at 19th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg190 = 510;\nvar arg191 = 922;\nvar x19 = add(arg190, arg191);\nvar v19 = 1432;\nif(!compare(x19, v19)){\n    throw 'Error at 20th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg200 = 345;\nvar arg201 = 819;\nvar x20 = add(arg200, arg201);\nvar v20 = 1164;\nif(!compare(x20, v20)){\n    throw 'Error at 21th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg210 = 895;\nvar arg211 = 436;\nvar x21 = add(arg210, arg211);\nvar v21 = 1331;\nif(!compare(x21, v21)){\n    throw 'Error at 22th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg220 = 123;\nvar arg221 = 424;\nvar x22 = add(arg220, arg221);\nvar v22 = 547;\nif(!compare(x22, v22)){\n    throw 'Error at 23th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg230 = 923;\nvar arg231 = 245;\nvar x23 = add(arg230, arg231);\nvar v23 = 1168;\nif(!compare(x23, v23)){\n    throw 'Error at 24th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg240 = 23;\nvar arg241 = 438;\nvar x24 = add(arg240, arg241);\nvar v24 = 461;\nif(!compare(x24, v24)){\n    throw 'Error at 25th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg250 = 565;\nvar arg251 = 133;\nvar x25 = add(arg250, arg251);\nvar v25 = 698;\nif(!compare(x25, v25)){\n    throw 'Error at 26th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg260 = 945;\nvar arg261 = 925;\nvar x26 = add(arg260, arg261);\nvar v26 = 1870;\nif(!compare(x26, v26)){\n    throw 'Error at 27th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg270 = 261;\nvar arg271 = 983;\nvar x27 = add(arg270, arg271);\nvar v27 = 1244;\nif(!compare(x27, v27)){\n    throw 'Error at 28th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg280 = 139;\nvar arg281 = 577;\nvar x28 = add(arg280, arg281);\nvar v28 = 716;\nif(!compare(x28, v28)){\n    throw 'Error at 29th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg290 = 763;\nvar arg291 = 178;\nvar x29 = add(arg290, arg291);\nvar v29 = 941;\nif(!compare(x29, v29)){\n    throw 'Error at 30th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg300 = 147;\nvar arg301 = 892;\nvar x30 = add(arg300, arg301);\nvar v30 = 1039;\nif(!compare(x30, v30)){\n    throw 'Error at 31th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg310 = 436;\nvar arg311 = 402;\nvar x31 = add(arg310, arg311);\nvar v31 = 838;\nif(!compare(x31, v31)){\n    throw 'Error at 32th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg320 = 610;\nvar arg321 = 581;\nvar x32 = add(arg320, arg321);\nvar v32 = 1191;\nif(!compare(x32, v32)){\n    throw 'Error at 33th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg330 = 103;\nvar arg331 = 416;\nvar x33 = add(arg330, arg331);\nvar v33 = 519;\nif(!compare(x33, v33)){\n    throw 'Error at 34th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg340 = 339;\nvar arg341 = 990;\nvar x34 = add(arg340, arg341);\nvar v34 = 1329;\nif(!compare(x34, v34)){\n    throw 'Error at 35th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg350 = 130;\nvar arg351 = 504;\nvar x35 = add(arg350, arg351);\nvar v35 = 634;\nif(!compare(x35, v35)){\n    throw 'Error at 36th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg360 = 242;\nvar arg361 = 717;\nvar x36 = add(arg360, arg361);\nvar v36 = 959;\nif(!compare(x36, v36)){\n    throw 'Error at 37th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg370 = 562;\nvar arg371 = 110;\nvar x37 = add(arg370, arg371);\nvar v37 = 672;\nif(!compare(x37, v37)){\n    throw 'Error at 38th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg380 = 396;\nvar arg381 = 909;\nvar x38 = add(arg380, arg381);\nvar v38 = 1305;\nif(!compare(x38, v38)){\n    throw 'Error at 39th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg390 = 887;\nvar arg391 = 703;\nvar x39 = add(arg390, arg391);\nvar v39 = 1590;\nif(!compare(x39, v39)){\n    throw 'Error at 40th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg400 = 870;\nvar arg401 = 551;\nvar x40 = add(arg400, arg401);\nvar v40 = 1421;\nif(!compare(x40, v40)){\n    throw 'Error at 41th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg410 = 422;\nvar arg411 = 391;\nvar x41 = add(arg410, arg411);\nvar v41 = 813;\nif(!compare(x41, v41)){\n    throw 'Error at 42th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg420 = 299;\nvar arg421 = 505;\nvar x42 = add(arg420, arg421);\nvar v42 = 804;\nif(!compare(x42, v42)){\n    throw 'Error at 43th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg430 = 346;\nvar arg431 = 56;\nvar x43 = add(arg430, arg431);\nvar v43 = 402;\nif(!compare(x43, v43)){\n    throw 'Error at 44th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg440 = 36;\nvar arg441 = 706;\nvar x44 = add(arg440, arg441);\nvar v44 = 742;\nif(!compare(x44, v44)){\n    throw 'Error at 45th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg450 = 738;\nvar arg451 = 411;\nvar x45 = add(arg450, arg451);\nvar v45 = 1149;\nif(!compare(x45, v45)){\n    throw 'Error at 46th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg460 = 679;\nvar arg461 = 87;\nvar x46 = add(arg460, arg461);\nvar v46 = 766;\nif(!compare(x46, v46)){\n    throw 'Error at 47th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg470 = 25;\nvar arg471 = 303;\nvar x47 = add(arg470, arg471);\nvar v47 = 328;\nif(!compare(x47, v47)){\n    throw 'Error at 48th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg480 = 161;\nvar arg481 = 612;\nvar x48 = add(arg480, arg481);\nvar v48 = 773;\nif(!compare(x48, v48)){\n    throw 'Error at 49th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg490 = 306;\nvar arg491 = 841;\nvar x49 = add(arg490, arg491);\nvar v49 = 1147;\nif(!compare(x49, v49)){\n    throw 'Error at 50th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg500 = 973;\nvar arg501 = 411;\nvar x50 = add(arg500, arg501);\nvar v50 = 1384;\nif(!compare(x50, v50)){\n    throw 'Error at 51th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg510 = 711;\nvar arg511 = 157;\nvar x51 = add(arg510, arg511);\nvar v51 = 868;\nif(!compare(x51, v51)){\n    throw 'Error at 52th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg520 = 471;\nvar arg521 = 27;\nvar x52 = add(arg520, arg521);\nvar v52 = 498;\nif(!compare(x52, v52)){\n    throw 'Error at 53th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg530 = 714;\nvar arg531 = 792;\nvar x53 = add(arg530, arg531);\nvar v53 = 1506;\nif(!compare(x53, v53)){\n    throw 'Error at 54th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg540 = 38;\nvar arg541 = 206;\nvar x54 = add(arg540, arg541);\nvar v54 = 244;\nif(!compare(x54, v54)){\n    throw 'Error at 55th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg550 = 907;\nvar arg551 = 343;\nvar x55 = add(arg550, arg551);\nvar v55 = 1250;\nif(!compare(x55, v55)){\n    throw 'Error at 56th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg560 = 23;\nvar arg561 = 760;\nvar x56 = add(arg560, arg561);\nvar v56 = 783;\nif(!compare(x56, v56)){\n    throw 'Error at 57th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg570 = 524;\nvar arg571 = 859;\nvar x57 = add(arg570, arg571);\nvar v57 = 1383;\nif(!compare(x57, v57)){\n    throw 'Error at 58th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg580 = 30;\nvar arg581 = 529;\nvar x58 = add(arg580, arg581);\nvar v58 = 559;\nif(!compare(x58, v58)){\n    throw 'Error at 59th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg590 = 341;\nvar arg591 = 691;\nvar x59 = add(arg590, arg591);\nvar v59 = 1032;\nif(!compare(x59, v59)){\n    throw 'Error at 60th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg600 = 167;\nvar arg601 = 729;\nvar x60 = add(arg600, arg601);\nvar v60 = 896;\nif(!compare(x60, v60)){\n    throw 'Error at 61th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg610 = 636;\nvar arg611 = 289;\nvar x61 = add(arg610, arg611);\nvar v61 = 925;\nif(!compare(x61, v61)){\n    throw 'Error at 62th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg620 = 503;\nvar arg621 = 144;\nvar x62 = add(arg620, arg621);\nvar v62 = 647;\nif(!compare(x62, v62)){\n    throw 'Error at 63th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg630 = 51;\nvar arg631 = 985;\nvar x63 = add(arg630, arg631);\nvar v63 = 1036;\nif(!compare(x63, v63)){\n    throw 'Error at 64th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg640 = 287;\nvar arg641 = 149;\nvar x64 = add(arg640, arg641);\nvar v64 = 436;\nif(!compare(x64, v64)){\n    throw 'Error at 65th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg650 = 659;\nvar arg651 = 75;\nvar x65 = add(arg650, arg651);\nvar v65 = 734;\nif(!compare(x65, v65)){\n    throw 'Error at 66th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg660 = 462;\nvar arg661 = 797;\nvar x66 = add(arg660, arg661);\nvar v66 = 1259;\nif(!compare(x66, v66)){\n    throw 'Error at 67th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg670 = 406;\nvar arg671 = 141;\nvar x67 = add(arg670, arg671);\nvar v67 = 547;\nif(!compare(x67, v67)){\n    throw 'Error at 68th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg680 = 106;\nvar arg681 = 44;\nvar x68 = add(arg680, arg681);\nvar v68 = 150;\nif(!compare(x68, v68)){\n    throw 'Error at 69th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg690 = 300;\nvar arg691 = 934;\nvar x69 = add(arg690, arg691);\nvar v69 = 1234;\nif(!compare(x69, v69)){\n    throw 'Error at 70th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg700 = 471;\nvar arg701 = 524;\nvar x70 = add(arg700, arg701);\nvar v70 = 995;\nif(!compare(x70, v70)){\n    throw 'Error at 71th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg710 = 122;\nvar arg711 = 429;\nvar x71 = add(arg710, arg711);\nvar v71 = 551;\nif(!compare(x71, v71)){\n    throw 'Error at 72th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg720 = 735;\nvar arg721 = 195;\nvar x72 = add(arg720, arg721);\nvar v72 = 930;\nif(!compare(x72, v72)){\n    throw 'Error at 73th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg730 = 335;\nvar arg731 = 484;\nvar x73 = add(arg730, arg731);\nvar v73 = 819;\nif(!compare(x73, v73)){\n    throw 'Error at 74th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg740 = 28;\nvar arg741 = 809;\nvar x74 = add(arg740, arg741);\nvar v74 = 837;\nif(!compare(x74, v74)){\n    throw 'Error at 75th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg750 = 430;\nvar arg751 = 20;\nvar x75 = add(arg750, arg751);\nvar v75 = 450;\nif(!compare(x75, v75)){\n    throw 'Error at 76th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg760 = 916;\nvar arg761 = 635;\nvar x76 = add(arg760, arg761);\nvar v76 = 1551;\nif(!compare(x76, v76)){\n    throw 'Error at 77th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg770 = 301;\nvar arg771 = 999;\nvar x77 = add(arg770, arg771);\nvar v77 = 1300;\nif(!compare(x77, v77)){\n    throw 'Error at 78th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg780 = 454;\nvar arg781 = 466;\nvar x78 = add(arg780, arg781);\nvar v78 = 920;\nif(!compare(x78, v78)){\n    throw 'Error at 79th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg790 = 905;\nvar arg791 = 259;\nvar x79 = add(arg790, arg791);\nvar v79 = 1164;\nif(!compare(x79, v79)){\n    throw 'Error at 80th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg800 = 168;\nvar arg801 = 205;\nvar x80 = add(arg800, arg801);\nvar v80 = 373;\nif(!compare(x80, v80)){\n    throw 'Error at 81th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg810 = 570;\nvar arg811 = 434;\nvar x81 = add(arg810, arg811);\nvar v81 = 1004;\nif(!compare(x81, v81)){\n    throw 'Error at 82th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg820 = 64;\nvar arg821 = 959;\nvar x82 = add(arg820, arg821);\nvar v82 = 1023;\nif(!compare(x82, v82)){\n    throw 'Error at 83th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg830 = 957;\nvar arg831 = 510;\nvar x83 = add(arg830, arg831);\nvar v83 = 1467;\nif(!compare(x83, v83)){\n    throw 'Error at 84th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg840 = 722;\nvar arg841 = 598;\nvar x84 = add(arg840, arg841);\nvar v84 = 1320;\nif(!compare(x84, v84)){\n    throw 'Error at 85th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg850 = 770;\nvar arg851 = 226;\nvar x85 = add(arg850, arg851);\nvar v85 = 996;\nif(!compare(x85, v85)){\n    throw 'Error at 86th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg860 = 579;\nvar arg861 = 66;\nvar x86 = add(arg860, arg861);\nvar v86 = 645;\nif(!compare(x86, v86)){\n    throw 'Error at 87th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg870 = 117;\nvar arg871 = 674;\nvar x87 = add(arg870, arg871);\nvar v87 = 791;\nif(!compare(x87, v87)){\n    throw 'Error at 88th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg880 = 530;\nvar arg881 = 30;\nvar x88 = add(arg880, arg881);\nvar v88 = 560;\nif(!compare(x88, v88)){\n    throw 'Error at 89th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg890 = 776;\nvar arg891 = 345;\nvar x89 = add(arg890, arg891);\nvar v89 = 1121;\nif(!compare(x89, v89)){\n    throw 'Error at 90th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg900 = 327;\nvar arg901 = 389;\nvar x90 = add(arg900, arg901);\nvar v90 = 716;\nif(!compare(x90, v90)){\n    throw 'Error at 91th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg910 = 596;\nvar arg911 = 12;\nvar x91 = add(arg910, arg911);\nvar v91 = 608;\nif(!compare(x91, v91)){\n    throw 'Error at 92th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg920 = 599;\nvar arg921 = 511;\nvar x92 = add(arg920, arg921);\nvar v92 = 1110;\nif(!compare(x92, v92)){\n    throw 'Error at 93th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg930 = 936;\nvar arg931 = 476;\nvar x93 = add(arg930, arg931);\nvar v93 = 1412;\nif(!compare(x93, v93)){\n    throw 'Error at 94th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg940 = 461;\nvar arg941 = 14;\nvar x94 = add(arg940, arg941);\nvar v94 = 475;\nif(!compare(x94, v94)){\n    throw 'Error at 95th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg950 = 966;\nvar arg951 = 157;\nvar x95 = add(arg950, arg951);\nvar v95 = 1123;\nif(!compare(x95, v95)){\n    throw 'Error at 96th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg960 = 326;\nvar arg961 = 91;\nvar x96 = add(arg960, arg961);\nvar v96 = 417;\nif(!compare(x96, v96)){\n    throw 'Error at 97th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg970 = 392;\nvar arg971 = 455;\nvar x97 = add(arg970, arg971);\nvar v97 = 847;\nif(!compare(x97, v97)){\n    throw 'Error at 98th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg980 = 446;\nvar arg981 = 477;\nvar x98 = add(arg980, arg981);\nvar v98 = 923;\nif(!compare(x98, v98)){\n    throw 'Error at 99th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg990 = 324;\nvar arg991 = 860;\nvar x99 = add(arg990, arg991);\nvar v99 = 1184;\nif(!compare(x99, v99)){\n    throw 'Error at 100th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg1000 = 945;\nvar arg1001 = 85;\nvar x100 = add(arg1000, arg1001);\nvar v100 = 1030;\nif(!compare(x100, v100)){\n    throw 'Error at 101th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg1010 = 886;\nvar arg1011 = 582;\nvar x101 = add(arg1010, arg1011);\nvar v101 = 1468;\nif(!compare(x101, v101)){\n    throw 'Error at 102th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg1020 = 886;\nvar arg1021 = 712;\nvar x102 = add(arg1020, arg1021);\nvar v102 = 1598;\nif(!compare(x102, v102)){\n    throw 'Error at 103th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg1030 = 842;\nvar arg1031 = 953;\nvar x103 = add(arg1030, arg1031);\nvar v103 = 1795;\nif(!compare(x103, v103)){\n    throw 'Error at 104th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * إضافة رقمين x و y\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/20", "prompt": "/**\n * * \n * تحقق مما إذا كانت كلمتان لديهما نفس الأحرف.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n *\n */\nfunction sameChars(s0, s1) {\n", "entry_point": "sameChars", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"eabcdzzzz\";\nvar arg01 = \"dddzzzzzzzddeddabc\";\nvar x0 = sameChars(arg00, arg01);\nvar v0 = true;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"abcd\";\nvar arg11 = \"dddddddabc\";\nvar x1 = sameChars(arg10, arg11);\nvar v1 = true;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"dddddddabc\";\nvar arg21 = \"abcd\";\nvar x2 = sameChars(arg20, arg21);\nvar v2 = true;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"eabcd\";\nvar arg31 = \"dddddddabc\";\nvar x3 = sameChars(arg30, arg31);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"abcd\";\nvar arg41 = \"dddddddabcf\";\nvar x4 = sameChars(arg40, arg41);\nvar v4 = false;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"eabcdzzzz\";\nvar arg51 = \"dddzzzzzzzddddabc\";\nvar x5 = sameChars(arg50, arg51);\nvar v5 = false;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"aabb\";\nvar arg61 = \"aaccc\";\nvar x6 = sameChars(arg60, arg61);\nvar v6 = false;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * تحقق مما إذا كانت كلمتان لديهما نفس الأحرف.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/21", "prompt": "/**\n * \n * إرجاع العدد الفيبوناتشي رقم n.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n *\n */\nfunction fib(n) {\n", "entry_point": "fib", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 10;\nvar x0 = fib(arg00);\nvar v0 = 55;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 1;\nvar x1 = fib(arg10);\nvar v1 = 1;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 8;\nvar x2 = fib(arg20);\nvar v2 = 21;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 11;\nvar x3 = fib(arg30);\nvar v3 = 89;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 12;\nvar x4 = fib(arg40);\nvar v4 = 144;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * إرجاع العدد الفيبوناتشي رقم n.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/22", "prompt": "/**\n * \n * إرجاع العناصر المشتركة الفريدة المرتبة لاثنين من القوائم.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n\n *\n */\nfunction common(l1, l2) {\n", "entry_point": "common", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [1, 4, 3, 34, 653, 2, 5];\nvar arg01 = [5, 7, 1, 5, 9, 653, 121];\nvar x0 = common(arg00, arg01);\nvar v0 = [1, 5, 653];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [5, 3, 2, 8];\nvar arg11 = [3, 2];\nvar x1 = common(arg10, arg11);\nvar v1 = [2, 3];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [4, 3, 2, 8];\nvar arg21 = [3, 2, 4];\nvar x2 = common(arg20, arg21);\nvar v2 = [2, 3, 4];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [4, 3, 2, 8];\nvar arg31 = [];\nvar x3 = common(arg30, arg31);\nvar v3 = [];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * إرجاع العناصر المشتركة الفريدة المرتبة لاثنين من القوائم.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/23", "prompt": "/**\n * \n * \"ارجع أكبر عامل أولي لـ n. افترض أن n> 1 وليس عددًا أوليًا.\"\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n *\n */\nfunction largestPrimeFactor(n) {\n", "entry_point": "largestPrimeFactor", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 15;\nvar x0 = largestPrimeFactor(arg00);\nvar v0 = 5;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 27;\nvar x1 = largestPrimeFactor(arg10);\nvar v1 = 3;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 63;\nvar x2 = largestPrimeFactor(arg20);\nvar v2 = 7;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 330;\nvar x3 = largestPrimeFactor(arg30);\nvar v3 = 11;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 13195;\nvar x4 = largestPrimeFactor(arg40);\nvar v4 = 29;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * \"ارجع أكبر عامل أولي لـ n. افترض أن n> 1 وليس عددًا أوليًا.\"\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/24", "prompt": "/**\n * \n * sum_to_n هي وظيفة تجمع الأرقام من 1 إلى n.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n *\n */\nfunction sumToN(n) {\n", "entry_point": "sumToN", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 1;\nvar x0 = sumToN(arg00);\nvar v0 = 1;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 6;\nvar x1 = sumToN(arg10);\nvar v1 = 21;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 11;\nvar x2 = sumToN(arg20);\nvar v2 = 66;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 30;\nvar x3 = sumToN(arg30);\nvar v3 = 465;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 100;\nvar x4 = sumToN(arg40);\nvar v4 = 5050;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * sum_to_n هي وظيفة تجمع الأرقام من 1 إلى n.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/25", "prompt": "/**\n * \n * xs تمثل معاملات متعددة الحدود.\n * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n * إرجاع المشتقة لهذه المعادلة متعددة الحدود بنفس الصيغة.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n *\n */\nfunction derivative(xs) {\n", "entry_point": "derivative", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [3, 1, 2, 4, 5];\nvar x0 = derivative(arg00);\nvar v0 = [1, 4, 12, 20];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1, 2, 3];\nvar x1 = derivative(arg10);\nvar v1 = [2, 6];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [3, 2, 1];\nvar x2 = derivative(arg20);\nvar v2 = [2, 2];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [3, 2, 1, 0, 4];\nvar x3 = derivative(arg30);\nvar v3 = [2, 2, 0, 16];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [1];\nvar x4 = derivative(arg40);\nvar v4 = [];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * xs تمثل معاملات متعددة الحدود.\n * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n * إرجاع المشتقة لهذه المعادلة متعددة الحدود بنفس الصيغة.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/26", "prompt": "/**\n * \n * تتبع سلسلة أرقام فيبفيب هي سلسلة مشابهة لسلسلة فيبوناتشي التي تعرف على النحو التالي:\n *     فيبفيب(0) == 0\n *     فيبفيب(1) == 0\n *     فيبفيب(2) == 1\n *     فيبفيب(n) == فيبفيب(n-1) + فيبفيب(n-2) + فيبفيب(n-3).\n *     يرجى كتابة وظيفة لحساب العنصر الثالث عشر بكفاءة في سلسلة أرقام فيبفيب.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n *\n */\nfunction fibfib(n) {\n", "entry_point": "fibfib", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 2;\nvar x0 = fibfib(arg00);\nvar v0 = 1;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 1;\nvar x1 = fibfib(arg10);\nvar v1 = 0;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 5;\nvar x2 = fibfib(arg20);\nvar v2 = 4;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 8;\nvar x3 = fibfib(arg30);\nvar v3 = 24;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 10;\nvar x4 = fibfib(arg40);\nvar v4 = 81;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 12;\nvar x5 = fibfib(arg50);\nvar v5 = 274;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 14;\nvar x6 = fibfib(arg60);\nvar v6 = 927;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * تتبع سلسلة أرقام فيبفيب هي سلسلة مشابهة لسلسلة فيبوناتشي التي تعرف على النحو التالي:\n *     فيبفيب(0) == 0\n *     فيبفيب(1) == 0\n *     فيبفيب(2) == 1\n *     فيبفيب(n) == فيبفيب(n-1) + فيبفيب(n-2) + فيبفيب(n-3).\n *     يرجى كتابة وظيفة لحساب العنصر الثالث عشر بكفاءة في سلسلة أرقام فيبفيب.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/27", "prompt": "/**\n * \n * اكتب دالة تسمى vowels_count تأخذ سلسلة نصية تمثل كلمة كإدخال وتعيد عدد الحروف الصوتية في السلسلة. الحروف الصوتية في هذه الحالة هي 'a'، 'e'، 'i'، 'o'، 'u'. هنا، 'y' هو أيضًا حرف صوتي، ولكن فقط عندما يكون في نهاية الكلمة المعطاة.\n * \n * مثال:\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n *\n */\nfunction vowelsCount(s) {\n", "entry_point": "vowelsCount", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"abcde\";\nvar x0 = vowelsCount(arg00);\nvar v0 = 2;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"Alone\";\nvar x1 = vowelsCount(arg10);\nvar v1 = 3;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"key\";\nvar x2 = vowelsCount(arg20);\nvar v2 = 2;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"bye\";\nvar x3 = vowelsCount(arg30);\nvar v3 = 1;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"keY\";\nvar x4 = vowelsCount(arg40);\nvar v4 = 2;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"bYe\";\nvar x5 = vowelsCount(arg50);\nvar v5 = 1;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"ACEDY\";\nvar x6 = vowelsCount(arg60);\nvar v6 = 3;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * اكتب دالة تسمى vowels_count تأخذ سلسلة نصية تمثل كلمة كإدخال وتعيد عدد الحروف الصوتية في السلسلة. الحروف الصوتية في هذه الحالة هي 'a'، 'e'، 'i'، 'o'، 'u'. هنا، 'y' هو أيضًا حرف صوتي، ولكن فقط عندما يكون في نهاية الكلمة المعطاة.\n * \n * مثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/28", "prompt": "/**\n * * \n * يتم تزويدك بقائمة غير فارغة من الأعداد الصحيحة الإيجابية. يجب إرجاع أكبر عدد صحيح يكون أكبر من الصفر وله تكرار أكبر من أو يساوي قيمة العدد الصحيح نفسه. تكرار العدد الصحيح هو عدد مرات ظهوره في القائمة. إذا لم يكن هناك قيمة كهذه ، فأرجع -1. أمثلة:\n * \n *     search([4, 1, 2, 2, 3, 1]) == 2\n *     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n *     search([5, 5, 4, 4, 4]) == -1\n *\n */\nfunction search(lst) {\n", "entry_point": "search", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [5, 5, 5, 5, 1];\nvar x0 = search(arg00);\nvar v0 = 1;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [4, 1, 4, 1, 4, 4];\nvar x1 = search(arg10);\nvar v1 = 4;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [3, 3];\nvar x2 = search(arg20);\nvar v2 = -1;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [8, 8, 8, 8, 8, 8, 8, 8];\nvar x3 = search(arg30);\nvar v3 = 8;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [2, 3, 3, 2, 2];\nvar x4 = search(arg40);\nvar v4 = 2;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1];\nvar x5 = search(arg50);\nvar v5 = 1;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = [3, 2, 8, 2];\nvar x6 = search(arg60);\nvar v6 = 2;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10];\nvar x7 = search(arg70);\nvar v7 = 1;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = [8, 8, 3, 6, 5, 6, 4];\nvar x8 = search(arg80);\nvar v8 = -1;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9];\nvar x9 = search(arg90);\nvar v9 = 1;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg100 = [1, 9, 10, 1, 3];\nvar x10 = search(arg100);\nvar v10 = 1;\nif(!compare(x10, v10)){\n    throw 'Error at 11th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg110 = [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10];\nvar x11 = search(arg110);\nvar v11 = 5;\nif(!compare(x11, v11)){\n    throw 'Error at 12th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg120 = [1];\nvar x12 = search(arg120);\nvar v12 = 1;\nif(!compare(x12, v12)){\n    throw 'Error at 13th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg130 = [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5];\nvar x13 = search(arg130);\nvar v13 = 4;\nif(!compare(x13, v13)){\n    throw 'Error at 14th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg140 = [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10];\nvar x14 = search(arg140);\nvar v14 = 2;\nif(!compare(x14, v14)){\n    throw 'Error at 15th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg150 = [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3];\nvar x15 = search(arg150);\nvar v15 = 1;\nif(!compare(x15, v15)){\n    throw 'Error at 16th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg160 = [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4];\nvar x16 = search(arg160);\nvar v16 = 4;\nif(!compare(x16, v16)){\n    throw 'Error at 17th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg170 = [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7];\nvar x17 = search(arg170);\nvar v17 = 4;\nif(!compare(x17, v17)){\n    throw 'Error at 18th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg180 = [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1];\nvar x18 = search(arg180);\nvar v18 = 2;\nif(!compare(x18, v18)){\n    throw 'Error at 19th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg190 = [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8];\nvar x19 = search(arg190);\nvar v19 = -1;\nif(!compare(x19, v19)){\n    throw 'Error at 20th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg200 = [10];\nvar x20 = search(arg200);\nvar v20 = -1;\nif(!compare(x20, v20)){\n    throw 'Error at 21th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg210 = [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2];\nvar x21 = search(arg210);\nvar v21 = 2;\nif(!compare(x21, v21)){\n    throw 'Error at 22th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg220 = [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8];\nvar x22 = search(arg220);\nvar v22 = 1;\nif(!compare(x22, v22)){\n    throw 'Error at 23th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg230 = [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6];\nvar x23 = search(arg230);\nvar v23 = 1;\nif(!compare(x23, v23)){\n    throw 'Error at 24th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg240 = [3, 10, 10, 9, 2];\nvar x24 = search(arg240);\nvar v24 = -1;\nif(!compare(x24, v24)){\n    throw 'Error at 25th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * يتم تزويدك بقائمة غير فارغة من الأعداد الصحيحة الإيجابية. يجب إرجاع أكبر عدد صحيح يكون أكبر من الصفر وله تكرار أكبر من أو يساوي قيمة العدد الصحيح نفسه. تكرار العدد الصحيح هو عدد مرات ظهوره في القائمة. إذا لم يكن هناك قيمة كهذه ، فأرجع -1. أمثلة:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/29", "prompt": "/**\n * * \n * بالنظر إلى أطوال الأضلاع الثلاثة لمثلث. يرجى إرجاع مساحة المثلث مستديرة إلى 2 نقطة عشرية إذا كانت الأضلاع الثلاثة تشكل مثلثًا صالحًا. وإلا، يرجى إرجاع -1. تشكل الأضلاع الثلاثة مثلثًا صالحًا عندما يكون مجموع أي ضلعين أكبر من الضلع الثالث. مثال:\n * \n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n *\n */\nfunction triangleArea(a, b, c) {\n", "entry_point": "triangleArea", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 3;\nvar arg01 = 4;\nvar arg02 = 5;\nvar x0 = triangleArea(arg00, arg01, arg02);\nvar v0 = 6.0;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 1;\nvar arg11 = 2;\nvar arg12 = 10;\nvar x1 = triangleArea(arg10, arg11, arg12);\nvar v1 = -1;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 4;\nvar arg21 = 8;\nvar arg22 = 5;\nvar x2 = triangleArea(arg20, arg21, arg22);\nvar v2 = 8.18;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 2;\nvar arg31 = 2;\nvar arg32 = 2;\nvar x3 = triangleArea(arg30, arg31, arg32);\nvar v3 = 1.73;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 1;\nvar arg41 = 2;\nvar arg42 = 3;\nvar x4 = triangleArea(arg40, arg41, arg42);\nvar v4 = -1;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 10;\nvar arg51 = 5;\nvar arg52 = 7;\nvar x5 = triangleArea(arg50, arg51, arg52);\nvar v5 = 16.25;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 2;\nvar arg61 = 6;\nvar arg62 = 3;\nvar x6 = triangleArea(arg60, arg61, arg62);\nvar v6 = -1;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = 1;\nvar arg71 = 1;\nvar arg72 = 1;\nvar x7 = triangleArea(arg70, arg71, arg72);\nvar v7 = 0.43;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = 2;\nvar arg81 = 2;\nvar arg82 = 10;\nvar x8 = triangleArea(arg80, arg81, arg82);\nvar v8 = -1;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * بالنظر إلى أطوال الأضلاع الثلاثة لمثلث. يرجى إرجاع مساحة المثلث مستديرة إلى 2 نقطة عشرية إذا كانت الأضلاع الثلاثة تشكل مثلثًا صالحًا. وإلا، يرجى إرجاع -1. تشكل الأضلاع الثلاثة مثلثًا صالحًا عندما يكون مجموع أي ضلعين أكبر من الضلع الثالث. مثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/30", "prompt": "/**\n * * \n * اكتب دالة تعيد القيمة صحيحة إذا كان الكائن q سيطير، وخطأ في حالة عدم ذلك.\n * سيطير الكائن q إذا كان متوازنًا (هو قائمة متناظرة) ومجموع عناصره أقل من أو يساوي الحد الأقصى الممكن للوزن w.\n * \n * مثال:\n * will_it_fly([1، 2]، 5) ➞ خطأ\n * # 1 + 2 أقل من الحد الأقصى الممكن للوزن ، لكنه غير متوازن.\n * \n * will_it_fly([3، 2، 3]، 1) ➞ خطأ\n * # إنه متوازن ، لكن 3 + 2 + 3 أكثر من الحد الأقصى الممكن للوزن.\n * \n * will_it_fly([3، 2، 3]، 9) ➞ صحيح\n * # 3 + 2 + 3 أقل من الحد الأقصى الممكن للوزن ، وهو متوازن.\n * \n * will_it_fly([3]، 5) ➞ صحيح\n * # 3 أقل من الحد الأقصى الممكن للوزن ، وهو متوازن.\n * \n *\n */\nfunction willItFly(q, w) {\n", "entry_point": "willItFly", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [3, 2, 3];\nvar arg01 = 9;\nvar x0 = willItFly(arg00, arg01);\nvar v0 = true;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1, 2];\nvar arg11 = 5;\nvar x1 = willItFly(arg10, arg11);\nvar v1 = false;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [3];\nvar arg21 = 5;\nvar x2 = willItFly(arg20, arg21);\nvar v2 = true;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [3, 2, 3];\nvar arg31 = 1;\nvar x3 = willItFly(arg30, arg31);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [1, 2, 3];\nvar arg41 = 6;\nvar x4 = willItFly(arg40, arg41);\nvar v4 = false;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [5];\nvar arg51 = 5;\nvar x5 = willItFly(arg50, arg51);\nvar v5 = true;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * اكتب دالة تعيد القيمة صحيحة إذا كان الكائن q سيطير، وخطأ في حالة عدم ذلك.\n * سيطير الكائن q إذا كان متوازنًا (هو قائمة متناظرة) ومجموع عناصره أقل من أو يساوي الحد الأقصى الممكن للوزن w.\n * \n * مثال:\n * will_it_fly([1، 2]، 5) ➞ خطأ\n * # 1 + 2 أقل من الحد الأقصى الممكن للوزن ، لكنه غير متوازن.\n * \n * will_it_fly([3، 2، 3]، 1) ➞ خطأ\n * # إنه متوازن ، لكن 3 + 2 + 3 أكثر من الحد الأقصى الممكن للوزن.\n * \n * will_it_fly([3، 2، 3]، 9) ➞ صحيح\n * # 3 + 2 + 3 أقل من الحد الأقصى الممكن للوزن ، وهو متوازن.\n * \n * will_it_fly([3]، 5) ➞ صحيح\n * # 3 أقل من الحد الأقصى الممكن للوزن ، وهو متوازن.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/31", "prompt": "/**\n * \n * اكتب دالة تعيد القيمة الصحيحة إذا كان الرقم المعطى هو ضرب 3 أعداد أولية، وإلا فهي تعيد القيمة الخاطئة. علمًا بأن (أ) أقل من 100. \n * \n * مثال:\n * \n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n *\n */\nfunction isMultiplyPrime(a) {\n", "entry_point": "isMultiplyPrime", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 5;\nvar x0 = isMultiplyPrime(arg00);\nvar v0 = false;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 30;\nvar x1 = isMultiplyPrime(arg10);\nvar v1 = true;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 8;\nvar x2 = isMultiplyPrime(arg20);\nvar v2 = true;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 10;\nvar x3 = isMultiplyPrime(arg30);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 125;\nvar x4 = isMultiplyPrime(arg40);\nvar v4 = true;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 105;\nvar x5 = isMultiplyPrime(arg50);\nvar v5 = true;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 126;\nvar x6 = isMultiplyPrime(arg60);\nvar v6 = false;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = 729;\nvar x7 = isMultiplyPrime(arg70);\nvar v7 = false;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = 891;\nvar x8 = isMultiplyPrime(arg80);\nvar v8 = false;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = 1001;\nvar x9 = isMultiplyPrime(arg90);\nvar v9 = true;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * اكتب دالة تعيد القيمة الصحيحة إذا كان الرقم المعطى هو ضرب 3 أعداد أولية، وإلا فهي تعيد القيمة الخاطئة. علمًا بأن (أ) أقل من 100. \n * \n * مثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/32", "prompt": "/**\n * \n * سيتم إعطاؤك رقمًا بالشكل العشري ومهمتك هي تحويله إلى الشكل الثنائي. يجب أن تعيد الدالة سلسلة نصية، حيث يمثل كل حرف رقمًا ثنائيًا. سيكون كل حرف في السلسلة هو '0' أو '1'.\n * \n * سيكون هناك حرفان إضافيان 'db' في بداية ونهاية السلسلة. الحروف الإضافية موجودة للمساعدة في التنسيق.\n * \n * أمثلة:\n * \n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n *\n */\nfunction decimalToBinary(decimal) {\n", "entry_point": "decimalToBinary", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 0;\nvar x0 = decimalToBinary(arg00);\nvar v0 = \"db0db\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 32;\nvar x1 = decimalToBinary(arg10);\nvar v1 = \"db100000db\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 103;\nvar x2 = decimalToBinary(arg20);\nvar v2 = \"db1100111db\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 15;\nvar x3 = decimalToBinary(arg30);\nvar v3 = \"db1111db\";\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * سيتم إعطاؤك رقمًا بالشكل العشري ومهمتك هي تحويله إلى الشكل الثنائي. يجب أن تعيد الدالة سلسلة نصية، حيث يمثل كل حرف رقمًا ثنائيًا. سيكون كل حرف في السلسلة هو '0' أو '1'.\n * \n * سيكون هناك حرفان إضافيان 'db' في بداية ونهاية السلسلة. الحروف الإضافية موجودة للمساعدة في التنسيق.\n * \n * أمثلة:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/33", "prompt": "/**\n * \n * يتم إعطاؤك سلسلة s.\n * مهمتك هي التحقق مما إذا كانت السلسلة سعيدة أم لا.\n * تعتبر السلسلة سعيدة إذا كان طولها على الأقل 3 وكانت كل 3 أحرف متتالية مختلفة.\n * على سبيل المثال:\n * \n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n *\n */\nfunction isHappy(s) {\n", "entry_point": "isHappy", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"a\";\nvar x0 = isHappy(arg00);\nvar v0 = false;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"aa\";\nvar x1 = isHappy(arg10);\nvar v1 = false;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"abcd\";\nvar x2 = isHappy(arg20);\nvar v2 = true;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"aabb\";\nvar x3 = isHappy(arg30);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"adb\";\nvar x4 = isHappy(arg40);\nvar v4 = true;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"xyy\";\nvar x5 = isHappy(arg50);\nvar v5 = false;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"iopaxpoi\";\nvar x6 = isHappy(arg60);\nvar v6 = true;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = \"iopaxioi\";\nvar x7 = isHappy(arg70);\nvar v7 = false;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * يتم إعطاؤك سلسلة s.\n * مهمتك هي التحقق مما إذا كانت السلسلة سعيدة أم لا.\n * تعتبر السلسلة سعيدة إذا كان طولها على الأقل 3 وكانت كل 3 أحرف متتالية مختلفة.\n * على سبيل المثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/34", "prompt": "/**\n * \n * هذا هو الأسبوع الأخير من الفصل الدراسي ويجب على المعلم إعطاء الدرجات للطلاب. كان المعلم يقوم بإنشاء خوارزمية خاصة به لتقييم الدرجات. المشكلة الوحيدة هي أنها فقدت الكود الذي استخدمته للتقييم. لقد قدمت لك قائمة بمعدلات النجاح لبعض الطلاب ويجب عليك كتابة وظيفة يمكنها إخراج قائمة بالدرجات الحرفية باستخدام الجدول التالي:\n *              GPA       |    Letter grade\n *               4.0                A+\n *             > 3.7                A \n *             > 3.3                A- \n *             > 3.0                B+\n *             > 2.7                B \n *             > 2.3                B-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                E\n *     \n * \n *     مثال:\n * \n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n *\n */\nfunction numericalLetterGrade(grades) {\n", "entry_point": "numericalLetterGrade", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [4.0, 3, 1.7, 2, 3.5];\nvar x0 = numericalLetterGrade(arg00);\nvar v0 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1.2];\nvar x1 = numericalLetterGrade(arg10);\nvar v1 = [\"D+\"];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [0.5];\nvar x2 = numericalLetterGrade(arg20);\nvar v2 = [\"D-\"];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [0.0];\nvar x3 = numericalLetterGrade(arg30);\nvar v3 = [\"E\"];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [1, 0.3, 1.5, 2.8, 3.3];\nvar x4 = numericalLetterGrade(arg40);\nvar v4 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [0, 0.7];\nvar x5 = numericalLetterGrade(arg50);\nvar v5 = [\"E\", \"D-\"];\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * هذا هو الأسبوع الأخير من الفصل الدراسي ويجب على المعلم إعطاء الدرجات للطلاب. كان المعلم يقوم بإنشاء خوارزمية خاصة به لتقييم الدرجات. المشكلة الوحيدة هي أنها فقدت الكود الذي استخدمته للتقييم. لقد قدمت لك قائمة بمعدلات النجاح لبعض الطلاب ويجب عليك كتابة وظيفة يمكنها إخراج قائمة بالدرجات الحرفية باستخدام الجدول التالي:\n *              GPA       |    Letter grade\n *               4.0                A+\n *             > 3.7                A \n *             > 3.3                A- \n *             > 3.0                B+\n *             > 2.7                B \n *             > 2.3                B-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                E\n *     \n * \n *     مثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/35", "prompt": "/**\n * \n * اكتب دالة تأخذ سلسلة نصية وتعيد True إذا كان طول السلسلة عددًا أوليًا أو False في حالة عكس ذلك\n *     أمثلة\n * \n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n *\n */\nfunction primeLength(string) {\n", "entry_point": "primeLength", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"Hello\";\nvar x0 = primeLength(arg00);\nvar v0 = true;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"abcdcba\";\nvar x1 = primeLength(arg10);\nvar v1 = true;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"kittens\";\nvar x2 = primeLength(arg20);\nvar v2 = true;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"orange\";\nvar x3 = primeLength(arg30);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"wow\";\nvar x4 = primeLength(arg40);\nvar v4 = true;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"world\";\nvar x5 = primeLength(arg50);\nvar v5 = true;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"MadaM\";\nvar x6 = primeLength(arg60);\nvar v6 = true;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = \"Wow\";\nvar x7 = primeLength(arg70);\nvar v7 = true;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = \"\";\nvar x8 = primeLength(arg80);\nvar v8 = false;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = \"HI\";\nvar x9 = primeLength(arg90);\nvar v9 = true;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg100 = \"go\";\nvar x10 = primeLength(arg100);\nvar v10 = true;\nif(!compare(x10, v10)){\n    throw 'Error at 11th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg110 = \"gogo\";\nvar x11 = primeLength(arg110);\nvar v11 = false;\nif(!compare(x11, v11)){\n    throw 'Error at 12th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg120 = \"aaaaaaaaaaaaaaa\";\nvar x12 = primeLength(arg120);\nvar v12 = false;\nif(!compare(x12, v12)){\n    throw 'Error at 13th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg130 = \"Madam\";\nvar x13 = primeLength(arg130);\nvar v13 = true;\nif(!compare(x13, v13)){\n    throw 'Error at 14th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg140 = \"M\";\nvar x14 = primeLength(arg140);\nvar v14 = false;\nif(!compare(x14, v14)){\n    throw 'Error at 15th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg150 = \"0\";\nvar x15 = primeLength(arg150);\nvar v15 = false;\nif(!compare(x15, v15)){\n    throw 'Error at 16th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * اكتب دالة تأخذ سلسلة نصية وتعيد True إذا كان طول السلسلة عددًا أوليًا أو False في حالة عكس ذلك\n *     أمثلة\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/36", "prompt": "/**\n * \n * بالنظر إلى عدد صحيح موجب N، يتم إرجاع إجمالي مجموع أرقامه في النظام الثنائي.\n * \n * مثال:\n *     بالنسبة لـ N = 1000، سيكون مجموع الأرقام 1 ويجب أن يكون الإخراج \"1\".\n *     بالنسبة لـ N = 150، سيكون مجموع الأرقام 6 ويجب أن يكون الإخراج \"110\".\n *     بالنسبة لـ N = 147، سيكون مجموع الأرقام 12 ويجب أن يكون الإخراج \"1100\".\n * \n * المتغيرات:\n *     @N عدد صحيح\n *          القيود: 0 ≤ N ≤ 10000.\n * الإخراج:\n *      سلسلة من الأرقام الثنائية.\n * \n *\n */\nfunction solve(n) {\n", "entry_point": "solve", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 1000;\nvar x0 = solve(arg00);\nvar v0 = \"1\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 150;\nvar x1 = solve(arg10);\nvar v1 = \"110\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 147;\nvar x2 = solve(arg20);\nvar v2 = \"1100\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 333;\nvar x3 = solve(arg30);\nvar v3 = \"1001\";\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 963;\nvar x4 = solve(arg40);\nvar v4 = \"10010\";\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * بالنظر إلى عدد صحيح موجب N، يتم إرجاع إجمالي مجموع أرقامه في النظام الثنائي.\n * \n * مثال:\n *     بالنسبة لـ N = 1000، سيكون مجموع الأرقام 1 ويجب أن يكون الإخراج \"1\".\n *     بالنسبة لـ N = 150، سيكون مجموع الأرقام 6 ويجب أن يكون الإخراج \"110\".\n *     بالنسبة لـ N = 147، سيكون مجموع الأرقام 12 ويجب أن يكون الإخراج \"1100\".\n * \n * المتغيرات:\n *     @N عدد صحيح\n *          القيود: 0 ≤ N ≤ 10000.\n * الإخراج:\n *      سلسلة من الأرقام الثنائية.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/37", "prompt": "/**\n * * \n * يتم تزويدك ببيانات ثنائية الأبعاد، على شكل قوائم متداخلة،\n *     والتي تشبه المصفوفة، ولكن على عكس المصفوفات،\n *     قد تحتوي كل صف على عدد مختلف من الأعمدة.\n *     بالنظر إلى lst و x عدد صحيح، ابحث عن الأعداد الصحيحة x في القائمة،\n *     وأرجع قائمة من الأزواج، [(x1، y1)، (x2، y2) ...] بحيث\n *     يكون كل زوج إحداثيات - (صف، أعمدة)، بدءًا من 0.\n *     فرز الإحداثيات في البداية حسب الصفوف بترتيب تصاعدي.\n *     أيضًا، فرز إحداثيات الصف حسب الأعمدة بترتيب تنازلي.\n *     \n *     أمثلة:\n * \n * get_row([\n *   [1,2,3,4,5,6],\n *   [1,2,3,4,1,6],\n *   [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n *\n */\nfunction getRow(lst, x) {\n", "entry_point": "getRow", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [];\nvar arg01 = 1;\nvar x0 = getRow(arg00, arg01);\nvar v0 = [];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [[1]];\nvar arg11 = 2;\nvar x1 = getRow(arg10, arg11);\nvar v1 = [];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [[], [1], [1, 2, 3]];\nvar arg21 = 3;\nvar x2 = getRow(arg20, arg21);\nvar v2 = [[2, 2]];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * يتم تزويدك ببيانات ثنائية الأبعاد، على شكل قوائم متداخلة،\n *     والتي تشبه المصفوفة، ولكن على عكس المصفوفات،\n *     قد تحتوي كل صف على عدد مختلف من الأعمدة.\n *     بالنظر إلى lst و x عدد صحيح، ابحث عن الأعداد الصحيحة x في القائمة،\n *     وأرجع قائمة من الأزواج، [(x1، y1)، (x2، y2) ...] بحيث\n *     يكون كل زوج إحداثيات - (صف، أعمدة)، بدءًا من 0.\n *     فرز الإحداثيات في البداية حسب الصفوف بترتيب تصاعدي.\n *     أيضًا، فرز إحداثيات الصف حسب الأعمدة بترتيب تنازلي.\n *     \n *     أمثلة:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/38", "prompt": "/**\n * * \n * تمنحك قائمة من الأعداد الصحيحة.\n * اكتب دالة next_smallest() التي تعيد العنصر الثاني الأصغر في القائمة.\n * إرجاع قيمة فارغة إذا لم يكن هناك عنصر من هذا النوع.\n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n *\n */\nfunction nextSmallest(lst) {\n", "entry_point": "nextSmallest", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [1, 2, 3, 4, 5];\nvar x0 = nextSmallest(arg00);\nvar v0 = 2;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [5, 1, 4, 3, 2];\nvar x1 = nextSmallest(arg10);\nvar v1 = 2;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [];\nvar x2 = nextSmallest(arg20);\nvar v2 = null;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [1, 1];\nvar x3 = nextSmallest(arg30);\nvar v3 = null;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [1, 1, 1, 1, 0];\nvar x4 = nextSmallest(arg40);\nvar v4 = 1;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [1, 1];\nvar x5 = nextSmallest(arg50);\nvar v5 = null;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = [-35, 34, 12, -45];\nvar x6 = nextSmallest(arg60);\nvar v6 = -35;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * تمنحك قائمة من الأعداد الصحيحة.\n * اكتب دالة next_smallest() التي تعيد العنصر الثاني الأصغر في القائمة.\n * إرجاع قيمة فارغة إذا لم يكن هناك عنصر من هذا النوع.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/39", "prompt": "/**\n * * \n * سيتم تزويدك بسلسلة من الكلمات، ومهمتك هي عدد الملل. الملل هو جملة تبدأ بكلمة \"أنا\". تتم فصل الجمل بواسطة '.' أو '?' أو '!'.\n * \n * على سبيل المثال:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n *\n */\nfunction isBored(s) {\n", "entry_point": "isBored", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"Hello world\";\nvar x0 = isBored(arg00);\nvar v0 = 0;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"Is the sky blue?\";\nvar x1 = isBored(arg10);\nvar v1 = 0;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"I love It !\";\nvar x2 = isBored(arg20);\nvar v2 = 1;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"bIt\";\nvar x3 = isBored(arg30);\nvar v3 = 0;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"I feel good today. I will be productive. will kill It\";\nvar x4 = isBored(arg40);\nvar v4 = 2;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"You and I are going for a walk\";\nvar x5 = isBored(arg50);\nvar v5 = 0;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * سيتم تزويدك بسلسلة من الكلمات، ومهمتك هي عدد الملل. الملل هو جملة تبدأ بكلمة \"أنا\". تتم فصل الجمل بواسطة '.' أو '?' أو '!'.\n * \n * على سبيل المثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/40", "prompt": "/**\n * \n * تمنحك قائمة من الأعداد الصحيحة.\n *     تحتاج إلى العثور على أكبر قيمة أولية وإرجاع مجموع أرقامها.\n * \n *     أمثلة:\n * \n * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n * For lst = [0,81,12,3,1,21] the output should be 3\n * For lst = [0,8,1,2,1,7] the output should be 7\n *\n */\nfunction skjkasdkd(lst) {\n", "entry_point": "skjkasdkd", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3];\nvar x0 = skjkasdkd(arg00);\nvar v0 = 10;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1];\nvar x1 = skjkasdkd(arg10);\nvar v1 = 25;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3];\nvar x2 = skjkasdkd(arg20);\nvar v2 = 13;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6];\nvar x3 = skjkasdkd(arg30);\nvar v3 = 11;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [0, 81, 12, 3, 1, 21];\nvar x4 = skjkasdkd(arg40);\nvar v4 = 3;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [0, 8, 1, 2, 1, 7];\nvar x5 = skjkasdkd(arg50);\nvar v5 = 7;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = [8191];\nvar x6 = skjkasdkd(arg60);\nvar v6 = 19;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = [8191, 123456, 127, 7];\nvar x7 = skjkasdkd(arg70);\nvar v7 = 19;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = [127, 97, 8192];\nvar x8 = skjkasdkd(arg80);\nvar v8 = 10;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * تمنحك قائمة من الأعداد الصحيحة.\n *     تحتاج إلى العثور على أكبر قيمة أولية وإرجاع مجموع أرقامها.\n * \n *     أمثلة:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/41", "prompt": "/**\n * * \n * بالنظر إلى قاموس، إرجاع قيمة True إذا كانت جميع المفاتيح هي سلاسل نصية في الحالة الصغيرة أو جميع المفاتيح هي سلاسل نصية في الحالة الكبيرة، وإلا فإنه يجب إرجاع False. يجب أن يعيد الدالة False إذا كان القاموس المعطى فارغًا. أمثلة:\n * \n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n *\n */\nfunction checkDictCase(dict) {\n", "entry_point": "checkDictCase", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = {'\"p\"':\"pineapple\",'\"b\"':\"banana\"};\nvar x0 = checkDictCase(arg00);\nvar v0 = true;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = {'\"p\"':\"pineapple\",'\"A\"':\"banana\",'\"B\"':\"banana\"};\nvar x1 = checkDictCase(arg10);\nvar v1 = false;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = {'\"p\"':\"pineapple\",\"5\":\"banana\",'\"a\"':\"apple\"};\nvar x2 = checkDictCase(arg20);\nvar v2 = false;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = {'\"Name\"':\"John\",'\"Age\"':\"36\",'\"City\"':\"Houston\"};\nvar x3 = checkDictCase(arg30);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = {'\"STATE\"':\"NC\",'\"ZIP\"':\"12345\"};\nvar x4 = checkDictCase(arg40);\nvar v4 = true;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = {'\"fruit\"':\"Orange\",'\"taste\"':\"Sweet\"};\nvar x5 = checkDictCase(arg50);\nvar v5 = true;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = {};\nvar x6 = checkDictCase(arg60);\nvar v6 = false;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * بالنظر إلى قاموس، إرجاع قيمة True إذا كانت جميع المفاتيح هي سلاسل نصية في الحالة الصغيرة أو جميع المفاتيح هي سلاسل نصية في الحالة الكبيرة، وإلا فإنه يجب إرجاع False. يجب أن يعيد الدالة False إذا كان القاموس المعطى فارغًا. أمثلة:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/42", "prompt": "/**\n * * \n * أنشئ دالة تأخذ قيمة (سلسلة نصية) تمثل رقمًا وتعيد أقرب عدد صحيح إليه. إذا كان الرقم على بعد مسافة متساوية من عددين صحيحين ، فقم بتقريبه بعيدًا عن الصفر.\n * \n *     أمثلة\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n\n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n *\n */\nfunction closestInteger(value) {\n", "entry_point": "closestInteger", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"10\";\nvar x0 = closestInteger(arg00);\nvar v0 = 10;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"14.5\";\nvar x1 = closestInteger(arg10);\nvar v1 = 15;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"-15.5\";\nvar x2 = closestInteger(arg20);\nvar v2 = -16;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"15.3\";\nvar x3 = closestInteger(arg30);\nvar v3 = 15;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"0\";\nvar x4 = closestInteger(arg40);\nvar v4 = 0;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * أنشئ دالة تأخذ قيمة (سلسلة نصية) تمثل رقمًا وتعيد أقرب عدد صحيح إليه. إذا كان الرقم على بعد مسافة متساوية من عددين صحيحين ، فقم بتقريبه بعيدًا عن الصفر.\n * \n *     أمثلة\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/43", "prompt": "/**\n * * \n * بالنظر إلى عدد صحيح موجب n، يجب عليك إنشاء كومة من n مستويات من الحجارة.\n * المستوى الأول يحتوي على n حجرًا.\n * عدد الحجارة في المستوى التالي هو:\n * - العدد الفردي التالي إذا كان n فرديًا.\n * - العدد الزوجي التالي إذا كان n زوجيًا.\n * يرجع عدد الحجارة في كل مستوى في قائمة، حيث يمثل العنصر في المؤشر i عدد الحجارة في المستوى (i + 1).\n * \n * أمثلة:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n *\n */\nfunction makeAPile(n) {\n", "entry_point": "makeAPile", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 3;\nvar x0 = makeAPile(arg00);\nvar v0 = [3, 5, 7];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 4;\nvar x1 = makeAPile(arg10);\nvar v1 = [4, 6, 8, 10];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 5;\nvar x2 = makeAPile(arg20);\nvar v2 = [5, 7, 9, 11, 13];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 6;\nvar x3 = makeAPile(arg30);\nvar v3 = [6, 8, 10, 12, 14, 16];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 8;\nvar x4 = makeAPile(arg40);\nvar v4 = [8, 10, 12, 14, 16, 18, 20, 22];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * بالنظر إلى عدد صحيح موجب n، يجب عليك إنشاء كومة من n مستويات من الحجارة.\n * المستوى الأول يحتوي على n حجرًا.\n * عدد الحجارة في المستوى التالي هو:\n * - العدد الفردي التالي إذا كان n فرديًا.\n * - العدد الزوجي التالي إذا كان n زوجيًا.\n * يرجع عدد الحجارة في كل مستوى في قائمة، حيث يمثل العنصر في المؤشر i عدد الحجارة في المستوى (i + 1).\n * \n * أمثلة:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/44", "prompt": "/**\n * * \n * سيتم إعطاؤك سلسلة من الكلمات مفصولة بفواصل أو مسافات. مهمتك هي تقسيم السلسلة إلى كلمات وإرجاع مصفوفة من الكلمات.\n * \n * على سبيل المثال:\n * \n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n *\n */\nfunction wordsString(s) {\n", "entry_point": "wordsString", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"Hi, my name is John\";\nvar x0 = wordsString(arg00);\nvar v0 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"One, two, three, four, five, six\";\nvar x1 = wordsString(arg10);\nvar v1 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"Hi, my name\";\nvar x2 = wordsString(arg20);\nvar v2 = [\"Hi\", \"my\", \"name\"];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"One,, two, three, four, five, six,\";\nvar x3 = wordsString(arg30);\nvar v3 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"\";\nvar x4 = wordsString(arg40);\nvar v4 = [];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"ahmed     , gamal\";\nvar x5 = wordsString(arg50);\nvar v5 = [\"ahmed\", \"gamal\"];\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * سيتم إعطاؤك سلسلة من الكلمات مفصولة بفواصل أو مسافات. مهمتك هي تقسيم السلسلة إلى كلمات وإرجاع مصفوفة من الكلمات.\n * \n * على سبيل المثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/45", "prompt": "/**\n * \n * هذه الدالة تأخذ رقمين موجبين x و y وتعيد أكبر عدد صحيح زوجي يقع في النطاق [x، y] بما في ذلك. إذا لم يكن هناك عدد كهذا ، يجب أن تعيد الدالة -1.\n * \n * على سبيل المثال:\n * \n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n *\n */\nfunction chooseNum(x, y) {\n", "entry_point": "chooseNum", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 12;\nvar arg01 = 15;\nvar x0 = chooseNum(arg00, arg01);\nvar v0 = 14;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 13;\nvar arg11 = 12;\nvar x1 = chooseNum(arg10, arg11);\nvar v1 = -1;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 33;\nvar arg21 = 12354;\nvar x2 = chooseNum(arg20, arg21);\nvar v2 = 12354;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 5234;\nvar arg31 = 5233;\nvar x3 = chooseNum(arg30, arg31);\nvar v3 = -1;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 6;\nvar arg41 = 29;\nvar x4 = chooseNum(arg40, arg41);\nvar v4 = 28;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 27;\nvar arg51 = 10;\nvar x5 = chooseNum(arg50, arg51);\nvar v5 = -1;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 7;\nvar arg61 = 7;\nvar x6 = chooseNum(arg60, arg61);\nvar v6 = -1;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = 546;\nvar arg71 = 546;\nvar x7 = chooseNum(arg70, arg71);\nvar v7 = 546;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * هذه الدالة تأخذ رقمين موجبين x و y وتعيد أكبر عدد صحيح زوجي يقع في النطاق [x، y] بما في ذلك. إذا لم يكن هناك عدد كهذا ، يجب أن تعيد الدالة -1.\n * \n * على سبيل المثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/46", "prompt": "/**\n * \n * يتم إعطاؤك عددين صحيحين موجبين n و m ، ومهمتك هي حساب المتوسط ​​للأعداد الصحيحة من n إلى m (بما في ذلك n و m). قم بتقريب الإجابة إلى أقرب عدد صحيح وتحويلها إلى النظام الثنائي. إذا كان n أكبر من m ، فأرجع -1. مثال:\n * \n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n *\n */\nfunction roundedAvg(n, m) {\n", "entry_point": "roundedAvg", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 1;\nvar arg01 = 5;\nvar x0 = roundedAvg(arg00, arg01);\nvar v0 = \"0b11\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 7;\nvar arg11 = 13;\nvar x1 = roundedAvg(arg10, arg11);\nvar v1 = \"0b1010\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 964;\nvar arg21 = 977;\nvar x2 = roundedAvg(arg20, arg21);\nvar v2 = \"0b1111001010\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 996;\nvar arg31 = 997;\nvar x3 = roundedAvg(arg30, arg31);\nvar v3 = \"0b1111100100\";\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 560;\nvar arg41 = 851;\nvar x4 = roundedAvg(arg40, arg41);\nvar v4 = \"0b1011000010\";\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 185;\nvar arg51 = 546;\nvar x5 = roundedAvg(arg50, arg51);\nvar v5 = \"0b101101110\";\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 362;\nvar arg61 = 496;\nvar x6 = roundedAvg(arg60, arg61);\nvar v6 = \"0b110101101\";\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = 350;\nvar arg71 = 902;\nvar x7 = roundedAvg(arg70, arg71);\nvar v7 = \"0b1001110010\";\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = 197;\nvar arg81 = 233;\nvar x8 = roundedAvg(arg80, arg81);\nvar v8 = \"0b11010111\";\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = 7;\nvar arg91 = 5;\nvar x9 = roundedAvg(arg90, arg91);\nvar v9 = -1;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg100 = 5;\nvar arg101 = 1;\nvar x10 = roundedAvg(arg100, arg101);\nvar v10 = -1;\nif(!compare(x10, v10)){\n    throw 'Error at 11th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg110 = 5;\nvar arg111 = 5;\nvar x11 = roundedAvg(arg110, arg111);\nvar v11 = \"0b101\";\nif(!compare(x11, v11)){\n    throw 'Error at 12th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * يتم إعطاؤك عددين صحيحين موجبين n و m ، ومهمتك هي حساب المتوسط ​​للأعداد الصحيحة من n إلى m (بما في ذلك n و m). قم بتقريب الإجابة إلى أقرب عدد صحيح وتحويلها إلى النظام الثنائي. إذا كان n أكبر من m ، فأرجع -1. مثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/47", "prompt": "/**\n * \n * قم بتنفيذ الدالة f التي تأخذ n كمعلمة،\n * وترجع قائمة بحجم n، بحيث يكون قيمة العنصر في المؤشر i هو عاملي الرقم i إذا كان i فرديًا،\n * أو مجموع الأرقام من 1 إلى i في حالة أخرى.\n * i يبدأ من 1.\n * عاملي الرقم i هو الضرب من الأرقام من 1 إلى i (1 * 2 * ... * i).\n * مثال:\n * \n * f(5) == [1, 2, 6, 24, 15]\n *\n */\nfunction f(n) {\n", "entry_point": "f", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 5;\nvar x0 = f(arg00);\nvar v0 = [1, 2, 6, 24, 15];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 7;\nvar x1 = f(arg10);\nvar v1 = [1, 2, 6, 24, 15, 720, 28];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 1;\nvar x2 = f(arg20);\nvar v2 = [1];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 3;\nvar x3 = f(arg30);\nvar v3 = [1, 2, 6];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * قم بتنفيذ الدالة f التي تأخذ n كمعلمة،\n * وترجع قائمة بحجم n، بحيث يكون قيمة العنصر في المؤشر i هو عاملي الرقم i إذا كان i فرديًا،\n * أو مجموع الأرقام من 1 إلى i في حالة أخرى.\n * i يبدأ من 1.\n * عاملي الرقم i هو الضرب من الأرقام من 1 إلى i (1 * 2 * ... * i).\n * مثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/48", "prompt": "/**\n * * \n * بالنظر إلى عدد صحيح موجب n ، يرجع tuple الذي يحتوي على عدد palindrome الصحيحة الزوجية والفردية التي تقع ضمن النطاق (1، n) ، شاملاً.\n * \n * مثال 1:\n * \n *     الإدخال: 3\n *     النتيجة: (1، 2)\n *     الشرح:\n *     عدد palindrome الصحيحة هي 1 و 2 و 3. واحد منهم زوجي ، واثنان منهم فرديان.\n * \n * مثال 2:\n * \n *     الإدخال: 12\n *     النتيجة: (4، 6)\n *     الشرح:\n *     عدد palindrome الصحيحة هي 1 و 2 و 3 و 4 و 5 و 6 و 7 و 8 و 9 و 11. أربعة منهم زوجيون ، و 6 منهم فرديون.\n * \n * ملاحظة:\n *     1. 1 <= n <= 10^3\n *     2. tuple المرجع يحتوي على عدد palindrome الصحيحة الزوجية والفردية على التوالي.\n * \n *\n */\nfunction evenOddPalindrome(n) {\n", "entry_point": "evenOddPalindrome", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 123;\nvar x0 = evenOddPalindrome(arg00);\nvar v0 = [8, 13];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 12;\nvar x1 = evenOddPalindrome(arg10);\nvar v1 = [4, 6];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 3;\nvar x2 = evenOddPalindrome(arg20);\nvar v2 = [1, 2];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 63;\nvar x3 = evenOddPalindrome(arg30);\nvar v3 = [6, 8];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 25;\nvar x4 = evenOddPalindrome(arg40);\nvar v4 = [5, 6];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 19;\nvar x5 = evenOddPalindrome(arg50);\nvar v5 = [4, 6];\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 9;\nvar x6 = evenOddPalindrome(arg60);\nvar v6 = [4, 5];\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = 1;\nvar x7 = evenOddPalindrome(arg70);\nvar v7 = [0, 1];\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * بالنظر إلى عدد صحيح موجب n ، يرجع tuple الذي يحتوي على عدد palindrome الصحيحة الزوجية والفردية التي تقع ضمن النطاق (1، n) ، شاملاً.\n * \n * مثال 1:\n * \n *     الإدخال: 3\n *     النتيجة: (1، 2)\n *     الشرح:\n *     عدد palindrome الصحيحة هي 1 و 2 و 3. واحد منهم زوجي ، واثنان منهم فرديان.\n * \n * مثال 2:\n * \n *     الإدخال: 12\n *     النتيجة: (4، 6)\n *     الشرح:\n *     عدد palindrome الصحيحة هي 1 و 2 و 3 و 4 و 5 و 6 و 7 و 8 و 9 و 11. أربعة منهم زوجيون ، و 6 منهم فرديون.\n * \n * ملاحظة:\n *     1. 1 <= n <= 10^3\n *     2. tuple المرجع يحتوي على عدد palindrome الصحيحة الزوجية والفردية على التوالي.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/49", "prompt": "/**\n * \n * لدينا مصفوفة 'arr' من N أعداد صحيحة arr [1]، arr [2]، ...، arr [N]. سيتم ترتيب الأرقام في المصفوفة بشكل عشوائي. مهمتك هي تحديد ما إذا كان من الممكن الحصول على مصفوفة مرتبة بترتيب غير تنازلي عن طريق تنفيذ العملية التالية على المصفوفة المعطاة:\n *     يسمح لك بتنفيذ عملية التحويل اليميني أي عدد من المرات.\n * \n *     تعني عملية التحويل اليميني الواحد تحويل جميع عناصر المصفوفة بمقدار واحد في الاتجاه الصحيح. سيتم نقل العنصر الأخير في المصفوفة إلى الموضع البدء في المصفوفة أي الفهرس 0.\n * \n *     إذا كان من الممكن الحصول على المصفوفة المرتبة بتنفيذ العملية أعلاه ، فأرجع True وإلا فأرجع False. إذا كانت المصفوفة المعطاة فارغة ، فأرجع True.\n * \n *     ملاحظة: يتم ضمان وجود عناصر فريدة في القائمة المعطاة.\n * \n *     على سبيل المثال:\n * \n *     move_one_ball ([3، 4، 5، 1، 2]) ==> True\n *     تفسير: يمكن تحقيق الترتيب غير التنازلي للمصفوفة المعطاة بتنفيذ 2 عمليات تحويل يمينية.\n *     move_one_ball ([3، 5، 4، 1، 2]) ==> False\n *     تفسير: لا يمكن الحصول على ترتيب غير تنازلي للمصفوفة المعطاة بتنفيذ أي عدد من عمليات التحويل اليميني.\n * \n *             \n *\n */\nfunction moveOneBall(arr) {\n", "entry_point": "moveOneBall", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [3, 4, 5, 1, 2];\nvar x0 = moveOneBall(arg00);\nvar v0 = true;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [3, 5, 10, 1, 2];\nvar x1 = moveOneBall(arg10);\nvar v1 = true;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [4, 3, 1, 2];\nvar x2 = moveOneBall(arg20);\nvar v2 = false;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [3, 5, 4, 1, 2];\nvar x3 = moveOneBall(arg30);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [];\nvar x4 = moveOneBall(arg40);\nvar v4 = true;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * لدينا مصفوفة 'arr' من N أعداد صحيحة arr [1]، arr [2]، ...، arr [N]. سيتم ترتيب الأرقام في المصفوفة بشكل عشوائي. مهمتك هي تحديد ما إذا كان من الممكن الحصول على مصفوفة مرتبة بترتيب غير تنازلي عن طريق تنفيذ العملية التالية على المصفوفة المعطاة:\n *     يسمح لك بتنفيذ عملية التحويل اليميني أي عدد من المرات.\n * \n *     تعني عملية التحويل اليميني الواحد تحويل جميع عناصر المصفوفة بمقدار واحد في الاتجاه الصحيح. سيتم نقل العنصر الأخير في المصفوفة إلى الموضع البدء في المصفوفة أي الفهرس 0.\n * \n *     إذا كان من الممكن الحصول على المصفوفة المرتبة بتنفيذ العملية أعلاه ، فأرجع True وإلا فأرجع False. إذا كانت المصفوفة المعطاة فارغة ، فأرجع True.\n * \n *     ملاحظة: يتم ضمان وجود عناصر فريدة في القائمة المعطاة.\n * \n *     على سبيل المثال:\n * \n *     move_one_ball ([3، 4، 5، 1، 2]) ==> True\n *     تفسير: يمكن تحقيق الترتيب غير التنازلي للمصفوفة المعطاة بتنفيذ 2 عمليات تحويل يمينية.\n *     move_one_ball ([3، 5، 4، 1، 2]) ==> False\n *     تفسير: لا يمكن الحصول على ترتيب غير تنازلي للمصفوفة المعطاة بتنفيذ أي عدد من عمليات التحويل اليميني.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/50", "prompt": "/**\n * \n * في هذه المشكلة، ستقوم بتنفيذ وظيفة تأخذ قائمتين من الأرقام، وتحدد ما إذا كان من الممكن القيام بتبادل العناصر بينهما لجعل lst1 قائمة من الأرقام الزوجية فقط. لا يوجد حد لعدد العناصر المتبادلة بين lst1 و lst2. إذا كان من الممكن تبادل العناصر بين lst1 و lst2 لجعل جميع عناصر lst1 زوجية، فأرجع \"نعم\". وإلا، أرجع \"لا\". على سبيل المثال: exchange([1، 2، 3، 4]، [1، 2، 3، 4]) => \"نعم\" exchange([1، 2، 3، 4]، [1، 5، 3، 4]) => \"لا\" يفترض أن تكون القوائم المدخلة غير فارغة.\n * \n *\n */\nfunction exchange(lst1, lst2) {\n", "entry_point": "exchange", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [1, 2, 3, 4];\nvar arg01 = [1, 2, 3, 4];\nvar x0 = exchange(arg00, arg01);\nvar v0 = \"YES\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1, 2, 3, 4];\nvar arg11 = [1, 5, 3, 4];\nvar x1 = exchange(arg10, arg11);\nvar v1 = \"NO\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [1, 2, 3, 4];\nvar arg21 = [2, 1, 4, 3];\nvar x2 = exchange(arg20, arg21);\nvar v2 = \"YES\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [5, 7, 3];\nvar arg31 = [2, 6, 4];\nvar x3 = exchange(arg30, arg31);\nvar v3 = \"YES\";\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [5, 7, 3];\nvar arg41 = [2, 6, 3];\nvar x4 = exchange(arg40, arg41);\nvar v4 = \"NO\";\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [3, 2, 6, 1, 8, 9];\nvar arg51 = [3, 5, 5, 1, 1, 1];\nvar x5 = exchange(arg50, arg51);\nvar v5 = \"NO\";\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = [100, 200];\nvar arg61 = [200, 200];\nvar x6 = exchange(arg60, arg61);\nvar v6 = \"YES\";\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * في هذه المشكلة، ستقوم بتنفيذ وظيفة تأخذ قائمتين من الأرقام، وتحدد ما إذا كان من الممكن القيام بتبادل العناصر بينهما لجعل lst1 قائمة من الأرقام الزوجية فقط. لا يوجد حد لعدد العناصر المتبادلة بين lst1 و lst2. إذا كان من الممكن تبادل العناصر بين lst1 و lst2 لجعل جميع عناصر lst1 زوجية، فأرجع \"نعم\". وإلا، أرجع \"لا\". على سبيل المثال: exchange([1، 2، 3، 4]، [1، 2، 3، 4]) => \"نعم\" exchange([1، 2، 3، 4]، [1، 5، 3، 4]) => \"لا\" يفترض أن تكون القوائم المدخلة غير فارغة.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/51", "prompt": "/**\n * \n * المهمة\n * نحن نحصل على سلسلتين s و c ، يجب عليك حذف جميع الأحرف في s التي تساوي أي حرف في c\n * ثم التحقق مما إذا كانت سلسلة النتيجة هي palindrome.\n * يسمى سلسلة palindrome إذا قرأت بالمعكوس نفسها.\n * يجب عليك إرجاع tuple يحتوي على سلسلة النتيجة و True / False للتحقق.\n * مثال\n * بالنسبة لـ s = \"abcde\" ، c = \"ae\" ، يجب أن يكون النتيجة ('bcd'،False)\n * بالنسبة لـ s = \"abcdef\" ، c = \"b\" يجب أن يكون النتيجة ('acdef'،False)\n * بالنسبة لـ s = \"abcdedcba\" ، c = \"ab\" يجب أن يكون النتيجة ('cdedc'،True)\n * \n *\n */\nfunction reverseDelete(s, c) {\n", "entry_point": "reverseDelete", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"abcde\";\nvar arg01 = \"ae\";\nvar x0 = reverseDelete(arg00, arg01);\nvar v0 = [\"bcd\", false];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"abcdef\";\nvar arg11 = \"b\";\nvar x1 = reverseDelete(arg10, arg11);\nvar v1 = [\"acdef\", false];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"abcdedcba\";\nvar arg21 = \"ab\";\nvar x2 = reverseDelete(arg20, arg21);\nvar v2 = [\"cdedc\", true];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"dwik\";\nvar arg31 = \"w\";\nvar x3 = reverseDelete(arg30, arg31);\nvar v3 = [\"dik\", false];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"a\";\nvar arg41 = \"a\";\nvar x4 = reverseDelete(arg40, arg41);\nvar v4 = [\"\", true];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"abcdedcba\";\nvar arg51 = \"\";\nvar x5 = reverseDelete(arg50, arg51);\nvar v5 = [\"abcdedcba\", true];\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"abcdedcba\";\nvar arg61 = \"v\";\nvar x6 = reverseDelete(arg60, arg61);\nvar v6 = [\"abcdedcba\", true];\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = \"vabba\";\nvar arg71 = \"v\";\nvar x7 = reverseDelete(arg70, arg71);\nvar v7 = [\"abba\", true];\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = \"mamma\";\nvar arg81 = \"mia\";\nvar x8 = reverseDelete(arg80, arg81);\nvar v8 = [\"\", true];\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * المهمة\n * نحن نحصل على سلسلتين s و c ، يجب عليك حذف جميع الأحرف في s التي تساوي أي حرف في c\n * ثم التحقق مما إذا كانت سلسلة النتيجة هي palindrome.\n * يسمى سلسلة palindrome إذا قرأت بالمعكوس نفسها.\n * يجب عليك إرجاع tuple يحتوي على سلسلة النتيجة و True / False للتحقق.\n * مثال\n * بالنسبة لـ s = \"abcde\" ، c = \"ae\" ، يجب أن يكون النتيجة ('bcd'،False)\n * بالنسبة لـ s = \"abcdef\" ، c = \"b\" يجب أن يكون النتيجة ('acdef'،False)\n * بالنسبة لـ s = \"abcdedcba\" ، c = \"ab\" يجب أن يكون النتيجة ('cdedc'،True)\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/52", "prompt": "/**\n * * \n * يتم تزويدك بشبكة مستطيلة من الآبار. تمثل كل صف بئرًا ويمثل الرقم 1 في الصف وحدة واحدة من الماء. لكل بئر دلو مقابل يمكن استخدامه لاستخراج الماء منه، وجميع الدلاء لديها نفس السعة. مهمتك هي استخدام الدلاء لتفريغ الآبار. أخرج عدد المرات التي تحتاج فيها إلى خفض الدلاء.\n * \n * مثال 1:\n *     المدخلات:\n *         grid: [[0،0،1،0]، [0،1،0،0]، [1،1،1،1]]\n *         bucket_capacity: 1\n *     الناتج: 6\n * \n * مثال 2:\n *     المدخلات:\n *         grid: [[0،0،1،1]، [0،0،0،0]، [1،1،1،1]، [0،1،1،1]]\n *         bucket_capacity: 2\n *     الناتج: 5\n * \n * مثال 3:\n *     المدخلات:\n *         grid: [[0،0،0]، [0،0،0]]\n *         bucket_capacity: 5\n *     الناتج: 0\n * \n * القيود:\n *     * جميع الآبار لديها نفس الطول\n *     * 1 <= grid.length <= 10^2\n *     * 1 <= grid [:،1].length <= 10^2\n *     * grid [i] [j] -> 0 | 1\n *     * 1 <= capacity <= 10\n * \n *\n */\nfunction maxFill(grid, capacity) {\n", "entry_point": "maxFill", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]];\nvar arg01 = 1;\nvar x0 = maxFill(arg00, arg01);\nvar v0 = 6;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]];\nvar arg11 = 2;\nvar x1 = maxFill(arg10, arg11);\nvar v1 = 5;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [[0, 0, 0], [0, 0, 0]];\nvar arg21 = 5;\nvar x2 = maxFill(arg20, arg21);\nvar v2 = 0;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [[1, 1, 1, 1], [1, 1, 1, 1]];\nvar arg31 = 2;\nvar x3 = maxFill(arg30, arg31);\nvar v3 = 4;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [[1, 1, 1, 1], [1, 1, 1, 1]];\nvar arg41 = 9;\nvar x4 = maxFill(arg40, arg41);\nvar v4 = 2;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * يتم تزويدك بشبكة مستطيلة من الآبار. تمثل كل صف بئرًا ويمثل الرقم 1 في الصف وحدة واحدة من الماء. لكل بئر دلو مقابل يمكن استخدامه لاستخراج الماء منه، وجميع الدلاء لديها نفس السعة. مهمتك هي استخدام الدلاء لتفريغ الآبار. أخرج عدد المرات التي تحتاج فيها إلى خفض الدلاء.\n * \n * مثال 1:\n *     المدخلات:\n *         grid: [[0،0،1،0]، [0،1،0،0]، [1،1،1،1]]\n *         bucket_capacity: 1\n *     الناتج: 6\n * \n * مثال 2:\n *     المدخلات:\n *         grid: [[0،0،1،1]، [0،0،0،0]، [1،1،1،1]، [0،1،1،1]]\n *         bucket_capacity: 2\n *     الناتج: 5\n * \n * مثال 3:\n *     المدخلات:\n *         grid: [[0،0،0]، [0،0،0]]\n *         bucket_capacity: 5\n *     الناتج: 0\n * \n * القيود:\n *     * جميع الآبار لديها نفس الطول\n *     * 1 <= grid.length <= 10^2\n *     * 1 <= grid [:،1].length <= 10^2\n *     * grid [i] [j] -> 0 | 1\n *     * 1 <= capacity <= 10\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/53", "prompt": "/**\n * \n * تم تكليفك بتنفيذ وظيفة تعيد قائمة بجميع الكلمات من السلسلة s التي تحتوي بالضبط على n حروف ساكنة، بالترتيب الذي تظهر به هذه الكلمات في السلسلة s. إذا كانت السلسلة s فارغة ، يجب أن تعيد الوظيفة قائمة فارغة. ملاحظة: يمكنك الافتراض بأن سلسلة الإدخال تحتوي فقط على الحروف والمسافات.\n *     أمثلة:\n * \n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n *\n */\nfunction selectWords(s, n) {\n", "entry_point": "selectWords", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"Mary had a little lamb\";\nvar arg01 = 4;\nvar x0 = selectWords(arg00, arg01);\nvar v0 = [\"little\"];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"Mary had a little lamb\";\nvar arg11 = 3;\nvar x1 = selectWords(arg10, arg11);\nvar v1 = [\"Mary\", \"lamb\"];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"simple white space\";\nvar arg21 = 2;\nvar x2 = selectWords(arg20, arg21);\nvar v2 = [];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"Hello world\";\nvar arg31 = 4;\nvar x3 = selectWords(arg30, arg31);\nvar v3 = [\"world\"];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"Uncle sam\";\nvar arg41 = 3;\nvar x4 = selectWords(arg40, arg41);\nvar v4 = [\"Uncle\"];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"\";\nvar arg51 = 4;\nvar x5 = selectWords(arg50, arg51);\nvar v5 = [];\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"a b c d e f\";\nvar arg61 = 1;\nvar x6 = selectWords(arg60, arg61);\nvar v6 = [\"b\", \"c\", \"d\", \"f\"];\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * تم تكليفك بتنفيذ وظيفة تعيد قائمة بجميع الكلمات من السلسلة s التي تحتوي بالضبط على n حروف ساكنة، بالترتيب الذي تظهر به هذه الكلمات في السلسلة s. إذا كانت السلسلة s فارغة ، يجب أن تعيد الوظيفة قائمة فارغة. ملاحظة: يمكنك الافتراض بأن سلسلة الإدخال تحتوي فقط على الحروف والمسافات.\n *     أمثلة:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/54", "prompt": "/**\n * * \n * بالنظر إلى مصفوفة arr من الأعداد الصحيحة وعدد صحيح موجب k ، يتم إرجاع قائمة مرتبة بطول k مع أكبر k أرقام في arr.\n * \n *     مثال 1:\n * \n *         المدخلات: arr = [-3، -4، 5]، k = 3\n *         الناتج: [-4، -3، 5]\n * \n *     مثال 2:\n * \n *         المدخلات: arr = [4، -4، 4]، k = 2\n *         الناتج: [4، 4]\n * \n *     مثال 3:\n * \n *         المدخلات: arr = [-3، 2، 1، 2، -1، -2، 1]، k = 1\n *         الناتج: [2]\n * \n *     ملاحظة:\n *         1. سيكون طول المصفوفة في نطاق [1، 1000].\n *         2. ستكون العناصر في المصفوفة في نطاق [-1000، 1000].\n *         3. 0 <= k <= len (arr)\n * \n *\n */\nfunction maximum(arr, k) {\n", "entry_point": "maximum", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [-3, -4, 5];\nvar arg01 = 3;\nvar x0 = maximum(arg00, arg01);\nvar v0 = [-4, -3, 5];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [4, -4, 4];\nvar arg11 = 2;\nvar x1 = maximum(arg10, arg11);\nvar v1 = [4, 4];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [-3, 2, 1, 2, -1, -2, 1];\nvar arg21 = 1;\nvar x2 = maximum(arg20, arg21);\nvar v2 = [2];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [123, -123, 20, 0, 1, 2, -3];\nvar arg31 = 3;\nvar x3 = maximum(arg30, arg31);\nvar v3 = [2, 20, 123];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [-123, 20, 0, 1, 2, -3];\nvar arg41 = 4;\nvar x4 = maximum(arg40, arg41);\nvar v4 = [0, 1, 2, 20];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [5, 15, 0, 3, -13, -8, 0];\nvar arg51 = 7;\nvar x5 = maximum(arg50, arg51);\nvar v5 = [-13, -8, 0, 0, 3, 5, 15];\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = [-1, 0, 2, 5, 3, -10];\nvar arg61 = 2;\nvar x6 = maximum(arg60, arg61);\nvar v6 = [3, 5];\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = [1, 0, 5, -7];\nvar arg71 = 1;\nvar x7 = maximum(arg70, arg71);\nvar v7 = [5];\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = [4, -4];\nvar arg81 = 2;\nvar x8 = maximum(arg80, arg81);\nvar v8 = [-4, 4];\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = [-10, 10];\nvar arg91 = 2;\nvar x9 = maximum(arg90, arg91);\nvar v9 = [-10, 10];\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg100 = [1, 2, 3, -23, 243, -400, 0];\nvar arg101 = 0;\nvar x10 = maximum(arg100, arg101);\nvar v10 = [];\nif(!compare(x10, v10)){\n    throw 'Error at 11th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * بالنظر إلى مصفوفة arr من الأعداد الصحيحة وعدد صحيح موجب k ، يتم إرجاع قائمة مرتبة بطول k مع أكبر k أرقام في arr.\n * \n *     مثال 1:\n * \n *         المدخلات: arr = [-3، -4، 5]، k = 3\n *         الناتج: [-4، -3، 5]\n * \n *     مثال 2:\n * \n *         المدخلات: arr = [4، -4، 4]، k = 2\n *         الناتج: [4، 4]\n * \n *     مثال 3:\n * \n *         المدخلات: arr = [-3، 2، 1، 2، -1، -2، 1]، k = 1\n *         الناتج: [2]\n * \n *     ملاحظة:\n *         1. سيكون طول المصفوفة في نطاق [1، 1000].\n *         2. ستكون العناصر في المصفوفة في نطاق [-1000، 1000].\n *         3. 0 <= k <= len (arr)\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/55", "prompt": "/**\n * * \n * عندما يتم إعطاء مصفوفة غير فارغة من الأعداد الصحيحة arr وعدد صحيح k ، يتم إرجاع مجموع العناصر التي لديها رقمين على الأكثر من أول k عنصرًا في arr.\n * \n *     مثال:\n * \n *         المدخلات: arr = [111،21،3،4000،5،6،7،8،9] ، k = 4\n *         الإخراج: 24 # مجموع 21 + 3\n * \n *     القيود:\n *         1. 1 <= len(arr) <= 100\n *         2. 1 <= k <= len(arr)\n * \n *\n */\nfunction addElements(arr, k) {\n", "entry_point": "addElements", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [1, -2, -3, 41, 57, 76, 87, 88, 99];\nvar arg01 = 3;\nvar x0 = addElements(arg00, arg01);\nvar v0 = -4;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [111, 121, 3, 4000, 5, 6];\nvar arg11 = 2;\nvar x1 = addElements(arg10, arg11);\nvar v1 = 0;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [11, 21, 3, 90, 5, 6, 7, 8, 9];\nvar arg21 = 4;\nvar x2 = addElements(arg20, arg21);\nvar v2 = 125;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [111, 21, 3, 4000, 5, 6, 7, 8, 9];\nvar arg31 = 4;\nvar x3 = addElements(arg30, arg31);\nvar v3 = 24;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [1];\nvar arg41 = 1;\nvar x4 = addElements(arg40, arg41);\nvar v4 = 1;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * عندما يتم إعطاء مصفوفة غير فارغة من الأعداد الصحيحة arr وعدد صحيح k ، يتم إرجاع مجموع العناصر التي لديها رقمين على الأكثر من أول k عنصرًا في arr.\n * \n *     مثال:\n * \n *         المدخلات: arr = [111،21،3،4000،5،6،7،8،9] ، k = 4\n *         الإخراج: 24 # مجموع 21 + 3\n * \n *     القيود:\n *         1. 1 <= len(arr) <= 100\n *         2. 1 <= k <= len(arr)\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/56", "prompt": "/**\n * \n * يتم تزويدك بنطاقين،\n * حيث يتكون كل نطاق من زوج من الأعداد الصحيحة. على سبيل المثال، النطاق = (البداية، النهاية) = (1، 2).\n * النطاقات المعطاة مغلقة مما يعني أن النطاق (البداية، النهاية)\n * يشمل كل من البداية والنهاية.\n * يفترض لكل نطاق معطى أن بدايته أقل أو يساوي نهايته.\n * مهمتك هي تحديد ما إذا كان طول تقاطع هذين النطاقين هو عدد أولي.\n * على سبيل المثال، تقاطع النطاقات (1، 3)، (2، 4) هو (2، 3)\n * الذي يبلغ طوله 1، وهو ليس عددًا أوليًا.\n * إذا كان طول التقاطع عددًا أوليًا، فأرجع \"نعم\"،\n * وإلا، أرجع \"لا\".\n * إذا لم يتقاطع النطاقان، فأرجع \"لا\".\n * \n * [المدخلات/المخرجات] الأمثلة:\n * \n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n *\n */\nfunction intersection(interval1, interval2) {\n", "entry_point": "intersection", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [1, 2];\nvar arg01 = [2, 3];\nvar x0 = intersection(arg00, arg01);\nvar v0 = \"NO\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [-1, 1];\nvar arg11 = [0, 4];\nvar x1 = intersection(arg10, arg11);\nvar v1 = \"NO\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [-3, -1];\nvar arg21 = [-5, 5];\nvar x2 = intersection(arg20, arg21);\nvar v2 = \"YES\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [-2, 2];\nvar arg31 = [-4, 0];\nvar x3 = intersection(arg30, arg31);\nvar v3 = \"YES\";\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [-11, 2];\nvar arg41 = [-1, -1];\nvar x4 = intersection(arg40, arg41);\nvar v4 = \"NO\";\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [1, 2];\nvar arg51 = [3, 5];\nvar x5 = intersection(arg50, arg51);\nvar v5 = \"NO\";\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = [1, 2];\nvar arg61 = [1, 2];\nvar x6 = intersection(arg60, arg61);\nvar v6 = \"NO\";\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = [-2, -2];\nvar arg71 = [-3, -2];\nvar x7 = intersection(arg70, arg71);\nvar v7 = \"NO\";\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * يتم تزويدك بنطاقين،\n * حيث يتكون كل نطاق من زوج من الأعداد الصحيحة. على سبيل المثال، النطاق = (البداية، النهاية) = (1، 2).\n * النطاقات المعطاة مغلقة مما يعني أن النطاق (البداية، النهاية)\n * يشمل كل من البداية والنهاية.\n * يفترض لكل نطاق معطى أن بدايته أقل أو يساوي نهايته.\n * مهمتك هي تحديد ما إذا كان طول تقاطع هذين النطاقين هو عدد أولي.\n * على سبيل المثال، تقاطع النطاقات (1، 3)، (2، 4) هو (2، 3)\n * الذي يبلغ طوله 1، وهو ليس عددًا أوليًا.\n * إذا كان طول التقاطع عددًا أوليًا، فأرجع \"نعم\"،\n * وإلا، أرجع \"لا\".\n * إذا لم يتقاطع النطاقان، فأرجع \"لا\".\n * \n * [المدخلات/المخرجات] الأمثلة:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/57", "prompt": "/**\n * \n * الجميع يعرف سلسلة فيبوناتشي، وقد درسها الرياضيون بعمق في القرون القليلة الماضية. ومع ذلك، ما لا يعرفه الناس هو سلسلة تريبوناتشي. تعرف سلسلة تريبوناتشي بالتكرار:\n * tri(1) = 3\n * tri(n) = 1 + n / 2، إذا كان n زوجيًا.\n * tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، إذا كان n فرديًا.\n * على سبيل المثال:\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n * = 2 + 3 + 3 = 8\n * يتم إعطاؤك عدد صحيح غير سلبي n ، ويجب عليك إرجاع قائمة بأول n + 1 عددًا في سلسلة تريبوناتشي.\n * أمثلة:\n * tri(3) = [1، 3، 2، 8]\n * \n *\n */\nfunction tri(n) {\n", "entry_point": "tri", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 3;\nvar x0 = tri(arg00);\nvar v0 = [1, 3, 2.0, 8.0];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 4;\nvar x1 = tri(arg10);\nvar v1 = [1, 3, 2.0, 8.0, 3.0];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 5;\nvar x2 = tri(arg20);\nvar v2 = [1, 3, 2.0, 8.0, 3.0, 15.0];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 6;\nvar x3 = tri(arg30);\nvar v3 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 7;\nvar x4 = tri(arg40);\nvar v4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 8;\nvar x5 = tri(arg50);\nvar v5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0];\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 9;\nvar x6 = tri(arg60);\nvar v6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0];\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = 20;\nvar x7 = tri(arg70);\nvar v7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0];\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = 0;\nvar x8 = tri(arg80);\nvar v8 = [1];\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = 1;\nvar x9 = tri(arg90);\nvar v9 = [1, 3];\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * الجميع يعرف سلسلة فيبوناتشي، وقد درسها الرياضيون بعمق في القرون القليلة الماضية. ومع ذلك، ما لا يعرفه الناس هو سلسلة تريبوناتشي. تعرف سلسلة تريبوناتشي بالتكرار:\n * tri(1) = 3\n * tri(n) = 1 + n / 2، إذا كان n زوجيًا.\n * tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، إذا كان n فرديًا.\n * على سبيل المثال:\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n * = 2 + 3 + 3 = 8\n * يتم إعطاؤك عدد صحيح غير سلبي n ، ويجب عليك إرجاع قائمة بأول n + 1 عددًا في سلسلة تريبوناتشي.\n * أمثلة:\n * tri(3) = [1، 3، 2، 8]\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/58", "prompt": "/**\n * \n * بالنظر إلى عدد صحيح موجب n، يتم إرجاع حاصل ضرب الأرقام الفردية.\n * إذا كانت جميع الأرقام زوجية، يتم إرجاع القيمة 0.\n * على سبيل المثال:\n * \n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n *\n */\nfunction digits(n) {\n", "entry_point": "digits", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 5;\nvar x0 = digits(arg00);\nvar v0 = 5;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 54;\nvar x1 = digits(arg10);\nvar v1 = 5;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 120;\nvar x2 = digits(arg20);\nvar v2 = 1;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 5014;\nvar x3 = digits(arg30);\nvar v3 = 5;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 98765;\nvar x4 = digits(arg40);\nvar v4 = 315;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 5576543;\nvar x5 = digits(arg50);\nvar v5 = 2625;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 2468;\nvar x6 = digits(arg60);\nvar v6 = 0;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * بالنظر إلى عدد صحيح موجب n، يتم إرجاع حاصل ضرب الأرقام الفردية.\n * إذا كانت جميع الأرقام زوجية، يتم إرجاع القيمة 0.\n * على سبيل المثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/59", "prompt": "/**\n * * \n * أنشئ دالة تأخذ سلسلة نصية كمدخلات تحتوي فقط على أقواس مربعة.\n * يجب أن تعيد الدالة True إذا وفقط إذا كان هناك متتالية صحيحة من الأقواس\n * حيث يتم تضمين على الأقل قوس واحد في المتتالية.\n * is_nested('[[]]') ➞ True\n * is_nested('[]]]]]]][[[[[]') ➞ False\n * is_nested('[][]') ➞ False\n * is_nested('[]') ➞ False\n * is_nested('[[][]]') ➞ True\n * is_nested('[[]][[') ➞ True\n *\n */\nfunction isNested(string) {\n", "entry_point": "isNested", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"[[]]\";\nvar x0 = isNested(arg00);\nvar v0 = true;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"[]]]]]]][[[[[]\";\nvar x1 = isNested(arg10);\nvar v1 = false;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"[][]\";\nvar x2 = isNested(arg20);\nvar v2 = false;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"[]\";\nvar x3 = isNested(arg30);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"[[[[]]]]\";\nvar x4 = isNested(arg40);\nvar v4 = true;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"[]]]]]]]]]]\";\nvar x5 = isNested(arg50);\nvar v5 = false;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"[][][[]]\";\nvar x6 = isNested(arg60);\nvar v6 = true;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = \"[[]\";\nvar x7 = isNested(arg70);\nvar v7 = false;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = \"[]]\";\nvar x8 = isNested(arg80);\nvar v8 = false;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = \"[[]][[\";\nvar x9 = isNested(arg90);\nvar v9 = true;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg100 = \"[[][]]\";\nvar x10 = isNested(arg100);\nvar v10 = true;\nif(!compare(x10, v10)){\n    throw 'Error at 11th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg110 = \"\";\nvar x11 = isNested(arg110);\nvar v11 = false;\nif(!compare(x11, v11)){\n    throw 'Error at 12th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg120 = \"[[[[[[[[\";\nvar x12 = isNested(arg120);\nvar v12 = false;\nif(!compare(x12, v12)){\n    throw 'Error at 13th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg130 = \"]]]]]]]]\";\nvar x13 = isNested(arg130);\nvar v13 = false;\nif(!compare(x13, v13)){\n    throw 'Error at 14th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * أنشئ دالة تأخذ سلسلة نصية كمدخلات تحتوي فقط على أقواس مربعة.\n * يجب أن تعيد الدالة True إذا وفقط إذا كان هناك متتالية صحيحة من الأقواس\n * حيث يتم تضمين على الأقل قوس واحد في المتتالية.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/60", "prompt": "/**\n * \n * تمنحك قائمة من الأرقام.\n * تحتاج إلى إرجاع مجموع الأرقام المربعة في القائمة المعطاة،\n * قم بتقريب كل عنصر في القائمة إلى العدد الصحيح الأعلى (السقف) أولاً.\n * أمثلة:\n * للقائمة = [1،2،3] يجب أن يكون الإخراج 14\n * للقائمة = [1،4،9] يجب أن يكون الإخراج 98\n * للقائمة = [1،3،5،7] يجب أن يكون الإخراج 84\n * للقائمة = [1.4،4.2،0] يجب أن يكون الإخراج 29\n * للقائمة = [-2.4،1،1] يجب أن يكون الإخراج 6\n * \n * \n\n *\n */\nfunction sumSquares(lst) {\n", "entry_point": "sumSquares", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [1, 2, 3];\nvar x0 = sumSquares(arg00);\nvar v0 = 14;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1.0, 2, 3];\nvar x1 = sumSquares(arg10);\nvar v1 = 14;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [1, 3, 5, 7];\nvar x2 = sumSquares(arg20);\nvar v2 = 84;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [1.4, 4.2, 0];\nvar x3 = sumSquares(arg30);\nvar v3 = 29;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [-2.4, 1, 1];\nvar x4 = sumSquares(arg40);\nvar v4 = 6;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [100, 1, 15, 2];\nvar x5 = sumSquares(arg50);\nvar v5 = 10230;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = [10000, 10000];\nvar x6 = sumSquares(arg60);\nvar v6 = 200000000;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = [-1.4, 4.6, 6.3];\nvar x7 = sumSquares(arg70);\nvar v7 = 75;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = [-1.4, 17.9, 18.9, 19.9];\nvar x8 = sumSquares(arg80);\nvar v8 = 1086;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = [0];\nvar x9 = sumSquares(arg90);\nvar v9 = 0;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg100 = [-1];\nvar x10 = sumSquares(arg100);\nvar v10 = 1;\nif(!compare(x10, v10)){\n    throw 'Error at 11th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg110 = [-1, 1, 0];\nvar x11 = sumSquares(arg110);\nvar v11 = 2;\nif(!compare(x11, v11)){\n    throw 'Error at 12th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * تمنحك قائمة من الأرقام.\n * تحتاج إلى إرجاع مجموع الأرقام المربعة في القائمة المعطاة،\n * قم بتقريب كل عنصر في القائمة إلى العدد الصحيح الأعلى (السقف) أولاً.\n * أمثلة:\n * للقائمة = [1،2،3] يجب أن يكون الإخراج 14\n * للقائمة = [1،4،9] يجب أن يكون الإخراج 98\n * للقائمة = [1،3،5،7] يجب أن يكون الإخراج 84\n * للقائمة = [1.4،4.2،0] يجب أن يكون الإخراج 29\n * للقائمة = [-2.4،1،1] يجب أن يكون الإخراج 6\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/61", "prompt": "/**\n * * \n * أنشئ دالة تعيد True إذا كان الحرف الأخير في السلسلة المعطاة حرفًا أبجديًا وليس جزءًا من كلمة، وتعيد False في الحالة الأخرى.\n * ملاحظة: \"الكلمة\" هي مجموعة من الأحرف مفصولة بمسافة.\n * \n * أمثلة:\n * \n * check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n * check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n * check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n * check_if_last_char_is_a_letter(\"\") ➞ False \n *\n */\nfunction checkIfLastCharIsALetter(txt) {\n", "entry_point": "checkIfLastCharIsALetter", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"apple\";\nvar x0 = checkIfLastCharIsALetter(arg00);\nvar v0 = false;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"apple pi e\";\nvar x1 = checkIfLastCharIsALetter(arg10);\nvar v1 = true;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"eeeee\";\nvar x2 = checkIfLastCharIsALetter(arg20);\nvar v2 = false;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"A\";\nvar x3 = checkIfLastCharIsALetter(arg30);\nvar v3 = true;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"Pumpkin pie \";\nvar x4 = checkIfLastCharIsALetter(arg40);\nvar v4 = false;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"Pumpkin pie 1\";\nvar x5 = checkIfLastCharIsALetter(arg50);\nvar v5 = false;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"\";\nvar x6 = checkIfLastCharIsALetter(arg60);\nvar v6 = false;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = \"eeeee e \";\nvar x7 = checkIfLastCharIsALetter(arg70);\nvar v7 = false;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = \"apple pie\";\nvar x8 = checkIfLastCharIsALetter(arg80);\nvar v8 = false;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = \"apple pi e \";\nvar x9 = checkIfLastCharIsALetter(arg90);\nvar v9 = false;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * أنشئ دالة تعيد True إذا كان الحرف الأخير في السلسلة المعطاة حرفًا أبجديًا وليس جزءًا من كلمة، وتعيد False في الحالة الأخرى.\n * ملاحظة: \"الكلمة\" هي مجموعة من الأحرف مفصولة بمسافة.\n * \n * أمثلة:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/62", "prompt": "/**\n * \n * أنشئ دالة تعيد أكبر فهرس لعنصر لا يزيد عن العنصر الذي يسبقه. إذا لم يوجد عنصر كهذا ، فأرجع -1. لن يحتوي المصفوفة المعطاة على قيم مكررة.\n * \n *     أمثلة:\n * \n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n *\n */\nfunction canArrange(arr) {\n", "entry_point": "canArrange", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [1, 2, 4, 3, 5];\nvar x0 = canArrange(arg00);\nvar v0 = 3;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1, 2, 4, 5];\nvar x1 = canArrange(arg10);\nvar v1 = -1;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [1, 4, 2, 5, 6, 7, 8, 9, 10];\nvar x2 = canArrange(arg20);\nvar v2 = 2;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [4, 8, 5, 7, 3];\nvar x3 = canArrange(arg30);\nvar v3 = 4;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [];\nvar x4 = canArrange(arg40);\nvar v4 = -1;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * أنشئ دالة تعيد أكبر فهرس لعنصر لا يزيد عن العنصر الذي يسبقه. إذا لم يوجد عنصر كهذا ، فأرجع -1. لن يحتوي المصفوفة المعطاة على قيم مكررة.\n * \n *     أمثلة:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/63", "prompt": "/**\n * * \n * أنشئ دالة تعيد tuple (a، b) ، حيث يكون 'a' هو أكبر الأعداد الصحيحة السالبة ، و 'b' هو أصغر الأعداد الصحيحة الموجبة في القائمة. إذا لم يكن هناك أعداد صحيحة سالبة أو موجبة ، فأرجعها كـ None.\n * \n *     Examples:\n * \n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n *\n */\nfunction largestSmallestIntegers(lst) {\n", "entry_point": "largestSmallestIntegers", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [2, 4, 1, 3, 5, 7];\nvar x0 = largestSmallestIntegers(arg00);\nvar v0 = [null, 1];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [2, 4, 1, 3, 5, 7, 0];\nvar x1 = largestSmallestIntegers(arg10);\nvar v1 = [null, 1];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [1, 3, 2, 4, 5, 6, -2];\nvar x2 = largestSmallestIntegers(arg20);\nvar v2 = [-2, 1];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [4, 5, 3, 6, 2, 7, -7];\nvar x3 = largestSmallestIntegers(arg30);\nvar v3 = [-7, 2];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [7, 3, 8, 4, 9, 2, 5, -9];\nvar x4 = largestSmallestIntegers(arg40);\nvar v4 = [-9, 2];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [];\nvar x5 = largestSmallestIntegers(arg50);\nvar v5 = [null, null];\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = [0];\nvar x6 = largestSmallestIntegers(arg60);\nvar v6 = [null, null];\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = [-1, -3, -5, -6];\nvar x7 = largestSmallestIntegers(arg70);\nvar v7 = [-1, null];\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = [-1, -3, -5, -6, 0];\nvar x8 = largestSmallestIntegers(arg80);\nvar v8 = [-1, null];\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = [-6, -4, -4, -3, 1];\nvar x9 = largestSmallestIntegers(arg90);\nvar v9 = [-3, 1];\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg100 = [-6, -4, -4, -3, -100, 1];\nvar x10 = largestSmallestIntegers(arg100);\nvar v10 = [-3, 1];\nif(!compare(x10, v10)){\n    throw 'Error at 11th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * أنشئ دالة تعيد tuple (a، b) ، حيث يكون 'a' هو أكبر الأعداد الصحيحة السالبة ، و 'b' هو أصغر الأعداد الصحيحة الموجبة في القائمة. إذا لم يكن هناك أعداد صحيحة سالبة أو موجبة ، فأرجعها كـ None.\n * \n *     Examples:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/64", "prompt": "/**\n * \n * العامل البرازيلي يعرف على أنه:\n *     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     حيث n > 0\n * \n *     على سبيل المثال:\n * >>> special_factorial(4)\n * 288\n\n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n *\n */\nfunction specialFactorial(n) {\n", "entry_point": "specialFactorial", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 4;\nvar x0 = specialFactorial(arg00);\nvar v0 = 288;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 5;\nvar x1 = specialFactorial(arg10);\nvar v1 = 34560;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 7;\nvar x2 = specialFactorial(arg20);\nvar v2 = 125411328000;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 1;\nvar x3 = specialFactorial(arg30);\nvar v3 = 1;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * العامل البرازيلي يعرف على أنه:\n *     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     حيث n > 0\n * \n *     على سبيل المثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/65", "prompt": "/**\n * * \n * يتم تزويدك بسلسلة تمثل جملة،\n * الجملة تحتوي على بعض الكلمات المفصولة بمسافة،\n * ويجب عليك إرجاع سلسلة تحتوي على الكلمات من الجملة الأصلية،\n * التي تحتوي على أعداد أولية من الأحرف،\n * يجب أن يكون ترتيب الكلمات في السلسلة الجديدة هو نفس الترتيب الأصلي.\n * \n * مثال 1:\n *     المدخلات: الجملة = \"This is a test\"\n *     الناتج: \"is\"\n * \n * مثال 2:\n *     المدخلات: الجملة = \"lets go for swimming\"\n *     الناتج: \"go for\"\n * \n * القيود:\n *     * 1 <= len(sentence) <= 100\n *     * تحتوي الجملة على أحرف فقط\n * \n *\n */\nfunction wordsInSentence(sentence) {\n", "entry_point": "wordsInSentence", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"This is a test\";\nvar x0 = wordsInSentence(arg00);\nvar v0 = \"is\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"lets go for swimming\";\nvar x1 = wordsInSentence(arg10);\nvar v1 = \"go for\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"there is no place available here\";\nvar x2 = wordsInSentence(arg20);\nvar v2 = \"there is no place\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"Hi I am Hussein\";\nvar x3 = wordsInSentence(arg30);\nvar v3 = \"Hi am Hussein\";\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"go for it\";\nvar x4 = wordsInSentence(arg40);\nvar v4 = \"go for it\";\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"here\";\nvar x5 = wordsInSentence(arg50);\nvar v5 = \"\";\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"here is\";\nvar x6 = wordsInSentence(arg60);\nvar v6 = \"is\";\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * يتم تزويدك بسلسلة تمثل جملة،\n * الجملة تحتوي على بعض الكلمات المفصولة بمسافة،\n * ويجب عليك إرجاع سلسلة تحتوي على الكلمات من الجملة الأصلية،\n * التي تحتوي على أعداد أولية من الأحرف،\n * يجب أن يكون ترتيب الكلمات في السلسلة الجديدة هو نفس الترتيب الأصلي.\n * \n * مثال 1:\n *     المدخلات: الجملة = \"This is a test\"\n *     الناتج: \"is\"\n * \n * مثال 2:\n *     المدخلات: الجملة = \"lets go for swimming\"\n *     الناتج: \"go for\"\n * \n * القيود:\n *     * 1 <= len(sentence) <= 100\n *     * تحتوي الجملة على أحرف فقط\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/66", "prompt": "/**\n * \n * مهمتك هي تنفيذ وظيفة ستبسط التعبير\n * x * n. تعيد الوظيفة True إذا كان x * n يقيم إلى عدد صحيح و False\n * إلا في ذلك. كل من x و n هما تمثيل سلسلة لكسر ، ولهما التنسيق التالي ،\n * <البسط>/<المقام> حيث كل من البسط والمقام هما أعداد صحيحة موجبة.\n * \n * يمكنك الافتراض أن x و n هما كسور صالحة ، ولا يحتويان على الصفر كمقام.\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n *\n */\nfunction simplify(x, n) {\n", "entry_point": "simplify", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"1/5\";\nvar arg01 = \"5/1\";\nvar x0 = simplify(arg00, arg01);\nvar v0 = true;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"1/6\";\nvar arg11 = \"2/1\";\nvar x1 = simplify(arg10, arg11);\nvar v1 = false;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"5/1\";\nvar arg21 = \"3/1\";\nvar x2 = simplify(arg20, arg21);\nvar v2 = true;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"7/10\";\nvar arg31 = \"10/2\";\nvar x3 = simplify(arg30, arg31);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"2/10\";\nvar arg41 = \"50/10\";\nvar x4 = simplify(arg40, arg41);\nvar v4 = true;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"7/2\";\nvar arg51 = \"4/2\";\nvar x5 = simplify(arg50, arg51);\nvar v5 = true;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"11/6\";\nvar arg61 = \"6/1\";\nvar x6 = simplify(arg60, arg61);\nvar v6 = true;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = \"2/3\";\nvar arg71 = \"5/2\";\nvar x7 = simplify(arg70, arg71);\nvar v7 = false;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = \"5/2\";\nvar arg81 = \"3/5\";\nvar x8 = simplify(arg80, arg81);\nvar v8 = false;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = \"2/4\";\nvar arg91 = \"8/4\";\nvar x9 = simplify(arg90, arg91);\nvar v9 = true;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg100 = \"2/4\";\nvar arg101 = \"4/2\";\nvar x10 = simplify(arg100, arg101);\nvar v10 = true;\nif(!compare(x10, v10)){\n    throw 'Error at 11th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg110 = \"1/5\";\nvar arg111 = \"5/1\";\nvar x11 = simplify(arg110, arg111);\nvar v11 = true;\nif(!compare(x11, v11)){\n    throw 'Error at 12th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg120 = \"1/5\";\nvar arg121 = \"1/5\";\nvar x12 = simplify(arg120, arg121);\nvar v12 = false;\nif(!compare(x12, v12)){\n    throw 'Error at 13th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * مهمتك هي تنفيذ وظيفة ستبسط التعبير\n * x * n. تعيد الوظيفة True إذا كان x * n يقيم إلى عدد صحيح و False\n * إلا في ذلك. كل من x و n هما تمثيل سلسلة لكسر ، ولهما التنسيق التالي ،\n * <البسط>/<المقام> حيث كل من البسط والمقام هما أعداد صحيحة موجبة.\n * \n * يمكنك الافتراض أن x و n هما كسور صالحة ، ولا يحتويان على الصفر كمقام.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/67", "prompt": "/**\n * * \n * اكتب دالة تقوم بفرز القائمة المعطاة من الأعداد الصحيحة بترتيب تصاعدي وفقًا لمجموع أرقامها. ملاحظة: إذا كان هناك عدة عناصر بمجموع أرقام مماثل ، فقم بترتيبها بناءً على مؤشرها في القائمة الأصلية.\n * \n * على سبيل المثال:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n *\n */\nfunction orderByPoints(nums) {\n", "entry_point": "orderByPoints", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [1, 11, -1, -11, -12];\nvar x0 = orderByPoints(arg00);\nvar v0 = [-1, -11, 1, -12, 11];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46];\nvar x1 = orderByPoints(arg10);\nvar v1 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [];\nvar x2 = orderByPoints(arg20);\nvar v2 = [];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [1, -11, -32, 43, 54, -98, 2, -3];\nvar x3 = orderByPoints(arg30);\nvar v3 = [-3, -32, -98, -11, 1, 2, 43, 54];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\nvar x4 = orderByPoints(arg40);\nvar v4 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [0, 6, 6, -76, -21, 23, 4];\nvar x5 = orderByPoints(arg50);\nvar v5 = [-76, -21, 0, 4, 23, 6, 6];\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * اكتب دالة تقوم بفرز القائمة المعطاة من الأعداد الصحيحة بترتيب تصاعدي وفقًا لمجموع أرقامها. ملاحظة: إذا كان هناك عدة عناصر بمجموع أرقام مماثل ، فقم بترتيبها بناءً على مؤشرها في القائمة الأصلية.\n * \n * على سبيل المثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/68", "prompt": "/**\n * \n * اكتب دالة تأخذ مصفوفة من الأرقام كمدخلات وتعيد عدد العناصر في المصفوفة التي تزيد عن 10 وكلاً من الأرقام الأولى والأخيرة للعدد فردية (1، 3، 5، 7، 9). على سبيل المثال:\n * \n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n *\n */\nfunction specialfilter(nums) {\n", "entry_point": "specialfilter", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [5, -2, 1, -5];\nvar x0 = specialfilter(arg00);\nvar v0 = 0;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [15, -73, 14, -15];\nvar x1 = specialfilter(arg10);\nvar v1 = 1;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [33, -2, -3, 45, 21, 109];\nvar x2 = specialfilter(arg20);\nvar v2 = 2;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [43, -12, 93, 125, 121, 109];\nvar x3 = specialfilter(arg30);\nvar v3 = 4;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [71, -2, -33, 75, 21, 19];\nvar x4 = specialfilter(arg40);\nvar v4 = 3;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [1];\nvar x5 = specialfilter(arg50);\nvar v5 = 0;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = [];\nvar x6 = specialfilter(arg60);\nvar v6 = 0;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * اكتب دالة تأخذ مصفوفة من الأرقام كمدخلات وتعيد عدد العناصر في المصفوفة التي تزيد عن 10 وكلاً من الأرقام الأولى والأخيرة للعدد فردية (1، 3، 5، 7، 9). على سبيل المثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/69", "prompt": "/**\n * * \n * تمنحك عدد صحيح موجب n. يجب عليك إنشاء مصفوفة صحيحة a طولها n.\n *         بالنسبة لكل i (1 ≤ i ≤ n) ، قيمة a [i] = i * i - i + 1.\n *         إرجاع عدد الثلاثيات (a [i]، a [j]، a [k]) من a حيث i <j <k ،\n *     و a [i] + a [j] + a [k] هو مضاعف للعدد 3.\n * \n *     مثال:\n *         المدخلات: n = 5\n *         الناتج: 1\n *         شرح:\n *         a = [1، 3، 7، 13، 21]\n *         الثلاثية الوحيدة الصالحة هي (1، 7، 13).\n * \n *\n */\nfunction getMaxTriples(n) {\n", "entry_point": "getMaxTriples", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 5;\nvar x0 = getMaxTriples(arg00);\nvar v0 = 1;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 6;\nvar x1 = getMaxTriples(arg10);\nvar v1 = 4;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 10;\nvar x2 = getMaxTriples(arg20);\nvar v2 = 36;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 100;\nvar x3 = getMaxTriples(arg30);\nvar v3 = 53361;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * تمنحك عدد صحيح موجب n. يجب عليك إنشاء مصفوفة صحيحة a طولها n.\n *         بالنسبة لكل i (1 ≤ i ≤ n) ، قيمة a [i] = i * i - i + 1.\n *         إرجاع عدد الثلاثيات (a [i]، a [j]، a [k]) من a حيث i <j <k ،\n *     و a [i] + a [j] + a [k] هو مضاعف للعدد 3.\n * \n *     مثال:\n *         المدخلات: n = 5\n *         الناتج: 1\n *         شرح:\n *         a = [1، 3، 7، 13، 21]\n *         الثلاثية الوحيدة الصالحة هي (1، 7، 13).\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/70", "prompt": "/**\n * * \n * هناك ثمانية كواكب في نظامنا الشمسي: الأقرب إلى الشمس هو عطارد، الكوكب التالي هو الزهرة، ثم الأرض، المريخ، المشتري، زحل، أورانوس، نبتون.\n * اكتب دالة تأخذ اسمي كوكب كسلسلة نصية planet1 و planet2. يجب أن تعيد الدالة tuple يحتوي على جميع الكواكب التي تقع مداراتها بين مدار كوكب1 ومدار كوكب2، مرتبة حسب القرب من الشمس. يجب أن تعيد الدالة tuple فارغًا إذا كان planet1 أو planet2 ليستا أسماء كواكب صحيحة.\n * أمثلة\n * \n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n *\n */\nfunction bf(planet1, planet2) {\n", "entry_point": "bf", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"Jupiter\";\nvar arg01 = \"Neptune\";\nvar x0 = bf(arg00, arg01);\nvar v0 = [\"Saturn\", \"Uranus\"];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"Earth\";\nvar arg11 = \"Mercury\";\nvar x1 = bf(arg10, arg11);\nvar v1 = [\"Venus\"];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"Mercury\";\nvar arg21 = \"Uranus\";\nvar x2 = bf(arg20, arg21);\nvar v2 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"Neptune\";\nvar arg31 = \"Venus\";\nvar x3 = bf(arg30, arg31);\nvar v3 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"Earth\";\nvar arg41 = \"Earth\";\nvar x4 = bf(arg40, arg41);\nvar v4 = [];\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"Mars\";\nvar arg51 = \"Earth\";\nvar x5 = bf(arg50, arg51);\nvar v5 = [];\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"Jupiter\";\nvar arg61 = \"Makemake\";\nvar x6 = bf(arg60, arg61);\nvar v6 = [];\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * هناك ثمانية كواكب في نظامنا الشمسي: الأقرب إلى الشمس هو عطارد، الكوكب التالي هو الزهرة، ثم الأرض، المريخ، المشتري، زحل، أورانوس، نبتون.\n * اكتب دالة تأخذ اسمي كوكب كسلسلة نصية planet1 و planet2. يجب أن تعيد الدالة tuple يحتوي على جميع الكواكب التي تقع مداراتها بين مدار كوكب1 ومدار كوكب2، مرتبة حسب القرب من الشمس. يجب أن تعيد الدالة tuple فارغًا إذا كان planet1 أو planet2 ليستا أسماء كواكب صحيحة.\n * أمثلة\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/71", "prompt": "/**\n * \n * برنامج بسيط يجب أن يعيد قيمة x إذا كان n عددًا أولًا ويجب أن يعيد قيمة y في حالة أخرى.\n * \n * أمثلة:\n * \n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n *\n */\nfunction xOrY(n, x, y) {\n", "entry_point": "xOrY", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 7;\nvar arg01 = 34;\nvar arg02 = 12;\nvar x0 = xOrY(arg00, arg01, arg02);\nvar v0 = 34;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 15;\nvar arg11 = 8;\nvar arg12 = 5;\nvar x1 = xOrY(arg10, arg11, arg12);\nvar v1 = 5;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 3;\nvar arg21 = 33;\nvar arg22 = 5212;\nvar x2 = xOrY(arg20, arg21, arg22);\nvar v2 = 33;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 1259;\nvar arg31 = 3;\nvar arg32 = 52;\nvar x3 = xOrY(arg30, arg31, arg32);\nvar v3 = 3;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 7919;\nvar arg41 = -1;\nvar arg42 = 12;\nvar x4 = xOrY(arg40, arg41, arg42);\nvar v4 = -1;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 3609;\nvar arg51 = 1245;\nvar arg52 = 583;\nvar x5 = xOrY(arg50, arg51, arg52);\nvar v5 = 583;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 91;\nvar arg61 = 56;\nvar arg62 = 129;\nvar x6 = xOrY(arg60, arg61, arg62);\nvar v6 = 129;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = 6;\nvar arg71 = 34;\nvar arg72 = 1234;\nvar x7 = xOrY(arg70, arg71, arg72);\nvar v7 = 1234;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = 1;\nvar arg81 = 2;\nvar arg82 = 0;\nvar x8 = xOrY(arg80, arg81, arg82);\nvar v8 = 0;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = 2;\nvar arg91 = 2;\nvar arg92 = 0;\nvar x9 = xOrY(arg90, arg91, arg92);\nvar v9 = 2;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * برنامج بسيط يجب أن يعيد قيمة x إذا كان n عددًا أولًا ويجب أن يعيد قيمة y في حالة أخرى.\n * \n * أمثلة:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/72", "prompt": "/**\n * * \n * عندما يتم إعطاء قائمة من الأرقام، يتم إرجاع مجموع مربعات الأرقام في القائمة التي هي فردية. يتم تجاهل الأرقام التي هي سلبية أو غير صحيحة.\n * \n * double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n * double_the_difference([-1, -2, 0]) == 0\n * double_the_difference([9, -2]) == 81\n * double_the_difference([0]) == 0\n * \n * إذا كانت القائمة المدخلة فارغة، يتم إرجاع 0.\n * \n *\n */\nfunction doubleTheDifference(lst) {\n", "entry_point": "doubleTheDifference", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = [];\nvar x0 = doubleTheDifference(arg00);\nvar v0 = 0;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = [5, 4];\nvar x1 = doubleTheDifference(arg10);\nvar v1 = 25;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = [0.1, 0.2, 0.3];\nvar x2 = doubleTheDifference(arg20);\nvar v2 = 0;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = [-10, -20, -30];\nvar x3 = doubleTheDifference(arg30);\nvar v3 = 0;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = [-1, -2, 8];\nvar x4 = doubleTheDifference(arg40);\nvar v4 = 0;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = [0.2, 3, 5];\nvar x5 = doubleTheDifference(arg50);\nvar v5 = 34;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = [-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99];\nvar x6 = doubleTheDifference(arg60);\nvar v6 = 166650;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * عندما يتم إعطاء قائمة من الأرقام، يتم إرجاع مجموع مربعات الأرقام في القائمة التي هي فردية. يتم تجاهل الأرقام التي هي سلبية أو غير صحيحة.\n * \n * double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n * double_the_difference([-1, -2, 0]) == 0\n * double_the_difference([9, -2]) == 81\n * double_the_difference([0]) == 0\n * \n * إذا كانت القائمة المدخلة فارغة، يتم إرجاع 0.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/73", "prompt": "/**\n * \n * سيتم تزويدك بإسم الصف (سلسلة نصية) وقائمة من الامتدادات.\n * يجب استخدام الامتدادات لتحميل صفوف إضافية إلى الصف. قوة الامتداد هي كما يلي: دع CAP يكون عدد الأحرف الكبيرة في اسم الامتداد، ودع SM يكون عدد الأحرف الصغيرة في اسم الامتداد، يتم إعطاء القوة بواسطة الكسر CAP - SM. يجب عليك العثور على الامتداد الأقوى وإرجاع سلسلة بهذا الشكل: اسم الصف.اسم الامتداد الأقوى.\n * إذا كان هناك اثنين أو أكثر من الامتدادات بنفس القوة، يجب اختيار الذي يأتي أولاً في القائمة.\n * على سبيل المثال، إذا تم تزويدك بـ \"Slices\" كصف وقائمة من الامتدادات: ['SErviNGSliCes'، 'Cheese'، 'StuFfed']، فيجب عليك إرجاع 'Slices.SErviNGSliCes' لأن 'SErviNGSliCes' هو الامتداد الأقوى (قوته -1).\n * مثال:\n * \n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n *\n */\nfunction strongestExtension(classname, extensions) {\n", "entry_point": "strongestExtension", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"Watashi\";\nvar arg01 = [\"tEN\", \"niNE\", \"eIGHt8OKe\"];\nvar x0 = strongestExtension(arg00, arg01);\nvar v0 = \"Watashi.eIGHt8OKe\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"Boku123\";\nvar arg11 = [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"];\nvar x1 = strongestExtension(arg10, arg11);\nvar v1 = \"Boku123.YEs.WeCaNe\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"__YESIMHERE\";\nvar arg21 = [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"];\nvar x2 = strongestExtension(arg20, arg21);\nvar v2 = \"__YESIMHERE.NuLl__\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"K\";\nvar arg31 = [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"];\nvar x3 = strongestExtension(arg30, arg31);\nvar v3 = \"K.TAR\";\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"__HAHA\";\nvar arg41 = [\"Tab\", \"123\", \"781345\", \"-_-\"];\nvar x4 = strongestExtension(arg40, arg41);\nvar v4 = \"__HAHA.123\";\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"YameRore\";\nvar arg51 = [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"];\nvar x5 = strongestExtension(arg50, arg51);\nvar v5 = \"YameRore.okIWILL123\";\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"finNNalLLly\";\nvar arg61 = [\"Die\", \"NowW\", \"Wow\", \"WoW\"];\nvar x6 = strongestExtension(arg60, arg61);\nvar v6 = \"finNNalLLly.WoW\";\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = \"_\";\nvar arg71 = [\"Bb\", \"91245\"];\nvar x7 = strongestExtension(arg70, arg71);\nvar v7 = \"_.Bb\";\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = \"Sp\";\nvar arg81 = [\"671235\", \"Bb\"];\nvar x8 = strongestExtension(arg80, arg81);\nvar v8 = \"Sp.671235\";\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * سيتم تزويدك بإسم الصف (سلسلة نصية) وقائمة من الامتدادات.\n * يجب استخدام الامتدادات لتحميل صفوف إضافية إلى الصف. قوة الامتداد هي كما يلي: دع CAP يكون عدد الأحرف الكبيرة في اسم الامتداد، ودع SM يكون عدد الأحرف الصغيرة في اسم الامتداد، يتم إعطاء القوة بواسطة الكسر CAP - SM. يجب عليك العثور على الامتداد الأقوى وإرجاع سلسلة بهذا الشكل: اسم الصف.اسم الامتداد الأقوى.\n * إذا كان هناك اثنين أو أكثر من الامتدادات بنفس القوة، يجب اختيار الذي يأتي أولاً في القائمة.\n * على سبيل المثال، إذا تم تزويدك بـ \"Slices\" كصف وقائمة من الامتدادات: ['SErviNGSliCes'، 'Cheese'، 'StuFfed']، فيجب عليك إرجاع 'Slices.SErviNGSliCes' لأن 'SErviNGSliCes' هو الامتداد الأقوى (قوته -1).\n * مثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/74", "prompt": "/**\n * \n * يتم تزويدك بكلمتين. تحتاج إلى إرجاع True إذا كانت الكلمة الثانية أو أي من دوراناتها هي متعابدة في الكلمة الأولى.\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n\n *\n */\nfunction cycpatternCheck(a, b) {\n", "entry_point": "cycpatternCheck", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"xyzw\";\nvar arg01 = \"xyw\";\nvar x0 = cycpatternCheck(arg00, arg01);\nvar v0 = false;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"yello\";\nvar arg11 = \"ell\";\nvar x1 = cycpatternCheck(arg10, arg11);\nvar v1 = true;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"whattup\";\nvar arg21 = \"ptut\";\nvar x2 = cycpatternCheck(arg20, arg21);\nvar v2 = false;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"efef\";\nvar arg31 = \"fee\";\nvar x3 = cycpatternCheck(arg30, arg31);\nvar v3 = true;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"abab\";\nvar arg41 = \"aabb\";\nvar x4 = cycpatternCheck(arg40, arg41);\nvar v4 = false;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"winemtt\";\nvar arg51 = \"tinem\";\nvar x5 = cycpatternCheck(arg50, arg51);\nvar v5 = true;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * يتم تزويدك بكلمتين. تحتاج إلى إرجاع True إذا كانت الكلمة الثانية أو أي من دوراناتها هي متعابدة في الكلمة الأولى.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/75", "prompt": "/**\n * * \n * بالنظر إلى عدد صحيح موجب، احصل على ما يعادله من الأرقام الرومانية كسلسلة نصية، وارجعها بأحرف صغيرة.\n * القيود: 1 <= num <= 1000\n * \n * أمثلة:\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n *\n */\nfunction intToMiniRoman(number) {\n", "entry_point": "intToMiniRoman", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 19;\nvar x0 = intToMiniRoman(arg00);\nvar v0 = \"xix\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 152;\nvar x1 = intToMiniRoman(arg10);\nvar v1 = \"clii\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 251;\nvar x2 = intToMiniRoman(arg20);\nvar v2 = \"ccli\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 426;\nvar x3 = intToMiniRoman(arg30);\nvar v3 = \"cdxxvi\";\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 500;\nvar x4 = intToMiniRoman(arg40);\nvar v4 = \"d\";\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 1;\nvar x5 = intToMiniRoman(arg50);\nvar v5 = \"i\";\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 4;\nvar x6 = intToMiniRoman(arg60);\nvar v6 = \"iv\";\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = 43;\nvar x7 = intToMiniRoman(arg70);\nvar v7 = \"xliii\";\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = 90;\nvar x8 = intToMiniRoman(arg80);\nvar v8 = \"xc\";\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = 94;\nvar x9 = intToMiniRoman(arg90);\nvar v9 = \"xciv\";\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg100 = 532;\nvar x10 = intToMiniRoman(arg100);\nvar v10 = \"dxxxii\";\nif(!compare(x10, v10)){\n    throw 'Error at 11th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg110 = 900;\nvar x11 = intToMiniRoman(arg110);\nvar v11 = \"cm\";\nif(!compare(x11, v11)){\n    throw 'Error at 12th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg120 = 994;\nvar x12 = intToMiniRoman(arg120);\nvar v12 = \"cmxciv\";\nif(!compare(x12, v12)){\n    throw 'Error at 13th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg130 = 1000;\nvar x13 = intToMiniRoman(arg130);\nvar v13 = \"m\";\nif(!compare(x13, v13)){\n    throw 'Error at 14th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * بالنظر إلى عدد صحيح موجب، احصل على ما يعادله من الأرقام الرومانية كسلسلة نصية، وارجعها بأحرف صغيرة.\n * القيود: 1 <= num <= 1000\n * \n * أمثلة:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/76", "prompt": "/**\n * * \n * بالنظر إلى أطوال الأضلاع الثلاثة لمثلث. إرجاع قيمة صحيحة (True) إذا كانت الأضلاع الثلاثة تشكل مثلثاً قائم الزاوية، وإرجاع قيمة خاطئة (False) في الحالات الأخرى. يعتبر المثلث القائم الزاوية هو مثلث يحتوي على زاوية قائمة أو بزاوية 90 درجة. مثال:\n * \n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n *\n */\nfunction rightAngleTriangle(a, b, c) {\n", "entry_point": "rightAngleTriangle", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 3;\nvar arg01 = 4;\nvar arg02 = 5;\nvar x0 = rightAngleTriangle(arg00, arg01, arg02);\nvar v0 = true;\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 1;\nvar arg11 = 2;\nvar arg12 = 3;\nvar x1 = rightAngleTriangle(arg10, arg11, arg12);\nvar v1 = false;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 10;\nvar arg21 = 6;\nvar arg22 = 8;\nvar x2 = rightAngleTriangle(arg20, arg21, arg22);\nvar v2 = true;\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 2;\nvar arg31 = 2;\nvar arg32 = 2;\nvar x3 = rightAngleTriangle(arg30, arg31, arg32);\nvar v3 = false;\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = 7;\nvar arg41 = 24;\nvar arg42 = 25;\nvar x4 = rightAngleTriangle(arg40, arg41, arg42);\nvar v4 = true;\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = 10;\nvar arg51 = 5;\nvar arg52 = 7;\nvar x5 = rightAngleTriangle(arg50, arg51, arg52);\nvar v5 = false;\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = 5;\nvar arg61 = 12;\nvar arg62 = 13;\nvar x6 = rightAngleTriangle(arg60, arg61, arg62);\nvar v6 = true;\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = 15;\nvar arg71 = 8;\nvar arg72 = 17;\nvar x7 = rightAngleTriangle(arg70, arg71, arg72);\nvar v7 = true;\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg80 = 48;\nvar arg81 = 55;\nvar arg82 = 73;\nvar x8 = rightAngleTriangle(arg80, arg81, arg82);\nvar v8 = true;\nif(!compare(x8, v8)){\n    throw 'Error at 9th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg90 = 1;\nvar arg91 = 1;\nvar arg92 = 1;\nvar x9 = rightAngleTriangle(arg90, arg91, arg92);\nvar v9 = false;\nif(!compare(x9, v9)){\n    throw 'Error at 10th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg100 = 2;\nvar arg101 = 2;\nvar arg102 = 10;\nvar x10 = rightAngleTriangle(arg100, arg101, arg102);\nvar v10 = false;\nif(!compare(x10, v10)){\n    throw 'Error at 11th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * بالنظر إلى أطوال الأضلاع الثلاثة لمثلث. إرجاع قيمة صحيحة (True) إذا كانت الأضلاع الثلاثة تشكل مثلثاً قائم الزاوية، وإرجاع قيمة خاطئة (False) في الحالات الأخرى. يعتبر المثلث القائم الزاوية هو مثلث يحتوي على زاوية قائمة أو بزاوية 90 درجة. مثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/77", "prompt": "/**\n * \n * تمنحك سلسلة s.\n *     إذا كان s[i] حرفًا، فعكس حالته من الحروف الصغيرة إلى الحروف الكبيرة أو العكس،\n *     وإلا فاحتفظ به كما هو.\n *     إذا لم تحتوي السلسلة على أحرف، فعكس السلسلة.\n *     يجب أن تعيد الدالة السلسلة الناتجة.\n *     أمثلة\n * \n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n *\n */\nfunction solve(s) {\n", "entry_point": "solve", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"AsDf\";\nvar x0 = solve(arg00);\nvar v0 = \"aSdF\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"1234\";\nvar x1 = solve(arg10);\nvar v1 = \"4321\";\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"ab\";\nvar x2 = solve(arg20);\nvar v2 = \"AB\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"#a@C\";\nvar x3 = solve(arg30);\nvar v3 = \"#A@c\";\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg40 = \"#AsdfW^45\";\nvar x4 = solve(arg40);\nvar v4 = \"#aSDFw^45\";\nif(!compare(x4, v4)){\n    throw 'Error at 5th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg50 = \"#6@2\";\nvar x5 = solve(arg50);\nvar v5 = \"2@6#\";\nif(!compare(x5, v5)){\n    throw 'Error at 6th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg60 = \"#\\$a^D\";\nvar x6 = solve(arg60);\nvar v6 = \"#\\$A^d\";\nif(!compare(x6, v6)){\n    throw 'Error at 7th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg70 = \"#ccc\";\nvar x7 = solve(arg70);\nvar v7 = \"#CCC\";\nif(!compare(x7, v7)){\n    throw 'Error at 8th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * تمنحك سلسلة s.\n *     إذا كان s[i] حرفًا، فعكس حالته من الحروف الصغيرة إلى الحروف الكبيرة أو العكس،\n *     وإلا فاحتفظ به كما هو.\n *     إذا لم تحتوي السلسلة على أحرف، فعكس السلسلة.\n *     يجب أن تعيد الدالة السلسلة الناتجة.\n *     أمثلة\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/78", "prompt": "/**\n * * \n * بالنظر إلى سلسلة 'text'، أرجع سلسلة مكافئة لها بتشفير md5.\n * إذا كانت 'text' فارغة، أرجع قيمة فارغة.\n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n *\n */\nfunction stringToMd5(text) {\n", "entry_point": "stringToMd5", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = \"Hello world\";\nvar x0 = stringToMd5(arg00);\nvar v0 = \"3e25960a79dbc69b674cd4ec67a72c62\";\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = \"\";\nvar x1 = stringToMd5(arg10);\nvar v1 = null;\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = \"A B C\";\nvar x2 = stringToMd5(arg20);\nvar v2 = \"0ef78513b0cb8cef12743f5aeb35f888\";\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = \"password\";\nvar x3 = stringToMd5(arg30);\nvar v3 = \"5f4dcc3b5aa765d61d8327deb882cf99\";\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * بالنظر إلى سلسلة 'text'، أرجع سلسلة مكافئة لها بتشفير md5.\n * إذا كانت 'text' فارغة، أرجع قيمة فارغة.\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "javascript/79", "prompt": "/**\n * * \n * بالنظر إلى عددين صحيحين موجبين a و b، يتم إرجاع الأرقام الزوجية بين a و b بترتيب تصاعدي.\n * \n * على سبيل المثال:\n * \n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n *\n */\nfunction generateIntegers(a, b) {\n", "entry_point": "generateIntegers", "test": "\nconst _ = require(\"lodash\")\n\nfunction compare(object1, object2){\n    return _.isEqual(object1, object2)\n}\n\nvar arg00 = 2;\nvar arg01 = 10;\nvar x0 = generateIntegers(arg00, arg01);\nvar v0 = [2, 4, 6, 8];\nif(!compare(x0, v0)){\n    throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg10 = 10;\nvar arg11 = 2;\nvar x1 = generateIntegers(arg10, arg11);\nvar v1 = [2, 4, 6, 8];\nif(!compare(x1, v1)){\n    throw 'Error at 2th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg20 = 132;\nvar arg21 = 2;\nvar x2 = generateIntegers(arg20, arg21);\nvar v2 = [2, 4, 6, 8];\nif(!compare(x2, v2)){\n    throw 'Error at 3th assert statement. Value = ' + JSON.stringify(x)  \n}\n\nvar arg30 = 17;\nvar arg31 = 89;\nvar x3 = generateIntegers(arg30, arg31);\nvar v3 = [];\nif(!compare(x3, v3)){\n    throw 'Error at 4th assert statement. Value = ' + JSON.stringify(x)  \n}\n\n", "description": "\n * بالنظر إلى عددين صحيحين موجبين a و b، يتم إرجاع الأرقام الزوجية بين a و b بترتيب تصاعدي.\n * \n * على سبيل المثال:\n * ", "language": "javascript", "canonical_solution": NaN, "natural_language": "Arabic"}
