{"task_id": "perl/0", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Je krijgt een lijst met stortingen en opnames op een bankrekening die begint met een saldo van nul. Je taak is om te detecteren of op enig moment het saldo van de rekening onder nul valt, en op dat moment moet de functie True retourneren. Anders moet het False retourneren.\n# >>> below_zero([1, 2, 3])\n# False\n# >>> below_zero([1, 2, -4, 5])\n# True\n#\nsub below_zero\n{\n  my ($operations) = @_;\n", "entry_point": "below_zero", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [];\nmy $x0 = below_zero($arg00);\nmy $v0 = 0;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1, 2, -3, 1, 2, -3];\nmy $x1 = below_zero($arg10);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [1, 2, -4, 5, 6];\nmy $x2 = below_zero($arg20);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [1, -1, 2, -2, 5, -5, 4, -4];\nmy $x3 = below_zero($arg30);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [1, -1, 2, -2, 5, -5, 4, -5];\nmy $x4 = below_zero($arg40);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [1, -2, 2, -2, 5, -5, 4, -4];\nmy $x5 = below_zero($arg50);\nmy $v5 = 1;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\n", "description": "Je krijgt een lijst met stortingen en opnames op een bankrekening die begint met een saldo van nul. Je taak is om te detecteren of op enig moment het saldo van de rekening onder nul valt, en op dat moment moet de functie True retourneren. Anders moet het False retourneren.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/1", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Voor een gegeven lijst van gehele getallen, retourneer een tuple bestaande uit de som en het product van alle getallen in de lijst.\n# Een lege som moet gelijk zijn aan 0 en een leeg product moet gelijk zijn aan 1.\n# >>> sum_product([])\n# (0, 1)\n# >>> sum_product([1, 2, 3, 4])\n# (10, 24)\n#\nsub sum_product\n{\n  my ($numbers) = @_;\n", "entry_point": "sum_product", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [];\nmy $x0 = sum_product($arg00);\nmy $v0 = [0, 1];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1, 1, 1];\nmy $x1 = sum_product($arg10);\nmy $v1 = [3, 1];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [100, 0];\nmy $x2 = sum_product($arg20);\nmy $v2 = [100, 0];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [3, 5, 7];\nmy $x3 = sum_product($arg30);\nmy $v3 = [15, 105];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [10];\nmy $x4 = sum_product($arg40);\nmy $v4 = [10, 10];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "Voor een gegeven lijst van gehele getallen, retourneer een tuple bestaande uit de som en het product van alle getallen in de lijst.\nEen lege som moet gelijk zijn aan 0 en een leeg product moet gelijk zijn aan 1.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/2", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# De input zijn twee strings a en b die alleen bestaan uit 1s en 0s.\n# Voer een binaire XOR uit op deze inputs en retourneer het resultaat ook als een string.\n# >>> string_xor('010', '110')\n# '100'\n#\nsub string_xor\n{\n  my ($a, $b) = @_;\n", "entry_point": "string_xor", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"111000\";\nmy $arg01 = \"101010\";\nmy $x0 = string_xor($arg00, $arg01);\nmy $v0 = \"010010\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"1\";\nmy $arg11 = \"1\";\nmy $x1 = string_xor($arg10, $arg11);\nmy $v1 = \"0\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"0101\";\nmy $arg21 = \"0000\";\nmy $x2 = string_xor($arg20, $arg21);\nmy $v2 = \"0101\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\n", "description": "De input zijn twee strings a en b die alleen bestaan uit 1s en 0s.\nVoer een binaire XOR uit op deze inputs en retourneer het resultaat ook als een string.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/3", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Uit een lijst van strings, retourneer de langste. Retourneer de eerste als er meerdere strings zijn van dezelfde lengte. Retourneer null als de invoerlijst leeg is.\n# >>> longest([])\n\n# >>> longest(['a', 'b', 'c'])\n# 'a'\n# >>> longest(['a', 'bb', 'ccc'])\n# 'ccc'\n#\nsub longest\n{\n  my ($strings) = @_;\n", "entry_point": "longest", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [];\nmy $x0 = longest($arg00);\nmy $v0 = \"none\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [\"x\", \"y\", \"z\"];\nmy $x1 = longest($arg10);\nmy $v1 = \"x\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"];\nmy $x2 = longest($arg20);\nmy $v2 = \"zzzz\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\n", "description": "Uit een lijst van strings, retourneer de langste. Retourneer de eerste als er meerdere strings zijn van dezelfde lengte. Retourneer null als de invoerlijst leeg is.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/4", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Geef de grootste gemene deler van twee gehele getallen a en b terug.\n# >>> greatest_common_divisor(3, 5)\n# 1\n# >>> greatest_common_divisor(25, 15)\n# 5\n#\nsub greatest_common_divisor\n{\n  my ($a, $b) = @_;\n", "entry_point": "greatest_common_divisor", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 3;\nmy $arg01 = 7;\nmy $x0 = greatest_common_divisor($arg00, $arg01);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 10;\nmy $arg11 = 15;\nmy $x1 = greatest_common_divisor($arg10, $arg11);\nmy $v1 = 5;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 49;\nmy $arg21 = 14;\nmy $x2 = greatest_common_divisor($arg20, $arg21);\nmy $v2 = 7;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 144;\nmy $arg31 = 60;\nmy $x3 = greatest_common_divisor($arg30, $arg31);\nmy $v3 = 12;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\n", "description": "Geef de grootste gemene deler van twee gehele getallen a en b terug.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/5", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# De input is een string van getallen gescheiden door spaties, van 'nul' tot 'negen'.\n#     Geldige keuzes zijn 'nul', 'een', 'twee', 'drie', 'vier', 'vijf', 'zes', 'zeven', 'acht' en 'negen'.\n#     Geef de string terug met de getallen gesorteerd van klein naar groot.\n# >>> sort_numbers('three one five')\n# 'one three five'\n#\nsub sort_numbers\n{\n  my ($numbers) = @_;\n", "entry_point": "sort_numbers", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"\";\nmy $x0 = sort_numbers($arg00);\nmy $v0 = \"\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"three\";\nmy $x1 = sort_numbers($arg10);\nmy $v1 = \"three\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"three five nine\";\nmy $x2 = sort_numbers($arg20);\nmy $v2 = \"three five nine\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"five zero four seven nine eight\";\nmy $x3 = sort_numbers($arg30);\nmy $v3 = \"zero four five seven eight nine\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"six five four three two one zero\";\nmy $x4 = sort_numbers($arg40);\nmy $v4 = \"zero one two three four five six\";\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "De input is een string van getallen gescheiden door spaties, van 'nul' tot 'negen'.\n    Geldige keuzes zijn 'nul', 'een', 'twee', 'drie', 'vier', 'vijf', 'zes', 'zeven', 'acht' en 'negen'.\n    Geef de string terug met de getallen gesorteerd van klein naar groot.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/6", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Gegeven een lijst van getallen (van ten minste twee elementen), pas een lineaire transformatie toe op die lijst, zodat het kleinste getal 0 wordt en het grootste getal 1 wordt.\n# >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\n#\nsub rescale_to_unit\n{\n  my ($numbers) = @_;\n", "entry_point": "rescale_to_unit", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [2.0, 49.9];\nmy $x0 = rescale_to_unit($arg00);\nmy $v0 = [0.0, 1.0];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [100.0, 49.9];\nmy $x1 = rescale_to_unit($arg10);\nmy $v1 = [1.0, 0.0];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [1.0, 2.0, 3.0, 4.0, 5.0];\nmy $x2 = rescale_to_unit($arg20);\nmy $v2 = [0.0, 0.25, 0.5, 0.75, 1.0];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [2.0, 1.0, 5.0, 3.0, 4.0];\nmy $x3 = rescale_to_unit($arg30);\nmy $v3 = [0.25, 0.0, 1.0, 0.5, 0.75];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [12.0, 11.0, 15.0, 13.0, 14.0];\nmy $x4 = rescale_to_unit($arg40);\nmy $v4 = [0.25, 0.0, 1.0, 0.5, 0.75];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "Gegeven een lijst van getallen (van ten minste twee elementen), pas een lineaire transformatie toe op die lijst, zodat het kleinste getal 0 wordt en het grootste getal 1 wordt.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/7", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Voor een gegeven string, verander kleine letters naar hoofdletters en hoofdletters naar kleine letters.\n# >>> flip_case('Hello')\n# 'hELLO'\n#\nsub flip_case\n{\n  my ($string) = @_;\n", "entry_point": "flip_case", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"\";\nmy $x0 = flip_case($arg00);\nmy $v0 = \"\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"Hello!\";\nmy $x1 = flip_case($arg10);\nmy $v1 = \"hELLO!\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"These violent delights have violent ends\";\nmy $x2 = flip_case($arg20);\nmy $v2 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\n", "description": "Voor een gegeven string, verander kleine letters naar hoofdletters en hoofdletters naar kleine letters.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/8", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Geef alleen positieve getallen terug in de lijst.\n# >>> get_positive([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\n#\nsub get_positive\n{\n  my ($l) = @_;\n", "entry_point": "get_positive", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [-1, -2, 4, 5, 6];\nmy $x0 = get_positive($arg00);\nmy $v0 = [4, 5, 6];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10];\nmy $x1 = get_positive($arg10);\nmy $v1 = [5, 3, 2, 3, 3, 9, 123, 1];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [-1, -2];\nmy $x2 = get_positive($arg20);\nmy $v2 = [];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [];\nmy $x3 = get_positive($arg30);\nmy $v3 = [];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\n", "description": "Geef alleen positieve getallen terug in de lijst.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/9", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Geef waar terug als een gegeven getal priem is, en anders onwaar.\n# >>> is_prime(6)\n# False\n# >>> is_prime(101)\n# True\n# >>> is_prime(11)\n# True\n# >>> is_prime(13441)\n# True\n# >>> is_prime(61)\n# True\n# >>> is_prime(4)\n# False\n# >>> is_prime(1)\n# False\n#\nsub is_prime\n{\n  my ($n) = @_;\n", "entry_point": "is_prime", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 6;\nmy $x0 = is_prime($arg00);\nmy $v0 = 0;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 101;\nmy $x1 = is_prime($arg10);\nmy $v1 = 1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 11;\nmy $x2 = is_prime($arg20);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 13441;\nmy $x3 = is_prime($arg30);\nmy $v3 = 1;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 61;\nmy $x4 = is_prime($arg40);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 4;\nmy $x5 = is_prime($arg50);\nmy $v5 = 0;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 1;\nmy $x6 = is_prime($arg60);\nmy $v6 = 0;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = 5;\nmy $x7 = is_prime($arg70);\nmy $v7 = 1;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = 11;\nmy $x8 = is_prime($arg80);\nmy $v8 = 1;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = 17;\nmy $x9 = is_prime($arg90);\nmy $v9 = 1;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\nmy $arg100 = 85;\nmy $x10 = is_prime($arg100);\nmy $v10 = 0;\nunless(Compare($x10, $v10)) {\n    die \"Exception -- test case 10 did not pass.\";\n}\nmy $arg110 = 77;\nmy $x11 = is_prime($arg110);\nmy $v11 = 0;\nunless(Compare($x11, $v11)) {\n    die \"Exception -- test case 11 did not pass.\";\n}\nmy $arg120 = 255379;\nmy $x12 = is_prime($arg120);\nmy $v12 = 0;\nunless(Compare($x12, $v12)) {\n    die \"Exception -- test case 12 did not pass.\";\n}\n", "description": "Geef waar terug als een gegeven getal priem is, en anders onwaar.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/10", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Geef gesorteerde unieke elementen terug in een lijst.\n# >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\n#\nsub unique\n{\n  my ($l) = @_;\n", "entry_point": "unique", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [5, 3, 5, 2, 3, 3, 9, 0, 123];\nmy $x0 = unique($arg00);\nmy $v0 = [0, 2, 3, 5, 9, 123];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\n", "description": "Geef gesorteerde unieke elementen terug in een lijst.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/11", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # prime_fib geeft het n-de getal terug dat zowel een Fibonacci-getal als een priemgetal is.\n# >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n# 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n# 89\n#\nsub prime_fib\n{\n  my ($n) = @_;\n", "entry_point": "prime_fib", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 1;\nmy $x0 = prime_fib($arg00);\nmy $v0 = 2;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 2;\nmy $x1 = prime_fib($arg10);\nmy $v1 = 3;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 3;\nmy $x2 = prime_fib($arg20);\nmy $v2 = 5;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 4;\nmy $x3 = prime_fib($arg30);\nmy $v3 = 13;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 5;\nmy $x4 = prime_fib($arg40);\nmy $v4 = 89;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 6;\nmy $x5 = prime_fib($arg50);\nmy $v5 = 233;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 7;\nmy $x6 = prime_fib($arg60);\nmy $v6 = 1597;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = 8;\nmy $x7 = prime_fib($arg70);\nmy $v7 = 28657;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = 9;\nmy $x8 = prime_fib($arg80);\nmy $v8 = 514229;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = 10;\nmy $x9 = prime_fib($arg90);\nmy $v9 = 433494437;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\n", "description": "prime_fib geeft het n-de getal terug dat zowel een Fibonacci-getal als een priemgetal is.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/12", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # triples_sum_to_zero neemt een lijst van gehele getallen als invoer.\n# Het retourneert True als er drie verschillende elementen in de lijst zijn die bij elkaar opgeteld nul zijn, en anders False.\n# >>> triples_sum_to_zero([1, 3, 5, 0])\n# False\n# >>> triples_sum_to_zero([1, 3, -2, 1])\n# True\n# >>> triples_sum_to_zero([1, 2, 3, 7])\n# False\n# >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n# True\n# >>> triples_sum_to_zero([1])\n# False\n#\nsub triples_sum_to_zero\n{\n  my ($l) = @_;\n", "entry_point": "triples_sum_to_zero", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [1, 3, 5, 0];\nmy $x0 = triples_sum_to_zero($arg00);\nmy $v0 = 0;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1, 3, 5, -1];\nmy $x1 = triples_sum_to_zero($arg10);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [1, 3, -2, 1];\nmy $x2 = triples_sum_to_zero($arg20);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [1, 2, 3, 7];\nmy $x3 = triples_sum_to_zero($arg30);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [1, 2, 5, 7];\nmy $x4 = triples_sum_to_zero($arg40);\nmy $v4 = 0;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [2, 4, -5, 3, 9, 7];\nmy $x5 = triples_sum_to_zero($arg50);\nmy $v5 = 1;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = [1];\nmy $x6 = triples_sum_to_zero($arg60);\nmy $v6 = 0;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = [1, 3, 5, -100];\nmy $x7 = triples_sum_to_zero($arg70);\nmy $v7 = 0;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = [100, 3, 5, -100];\nmy $x8 = triples_sum_to_zero($arg80);\nmy $v8 = 0;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\n", "description": "triples_sum_to_zero neemt een lijst van gehele getallen als invoer.\nHet retourneert True als er drie verschillende elementen in de lijst zijn die bij elkaar opgeteld nul zijn, en anders False.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/13", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # pairs_sum_to_zero neemt een lijst van gehele getallen als invoer.\n#     Het retourneert True als er twee verschillende elementen in de lijst zijn die\n#     opgeteld nul zijn, en anders False.\n# >>> pairs_sum_to_zero([1, 3, 5, 0])\n# False\n# >>> pairs_sum_to_zero([1, 3, -2, 1])\n# False\n# >>> pairs_sum_to_zero([1, 2, 3, 7])\n# False\n# >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n# True\n# >>> pairs_sum_to_zero([1])\n# False\n#\nsub pairs_sum_to_zero\n{\n  my ($l) = @_;\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [1, 3, 5, 0];\nmy $x0 = pairs_sum_to_zero($arg00);\nmy $v0 = 0;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1, 3, -2, 1];\nmy $x1 = pairs_sum_to_zero($arg10);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [1, 2, 3, 7];\nmy $x2 = pairs_sum_to_zero($arg20);\nmy $v2 = 0;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [2, 4, -5, 3, 5, 7];\nmy $x3 = pairs_sum_to_zero($arg30);\nmy $v3 = 1;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [1];\nmy $x4 = pairs_sum_to_zero($arg40);\nmy $v4 = 0;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [-3, 9, -1, 3, 2, 30];\nmy $x5 = pairs_sum_to_zero($arg50);\nmy $v5 = 1;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = [-3, 9, -1, 3, 2, 31];\nmy $x6 = pairs_sum_to_zero($arg60);\nmy $v6 = 1;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = [-3, 9, -1, 4, 2, 30];\nmy $x7 = pairs_sum_to_zero($arg70);\nmy $v7 = 0;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = [-3, 9, -1, 4, 2, 31];\nmy $x8 = pairs_sum_to_zero($arg80);\nmy $v8 = 0;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\n", "description": "pairs_sum_to_zero neemt een lijst van gehele getallen als invoer.\n    Het retourneert True als er twee verschillende elementen in de lijst zijn die\n    opgeteld nul zijn, en anders False.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/14", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# De Fib4-nummerreeks is een reeks vergelijkbaar met de Fibbonacci-reeks die als volgt wordt gedefinieerd:\n#     fib4(0) -> 0\n#     fib4(1) -> 0\n#     fib4(2) -> 2\n#     fib4(3) -> 0\n#     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n#     Schrijf alstublieft een functie om efficiënt het n-de element van de Fib4-nummerreeks te berekenen. Gebruik geen recursie.\n# >>> fib4(5)\n# 4\n# >>> fib4(6)\n# 8\n# >>> fib4(7)\n# 14\n#\nsub fib4\n{\n  my ($n) = @_;\n", "entry_point": "fib4", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 5;\nmy $x0 = fib4($arg00);\nmy $v0 = 4;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 8;\nmy $x1 = fib4($arg10);\nmy $v1 = 28;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 10;\nmy $x2 = fib4($arg20);\nmy $v2 = 104;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 12;\nmy $x3 = fib4($arg30);\nmy $v3 = 386;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\n", "description": "De Fib4-nummerreeks is een reeks vergelijkbaar met de Fibbonacci-reeks die als volgt wordt gedefinieerd:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Schrijf alstublieft een functie om efficiënt het n-de element van de Fib4-nummerreeks te berekenen. Gebruik geen recursie.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/15", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Geef de mediaan terug van de elementen in de lijst l.\n# >>> median([3, 1, 2, 4, 5])\n# 3\n# >>> median([-10, 4, 6, 1000, 10, 20])\n# 15.0\n#\nsub median\n{\n  my ($l) = @_;\n", "entry_point": "median", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [3, 1, 2, 4, 5];\nmy $x0 = median($arg00);\nmy $v0 = 3;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [-10, 4, 6, 1000, 10, 20];\nmy $x1 = median($arg10);\nmy $v1 = 8.0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [5];\nmy $x2 = median($arg20);\nmy $v2 = 5;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [6, 5];\nmy $x3 = median($arg30);\nmy $v3 = 5.5;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [8, 1, 3, 9, 9, 2, 7];\nmy $x4 = median($arg40);\nmy $v4 = 7;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "Geef de mediaan terug van de elementen in de lijst l.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/16", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Controleert of de gegeven string een palindroom is.\n# >>> is_palindrome('')\n# True\n# >>> is_palindrome('aba')\n# True\n# >>> is_palindrome('aaaaa')\n# True\n# >>> is_palindrome('zbcd')\n# False\n#\nsub is_palindrome\n{\n  my ($text) = @_;\n", "entry_point": "is_palindrome", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"\";\nmy $x0 = is_palindrome($arg00);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"aba\";\nmy $x1 = is_palindrome($arg10);\nmy $v1 = 1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"aaaaa\";\nmy $x2 = is_palindrome($arg20);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"zbcd\";\nmy $x3 = is_palindrome($arg30);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"xywyx\";\nmy $x4 = is_palindrome($arg40);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"xywyz\";\nmy $x5 = is_palindrome($arg50);\nmy $v5 = 0;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"xywzx\";\nmy $x6 = is_palindrome($arg60);\nmy $v6 = 0;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "Controleert of de gegeven string een palindroom is.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/17", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # remove_vowels is een functie die een string als input neemt en een string teruggeeft zonder klinkers.\n# >>> remove_vowels('')\n# ''\n# >>> remove_vowels(\"abcdef\\nghijklm\")\n# 'bcdf\\nghjklm'\n# >>> remove_vowels('abcdef')\n# 'bcdf'\n# >>> remove_vowels('aaaaa')\n# ''\n# >>> remove_vowels('aaBAA')\n# 'B'\n# >>> remove_vowels('zbcd')\n# 'zbcd'\n#\nsub remove_vowels\n{\n  my ($text) = @_;\n", "entry_point": "remove_vowels", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"\";\nmy $x0 = remove_vowels($arg00);\nmy $v0 = \"\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"abcdef\\nghijklm\";\nmy $x1 = remove_vowels($arg10);\nmy $v1 = \"bcdf\\nghjklm\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"fedcba\";\nmy $x2 = remove_vowels($arg20);\nmy $v2 = \"fdcb\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"eeeee\";\nmy $x3 = remove_vowels($arg30);\nmy $v3 = \"\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"acBAA\";\nmy $x4 = remove_vowels($arg40);\nmy $v4 = \"cB\";\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"EcBOO\";\nmy $x5 = remove_vowels($arg50);\nmy $v5 = \"cB\";\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"ybcd\";\nmy $x6 = remove_vowels($arg60);\nmy $v6 = \"ybcd\";\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "remove_vowels is een functie die een string als input neemt en een string teruggeeft zonder klinkers.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/18", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Geef True terug als alle getallen in de lijst l onder de drempelwaarde t liggen.\n# >>> below_threshold([1, 2, 4, 10], 100)\n# True\n# >>> below_threshold([1, 20, 4, 10], 5)\n# False\n#\nsub below_threshold\n{\n  my ($l, $t) = @_;\n", "entry_point": "below_threshold", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [1, 2, 4, 10];\nmy $arg01 = 100;\nmy $x0 = below_threshold($arg00, $arg01);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1, 20, 4, 10];\nmy $arg11 = 5;\nmy $x1 = below_threshold($arg10, $arg11);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [1, 20, 4, 10];\nmy $arg21 = 21;\nmy $x2 = below_threshold($arg20, $arg21);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [1, 20, 4, 10];\nmy $arg31 = 22;\nmy $x3 = below_threshold($arg30, $arg31);\nmy $v3 = 1;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [1, 8, 4, 10];\nmy $arg41 = 11;\nmy $x4 = below_threshold($arg40, $arg41);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [1, 8, 4, 10];\nmy $arg51 = 10;\nmy $x5 = below_threshold($arg50, $arg51);\nmy $v5 = 0;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\n", "description": "Geef True terug als alle getallen in de lijst l onder de drempelwaarde t liggen.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/19", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Tel twee getallen x en y bij elkaar op.\n# >>> add(2, 3)\n# 5\n# >>> add(5, 7)\n# 12\n#\nsub add\n{\n  my ($x, $y) = @_;\n", "entry_point": "add", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 0;\nmy $arg01 = 1;\nmy $x0 = add($arg00, $arg01);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 1;\nmy $arg11 = 0;\nmy $x1 = add($arg10, $arg11);\nmy $v1 = 1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 2;\nmy $arg21 = 3;\nmy $x2 = add($arg20, $arg21);\nmy $v2 = 5;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 5;\nmy $arg31 = 7;\nmy $x3 = add($arg30, $arg31);\nmy $v3 = 12;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 7;\nmy $arg41 = 5;\nmy $x4 = add($arg40, $arg41);\nmy $v4 = 12;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 572;\nmy $arg51 = 725;\nmy $x5 = add($arg50, $arg51);\nmy $v5 = 1297;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 51;\nmy $arg61 = 804;\nmy $x6 = add($arg60, $arg61);\nmy $v6 = 855;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = 645;\nmy $arg71 = 96;\nmy $x7 = add($arg70, $arg71);\nmy $v7 = 741;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = 712;\nmy $arg81 = 853;\nmy $x8 = add($arg80, $arg81);\nmy $v8 = 1565;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = 223;\nmy $arg91 = 101;\nmy $x9 = add($arg90, $arg91);\nmy $v9 = 324;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\nmy $arg100 = 76;\nmy $arg101 = 29;\nmy $x10 = add($arg100, $arg101);\nmy $v10 = 105;\nunless(Compare($x10, $v10)) {\n    die \"Exception -- test case 10 did not pass.\";\n}\nmy $arg110 = 416;\nmy $arg111 = 149;\nmy $x11 = add($arg110, $arg111);\nmy $v11 = 565;\nunless(Compare($x11, $v11)) {\n    die \"Exception -- test case 11 did not pass.\";\n}\nmy $arg120 = 145;\nmy $arg121 = 409;\nmy $x12 = add($arg120, $arg121);\nmy $v12 = 554;\nunless(Compare($x12, $v12)) {\n    die \"Exception -- test case 12 did not pass.\";\n}\nmy $arg130 = 535;\nmy $arg131 = 430;\nmy $x13 = add($arg130, $arg131);\nmy $v13 = 965;\nunless(Compare($x13, $v13)) {\n    die \"Exception -- test case 13 did not pass.\";\n}\nmy $arg140 = 118;\nmy $arg141 = 303;\nmy $x14 = add($arg140, $arg141);\nmy $v14 = 421;\nunless(Compare($x14, $v14)) {\n    die \"Exception -- test case 14 did not pass.\";\n}\nmy $arg150 = 287;\nmy $arg151 = 94;\nmy $x15 = add($arg150, $arg151);\nmy $v15 = 381;\nunless(Compare($x15, $v15)) {\n    die \"Exception -- test case 15 did not pass.\";\n}\nmy $arg160 = 768;\nmy $arg161 = 257;\nmy $x16 = add($arg160, $arg161);\nmy $v16 = 1025;\nunless(Compare($x16, $v16)) {\n    die \"Exception -- test case 16 did not pass.\";\n}\nmy $arg170 = 421;\nmy $arg171 = 677;\nmy $x17 = add($arg170, $arg171);\nmy $v17 = 1098;\nunless(Compare($x17, $v17)) {\n    die \"Exception -- test case 17 did not pass.\";\n}\nmy $arg180 = 802;\nmy $arg181 = 814;\nmy $x18 = add($arg180, $arg181);\nmy $v18 = 1616;\nunless(Compare($x18, $v18)) {\n    die \"Exception -- test case 18 did not pass.\";\n}\nmy $arg190 = 510;\nmy $arg191 = 922;\nmy $x19 = add($arg190, $arg191);\nmy $v19 = 1432;\nunless(Compare($x19, $v19)) {\n    die \"Exception -- test case 19 did not pass.\";\n}\nmy $arg200 = 345;\nmy $arg201 = 819;\nmy $x20 = add($arg200, $arg201);\nmy $v20 = 1164;\nunless(Compare($x20, $v20)) {\n    die \"Exception -- test case 20 did not pass.\";\n}\nmy $arg210 = 895;\nmy $arg211 = 436;\nmy $x21 = add($arg210, $arg211);\nmy $v21 = 1331;\nunless(Compare($x21, $v21)) {\n    die \"Exception -- test case 21 did not pass.\";\n}\nmy $arg220 = 123;\nmy $arg221 = 424;\nmy $x22 = add($arg220, $arg221);\nmy $v22 = 547;\nunless(Compare($x22, $v22)) {\n    die \"Exception -- test case 22 did not pass.\";\n}\nmy $arg230 = 923;\nmy $arg231 = 245;\nmy $x23 = add($arg230, $arg231);\nmy $v23 = 1168;\nunless(Compare($x23, $v23)) {\n    die \"Exception -- test case 23 did not pass.\";\n}\nmy $arg240 = 23;\nmy $arg241 = 438;\nmy $x24 = add($arg240, $arg241);\nmy $v24 = 461;\nunless(Compare($x24, $v24)) {\n    die \"Exception -- test case 24 did not pass.\";\n}\nmy $arg250 = 565;\nmy $arg251 = 133;\nmy $x25 = add($arg250, $arg251);\nmy $v25 = 698;\nunless(Compare($x25, $v25)) {\n    die \"Exception -- test case 25 did not pass.\";\n}\nmy $arg260 = 945;\nmy $arg261 = 925;\nmy $x26 = add($arg260, $arg261);\nmy $v26 = 1870;\nunless(Compare($x26, $v26)) {\n    die \"Exception -- test case 26 did not pass.\";\n}\nmy $arg270 = 261;\nmy $arg271 = 983;\nmy $x27 = add($arg270, $arg271);\nmy $v27 = 1244;\nunless(Compare($x27, $v27)) {\n    die \"Exception -- test case 27 did not pass.\";\n}\nmy $arg280 = 139;\nmy $arg281 = 577;\nmy $x28 = add($arg280, $arg281);\nmy $v28 = 716;\nunless(Compare($x28, $v28)) {\n    die \"Exception -- test case 28 did not pass.\";\n}\nmy $arg290 = 763;\nmy $arg291 = 178;\nmy $x29 = add($arg290, $arg291);\nmy $v29 = 941;\nunless(Compare($x29, $v29)) {\n    die \"Exception -- test case 29 did not pass.\";\n}\nmy $arg300 = 147;\nmy $arg301 = 892;\nmy $x30 = add($arg300, $arg301);\nmy $v30 = 1039;\nunless(Compare($x30, $v30)) {\n    die \"Exception -- test case 30 did not pass.\";\n}\nmy $arg310 = 436;\nmy $arg311 = 402;\nmy $x31 = add($arg310, $arg311);\nmy $v31 = 838;\nunless(Compare($x31, $v31)) {\n    die \"Exception -- test case 31 did not pass.\";\n}\nmy $arg320 = 610;\nmy $arg321 = 581;\nmy $x32 = add($arg320, $arg321);\nmy $v32 = 1191;\nunless(Compare($x32, $v32)) {\n    die \"Exception -- test case 32 did not pass.\";\n}\nmy $arg330 = 103;\nmy $arg331 = 416;\nmy $x33 = add($arg330, $arg331);\nmy $v33 = 519;\nunless(Compare($x33, $v33)) {\n    die \"Exception -- test case 33 did not pass.\";\n}\nmy $arg340 = 339;\nmy $arg341 = 990;\nmy $x34 = add($arg340, $arg341);\nmy $v34 = 1329;\nunless(Compare($x34, $v34)) {\n    die \"Exception -- test case 34 did not pass.\";\n}\nmy $arg350 = 130;\nmy $arg351 = 504;\nmy $x35 = add($arg350, $arg351);\nmy $v35 = 634;\nunless(Compare($x35, $v35)) {\n    die \"Exception -- test case 35 did not pass.\";\n}\nmy $arg360 = 242;\nmy $arg361 = 717;\nmy $x36 = add($arg360, $arg361);\nmy $v36 = 959;\nunless(Compare($x36, $v36)) {\n    die \"Exception -- test case 36 did not pass.\";\n}\nmy $arg370 = 562;\nmy $arg371 = 110;\nmy $x37 = add($arg370, $arg371);\nmy $v37 = 672;\nunless(Compare($x37, $v37)) {\n    die \"Exception -- test case 37 did not pass.\";\n}\nmy $arg380 = 396;\nmy $arg381 = 909;\nmy $x38 = add($arg380, $arg381);\nmy $v38 = 1305;\nunless(Compare($x38, $v38)) {\n    die \"Exception -- test case 38 did not pass.\";\n}\nmy $arg390 = 887;\nmy $arg391 = 703;\nmy $x39 = add($arg390, $arg391);\nmy $v39 = 1590;\nunless(Compare($x39, $v39)) {\n    die \"Exception -- test case 39 did not pass.\";\n}\nmy $arg400 = 870;\nmy $arg401 = 551;\nmy $x40 = add($arg400, $arg401);\nmy $v40 = 1421;\nunless(Compare($x40, $v40)) {\n    die \"Exception -- test case 40 did not pass.\";\n}\nmy $arg410 = 422;\nmy $arg411 = 391;\nmy $x41 = add($arg410, $arg411);\nmy $v41 = 813;\nunless(Compare($x41, $v41)) {\n    die \"Exception -- test case 41 did not pass.\";\n}\nmy $arg420 = 299;\nmy $arg421 = 505;\nmy $x42 = add($arg420, $arg421);\nmy $v42 = 804;\nunless(Compare($x42, $v42)) {\n    die \"Exception -- test case 42 did not pass.\";\n}\nmy $arg430 = 346;\nmy $arg431 = 56;\nmy $x43 = add($arg430, $arg431);\nmy $v43 = 402;\nunless(Compare($x43, $v43)) {\n    die \"Exception -- test case 43 did not pass.\";\n}\nmy $arg440 = 36;\nmy $arg441 = 706;\nmy $x44 = add($arg440, $arg441);\nmy $v44 = 742;\nunless(Compare($x44, $v44)) {\n    die \"Exception -- test case 44 did not pass.\";\n}\nmy $arg450 = 738;\nmy $arg451 = 411;\nmy $x45 = add($arg450, $arg451);\nmy $v45 = 1149;\nunless(Compare($x45, $v45)) {\n    die \"Exception -- test case 45 did not pass.\";\n}\nmy $arg460 = 679;\nmy $arg461 = 87;\nmy $x46 = add($arg460, $arg461);\nmy $v46 = 766;\nunless(Compare($x46, $v46)) {\n    die \"Exception -- test case 46 did not pass.\";\n}\nmy $arg470 = 25;\nmy $arg471 = 303;\nmy $x47 = add($arg470, $arg471);\nmy $v47 = 328;\nunless(Compare($x47, $v47)) {\n    die \"Exception -- test case 47 did not pass.\";\n}\nmy $arg480 = 161;\nmy $arg481 = 612;\nmy $x48 = add($arg480, $arg481);\nmy $v48 = 773;\nunless(Compare($x48, $v48)) {\n    die \"Exception -- test case 48 did not pass.\";\n}\nmy $arg490 = 306;\nmy $arg491 = 841;\nmy $x49 = add($arg490, $arg491);\nmy $v49 = 1147;\nunless(Compare($x49, $v49)) {\n    die \"Exception -- test case 49 did not pass.\";\n}\nmy $arg500 = 973;\nmy $arg501 = 411;\nmy $x50 = add($arg500, $arg501);\nmy $v50 = 1384;\nunless(Compare($x50, $v50)) {\n    die \"Exception -- test case 50 did not pass.\";\n}\nmy $arg510 = 711;\nmy $arg511 = 157;\nmy $x51 = add($arg510, $arg511);\nmy $v51 = 868;\nunless(Compare($x51, $v51)) {\n    die \"Exception -- test case 51 did not pass.\";\n}\nmy $arg520 = 471;\nmy $arg521 = 27;\nmy $x52 = add($arg520, $arg521);\nmy $v52 = 498;\nunless(Compare($x52, $v52)) {\n    die \"Exception -- test case 52 did not pass.\";\n}\nmy $arg530 = 714;\nmy $arg531 = 792;\nmy $x53 = add($arg530, $arg531);\nmy $v53 = 1506;\nunless(Compare($x53, $v53)) {\n    die \"Exception -- test case 53 did not pass.\";\n}\nmy $arg540 = 38;\nmy $arg541 = 206;\nmy $x54 = add($arg540, $arg541);\nmy $v54 = 244;\nunless(Compare($x54, $v54)) {\n    die \"Exception -- test case 54 did not pass.\";\n}\nmy $arg550 = 907;\nmy $arg551 = 343;\nmy $x55 = add($arg550, $arg551);\nmy $v55 = 1250;\nunless(Compare($x55, $v55)) {\n    die \"Exception -- test case 55 did not pass.\";\n}\nmy $arg560 = 23;\nmy $arg561 = 760;\nmy $x56 = add($arg560, $arg561);\nmy $v56 = 783;\nunless(Compare($x56, $v56)) {\n    die \"Exception -- test case 56 did not pass.\";\n}\nmy $arg570 = 524;\nmy $arg571 = 859;\nmy $x57 = add($arg570, $arg571);\nmy $v57 = 1383;\nunless(Compare($x57, $v57)) {\n    die \"Exception -- test case 57 did not pass.\";\n}\nmy $arg580 = 30;\nmy $arg581 = 529;\nmy $x58 = add($arg580, $arg581);\nmy $v58 = 559;\nunless(Compare($x58, $v58)) {\n    die \"Exception -- test case 58 did not pass.\";\n}\nmy $arg590 = 341;\nmy $arg591 = 691;\nmy $x59 = add($arg590, $arg591);\nmy $v59 = 1032;\nunless(Compare($x59, $v59)) {\n    die \"Exception -- test case 59 did not pass.\";\n}\nmy $arg600 = 167;\nmy $arg601 = 729;\nmy $x60 = add($arg600, $arg601);\nmy $v60 = 896;\nunless(Compare($x60, $v60)) {\n    die \"Exception -- test case 60 did not pass.\";\n}\nmy $arg610 = 636;\nmy $arg611 = 289;\nmy $x61 = add($arg610, $arg611);\nmy $v61 = 925;\nunless(Compare($x61, $v61)) {\n    die \"Exception -- test case 61 did not pass.\";\n}\nmy $arg620 = 503;\nmy $arg621 = 144;\nmy $x62 = add($arg620, $arg621);\nmy $v62 = 647;\nunless(Compare($x62, $v62)) {\n    die \"Exception -- test case 62 did not pass.\";\n}\nmy $arg630 = 51;\nmy $arg631 = 985;\nmy $x63 = add($arg630, $arg631);\nmy $v63 = 1036;\nunless(Compare($x63, $v63)) {\n    die \"Exception -- test case 63 did not pass.\";\n}\nmy $arg640 = 287;\nmy $arg641 = 149;\nmy $x64 = add($arg640, $arg641);\nmy $v64 = 436;\nunless(Compare($x64, $v64)) {\n    die \"Exception -- test case 64 did not pass.\";\n}\nmy $arg650 = 659;\nmy $arg651 = 75;\nmy $x65 = add($arg650, $arg651);\nmy $v65 = 734;\nunless(Compare($x65, $v65)) {\n    die \"Exception -- test case 65 did not pass.\";\n}\nmy $arg660 = 462;\nmy $arg661 = 797;\nmy $x66 = add($arg660, $arg661);\nmy $v66 = 1259;\nunless(Compare($x66, $v66)) {\n    die \"Exception -- test case 66 did not pass.\";\n}\nmy $arg670 = 406;\nmy $arg671 = 141;\nmy $x67 = add($arg670, $arg671);\nmy $v67 = 547;\nunless(Compare($x67, $v67)) {\n    die \"Exception -- test case 67 did not pass.\";\n}\nmy $arg680 = 106;\nmy $arg681 = 44;\nmy $x68 = add($arg680, $arg681);\nmy $v68 = 150;\nunless(Compare($x68, $v68)) {\n    die \"Exception -- test case 68 did not pass.\";\n}\nmy $arg690 = 300;\nmy $arg691 = 934;\nmy $x69 = add($arg690, $arg691);\nmy $v69 = 1234;\nunless(Compare($x69, $v69)) {\n    die \"Exception -- test case 69 did not pass.\";\n}\nmy $arg700 = 471;\nmy $arg701 = 524;\nmy $x70 = add($arg700, $arg701);\nmy $v70 = 995;\nunless(Compare($x70, $v70)) {\n    die \"Exception -- test case 70 did not pass.\";\n}\nmy $arg710 = 122;\nmy $arg711 = 429;\nmy $x71 = add($arg710, $arg711);\nmy $v71 = 551;\nunless(Compare($x71, $v71)) {\n    die \"Exception -- test case 71 did not pass.\";\n}\nmy $arg720 = 735;\nmy $arg721 = 195;\nmy $x72 = add($arg720, $arg721);\nmy $v72 = 930;\nunless(Compare($x72, $v72)) {\n    die \"Exception -- test case 72 did not pass.\";\n}\nmy $arg730 = 335;\nmy $arg731 = 484;\nmy $x73 = add($arg730, $arg731);\nmy $v73 = 819;\nunless(Compare($x73, $v73)) {\n    die \"Exception -- test case 73 did not pass.\";\n}\nmy $arg740 = 28;\nmy $arg741 = 809;\nmy $x74 = add($arg740, $arg741);\nmy $v74 = 837;\nunless(Compare($x74, $v74)) {\n    die \"Exception -- test case 74 did not pass.\";\n}\nmy $arg750 = 430;\nmy $arg751 = 20;\nmy $x75 = add($arg750, $arg751);\nmy $v75 = 450;\nunless(Compare($x75, $v75)) {\n    die \"Exception -- test case 75 did not pass.\";\n}\nmy $arg760 = 916;\nmy $arg761 = 635;\nmy $x76 = add($arg760, $arg761);\nmy $v76 = 1551;\nunless(Compare($x76, $v76)) {\n    die \"Exception -- test case 76 did not pass.\";\n}\nmy $arg770 = 301;\nmy $arg771 = 999;\nmy $x77 = add($arg770, $arg771);\nmy $v77 = 1300;\nunless(Compare($x77, $v77)) {\n    die \"Exception -- test case 77 did not pass.\";\n}\nmy $arg780 = 454;\nmy $arg781 = 466;\nmy $x78 = add($arg780, $arg781);\nmy $v78 = 920;\nunless(Compare($x78, $v78)) {\n    die \"Exception -- test case 78 did not pass.\";\n}\nmy $arg790 = 905;\nmy $arg791 = 259;\nmy $x79 = add($arg790, $arg791);\nmy $v79 = 1164;\nunless(Compare($x79, $v79)) {\n    die \"Exception -- test case 79 did not pass.\";\n}\nmy $arg800 = 168;\nmy $arg801 = 205;\nmy $x80 = add($arg800, $arg801);\nmy $v80 = 373;\nunless(Compare($x80, $v80)) {\n    die \"Exception -- test case 80 did not pass.\";\n}\nmy $arg810 = 570;\nmy $arg811 = 434;\nmy $x81 = add($arg810, $arg811);\nmy $v81 = 1004;\nunless(Compare($x81, $v81)) {\n    die \"Exception -- test case 81 did not pass.\";\n}\nmy $arg820 = 64;\nmy $arg821 = 959;\nmy $x82 = add($arg820, $arg821);\nmy $v82 = 1023;\nunless(Compare($x82, $v82)) {\n    die \"Exception -- test case 82 did not pass.\";\n}\nmy $arg830 = 957;\nmy $arg831 = 510;\nmy $x83 = add($arg830, $arg831);\nmy $v83 = 1467;\nunless(Compare($x83, $v83)) {\n    die \"Exception -- test case 83 did not pass.\";\n}\nmy $arg840 = 722;\nmy $arg841 = 598;\nmy $x84 = add($arg840, $arg841);\nmy $v84 = 1320;\nunless(Compare($x84, $v84)) {\n    die \"Exception -- test case 84 did not pass.\";\n}\nmy $arg850 = 770;\nmy $arg851 = 226;\nmy $x85 = add($arg850, $arg851);\nmy $v85 = 996;\nunless(Compare($x85, $v85)) {\n    die \"Exception -- test case 85 did not pass.\";\n}\nmy $arg860 = 579;\nmy $arg861 = 66;\nmy $x86 = add($arg860, $arg861);\nmy $v86 = 645;\nunless(Compare($x86, $v86)) {\n    die \"Exception -- test case 86 did not pass.\";\n}\nmy $arg870 = 117;\nmy $arg871 = 674;\nmy $x87 = add($arg870, $arg871);\nmy $v87 = 791;\nunless(Compare($x87, $v87)) {\n    die \"Exception -- test case 87 did not pass.\";\n}\nmy $arg880 = 530;\nmy $arg881 = 30;\nmy $x88 = add($arg880, $arg881);\nmy $v88 = 560;\nunless(Compare($x88, $v88)) {\n    die \"Exception -- test case 88 did not pass.\";\n}\nmy $arg890 = 776;\nmy $arg891 = 345;\nmy $x89 = add($arg890, $arg891);\nmy $v89 = 1121;\nunless(Compare($x89, $v89)) {\n    die \"Exception -- test case 89 did not pass.\";\n}\nmy $arg900 = 327;\nmy $arg901 = 389;\nmy $x90 = add($arg900, $arg901);\nmy $v90 = 716;\nunless(Compare($x90, $v90)) {\n    die \"Exception -- test case 90 did not pass.\";\n}\nmy $arg910 = 596;\nmy $arg911 = 12;\nmy $x91 = add($arg910, $arg911);\nmy $v91 = 608;\nunless(Compare($x91, $v91)) {\n    die \"Exception -- test case 91 did not pass.\";\n}\nmy $arg920 = 599;\nmy $arg921 = 511;\nmy $x92 = add($arg920, $arg921);\nmy $v92 = 1110;\nunless(Compare($x92, $v92)) {\n    die \"Exception -- test case 92 did not pass.\";\n}\nmy $arg930 = 936;\nmy $arg931 = 476;\nmy $x93 = add($arg930, $arg931);\nmy $v93 = 1412;\nunless(Compare($x93, $v93)) {\n    die \"Exception -- test case 93 did not pass.\";\n}\nmy $arg940 = 461;\nmy $arg941 = 14;\nmy $x94 = add($arg940, $arg941);\nmy $v94 = 475;\nunless(Compare($x94, $v94)) {\n    die \"Exception -- test case 94 did not pass.\";\n}\nmy $arg950 = 966;\nmy $arg951 = 157;\nmy $x95 = add($arg950, $arg951);\nmy $v95 = 1123;\nunless(Compare($x95, $v95)) {\n    die \"Exception -- test case 95 did not pass.\";\n}\nmy $arg960 = 326;\nmy $arg961 = 91;\nmy $x96 = add($arg960, $arg961);\nmy $v96 = 417;\nunless(Compare($x96, $v96)) {\n    die \"Exception -- test case 96 did not pass.\";\n}\nmy $arg970 = 392;\nmy $arg971 = 455;\nmy $x97 = add($arg970, $arg971);\nmy $v97 = 847;\nunless(Compare($x97, $v97)) {\n    die \"Exception -- test case 97 did not pass.\";\n}\nmy $arg980 = 446;\nmy $arg981 = 477;\nmy $x98 = add($arg980, $arg981);\nmy $v98 = 923;\nunless(Compare($x98, $v98)) {\n    die \"Exception -- test case 98 did not pass.\";\n}\nmy $arg990 = 324;\nmy $arg991 = 860;\nmy $x99 = add($arg990, $arg991);\nmy $v99 = 1184;\nunless(Compare($x99, $v99)) {\n    die \"Exception -- test case 99 did not pass.\";\n}\nmy $arg1000 = 945;\nmy $arg1001 = 85;\nmy $x100 = add($arg1000, $arg1001);\nmy $v100 = 1030;\nunless(Compare($x100, $v100)) {\n    die \"Exception -- test case 100 did not pass.\";\n}\nmy $arg1010 = 886;\nmy $arg1011 = 582;\nmy $x101 = add($arg1010, $arg1011);\nmy $v101 = 1468;\nunless(Compare($x101, $v101)) {\n    die \"Exception -- test case 101 did not pass.\";\n}\nmy $arg1020 = 886;\nmy $arg1021 = 712;\nmy $x102 = add($arg1020, $arg1021);\nmy $v102 = 1598;\nunless(Compare($x102, $v102)) {\n    die \"Exception -- test case 102 did not pass.\";\n}\nmy $arg1030 = 842;\nmy $arg1031 = 953;\nmy $x103 = add($arg1030, $arg1031);\nmy $v103 = 1795;\nunless(Compare($x103, $v103)) {\n    die \"Exception -- test case 103 did not pass.\";\n}\n", "description": "Tel twee getallen x en y bij elkaar op.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/20", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Controleer of twee woorden dezelfde karakters hebben.\n# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n# True\n# >>> same_chars('abcd', 'dddddddabc')\n# True\n# >>> same_chars('dddddddabc', 'abcd')\n# True\n# >>> same_chars('eabcd', 'dddddddabc')\n# False\n# >>> same_chars('abcd', 'dddddddabce')\n# False\n# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n# False\n#\nsub same_chars\n{\n  my ($s0, $s1) = @_;\n", "entry_point": "same_chars", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"eabcdzzzz\";\nmy $arg01 = \"dddzzzzzzzddeddabc\";\nmy $x0 = same_chars($arg00, $arg01);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"abcd\";\nmy $arg11 = \"dddddddabc\";\nmy $x1 = same_chars($arg10, $arg11);\nmy $v1 = 1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"dddddddabc\";\nmy $arg21 = \"abcd\";\nmy $x2 = same_chars($arg20, $arg21);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"eabcd\";\nmy $arg31 = \"dddddddabc\";\nmy $x3 = same_chars($arg30, $arg31);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"abcd\";\nmy $arg41 = \"dddddddabcf\";\nmy $x4 = same_chars($arg40, $arg41);\nmy $v4 = 0;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"eabcdzzzz\";\nmy $arg51 = \"dddzzzzzzzddddabc\";\nmy $x5 = same_chars($arg50, $arg51);\nmy $v5 = 0;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"aabb\";\nmy $arg61 = \"aaccc\";\nmy $x6 = same_chars($arg60, $arg61);\nmy $v6 = 0;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "Controleer of twee woorden dezelfde karakters hebben.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/21", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Geef het n-de Fibonacci-getal terug.\n# >>> fib(10)\n# 55\n# >>> fib(1)\n# 1\n# >>> fib(8)\n# 21\n#\nsub fib\n{\n  my ($n) = @_;\n", "entry_point": "fib", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 10;\nmy $x0 = fib($arg00);\nmy $v0 = 55;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 1;\nmy $x1 = fib($arg10);\nmy $v1 = 1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 8;\nmy $x2 = fib($arg20);\nmy $v2 = 21;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 11;\nmy $x3 = fib($arg30);\nmy $v3 = 89;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 12;\nmy $x4 = fib($arg40);\nmy $v4 = 144;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "Geef het n-de Fibonacci-getal terug.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/22", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Geef gesorteerde unieke gemeenschappelijke elementen terug voor twee lijsten.\n# >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5, 3, 2, 8], [3, 2])\n# [2, 3]\n\n#\nsub common\n{\n  my ($l1, $l2) = @_;\n", "entry_point": "common", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [1, 4, 3, 34, 653, 2, 5];\nmy $arg01 = [5, 7, 1, 5, 9, 653, 121];\nmy $x0 = common($arg00, $arg01);\nmy $v0 = [1, 5, 653];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [5, 3, 2, 8];\nmy $arg11 = [3, 2];\nmy $x1 = common($arg10, $arg11);\nmy $v1 = [2, 3];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [4, 3, 2, 8];\nmy $arg21 = [3, 2, 4];\nmy $x2 = common($arg20, $arg21);\nmy $v2 = [2, 3, 4];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [4, 3, 2, 8];\nmy $arg31 = [];\nmy $x3 = common($arg30, $arg31);\nmy $v3 = [];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\n", "description": "Geef gesorteerde unieke gemeenschappelijke elementen terug voor twee lijsten.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/23", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Geef de grootste priemfactor van n terug. Ga ervan uit dat n > 1 is en geen priemgetal is.\n# >>> largest_prime_factor(13195)\n# 29\n# >>> largest_prime_factor(2048)\n# 2\n#\nsub largest_prime_factor\n{\n  my ($n) = @_;\n", "entry_point": "largest_prime_factor", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 15;\nmy $x0 = largest_prime_factor($arg00);\nmy $v0 = 5;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 27;\nmy $x1 = largest_prime_factor($arg10);\nmy $v1 = 3;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 63;\nmy $x2 = largest_prime_factor($arg20);\nmy $v2 = 7;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 330;\nmy $x3 = largest_prime_factor($arg30);\nmy $v3 = 11;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 13195;\nmy $x4 = largest_prime_factor($arg40);\nmy $v4 = 29;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "Geef de grootste priemfactor van n terug. Ga ervan uit dat n > 1 is en geen priemgetal is.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/24", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# sum_to_n is een functie die getallen optelt van 1 tot n.\n# >>> sum_to_n(30)\n# 465\n# >>> sum_to_n(100)\n# 5050\n# >>> sum_to_n(5)\n# 15\n# >>> sum_to_n(10)\n# 55\n# >>> sum_to_n(1)\n# 1\n#\nsub sum_to_n\n{\n  my ($n) = @_;\n", "entry_point": "sum_to_n", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 1;\nmy $x0 = sum_to_n($arg00);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 6;\nmy $x1 = sum_to_n($arg10);\nmy $v1 = 21;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 11;\nmy $x2 = sum_to_n($arg20);\nmy $v2 = 66;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 30;\nmy $x3 = sum_to_n($arg30);\nmy $v3 = 465;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 100;\nmy $x4 = sum_to_n($arg40);\nmy $v4 = 5050;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "sum_to_n is een functie die getallen optelt van 1 tot n.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/25", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# xs vertegenwoordigen de coëfficiënten van een polynoom.\n#     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n#      Geef de afgeleide van deze polynoom terug in dezelfde vorm.\n# >>> derivative([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative([1, 2, 3])\n# [2, 6]\n#\nsub derivative\n{\n  my ($xs) = @_;\n", "entry_point": "derivative", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [3, 1, 2, 4, 5];\nmy $x0 = derivative($arg00);\nmy $v0 = [1, 4, 12, 20];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1, 2, 3];\nmy $x1 = derivative($arg10);\nmy $v1 = [2, 6];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [3, 2, 1];\nmy $x2 = derivative($arg20);\nmy $v2 = [2, 2];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [3, 2, 1, 0, 4];\nmy $x3 = derivative($arg30);\nmy $v3 = [2, 2, 0, 16];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [1];\nmy $x4 = derivative($arg40);\nmy $v4 = [];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "xs vertegenwoordigen de coëfficiënten van een polynoom.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Geef de afgeleide van deze polynoom terug in dezelfde vorm.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/26", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# De FibFib-reeks is een reeks getallen vergelijkbaar met de Fibbonacci-reeks die als volgt wordt gedefinieerd:\n#     fibfib(0) == 0\n#     fibfib(1) == 0\n#     fibfib(2) == 1\n#     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n#     Schrijf alstublieft een functie om het n-de element van de FibFib-reeks efficiënt te berekenen.\n# >>> fibfib(1)\n# 0\n# >>> fibfib(5)\n# 4\n# >>> fibfib(8)\n# 24\n#\nsub fibfib\n{\n  my ($n) = @_;\n", "entry_point": "fibfib", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 2;\nmy $x0 = fibfib($arg00);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 1;\nmy $x1 = fibfib($arg10);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 5;\nmy $x2 = fibfib($arg20);\nmy $v2 = 4;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 8;\nmy $x3 = fibfib($arg30);\nmy $v3 = 24;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 10;\nmy $x4 = fibfib($arg40);\nmy $v4 = 81;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 12;\nmy $x5 = fibfib($arg50);\nmy $v5 = 274;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 14;\nmy $x6 = fibfib($arg60);\nmy $v6 = 927;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "De FibFib-reeks is een reeks getallen vergelijkbaar met de Fibbonacci-reeks die als volgt wordt gedefinieerd:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Schrijf alstublieft een functie om het n-de element van de FibFib-reeks efficiënt te berekenen.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/27", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Schrijf een functie genaamd vowels_count die een string als input neemt die een woord voorstelt en het aantal klinkers in de string teruggeeft. Klinkers in dit geval zijn 'a', 'e', 'i', 'o', 'u'. Hierbij is 'y' ook een klinker, maar alleen wanneer het aan het einde van het gegeven woord staat.\n# \n# Voorbeeld:\n# >>> vowels_count(\"abcde\")\n# 2\n# >>> vowels_count(\"ACEDY\")\n# 3\n#\nsub vowels_count\n{\n  my ($s) = @_;\n", "entry_point": "vowels_count", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"abcde\";\nmy $x0 = vowels_count($arg00);\nmy $v0 = 2;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"Alone\";\nmy $x1 = vowels_count($arg10);\nmy $v1 = 3;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"key\";\nmy $x2 = vowels_count($arg20);\nmy $v2 = 2;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"bye\";\nmy $x3 = vowels_count($arg30);\nmy $v3 = 1;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"keY\";\nmy $x4 = vowels_count($arg40);\nmy $v4 = 2;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"bYe\";\nmy $x5 = vowels_count($arg50);\nmy $v5 = 1;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"ACEDY\";\nmy $x6 = vowels_count($arg60);\nmy $v6 = 3;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "Schrijf een functie genaamd vowels_count die een string als input neemt die een woord voorstelt en het aantal klinkers in de string teruggeeft. Klinkers in dit geval zijn 'a', 'e', 'i', 'o', 'u'. Hierbij is 'y' ook een klinker, maar alleen wanneer het aan het einde van het gegeven woord staat.\n\nVoorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/28", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Je krijgt een niet-lege lijst van positieve integers. Geef de grootste integer terug die groter is dan nul en een frequentie heeft die groter is dan of gelijk is aan de waarde van de integer zelf. De frequentie van een integer is het aantal keren dat het voorkomt in de lijst. Als er geen dergelijke waarde bestaat, geef dan -1 terug. Voorbeelden:\n# \n#     search([4, 1, 2, 2, 3, 1]) == 2\n#     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n#     search([5, 5, 4, 4, 4]) == -1\n#\nsub search\n{\n  my ($lst) = @_;\n", "entry_point": "search", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [5, 5, 5, 5, 1];\nmy $x0 = search($arg00);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [4, 1, 4, 1, 4, 4];\nmy $x1 = search($arg10);\nmy $v1 = 4;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [3, 3];\nmy $x2 = search($arg20);\nmy $v2 = -1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [8, 8, 8, 8, 8, 8, 8, 8];\nmy $x3 = search($arg30);\nmy $v3 = 8;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [2, 3, 3, 2, 2];\nmy $x4 = search($arg40);\nmy $v4 = 2;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1];\nmy $x5 = search($arg50);\nmy $v5 = 1;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = [3, 2, 8, 2];\nmy $x6 = search($arg60);\nmy $v6 = 2;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10];\nmy $x7 = search($arg70);\nmy $v7 = 1;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = [8, 8, 3, 6, 5, 6, 4];\nmy $x8 = search($arg80);\nmy $v8 = -1;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9];\nmy $x9 = search($arg90);\nmy $v9 = 1;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\nmy $arg100 = [1, 9, 10, 1, 3];\nmy $x10 = search($arg100);\nmy $v10 = 1;\nunless(Compare($x10, $v10)) {\n    die \"Exception -- test case 10 did not pass.\";\n}\nmy $arg110 = [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10];\nmy $x11 = search($arg110);\nmy $v11 = 5;\nunless(Compare($x11, $v11)) {\n    die \"Exception -- test case 11 did not pass.\";\n}\nmy $arg120 = [1];\nmy $x12 = search($arg120);\nmy $v12 = 1;\nunless(Compare($x12, $v12)) {\n    die \"Exception -- test case 12 did not pass.\";\n}\nmy $arg130 = [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5];\nmy $x13 = search($arg130);\nmy $v13 = 4;\nunless(Compare($x13, $v13)) {\n    die \"Exception -- test case 13 did not pass.\";\n}\nmy $arg140 = [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10];\nmy $x14 = search($arg140);\nmy $v14 = 2;\nunless(Compare($x14, $v14)) {\n    die \"Exception -- test case 14 did not pass.\";\n}\nmy $arg150 = [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3];\nmy $x15 = search($arg150);\nmy $v15 = 1;\nunless(Compare($x15, $v15)) {\n    die \"Exception -- test case 15 did not pass.\";\n}\nmy $arg160 = [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4];\nmy $x16 = search($arg160);\nmy $v16 = 4;\nunless(Compare($x16, $v16)) {\n    die \"Exception -- test case 16 did not pass.\";\n}\nmy $arg170 = [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7];\nmy $x17 = search($arg170);\nmy $v17 = 4;\nunless(Compare($x17, $v17)) {\n    die \"Exception -- test case 17 did not pass.\";\n}\nmy $arg180 = [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1];\nmy $x18 = search($arg180);\nmy $v18 = 2;\nunless(Compare($x18, $v18)) {\n    die \"Exception -- test case 18 did not pass.\";\n}\nmy $arg190 = [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8];\nmy $x19 = search($arg190);\nmy $v19 = -1;\nunless(Compare($x19, $v19)) {\n    die \"Exception -- test case 19 did not pass.\";\n}\nmy $arg200 = [10];\nmy $x20 = search($arg200);\nmy $v20 = -1;\nunless(Compare($x20, $v20)) {\n    die \"Exception -- test case 20 did not pass.\";\n}\nmy $arg210 = [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2];\nmy $x21 = search($arg210);\nmy $v21 = 2;\nunless(Compare($x21, $v21)) {\n    die \"Exception -- test case 21 did not pass.\";\n}\nmy $arg220 = [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8];\nmy $x22 = search($arg220);\nmy $v22 = 1;\nunless(Compare($x22, $v22)) {\n    die \"Exception -- test case 22 did not pass.\";\n}\nmy $arg230 = [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6];\nmy $x23 = search($arg230);\nmy $v23 = 1;\nunless(Compare($x23, $v23)) {\n    die \"Exception -- test case 23 did not pass.\";\n}\nmy $arg240 = [3, 10, 10, 9, 2];\nmy $x24 = search($arg240);\nmy $v24 = -1;\nunless(Compare($x24, $v24)) {\n    die \"Exception -- test case 24 did not pass.\";\n}\n", "description": "Je krijgt een niet-lege lijst van positieve integers. Geef de grootste integer terug die groter is dan nul en een frequentie heeft die groter is dan of gelijk is aan de waarde van de integer zelf. De frequentie van een integer is het aantal keren dat het voorkomt in de lijst. Als er geen dergelijke waarde bestaat, geef dan -1 terug. Voorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/29", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Gegeven de lengtes van de drie zijden van een driehoek. Geef het oppervlak van de driehoek terug afgerond op 2 decimalen als de drie zijden een geldige driehoek vormen. Anders geef -1 terug. Drie zijden vormen een geldige driehoek wanneer de som van elke twee zijden groter is dan de derde zijde. Voorbeeld:\n# \n# triangle_area(3, 4, 5) == 6.00\n# triangle_area(1, 2, 10) == -1\n#\nsub triangle_area\n{\n  my ($a, $b, $c) = @_;\n", "entry_point": "triangle_area", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 3;\nmy $arg01 = 4;\nmy $arg02 = 5;\nmy $x0 = triangle_area($arg00, $arg01, $arg02);\nmy $v0 = 6.0;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 1;\nmy $arg11 = 2;\nmy $arg12 = 10;\nmy $x1 = triangle_area($arg10, $arg11, $arg12);\nmy $v1 = -1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 4;\nmy $arg21 = 8;\nmy $arg22 = 5;\nmy $x2 = triangle_area($arg20, $arg21, $arg22);\nmy $v2 = 8.18;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 2;\nmy $arg31 = 2;\nmy $arg32 = 2;\nmy $x3 = triangle_area($arg30, $arg31, $arg32);\nmy $v3 = 1.73;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 1;\nmy $arg41 = 2;\nmy $arg42 = 3;\nmy $x4 = triangle_area($arg40, $arg41, $arg42);\nmy $v4 = -1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 10;\nmy $arg51 = 5;\nmy $arg52 = 7;\nmy $x5 = triangle_area($arg50, $arg51, $arg52);\nmy $v5 = 16.25;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 2;\nmy $arg61 = 6;\nmy $arg62 = 3;\nmy $x6 = triangle_area($arg60, $arg61, $arg62);\nmy $v6 = -1;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = 1;\nmy $arg71 = 1;\nmy $arg72 = 1;\nmy $x7 = triangle_area($arg70, $arg71, $arg72);\nmy $v7 = 0.43;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = 2;\nmy $arg81 = 2;\nmy $arg82 = 10;\nmy $x8 = triangle_area($arg80, $arg81, $arg82);\nmy $v8 = -1;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\n", "description": "Gegeven de lengtes van de drie zijden van een driehoek. Geef het oppervlak van de driehoek terug afgerond op 2 decimalen als de drie zijden een geldige driehoek vormen. Anders geef -1 terug. Drie zijden vormen een geldige driehoek wanneer de som van elke twee zijden groter is dan de derde zijde. Voorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/30", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Schrijf een functie die True teruggeeft als het object q zal vliegen, en False andersom.\n# Het object q zal vliegen als het in balans is (het is een palindromische lijst) en de som van de elementen kleiner is dan of gelijk aan het maximale mogelijke gewicht w.\n# \n# Voorbeeld:\n# will_it_fly([1, 2], 5) ➞ False\n# # 1+2 is minder dan het maximale mogelijke gewicht, maar het is niet in balans.\n# \n# will_it_fly([3, 2, 3], 1) ➞ False\n# # het is in balans, maar 3+2+3 is meer dan het maximale mogelijke gewicht.\n# \n# will_it_fly([3, 2, 3], 9) ➞ True\n# # 3+2+3 is minder dan het maximale mogelijke gewicht, en het is in balans.\n# \n# will_it_fly([3], 5) ➞ True\n# # 3 is minder dan het maximale mogelijke gewicht, en het is in balans.\n# \n#\nsub will_it_fly\n{\n  my ($q, $w) = @_;\n", "entry_point": "will_it_fly", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [3, 2, 3];\nmy $arg01 = 9;\nmy $x0 = will_it_fly($arg00, $arg01);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1, 2];\nmy $arg11 = 5;\nmy $x1 = will_it_fly($arg10, $arg11);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [3];\nmy $arg21 = 5;\nmy $x2 = will_it_fly($arg20, $arg21);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [3, 2, 3];\nmy $arg31 = 1;\nmy $x3 = will_it_fly($arg30, $arg31);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [1, 2, 3];\nmy $arg41 = 6;\nmy $x4 = will_it_fly($arg40, $arg41);\nmy $v4 = 0;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [5];\nmy $arg51 = 5;\nmy $x5 = will_it_fly($arg50, $arg51);\nmy $v5 = 1;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\n", "description": "Schrijf een functie die True teruggeeft als het object q zal vliegen, en False andersom.\nHet object q zal vliegen als het in balans is (het is een palindromische lijst) en de som van de elementen kleiner is dan of gelijk aan het maximale mogelijke gewicht w.\n\nVoorbeeld:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 is minder dan het maximale mogelijke gewicht, maar het is niet in balans.\n\nwill_it_fly([3, 2, 3], 1) ➞ False\n# het is in balans, maar 3+2+3 is meer dan het maximale mogelijke gewicht.\n\nwill_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 is minder dan het maximale mogelijke gewicht, en het is in balans.\n\nwill_it_fly([3], 5) ➞ True\n# 3 is minder dan het maximale mogelijke gewicht, en het is in balans.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/31", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Schrijf een functie die waar teruggeeft als het gegeven getal het product is van 3 priemgetallen en anders onwaar. Wetende dat (a) kleiner is dan 100. Voorbeeld:\n# \n# is_multiply_prime(30) == True\n# 30 = 2 * 3 * 5\n#\nsub is_multiply_prime\n{\n  my ($a) = @_;\n", "entry_point": "is_multiply_prime", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 5;\nmy $x0 = is_multiply_prime($arg00);\nmy $v0 = 0;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 30;\nmy $x1 = is_multiply_prime($arg10);\nmy $v1 = 1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 8;\nmy $x2 = is_multiply_prime($arg20);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 10;\nmy $x3 = is_multiply_prime($arg30);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 125;\nmy $x4 = is_multiply_prime($arg40);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 105;\nmy $x5 = is_multiply_prime($arg50);\nmy $v5 = 1;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 126;\nmy $x6 = is_multiply_prime($arg60);\nmy $v6 = 0;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = 729;\nmy $x7 = is_multiply_prime($arg70);\nmy $v7 = 0;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = 891;\nmy $x8 = is_multiply_prime($arg80);\nmy $v8 = 0;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = 1001;\nmy $x9 = is_multiply_prime($arg90);\nmy $v9 = 1;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\n", "description": "Schrijf een functie die waar teruggeeft als het gegeven getal het product is van 3 priemgetallen en anders onwaar. Wetende dat (a) kleiner is dan 100. Voorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/32", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Je krijgt een getal in decimale vorm en jouw taak is om het om te zetten naar binaire vorm. De functie moet een string retourneren, waarbij elk karakter een binair getal vertegenwoordigt. Elk karakter in de string zal '0' of '1' zijn.\n# \n# Er zullen een paar extra karakters 'db' aan het begin en aan het einde van de string zijn. De extra karakters zijn er om te helpen met de opmaak.\n# \n# Voorbeelden:\n# \n# decimal_to_binary(15)   # returns \"db1111db\"\n# decimal_to_binary(32)   # returns \"db100000db\"\n#\nsub decimal_to_binary\n{\n  my ($decimal) = @_;\n", "entry_point": "decimal_to_binary", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 0;\nmy $x0 = decimal_to_binary($arg00);\nmy $v0 = \"db0db\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 32;\nmy $x1 = decimal_to_binary($arg10);\nmy $v1 = \"db100000db\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 103;\nmy $x2 = decimal_to_binary($arg20);\nmy $v2 = \"db1100111db\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 15;\nmy $x3 = decimal_to_binary($arg30);\nmy $v3 = \"db1111db\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\n", "description": "Je krijgt een getal in decimale vorm en jouw taak is om het om te zetten naar binaire vorm. De functie moet een string retourneren, waarbij elk karakter een binair getal vertegenwoordigt. Elk karakter in de string zal '0' of '1' zijn.\n\nEr zullen een paar extra karakters 'db' aan het begin en aan het einde van de string zijn. De extra karakters zijn er om te helpen met de opmaak.\n\nVoorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/33", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Je krijgt een string s.\n# Je taak is om te controleren of de string gelukkig is of niet.\n# Een string is gelukkig als de lengte ten minste 3 is en elke 3 opeenvolgende letters verschillend zijn.\n# Bijvoorbeeld:\n# \n# is_happy(a) => False\n# is_happy(aa) => False\n# is_happy(abcd) => True\n# is_happy(aabb) => False\n# is_happy(adb) => True\n# is_happy(xyy) => False\n#\nsub is_happy\n{\n  my ($s) = @_;\n", "entry_point": "is_happy", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"a\";\nmy $x0 = is_happy($arg00);\nmy $v0 = 0;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"aa\";\nmy $x1 = is_happy($arg10);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"abcd\";\nmy $x2 = is_happy($arg20);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"aabb\";\nmy $x3 = is_happy($arg30);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"adb\";\nmy $x4 = is_happy($arg40);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"xyy\";\nmy $x5 = is_happy($arg50);\nmy $v5 = 0;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"iopaxpoi\";\nmy $x6 = is_happy($arg60);\nmy $v6 = 1;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = \"iopaxioi\";\nmy $x7 = is_happy($arg70);\nmy $v7 = 0;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\n", "description": "Je krijgt een string s.\nJe taak is om te controleren of de string gelukkig is of niet.\nEen string is gelukkig als de lengte ten minste 3 is en elke 3 opeenvolgende letters verschillend zijn.\nBijvoorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/34", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Het is de laatste week van het semester en de leraar moet de cijfers aan de studenten geven. De leraar heeft haar eigen algoritme voor het beoordelen gemaakt. Het enige probleem is dat ze de code die ze voor het beoordelen heeft gebruikt, is kwijtgeraakt. Ze heeft je een lijst met GPAs voor sommige studenten gegeven en je moet een functie schrijven die een lijst met lettercijfers kan produceren met behulp van de volgende tabel:\n#              GPA       |    Letter grade\n#               4.0                A+\n#             > 3.7                A \n#             > 3.3                A- \n#             > 3.0                B+\n#             > 2.7                B \n#             > 2.3                B-\n#             > 2.0                C+\n#             > 1.7                C\n#             > 1.3                C-\n#             > 1.0                D+ \n#             > 0.7                D \n#             > 0.0                D-\n#               0.0                E\n#     \n# \n#     Voorbeeld:\n# \n# grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n#\nsub numerical_letter_grade\n{\n  my ($grades) = @_;\n", "entry_point": "numerical_letter_grade", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [4.0, 3, 1.7, 2, 3.5];\nmy $x0 = numerical_letter_grade($arg00);\nmy $v0 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1.2];\nmy $x1 = numerical_letter_grade($arg10);\nmy $v1 = [\"D+\"];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [0.5];\nmy $x2 = numerical_letter_grade($arg20);\nmy $v2 = [\"D-\"];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [0.0];\nmy $x3 = numerical_letter_grade($arg30);\nmy $v3 = [\"E\"];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [1, 0.3, 1.5, 2.8, 3.3];\nmy $x4 = numerical_letter_grade($arg40);\nmy $v4 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [0, 0.7];\nmy $x5 = numerical_letter_grade($arg50);\nmy $v5 = [\"E\", \"D-\"];\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\n", "description": "Het is de laatste week van het semester en de leraar moet de cijfers aan de studenten geven. De leraar heeft haar eigen algoritme voor het beoordelen gemaakt. Het enige probleem is dat ze de code die ze voor het beoordelen heeft gebruikt, is kwijtgeraakt. Ze heeft je een lijst met GPAs voor sommige studenten gegeven en je moet een functie schrijven die een lijst met lettercijfers kan produceren met behulp van de volgende tabel:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Voorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/35", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Schrijf een functie die een string als argument neemt en True teruggeeft als de lengte van de string een priemgetal is, anders False.\n# Voorbeelden\n# \n# prime_length('Hello') == True\n# prime_length('abcdcba') == True\n# prime_length('kittens') == True\n# prime_length('orange') == False\n#\nsub prime_length\n{\n  my ($string) = @_;\n", "entry_point": "prime_length", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"Hello\";\nmy $x0 = prime_length($arg00);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"abcdcba\";\nmy $x1 = prime_length($arg10);\nmy $v1 = 1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"kittens\";\nmy $x2 = prime_length($arg20);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"orange\";\nmy $x3 = prime_length($arg30);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"wow\";\nmy $x4 = prime_length($arg40);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"world\";\nmy $x5 = prime_length($arg50);\nmy $v5 = 1;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"MadaM\";\nmy $x6 = prime_length($arg60);\nmy $v6 = 1;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = \"Wow\";\nmy $x7 = prime_length($arg70);\nmy $v7 = 1;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = \"\";\nmy $x8 = prime_length($arg80);\nmy $v8 = 0;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = \"HI\";\nmy $x9 = prime_length($arg90);\nmy $v9 = 1;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\nmy $arg100 = \"go\";\nmy $x10 = prime_length($arg100);\nmy $v10 = 1;\nunless(Compare($x10, $v10)) {\n    die \"Exception -- test case 10 did not pass.\";\n}\nmy $arg110 = \"gogo\";\nmy $x11 = prime_length($arg110);\nmy $v11 = 0;\nunless(Compare($x11, $v11)) {\n    die \"Exception -- test case 11 did not pass.\";\n}\nmy $arg120 = \"aaaaaaaaaaaaaaa\";\nmy $x12 = prime_length($arg120);\nmy $v12 = 0;\nunless(Compare($x12, $v12)) {\n    die \"Exception -- test case 12 did not pass.\";\n}\nmy $arg130 = \"Madam\";\nmy $x13 = prime_length($arg130);\nmy $v13 = 1;\nunless(Compare($x13, $v13)) {\n    die \"Exception -- test case 13 did not pass.\";\n}\nmy $arg140 = \"M\";\nmy $x14 = prime_length($arg140);\nmy $v14 = 0;\nunless(Compare($x14, $v14)) {\n    die \"Exception -- test case 14 did not pass.\";\n}\nmy $arg150 = \"0\";\nmy $x15 = prime_length($arg150);\nmy $v15 = 0;\nunless(Compare($x15, $v15)) {\n    die \"Exception -- test case 15 did not pass.\";\n}\n", "description": "Schrijf een functie die een string als argument neemt en True teruggeeft als de lengte van de string een priemgetal is, anders False.\nVoorbeelden", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/36", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Gegeven een positief geheel getal N, retourneer de totale som van zijn cijfers in binair formaat.\n# \n#     Voorbeeld\n#         Voor N = 1000, zal de som van de cijfers 1 zijn en de output moet \"1\" zijn.\n#         Voor N = 150, zal de som van de cijfers 6 zijn en de output moet \"110\" zijn.\n#         Voor N = 147, zal de som van de cijfers 12 zijn en de output moet \"1100\" zijn.\n#     \n#     Variabelen:\n#         @N integer\n#              Beperkingen: 0 ≤ N ≤ 10000.\n#     Output:\n#          een string van binair getal\n# \n#\nsub solve\n{\n  my ($n) = @_;\n", "entry_point": "solve", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 1000;\nmy $x0 = solve($arg00);\nmy $v0 = \"1\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 150;\nmy $x1 = solve($arg10);\nmy $v1 = \"110\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 147;\nmy $x2 = solve($arg20);\nmy $v2 = \"1100\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 333;\nmy $x3 = solve($arg30);\nmy $v3 = \"1001\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 963;\nmy $x4 = solve($arg40);\nmy $v4 = \"10010\";\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "Gegeven een positief geheel getal N, retourneer de totale som van zijn cijfers in binair formaat.\n\n    Voorbeeld\n        Voor N = 1000, zal de som van de cijfers 1 zijn en de output moet \"1\" zijn.\n        Voor N = 150, zal de som van de cijfers 6 zijn en de output moet \"110\" zijn.\n        Voor N = 147, zal de som van de cijfers 12 zijn en de output moet \"1100\" zijn.\n    \n    Variabelen:\n        @N integer\n             Beperkingen: 0 ≤ N ≤ 10000.\n    Output:\n         een string van binair getal", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/37", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Je krijgt een 2-dimensionale dataset als geneste lijsten, vergelijkbaar met een matrix, maar in tegenstelling tot matrices kan elke rij een ander aantal kolommen bevatten. Gegeven lst en een geheel getal x, zoek je de gehele getallen x in de lijst en retourneer je een lijst van tuples, [(x1, y1), (x2, y2) ...] zodat elke tuple een coördinaat is - (rij, kolommen), beginnend bij 0. Sorteer de coördinaten aanvankelijk op rijen in oplopende volgorde. Sorteer ook de coördinaten van de rij op kolommen in aflopende volgorde.\n# \n# Voorbeelden:\n# \n# get_row([\n#   [1,2,3,4,5,6],\n#   [1,2,3,4,1,6],\n#   [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([], 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n#\nsub get_row\n{\n  my ($lst, $x) = @_;\n", "entry_point": "get_row", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [];\nmy $arg01 = 1;\nmy $x0 = get_row($arg00, $arg01);\nmy $v0 = [];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [[1]];\nmy $arg11 = 2;\nmy $x1 = get_row($arg10, $arg11);\nmy $v1 = [];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [[], [1], [1, 2, 3]];\nmy $arg21 = 3;\nmy $x2 = get_row($arg20, $arg21);\nmy $v2 = [[2, 2]];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\n", "description": "Je krijgt een 2-dimensionale dataset als geneste lijsten, vergelijkbaar met een matrix, maar in tegenstelling tot matrices kan elke rij een ander aantal kolommen bevatten. Gegeven lst en een geheel getal x, zoek je de gehele getallen x in de lijst en retourneer je een lijst van tuples, [(x1, y1), (x2, y2) ...] zodat elke tuple een coördinaat is - (rij, kolommen), beginnend bij 0. Sorteer de coördinaten aanvankelijk op rijen in oplopende volgorde. Sorteer ook de coördinaten van de rij op kolommen in aflopende volgorde.\n\nVoorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/38", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Je krijgt een lijst van integers.\n# Schrijf een functie next_smallest() die het op één na kleinste element van de lijst teruggeeft.\n# Geef null terug als er geen dergelijk element is.\n# next_smallest([1, 2, 3, 4, 5]) == 2\n# next_smallest([5, 1, 4, 3, 2]) == 2\n# next_smallest([]) == None\n# next_smallest([1, 1]) == None\n#\nsub next_smallest\n{\n  my ($lst) = @_;\n", "entry_point": "next_smallest", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [1, 2, 3, 4, 5];\nmy $x0 = next_smallest($arg00);\nmy $v0 = 2;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [5, 1, 4, 3, 2];\nmy $x1 = next_smallest($arg10);\nmy $v1 = 2;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [];\nmy $x2 = next_smallest($arg20);\nmy $v2 = \"none\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [1, 1];\nmy $x3 = next_smallest($arg30);\nmy $v3 = \"none\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [1, 1, 1, 1, 0];\nmy $x4 = next_smallest($arg40);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [1, 1];\nmy $x5 = next_smallest($arg50);\nmy $v5 = \"none\";\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = [-35, 34, 12, -45];\nmy $x6 = next_smallest($arg60);\nmy $v6 = -35;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "Je krijgt een lijst van integers.\nSchrijf een functie next_smallest() die het op één na kleinste element van de lijst teruggeeft.\nGeef null terug als er geen dergelijk element is.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/39", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Je krijgt een reeks woorden en jouw taak is om het aantal saaiheden te tellen. Een saaiheid is een zin die begint met het woord \"Ik\". Zinnen worden begrensd door '.', '?' of '!'.\n# \n# Bijvoorbeeld:\n# >>> is_bored(\"Hello world\")\n# 0\n# >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\n#\nsub is_bored\n{\n  my ($s) = @_;\n", "entry_point": "is_bored", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"Hello world\";\nmy $x0 = is_bored($arg00);\nmy $v0 = 0;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"Is the sky blue?\";\nmy $x1 = is_bored($arg10);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"I love It !\";\nmy $x2 = is_bored($arg20);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"bIt\";\nmy $x3 = is_bored($arg30);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"I feel good today. I will be productive. will kill It\";\nmy $x4 = is_bored($arg40);\nmy $v4 = 2;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"You and I are going for a walk\";\nmy $x5 = is_bored($arg50);\nmy $v5 = 0;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\n", "description": "Je krijgt een reeks woorden en jouw taak is om het aantal saaiheden te tellen. Een saaiheid is een zin die begint met het woord \"Ik\". Zinnen worden begrensd door '.', '?' of '!'.\n\nBijvoorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/40", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Je krijgt een lijst met gehele getallen.\n#     Je moet het grootste priemgetal vinden en de som van zijn cijfers teruggeven.\n# \n#     Voorbeelden:\n# \n# For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n# For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n# For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n# For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n# For lst = [0,81,12,3,1,21] the output should be 3\n# For lst = [0,8,1,2,1,7] the output should be 7\n#\nsub skjkasdkd\n{\n  my ($lst) = @_;\n", "entry_point": "skjkasdkd", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3];\nmy $x0 = skjkasdkd($arg00);\nmy $v0 = 10;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1];\nmy $x1 = skjkasdkd($arg10);\nmy $v1 = 25;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3];\nmy $x2 = skjkasdkd($arg20);\nmy $v2 = 13;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6];\nmy $x3 = skjkasdkd($arg30);\nmy $v3 = 11;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [0, 81, 12, 3, 1, 21];\nmy $x4 = skjkasdkd($arg40);\nmy $v4 = 3;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [0, 8, 1, 2, 1, 7];\nmy $x5 = skjkasdkd($arg50);\nmy $v5 = 7;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = [8191];\nmy $x6 = skjkasdkd($arg60);\nmy $v6 = 19;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = [8191, 123456, 127, 7];\nmy $x7 = skjkasdkd($arg70);\nmy $v7 = 19;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = [127, 97, 8192];\nmy $x8 = skjkasdkd($arg80);\nmy $v8 = 10;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\n", "description": "Je krijgt een lijst met gehele getallen.\n    Je moet het grootste priemgetal vinden en de som van zijn cijfers teruggeven.\n\n    Voorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/41", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Gegeven een woordenboek, retourneer True als alle sleutels strings zijn in kleine letters of alle sleutels strings zijn in hoofdletters, anders retourneer False. De functie moet False retourneren als het gegeven woordenboek leeg is. Voorbeelden:\n# \n# check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n# check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n# check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n# check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n# check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n#\nsub check_dict_case\n{\n  my ($dict) = @_;\n", "entry_point": "check_dict_case", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = {\"p\" => \"pineapple\", \"b\" => \"banana\"};\nmy $x0 = check_dict_case($arg00);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = {\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"};\nmy $x1 = check_dict_case($arg10);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = {\"p\" => \"pineapple\", 5 => \"banana\", \"a\" => \"apple\"};\nmy $x2 = check_dict_case($arg20);\nmy $v2 = 0;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = {\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"};\nmy $x3 = check_dict_case($arg30);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = {\"STATE\" => \"NC\", \"ZIP\" => \"12345\"};\nmy $x4 = check_dict_case($arg40);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = {\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"};\nmy $x5 = check_dict_case($arg50);\nmy $v5 = 1;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = {};\nmy $x6 = check_dict_case($arg60);\nmy $v6 = 0;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "Gegeven een woordenboek, retourneer True als alle sleutels strings zijn in kleine letters of alle sleutels strings zijn in hoofdletters, anders retourneer False. De functie moet False retourneren als het gegeven woordenboek leeg is. Voorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/42", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Maak een functie die een waarde (string) vertegenwoordigt als een getal aanneemt en het dichtstbijzijnde gehele getal teruggeeft. Als het getal even ver van twee gehele getallen af ligt, rond dan af vanaf nul.\n# \n# Voorbeelden\n# >>> closest_integer(\"10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\n#\nsub closest_integer\n{\n  my ($value) = @_;\n", "entry_point": "closest_integer", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"10\";\nmy $x0 = closest_integer($arg00);\nmy $v0 = 10;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"14.5\";\nmy $x1 = closest_integer($arg10);\nmy $v1 = 15;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"-15.5\";\nmy $x2 = closest_integer($arg20);\nmy $v2 = -16;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"15.3\";\nmy $x3 = closest_integer($arg30);\nmy $v3 = 15;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"0\";\nmy $x4 = closest_integer($arg40);\nmy $v4 = 0;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "Maak een functie die een waarde (string) vertegenwoordigt als een getal aanneemt en het dichtstbijzijnde gehele getal teruggeeft. Als het getal even ver van twee gehele getallen af ligt, rond dan af vanaf nul.\n\nVoorbeelden", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/43", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Gegeven een positief geheel getal n, moet je een stapel van n niveaus stenen maken.\n#     Het eerste niveau heeft n stenen.\n#     Het aantal stenen in het volgende niveau is:\n#         - het volgende oneven getal als n oneven is.\n#         - het volgende even getal als n even is.\n#     Geef het aantal stenen in elk niveau terug in een lijst, waarbij het element op index\n#     i het aantal stenen in niveau (i+1) vertegenwoordigt.\n# \n#     Voorbeelden:\n# >>> make_a_pile(3)\n# [3, 5, 7]\n#\nsub make_a_pile\n{\n  my ($n) = @_;\n", "entry_point": "make_a_pile", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 3;\nmy $x0 = make_a_pile($arg00);\nmy $v0 = [3, 5, 7];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 4;\nmy $x1 = make_a_pile($arg10);\nmy $v1 = [4, 6, 8, 10];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 5;\nmy $x2 = make_a_pile($arg20);\nmy $v2 = [5, 7, 9, 11, 13];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 6;\nmy $x3 = make_a_pile($arg30);\nmy $v3 = [6, 8, 10, 12, 14, 16];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 8;\nmy $x4 = make_a_pile($arg40);\nmy $v4 = [8, 10, 12, 14, 16, 18, 20, 22];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "Gegeven een positief geheel getal n, moet je een stapel van n niveaus stenen maken.\n    Het eerste niveau heeft n stenen.\n    Het aantal stenen in het volgende niveau is:\n        - het volgende oneven getal als n oneven is.\n        - het volgende even getal als n even is.\n    Geef het aantal stenen in elk niveau terug in een lijst, waarbij het element op index\n    i het aantal stenen in niveau (i+1) vertegenwoordigt.\n\n    Voorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/44", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Je krijgt een string van woorden gescheiden door komma's of spaties. Je taak is om de string in woorden te splitsen en een array van de woorden terug te geven.\n# \n# Bijvoorbeeld:\n# \n# words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n#\nsub words_string\n{\n  my ($s) = @_;\n", "entry_point": "words_string", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"Hi, my name is John\";\nmy $x0 = words_string($arg00);\nmy $v0 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"One, two, three, four, five, six\";\nmy $x1 = words_string($arg10);\nmy $v1 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"Hi, my name\";\nmy $x2 = words_string($arg20);\nmy $v2 = [\"Hi\", \"my\", \"name\"];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"One,, two, three, four, five, six,\";\nmy $x3 = words_string($arg30);\nmy $v3 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"\";\nmy $x4 = words_string($arg40);\nmy $v4 = [];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"ahmed     , gamal\";\nmy $x5 = words_string($arg50);\nmy $v5 = [\"ahmed\", \"gamal\"];\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\n", "description": "Je krijgt een string van woorden gescheiden door komma's of spaties. Je taak is om de string in woorden te splitsen en een array van de woorden terug te geven.\n\nBijvoorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/45", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Deze functie neemt twee positieve getallen x en y en retourneert het grootste even gehele getal dat in het bereik [x, y] ligt. Als er geen dergelijk getal is, moet de functie -1 retourneren.\n# \n# Bijvoorbeeld:\n# \n# choose_num(12, 15) = 14\n# choose_num(13, 12) = -1\n#\nsub choose_num\n{\n  my ($x, $y) = @_;\n", "entry_point": "choose_num", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 12;\nmy $arg01 = 15;\nmy $x0 = choose_num($arg00, $arg01);\nmy $v0 = 14;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 13;\nmy $arg11 = 12;\nmy $x1 = choose_num($arg10, $arg11);\nmy $v1 = -1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 33;\nmy $arg21 = 12354;\nmy $x2 = choose_num($arg20, $arg21);\nmy $v2 = 12354;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 5234;\nmy $arg31 = 5233;\nmy $x3 = choose_num($arg30, $arg31);\nmy $v3 = -1;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 6;\nmy $arg41 = 29;\nmy $x4 = choose_num($arg40, $arg41);\nmy $v4 = 28;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 27;\nmy $arg51 = 10;\nmy $x5 = choose_num($arg50, $arg51);\nmy $v5 = -1;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 7;\nmy $arg61 = 7;\nmy $x6 = choose_num($arg60, $arg61);\nmy $v6 = -1;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = 546;\nmy $arg71 = 546;\nmy $x7 = choose_num($arg70, $arg71);\nmy $v7 = 546;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\n", "description": "Deze functie neemt twee positieve getallen x en y en retourneert het grootste even gehele getal dat in het bereik [x, y] ligt. Als er geen dergelijk getal is, moet de functie -1 retourneren.\n\nBijvoorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/46", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Je krijgt twee positieve gehele getallen n en m, en jouw taak is om het gemiddelde te berekenen van de gehele getallen van n tot en met m (inclusief n en m). Rond het antwoord af naar het dichtstbijzijnde gehele getal en converteer dat naar binair. Als n groter is dan m, geef dan -1 terug. Voorbeeld:\n# \n# rounded_avg(1, 5) => \"0b11\"\n# rounded_avg(7, 5) => -1\n# rounded_avg(10, 20) => \"0b1111\"\n# rounded_avg(20, 33) => \"0b11010\"\n#\nsub rounded_avg\n{\n  my ($n, $m) = @_;\n", "entry_point": "rounded_avg", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 1;\nmy $arg01 = 5;\nmy $x0 = rounded_avg($arg00, $arg01);\nmy $v0 = \"0b11\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 7;\nmy $arg11 = 13;\nmy $x1 = rounded_avg($arg10, $arg11);\nmy $v1 = \"0b1010\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 964;\nmy $arg21 = 977;\nmy $x2 = rounded_avg($arg20, $arg21);\nmy $v2 = \"0b1111001010\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 996;\nmy $arg31 = 997;\nmy $x3 = rounded_avg($arg30, $arg31);\nmy $v3 = \"0b1111100100\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 560;\nmy $arg41 = 851;\nmy $x4 = rounded_avg($arg40, $arg41);\nmy $v4 = \"0b1011000010\";\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 185;\nmy $arg51 = 546;\nmy $x5 = rounded_avg($arg50, $arg51);\nmy $v5 = \"0b101101110\";\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 362;\nmy $arg61 = 496;\nmy $x6 = rounded_avg($arg60, $arg61);\nmy $v6 = \"0b110101101\";\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = 350;\nmy $arg71 = 902;\nmy $x7 = rounded_avg($arg70, $arg71);\nmy $v7 = \"0b1001110010\";\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = 197;\nmy $arg81 = 233;\nmy $x8 = rounded_avg($arg80, $arg81);\nmy $v8 = \"0b11010111\";\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = 7;\nmy $arg91 = 5;\nmy $x9 = rounded_avg($arg90, $arg91);\nmy $v9 = -1;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\nmy $arg100 = 5;\nmy $arg101 = 1;\nmy $x10 = rounded_avg($arg100, $arg101);\nmy $v10 = -1;\nunless(Compare($x10, $v10)) {\n    die \"Exception -- test case 10 did not pass.\";\n}\nmy $arg110 = 5;\nmy $arg111 = 5;\nmy $x11 = rounded_avg($arg110, $arg111);\nmy $v11 = \"0b101\";\nunless(Compare($x11, $v11)) {\n    die \"Exception -- test case 11 did not pass.\";\n}\n", "description": "Je krijgt twee positieve gehele getallen n en m, en jouw taak is om het gemiddelde te berekenen van de gehele getallen van n tot en met m (inclusief n en m). Rond het antwoord af naar het dichtstbijzijnde gehele getal en converteer dat naar binair. Als n groter is dan m, geef dan -1 terug. Voorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/47", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Implementeer de functie f die n als parameter neemt en een lijst van grootte n retourneert, waarbij de waarde van het element op index i de faculteit van i is als i even is, of anders de som van getallen van 1 tot i. i begint bij 1. De faculteit van i is de vermenigvuldiging van de getallen van 1 tot i (1 * 2 * ... * i). Voorbeeld:\n# \n# f(5) == [1, 2, 6, 24, 15]\n#\nsub f\n{\n  my ($n) = @_;\n", "entry_point": "f", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 5;\nmy $x0 = f($arg00);\nmy $v0 = [1, 2, 6, 24, 15];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 7;\nmy $x1 = f($arg10);\nmy $v1 = [1, 2, 6, 24, 15, 720, 28];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 1;\nmy $x2 = f($arg20);\nmy $v2 = [1];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 3;\nmy $x3 = f($arg30);\nmy $v3 = [1, 2, 6];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\n", "description": "Implementeer de functie f die n als parameter neemt en een lijst van grootte n retourneert, waarbij de waarde van het element op index i de faculteit van i is als i even is, of anders de som van getallen van 1 tot i. i begint bij 1. De faculteit van i is de vermenigvuldiging van de getallen van 1 tot i (1 * 2 * ... * i). Voorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/48", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Gegeven een positief geheel getal n, retourneer een tuple met het aantal even en oneven gehele palindromen die vallen binnen het bereik (1, n), inclusief.\n# \n# Voorbeeld 1:\n# \n#     Input: 3\n#     Output: (1, 2)\n#     Uitleg:\n#     Gehele palindromen zijn 1, 2, 3. Eén daarvan is even en twee daarvan zijn oneven.\n# \n# Voorbeeld 2:\n# \n#     Input: 12\n#     Output: (4, 6)\n#     Uitleg:\n#     Gehele palindromen zijn 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier daarvan zijn even en zes daarvan zijn oneven.\n# \n# Opmerking:\n#     1. 1 <= n <= 10^3\n#     2. De geretourneerde tuple heeft respectievelijk het aantal even en oneven gehele palindromen.\n# \n#\nsub even_odd_palindrome\n{\n  my ($n) = @_;\n", "entry_point": "even_odd_palindrome", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 123;\nmy $x0 = even_odd_palindrome($arg00);\nmy $v0 = [8, 13];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 12;\nmy $x1 = even_odd_palindrome($arg10);\nmy $v1 = [4, 6];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 3;\nmy $x2 = even_odd_palindrome($arg20);\nmy $v2 = [1, 2];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 63;\nmy $x3 = even_odd_palindrome($arg30);\nmy $v3 = [6, 8];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 25;\nmy $x4 = even_odd_palindrome($arg40);\nmy $v4 = [5, 6];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 19;\nmy $x5 = even_odd_palindrome($arg50);\nmy $v5 = [4, 6];\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 9;\nmy $x6 = even_odd_palindrome($arg60);\nmy $v6 = [4, 5];\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = 1;\nmy $x7 = even_odd_palindrome($arg70);\nmy $v7 = [0, 1];\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\n", "description": "Gegeven een positief geheel getal n, retourneer een tuple met het aantal even en oneven gehele palindromen die vallen binnen het bereik (1, n), inclusief.\n\nVoorbeeld 1:\n\n    Input: 3\n    Output: (1, 2)\n    Uitleg:\n    Gehele palindromen zijn 1, 2, 3. Eén daarvan is even en twee daarvan zijn oneven.\n\nVoorbeeld 2:\n\n    Input: 12\n    Output: (4, 6)\n    Uitleg:\n    Gehele palindromen zijn 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier daarvan zijn even en zes daarvan zijn oneven.\n\nOpmerking:\n    1. 1 <= n <= 10^3\n    2. De geretourneerde tuple heeft respectievelijk het aantal even en oneven gehele palindromen.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/49", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# We hebben een array 'arr' van N integers arr[1], arr[2], ..., arr[N]. De getallen in de array zullen willekeurig geordend zijn. Jouw taak is om te bepalen of het mogelijk is om een array gesorteerd in niet-afnemende volgorde te krijgen door de volgende operatie uit te voeren op de gegeven array:\n# \n# Je mag een rechtsverschuivingsoperatie zo vaak uitvoeren als je wilt.\n# \n# Eén rechtsverschuivingsoperatie betekent dat alle elementen van de array één positie naar rechts worden verschoven. Het laatste element van de array wordt verplaatst naar de startpositie in de array, d.w.z. index 0.\n# \n# Als het mogelijk is om de gesorteerde array te verkrijgen door de bovenstaande operatie uit te voeren, retourneer dan True, anders retourneer False. Als de gegeven array leeg is, retourneer dan True.\n# \n# Opmerking: De gegeven lijst heeft gegarandeerd unieke elementen.\n# \n# Bijvoorbeeld:\n# \n# move_one_ball([3, 4, 5, 1, 2])==>True\n# Uitleg: Door 2 rechtsverschuivingsoperaties uit te voeren, kan niet-afnemende volgorde worden bereikt voor de gegeven array.\n# \n# move_one_ball([3, 5, 4, 1, 2])==>False\n# Uitleg: Het is niet mogelijk om niet-afnemende volgorde te krijgen voor de gegeven array door een willekeurig aantal rechtsverschuivingsoperaties uit te voeren.\n# \n#             \n#\nsub move_one_ball\n{\n  my ($arr) = @_;\n", "entry_point": "move_one_ball", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [3, 4, 5, 1, 2];\nmy $x0 = move_one_ball($arg00);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [3, 5, 10, 1, 2];\nmy $x1 = move_one_ball($arg10);\nmy $v1 = 1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [4, 3, 1, 2];\nmy $x2 = move_one_ball($arg20);\nmy $v2 = 0;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [3, 5, 4, 1, 2];\nmy $x3 = move_one_ball($arg30);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [];\nmy $x4 = move_one_ball($arg40);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "We hebben een array 'arr' van N integers arr[1], arr[2], ..., arr[N]. De getallen in de array zullen willekeurig geordend zijn. Jouw taak is om te bepalen of het mogelijk is om een array gesorteerd in niet-afnemende volgorde te krijgen door de volgende operatie uit te voeren op de gegeven array:\n\nJe mag een rechtsverschuivingsoperatie zo vaak uitvoeren als je wilt.\n\nEén rechtsverschuivingsoperatie betekent dat alle elementen van de array één positie naar rechts worden verschoven. Het laatste element van de array wordt verplaatst naar de startpositie in de array, d.w.z. index 0.\n\nAls het mogelijk is om de gesorteerde array te verkrijgen door de bovenstaande operatie uit te voeren, retourneer dan True, anders retourneer False. Als de gegeven array leeg is, retourneer dan True.\n\nOpmerking: De gegeven lijst heeft gegarandeerd unieke elementen.\n\nBijvoorbeeld:\n\nmove_one_ball([3, 4, 5, 1, 2])==>True\nUitleg: Door 2 rechtsverschuivingsoperaties uit te voeren, kan niet-afnemende volgorde worden bereikt voor de gegeven array.\n\nmove_one_ball([3, 5, 4, 1, 2])==>False\nUitleg: Het is niet mogelijk om niet-afnemende volgorde te krijgen voor de gegeven array door een willekeurig aantal rechtsverschuivingsoperaties uit te voeren.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/50", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# In dit probleem implementeer je een functie die twee lijsten van getallen neemt en bepaalt of het mogelijk is om een uitwisseling van elementen tussen hen uit te voeren om lst1 een lijst van alleen even getallen te maken. Er is geen limiet aan het aantal uitgewisselde elementen tussen lst1 en lst2. Als het mogelijk is om elementen uit te wisselen tussen lst1 en lst2 om alle elementen van lst1 even te maken, retourneer dan \"JA\". Anders retourneer \"NEE\". Bijvoorbeeld: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"JA\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NEE\" Er wordt aangenomen dat de invoerlijsten niet leeg zullen zijn.\n# \n#\nsub exchange\n{\n  my ($lst1, $lst2) = @_;\n", "entry_point": "exchange", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [1, 2, 3, 4];\nmy $arg01 = [1, 2, 3, 4];\nmy $x0 = exchange($arg00, $arg01);\nmy $v0 = \"YES\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1, 2, 3, 4];\nmy $arg11 = [1, 5, 3, 4];\nmy $x1 = exchange($arg10, $arg11);\nmy $v1 = \"NO\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [1, 2, 3, 4];\nmy $arg21 = [2, 1, 4, 3];\nmy $x2 = exchange($arg20, $arg21);\nmy $v2 = \"YES\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [5, 7, 3];\nmy $arg31 = [2, 6, 4];\nmy $x3 = exchange($arg30, $arg31);\nmy $v3 = \"YES\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [5, 7, 3];\nmy $arg41 = [2, 6, 3];\nmy $x4 = exchange($arg40, $arg41);\nmy $v4 = \"NO\";\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [3, 2, 6, 1, 8, 9];\nmy $arg51 = [3, 5, 5, 1, 1, 1];\nmy $x5 = exchange($arg50, $arg51);\nmy $v5 = \"NO\";\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = [100, 200];\nmy $arg61 = [200, 200];\nmy $x6 = exchange($arg60, $arg61);\nmy $v6 = \"YES\";\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "In dit probleem implementeer je een functie die twee lijsten van getallen neemt en bepaalt of het mogelijk is om een uitwisseling van elementen tussen hen uit te voeren om lst1 een lijst van alleen even getallen te maken. Er is geen limiet aan het aantal uitgewisselde elementen tussen lst1 en lst2. Als het mogelijk is om elementen uit te wisselen tussen lst1 en lst2 om alle elementen van lst1 even te maken, retourneer dan \"JA\". Anders retourneer \"NEE\". Bijvoorbeeld: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"JA\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NEE\" Er wordt aangenomen dat de invoerlijsten niet leeg zullen zijn.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/51", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Taak\n#     We krijgen twee strings s en c, je moet alle karakters in s verwijderen die gelijk zijn aan een karakter in c\n#     en vervolgens controleren of de resulterende string een palindroom is.\n#     Een string wordt een palindroom genoemd als het achterstevoren hetzelfde leest als vooruit.\n#     Je moet een tuple retourneren met de resulterende string en True/False voor de controle.\n#     Voorbeeld\n#     Voor s = \"abcde\", c = \"ae\", moet het resultaat zijn ('bcd',False)\n#     Voor s = \"abcdef\", c = \"b\" moet het resultaat zijn ('acdef',False)\n#     Voor s = \"abcdedcba\", c = \"ab\", moet het resultaat zijn ('cdedc',True)\n# \n#\nsub reverse_delete\n{\n  my ($s, $c) = @_;\n", "entry_point": "reverse_delete", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"abcde\";\nmy $arg01 = \"ae\";\nmy $x0 = reverse_delete($arg00, $arg01);\nmy $v0 = [\"bcd\", 0];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"abcdef\";\nmy $arg11 = \"b\";\nmy $x1 = reverse_delete($arg10, $arg11);\nmy $v1 = [\"acdef\", 0];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"abcdedcba\";\nmy $arg21 = \"ab\";\nmy $x2 = reverse_delete($arg20, $arg21);\nmy $v2 = [\"cdedc\", 1];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"dwik\";\nmy $arg31 = \"w\";\nmy $x3 = reverse_delete($arg30, $arg31);\nmy $v3 = [\"dik\", 0];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"a\";\nmy $arg41 = \"a\";\nmy $x4 = reverse_delete($arg40, $arg41);\nmy $v4 = [\"\", 1];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"abcdedcba\";\nmy $arg51 = \"\";\nmy $x5 = reverse_delete($arg50, $arg51);\nmy $v5 = [\"abcdedcba\", 1];\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"abcdedcba\";\nmy $arg61 = \"v\";\nmy $x6 = reverse_delete($arg60, $arg61);\nmy $v6 = [\"abcdedcba\", 1];\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = \"vabba\";\nmy $arg71 = \"v\";\nmy $x7 = reverse_delete($arg70, $arg71);\nmy $v7 = [\"abba\", 1];\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = \"mamma\";\nmy $arg81 = \"mia\";\nmy $x8 = reverse_delete($arg80, $arg81);\nmy $v8 = [\"\", 1];\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\n", "description": "Taak\n    We krijgen twee strings s en c, je moet alle karakters in s verwijderen die gelijk zijn aan een karakter in c\n    en vervolgens controleren of de resulterende string een palindroom is.\n    Een string wordt een palindroom genoemd als het achterstevoren hetzelfde leest als vooruit.\n    Je moet een tuple retourneren met de resulterende string en True/False voor de controle.\n    Voorbeeld\n    Voor s = \"abcde\", c = \"ae\", moet het resultaat zijn ('bcd',False)\n    Voor s = \"abcdef\", c = \"b\" moet het resultaat zijn ('acdef',False)\n    Voor s = \"abcdedcba\", c = \"ab\", moet het resultaat zijn ('cdedc',True)", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/52", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Je krijgt een rechthoekig raster van putten. Elke rij vertegenwoordigt een enkele put, en elke 1 in een rij vertegenwoordigt een enkele eenheid water. Elke put heeft een bijbehorende emmer die kan worden gebruikt om water eruit te halen, en alle emmers hebben dezelfde capaciteit. Jouw taak is om de emmers te gebruiken om de putten leeg te maken. Geef als output het aantal keren dat je de emmers moet laten zakken.\n# \n# Voorbeeld 1:\n#     Input:\n#         grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n#         emmer_capaciteit: 1\n#     Output: 6\n# \n# Voorbeeld 2:\n#     Input:\n#         grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n#         emmer_capaciteit: 2\n#     Output: 5\n# \n# Voorbeeld 3:\n#     Input:\n#         grid: [[0,0,0], [0,0,0]]\n#         emmer_capaciteit: 5\n#     Output: 0\n# \n# Beperkingen:\n#     * alle putten hebben dezelfde lengte\n#     * 1 <= grid.lengte <= 10^2\n#     * 1 <= grid[:,1].lengte <= 10^2\n#     * grid[i][j] -> 0 | 1\n#     * 1 <= capaciteit <= 10\n# \n#\nsub max_fill\n{\n  my ($grid, $capacity) = @_;\n", "entry_point": "max_fill", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]];\nmy $arg01 = 1;\nmy $x0 = max_fill($arg00, $arg01);\nmy $v0 = 6;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]];\nmy $arg11 = 2;\nmy $x1 = max_fill($arg10, $arg11);\nmy $v1 = 5;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [[0, 0, 0], [0, 0, 0]];\nmy $arg21 = 5;\nmy $x2 = max_fill($arg20, $arg21);\nmy $v2 = 0;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [[1, 1, 1, 1], [1, 1, 1, 1]];\nmy $arg31 = 2;\nmy $x3 = max_fill($arg30, $arg31);\nmy $v3 = 4;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [[1, 1, 1, 1], [1, 1, 1, 1]];\nmy $arg41 = 9;\nmy $x4 = max_fill($arg40, $arg41);\nmy $v4 = 2;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "Je krijgt een rechthoekig raster van putten. Elke rij vertegenwoordigt een enkele put, en elke 1 in een rij vertegenwoordigt een enkele eenheid water. Elke put heeft een bijbehorende emmer die kan worden gebruikt om water eruit te halen, en alle emmers hebben dezelfde capaciteit. Jouw taak is om de emmers te gebruiken om de putten leeg te maken. Geef als output het aantal keren dat je de emmers moet laten zakken.\n\nVoorbeeld 1:\n    Input:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        emmer_capaciteit: 1\n    Output: 6\n\nVoorbeeld 2:\n    Input:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        emmer_capaciteit: 2\n    Output: 5\n\nVoorbeeld 3:\n    Input:\n        grid: [[0,0,0], [0,0,0]]\n        emmer_capaciteit: 5\n    Output: 0\n\nBeperkingen:\n    * alle putten hebben dezelfde lengte\n    * 1 <= grid.lengte <= 10^2\n    * 1 <= grid[:,1].lengte <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= capaciteit <= 10", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/53", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Gegeven een string s en een natuurlijk getal n, is het jouw taak om een functie te implementeren die een lijst teruggeeft van alle woorden uit string s die precies n medeklinkers bevatten, in de volgorde waarin deze woorden voorkomen in string s. Als de string s leeg is, moet de functie een lege lijst retourneren. Let op: je mag ervan uitgaan dat de invoerstring alleen letters en spaties bevat. Voorbeelden:\n# \n# select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n# select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n# select_words(\"simple white space\", 2) ==> []\n# select_words(\"Hello world\", 4) ==> [\"world\"]\n# select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n#\nsub select_words\n{\n  my ($s, $n) = @_;\n", "entry_point": "select_words", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"Mary had a little lamb\";\nmy $arg01 = 4;\nmy $x0 = select_words($arg00, $arg01);\nmy $v0 = [\"little\"];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"Mary had a little lamb\";\nmy $arg11 = 3;\nmy $x1 = select_words($arg10, $arg11);\nmy $v1 = [\"Mary\", \"lamb\"];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"simple white space\";\nmy $arg21 = 2;\nmy $x2 = select_words($arg20, $arg21);\nmy $v2 = [];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"Hello world\";\nmy $arg31 = 4;\nmy $x3 = select_words($arg30, $arg31);\nmy $v3 = [\"world\"];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"Uncle sam\";\nmy $arg41 = 3;\nmy $x4 = select_words($arg40, $arg41);\nmy $v4 = [\"Uncle\"];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"\";\nmy $arg51 = 4;\nmy $x5 = select_words($arg50, $arg51);\nmy $v5 = [];\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"a b c d e f\";\nmy $arg61 = 1;\nmy $x6 = select_words($arg60, $arg61);\nmy $v6 = [\"b\", \"c\", \"d\", \"f\"];\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "Gegeven een string s en een natuurlijk getal n, is het jouw taak om een functie te implementeren die een lijst teruggeeft van alle woorden uit string s die precies n medeklinkers bevatten, in de volgorde waarin deze woorden voorkomen in string s. Als de string s leeg is, moet de functie een lege lijst retourneren. Let op: je mag ervan uitgaan dat de invoerstring alleen letters en spaties bevat. Voorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/54", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Gegeven een array arr van integers en een positief integer k, retourneer een gesorteerde lijst van lengte k met de k grootste getallen in arr.\n# \n# Voorbeeld 1:\n# \n#     Input: arr = [-3, -4, 5], k = 3\n#     Output: [-4, -3, 5]\n# \n# Voorbeeld 2:\n# \n#     Input: arr = [4, -4, 4], k = 2\n#     Output: [4, 4]\n# \n# Voorbeeld 3:\n# \n#     Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n#     Output: [2]\n# \n# Opmerkingen:\n#     1. De lengte van de array zal in het bereik van [1, 1000] zijn.\n#     2. De elementen in de array zullen in het bereik van [-1000, 1000] zijn.\n#     3. 0 <= k <= len(arr)\n# \n#\nsub maximum\n{\n  my ($arr, $k) = @_;\n", "entry_point": "maximum", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [-3, -4, 5];\nmy $arg01 = 3;\nmy $x0 = maximum($arg00, $arg01);\nmy $v0 = [-4, -3, 5];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [4, -4, 4];\nmy $arg11 = 2;\nmy $x1 = maximum($arg10, $arg11);\nmy $v1 = [4, 4];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [-3, 2, 1, 2, -1, -2, 1];\nmy $arg21 = 1;\nmy $x2 = maximum($arg20, $arg21);\nmy $v2 = [2];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [123, -123, 20, 0, 1, 2, -3];\nmy $arg31 = 3;\nmy $x3 = maximum($arg30, $arg31);\nmy $v3 = [2, 20, 123];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [-123, 20, 0, 1, 2, -3];\nmy $arg41 = 4;\nmy $x4 = maximum($arg40, $arg41);\nmy $v4 = [0, 1, 2, 20];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [5, 15, 0, 3, -13, -8, 0];\nmy $arg51 = 7;\nmy $x5 = maximum($arg50, $arg51);\nmy $v5 = [-13, -8, 0, 0, 3, 5, 15];\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = [-1, 0, 2, 5, 3, -10];\nmy $arg61 = 2;\nmy $x6 = maximum($arg60, $arg61);\nmy $v6 = [3, 5];\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = [1, 0, 5, -7];\nmy $arg71 = 1;\nmy $x7 = maximum($arg70, $arg71);\nmy $v7 = [5];\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = [4, -4];\nmy $arg81 = 2;\nmy $x8 = maximum($arg80, $arg81);\nmy $v8 = [-4, 4];\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = [-10, 10];\nmy $arg91 = 2;\nmy $x9 = maximum($arg90, $arg91);\nmy $v9 = [-10, 10];\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\nmy $arg100 = [1, 2, 3, -23, 243, -400, 0];\nmy $arg101 = 0;\nmy $x10 = maximum($arg100, $arg101);\nmy $v10 = [];\nunless(Compare($x10, $v10)) {\n    die \"Exception -- test case 10 did not pass.\";\n}\n", "description": "Gegeven een array arr van integers en een positief integer k, retourneer een gesorteerde lijst van lengte k met de k grootste getallen in arr.\n\nVoorbeeld 1:\n\n    Input: arr = [-3, -4, 5], k = 3\n    Output: [-4, -3, 5]\n\nVoorbeeld 2:\n\n    Input: arr = [4, -4, 4], k = 2\n    Output: [4, 4]\n\nVoorbeeld 3:\n\n    Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Output: [2]\n\nOpmerkingen:\n    1. De lengte van de array zal in het bereik van [1, 1000] zijn.\n    2. De elementen in de array zullen in het bereik van [-1000, 1000] zijn.\n    3. 0 <= k <= len(arr)", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/55", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Gegeven een niet-lege array van integers arr en een integer k, retourneer de som van de elementen met hoogstens twee cijfers van de eerste k elementen van arr.\n# \n# Voorbeeld:\n# \n#     Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n#     Output: 24 # som van 21 + 3\n# \n# Beperkingen:\n#     1. 1 <= len(arr) <= 100\n#     2. 1 <= k <= len(arr)\n# \n#\nsub add_elements\n{\n  my ($arr, $k) = @_;\n", "entry_point": "add_elements", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [1, -2, -3, 41, 57, 76, 87, 88, 99];\nmy $arg01 = 3;\nmy $x0 = add_elements($arg00, $arg01);\nmy $v0 = -4;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [111, 121, 3, 4000, 5, 6];\nmy $arg11 = 2;\nmy $x1 = add_elements($arg10, $arg11);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [11, 21, 3, 90, 5, 6, 7, 8, 9];\nmy $arg21 = 4;\nmy $x2 = add_elements($arg20, $arg21);\nmy $v2 = 125;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [111, 21, 3, 4000, 5, 6, 7, 8, 9];\nmy $arg31 = 4;\nmy $x3 = add_elements($arg30, $arg31);\nmy $v3 = 24;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [1];\nmy $arg41 = 1;\nmy $x4 = add_elements($arg40, $arg41);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "Gegeven een niet-lege array van integers arr en een integer k, retourneer de som van de elementen met hoogstens twee cijfers van de eerste k elementen van arr.\n\nVoorbeeld:\n\n    Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Output: 24 # som van 21 + 3\n\nBeperkingen:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/56", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Je krijgt twee intervallen,\n#     waarbij elk interval een paar van gehele getallen is. Bijvoorbeeld, interval = (start, end) = (1, 2).\n#     De gegeven intervallen zijn gesloten, wat betekent dat het interval (start, end)\n#     zowel start als end bevat.\n#     Voor elk gegeven interval wordt aangenomen dat de start kleiner of gelijk is aan de end.\n#     Je taak is om te bepalen of de lengte van de intersectie van deze twee\n#     intervallen een priemgetal is.\n#     Bijvoorbeeld, de intersectie van de intervallen (1, 3), (2, 4) is (2, 3)\n#     waarvan de lengte 1 is, wat geen priemgetal is.\n#     Als de lengte van de intersectie een priemgetal is, retourneer dan \"YES\",\n#     anders retourneer \"NO\".\n#     Als de twee intervallen elkaar niet overlappen, retourneer dan \"NO\".\n# \n# \n#     [invoer/uitvoer] voorbeelden:\n# \n# intersection((1, 2), (2, 3)) ==> \"NO\"\n# intersection((-1, 1), (0, 4)) ==> \"NO\"\n# intersection((-3, -1), (-5, 5)) ==> \"YES\"\n#\nsub intersection\n{\n  my ($interval1, $interval2) = @_;\n", "entry_point": "intersection", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [1, 2];\nmy $arg01 = [2, 3];\nmy $x0 = intersection($arg00, $arg01);\nmy $v0 = \"NO\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [-1, 1];\nmy $arg11 = [0, 4];\nmy $x1 = intersection($arg10, $arg11);\nmy $v1 = \"NO\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [-3, -1];\nmy $arg21 = [-5, 5];\nmy $x2 = intersection($arg20, $arg21);\nmy $v2 = \"YES\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [-2, 2];\nmy $arg31 = [-4, 0];\nmy $x3 = intersection($arg30, $arg31);\nmy $v3 = \"YES\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [-11, 2];\nmy $arg41 = [-1, -1];\nmy $x4 = intersection($arg40, $arg41);\nmy $v4 = \"NO\";\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [1, 2];\nmy $arg51 = [3, 5];\nmy $x5 = intersection($arg50, $arg51);\nmy $v5 = \"NO\";\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = [1, 2];\nmy $arg61 = [1, 2];\nmy $x6 = intersection($arg60, $arg61);\nmy $v6 = \"NO\";\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = [-2, -2];\nmy $arg71 = [-3, -2];\nmy $x7 = intersection($arg70, $arg71);\nmy $v7 = \"NO\";\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\n", "description": "Je krijgt twee intervallen,\n    waarbij elk interval een paar van gehele getallen is. Bijvoorbeeld, interval = (start, end) = (1, 2).\n    De gegeven intervallen zijn gesloten, wat betekent dat het interval (start, end)\n    zowel start als end bevat.\n    Voor elk gegeven interval wordt aangenomen dat de start kleiner of gelijk is aan de end.\n    Je taak is om te bepalen of de lengte van de intersectie van deze twee\n    intervallen een priemgetal is.\n    Bijvoorbeeld, de intersectie van de intervallen (1, 3), (2, 4) is (2, 3)\n    waarvan de lengte 1 is, wat geen priemgetal is.\n    Als de lengte van de intersectie een priemgetal is, retourneer dan \"YES\",\n    anders retourneer \"NO\".\n    Als de twee intervallen elkaar niet overlappen, retourneer dan \"NO\".\n\n\n    [invoer/uitvoer] voorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/57", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Iedereen kent de Fibonacci-reeks, die diep is bestudeerd door wiskundigen in de afgelopen eeuwen. Wat mensen echter niet weten, is de Tribonacci-reeks. De Tribonacci-reeks wordt gedefinieerd door de recursie:\n# tri(1) = 3\n# tri(n) = 1 + n / 2, als n even is.\n# tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), als n oneven is.\n# Bijvoorbeeld:\n# tri(2) = 1 + (2 / 2) = 2\n# tri(4) = 3\n# tri(3) = tri(2) + tri(1) + tri(4)\n# = 2 + 3 + 3 = 8\n# Je krijgt een niet-negatief geheel getal n, je moet een lijst retourneren van de eerste n + 1 getallen van de Tribonacci-reeks.\n# Voorbeelden:\n# tri(3) = [1, 3, 2, 8]\n# \n#\nsub tri\n{\n  my ($n) = @_;\n", "entry_point": "tri", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 3;\nmy $x0 = tri($arg00);\nmy $v0 = [1, 3, 2.0, 8.0];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 4;\nmy $x1 = tri($arg10);\nmy $v1 = [1, 3, 2.0, 8.0, 3.0];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 5;\nmy $x2 = tri($arg20);\nmy $v2 = [1, 3, 2.0, 8.0, 3.0, 15.0];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 6;\nmy $x3 = tri($arg30);\nmy $v3 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 7;\nmy $x4 = tri($arg40);\nmy $v4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 8;\nmy $x5 = tri($arg50);\nmy $v5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0];\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 9;\nmy $x6 = tri($arg60);\nmy $v6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0];\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = 20;\nmy $x7 = tri($arg70);\nmy $v7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0];\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = 0;\nmy $x8 = tri($arg80);\nmy $v8 = [1];\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = 1;\nmy $x9 = tri($arg90);\nmy $v9 = [1, 3];\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\n", "description": "Iedereen kent de Fibonacci-reeks, die diep is bestudeerd door wiskundigen in de afgelopen eeuwen. Wat mensen echter niet weten, is de Tribonacci-reeks. De Tribonacci-reeks wordt gedefinieerd door de recursie:\ntri(1) = 3\ntri(n) = 1 + n / 2, als n even is.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), als n oneven is.\nBijvoorbeeld:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nJe krijgt een niet-negatief geheel getal n, je moet een lijst retourneren van de eerste n + 1 getallen van de Tribonacci-reeks.\nVoorbeelden:\ntri(3) = [1, 3, 2, 8]", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/58", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Gegeven een positief geheel getal n, retourneer het product van de oneven cijfers.\n#     Retourneer 0 als alle cijfers even zijn.\n#     Bijvoorbeeld:\n# \n# digits(1)  == 1\n# digits(4)  == 0\n# digits(235) == 15\n#\nsub digits\n{\n  my ($n) = @_;\n", "entry_point": "digits", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 5;\nmy $x0 = digits($arg00);\nmy $v0 = 5;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 54;\nmy $x1 = digits($arg10);\nmy $v1 = 5;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 120;\nmy $x2 = digits($arg20);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 5014;\nmy $x3 = digits($arg30);\nmy $v3 = 5;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 98765;\nmy $x4 = digits($arg40);\nmy $v4 = 315;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 5576543;\nmy $x5 = digits($arg50);\nmy $v5 = 2625;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 2468;\nmy $x6 = digits($arg60);\nmy $v6 = 0;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "Gegeven een positief geheel getal n, retourneer het product van de oneven cijfers.\n    Retourneer 0 als alle cijfers even zijn.\n    Bijvoorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/59", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Maak een functie die een string als invoer neemt die alleen vierkante haken bevat. De functie moet True retourneren als en alleen als er een geldige deelsequentie van haken is waar ten minste één haak in de deelsequentie genest is.\n# is_nested('[[]]') ➞ True\n# is_nested('[]]]]]]][[[[[]') ➞ False\n# is_nested('[][]') ➞ False\n# is_nested('[]') ➞ False\n# is_nested('[[][]]') ➞ True\n# is_nested('[[]][[') ➞ True\n#\nsub is_nested\n{\n  my ($string) = @_;\n", "entry_point": "is_nested", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"[[]]\";\nmy $x0 = is_nested($arg00);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"[]]]]]]][[[[[]\";\nmy $x1 = is_nested($arg10);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"[][]\";\nmy $x2 = is_nested($arg20);\nmy $v2 = 0;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"[]\";\nmy $x3 = is_nested($arg30);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"[[[[]]]]\";\nmy $x4 = is_nested($arg40);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"[]]]]]]]]]]\";\nmy $x5 = is_nested($arg50);\nmy $v5 = 0;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"[][][[]]\";\nmy $x6 = is_nested($arg60);\nmy $v6 = 1;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = \"[[]\";\nmy $x7 = is_nested($arg70);\nmy $v7 = 0;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = \"[]]\";\nmy $x8 = is_nested($arg80);\nmy $v8 = 0;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = \"[[]][[\";\nmy $x9 = is_nested($arg90);\nmy $v9 = 1;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\nmy $arg100 = \"[[][]]\";\nmy $x10 = is_nested($arg100);\nmy $v10 = 1;\nunless(Compare($x10, $v10)) {\n    die \"Exception -- test case 10 did not pass.\";\n}\nmy $arg110 = \"\";\nmy $x11 = is_nested($arg110);\nmy $v11 = 0;\nunless(Compare($x11, $v11)) {\n    die \"Exception -- test case 11 did not pass.\";\n}\nmy $arg120 = \"[[[[[[[[\";\nmy $x12 = is_nested($arg120);\nmy $v12 = 0;\nunless(Compare($x12, $v12)) {\n    die \"Exception -- test case 12 did not pass.\";\n}\nmy $arg130 = \"]]]]]]]]\";\nmy $x13 = is_nested($arg130);\nmy $v13 = 0;\nunless(Compare($x13, $v13)) {\n    die \"Exception -- test case 13 did not pass.\";\n}\n", "description": "Maak een functie die een string als invoer neemt die alleen vierkante haken bevat. De functie moet True retourneren als en alleen als er een geldige deelsequentie van haken is waar ten minste één haak in de deelsequentie genest is.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/60", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Je krijgt een lijst met getallen.\n# Je moet de som van de gekwadrateerde getallen in de gegeven lijst teruggeven,\n# rond elk element in de lijst eerst af naar het bovenste gehele getal (Ceiling).\n# Voorbeelden:\n# Voor lst = [1,2,3] is de output 14\n# Voor lst = [1,4,9] is de output 98\n# Voor lst = [1,3,5,7] is de output 84\n# Voor lst = [1.4,4.2,0] is de output 29\n# Voor lst = [-2.4,1,1] is de output 6\n# \n# \n\n#\nsub sum_squares\n{\n  my ($lst) = @_;\n", "entry_point": "sum_squares", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [1, 2, 3];\nmy $x0 = sum_squares($arg00);\nmy $v0 = 14;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1.0, 2, 3];\nmy $x1 = sum_squares($arg10);\nmy $v1 = 14;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [1, 3, 5, 7];\nmy $x2 = sum_squares($arg20);\nmy $v2 = 84;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [1.4, 4.2, 0];\nmy $x3 = sum_squares($arg30);\nmy $v3 = 29;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [-2.4, 1, 1];\nmy $x4 = sum_squares($arg40);\nmy $v4 = 6;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [100, 1, 15, 2];\nmy $x5 = sum_squares($arg50);\nmy $v5 = 10230;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = [10000, 10000];\nmy $x6 = sum_squares($arg60);\nmy $v6 = 200000000;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = [-1.4, 4.6, 6.3];\nmy $x7 = sum_squares($arg70);\nmy $v7 = 75;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = [-1.4, 17.9, 18.9, 19.9];\nmy $x8 = sum_squares($arg80);\nmy $v8 = 1086;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = [0];\nmy $x9 = sum_squares($arg90);\nmy $v9 = 0;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\nmy $arg100 = [-1];\nmy $x10 = sum_squares($arg100);\nmy $v10 = 1;\nunless(Compare($x10, $v10)) {\n    die \"Exception -- test case 10 did not pass.\";\n}\nmy $arg110 = [-1, 1, 0];\nmy $x11 = sum_squares($arg110);\nmy $v11 = 2;\nunless(Compare($x11, $v11)) {\n    die \"Exception -- test case 11 did not pass.\";\n}\n", "description": "Je krijgt een lijst met getallen.\nJe moet de som van de gekwadrateerde getallen in de gegeven lijst teruggeven,\nrond elk element in de lijst eerst af naar het bovenste gehele getal (Ceiling).\nVoorbeelden:\nVoor lst = [1,2,3] is de output 14\nVoor lst = [1,4,9] is de output 98\nVoor lst = [1,3,5,7] is de output 84\nVoor lst = [1.4,4.2,0] is de output 29\nVoor lst = [-2.4,1,1] is de output 6", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/61", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Maak een functie die True retourneert als het laatste karakter van een gegeven string een alfabetisch karakter is en geen deel uitmaakt van een woord, en anders False retourneert.\n# Opmerking: \"woord\" is een groep tekens gescheiden door spaties.\n# \n# Voorbeelden:\n# \n# check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n# check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n# check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n# check_if_last_char_is_a_letter(\"\") ➞ False \n#\nsub check_if_last_char_is_a_letter\n{\n  my ($txt) = @_;\n", "entry_point": "check_if_last_char_is_a_letter", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"apple\";\nmy $x0 = check_if_last_char_is_a_letter($arg00);\nmy $v0 = 0;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"apple pi e\";\nmy $x1 = check_if_last_char_is_a_letter($arg10);\nmy $v1 = 1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"eeeee\";\nmy $x2 = check_if_last_char_is_a_letter($arg20);\nmy $v2 = 0;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"A\";\nmy $x3 = check_if_last_char_is_a_letter($arg30);\nmy $v3 = 1;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"Pumpkin pie \";\nmy $x4 = check_if_last_char_is_a_letter($arg40);\nmy $v4 = 0;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"Pumpkin pie 1\";\nmy $x5 = check_if_last_char_is_a_letter($arg50);\nmy $v5 = 0;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"\";\nmy $x6 = check_if_last_char_is_a_letter($arg60);\nmy $v6 = 0;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = \"eeeee e \";\nmy $x7 = check_if_last_char_is_a_letter($arg70);\nmy $v7 = 0;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = \"apple pie\";\nmy $x8 = check_if_last_char_is_a_letter($arg80);\nmy $v8 = 0;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = \"apple pi e \";\nmy $x9 = check_if_last_char_is_a_letter($arg90);\nmy $v9 = 0;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\n", "description": "Maak een functie die True retourneert als het laatste karakter van een gegeven string een alfabetisch karakter is en geen deel uitmaakt van een woord, en anders False retourneert.\nOpmerking: \"woord\" is een groep tekens gescheiden door spaties.\n\nVoorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/62", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Maak een functie die het grootste indexnummer retourneert van een element dat niet groter is dan het element direct ervoor. Als er geen dergelijk element bestaat, retourneer dan -1. De gegeven array bevat geen dubbele waarden.\n# \n# Voorbeelden:\n# \n# can_arrange([1,2,4,3,5]) = 3\n# can_arrange([1,2,3]) = -1\n#\nsub can_arrange\n{\n  my ($arr) = @_;\n", "entry_point": "can_arrange", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [1, 2, 4, 3, 5];\nmy $x0 = can_arrange($arg00);\nmy $v0 = 3;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1, 2, 4, 5];\nmy $x1 = can_arrange($arg10);\nmy $v1 = -1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [1, 4, 2, 5, 6, 7, 8, 9, 10];\nmy $x2 = can_arrange($arg20);\nmy $v2 = 2;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [4, 8, 5, 7, 3];\nmy $x3 = can_arrange($arg30);\nmy $v3 = 4;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [];\nmy $x4 = can_arrange($arg40);\nmy $v4 = -1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\n", "description": "Maak een functie die het grootste indexnummer retourneert van een element dat niet groter is dan het element direct ervoor. Als er geen dergelijk element bestaat, retourneer dan -1. De gegeven array bevat geen dubbele waarden.\n\nVoorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/63", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Maak een functie die een tuple (a, b) retourneert, waarbij 'a' het grootste negatieve gehele getal is en 'b' het kleinste positieve gehele getal in een lijst is. Als er geen negatieve of positieve gehele getallen zijn, retourneer ze dan als None.\n# \n# Voorbeelden:\n# \n# largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n# largest_smallest_integers([]) == (None, None)\n# largest_smallest_integers([0]) == (None, None)\n#\nsub largest_smallest_integers\n{\n  my ($lst) = @_;\n", "entry_point": "largest_smallest_integers", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [2, 4, 1, 3, 5, 7];\nmy $x0 = largest_smallest_integers($arg00);\nmy $v0 = [\"none\", 1];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [2, 4, 1, 3, 5, 7, 0];\nmy $x1 = largest_smallest_integers($arg10);\nmy $v1 = [\"none\", 1];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [1, 3, 2, 4, 5, 6, -2];\nmy $x2 = largest_smallest_integers($arg20);\nmy $v2 = [-2, 1];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [4, 5, 3, 6, 2, 7, -7];\nmy $x3 = largest_smallest_integers($arg30);\nmy $v3 = [-7, 2];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [7, 3, 8, 4, 9, 2, 5, -9];\nmy $x4 = largest_smallest_integers($arg40);\nmy $v4 = [-9, 2];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [];\nmy $x5 = largest_smallest_integers($arg50);\nmy $v5 = [\"none\", \"none\"];\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = [0];\nmy $x6 = largest_smallest_integers($arg60);\nmy $v6 = [\"none\", \"none\"];\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = [-1, -3, -5, -6];\nmy $x7 = largest_smallest_integers($arg70);\nmy $v7 = [-1, \"none\"];\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = [-1, -3, -5, -6, 0];\nmy $x8 = largest_smallest_integers($arg80);\nmy $v8 = [-1, \"none\"];\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = [-6, -4, -4, -3, 1];\nmy $x9 = largest_smallest_integers($arg90);\nmy $v9 = [-3, 1];\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\nmy $arg100 = [-6, -4, -4, -3, -100, 1];\nmy $x10 = largest_smallest_integers($arg100);\nmy $v10 = [-3, 1];\nunless(Compare($x10, $v10)) {\n    die \"Exception -- test case 10 did not pass.\";\n}\n", "description": "Maak een functie die een tuple (a, b) retourneert, waarbij 'a' het grootste negatieve gehele getal is en 'b' het kleinste positieve gehele getal in een lijst is. Als er geen negatieve of positieve gehele getallen zijn, retourneer ze dan als None.\n\nVoorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/64", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# De Braziliaanse faculteit is gedefinieerd als:\n#     braziliaanse_faculteit(n) = n! * (n-1)! * (n-2)! * ... * 1!\n#     waarbij n > 0\n# \n#     Bijvoorbeeld:\n# >>> special_factorial(4)\n# 288\n\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\n#\nsub special_factorial\n{\n  my ($n) = @_;\n", "entry_point": "special_factorial", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 4;\nmy $x0 = special_factorial($arg00);\nmy $v0 = 288;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 5;\nmy $x1 = special_factorial($arg10);\nmy $v1 = 34560;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 7;\nmy $x2 = special_factorial($arg20);\nmy $v2 = 125411328000;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 1;\nmy $x3 = special_factorial($arg30);\nmy $v3 = 1;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\n", "description": "De Braziliaanse faculteit is gedefinieerd als:\n    braziliaanse_faculteit(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    waarbij n > 0\n\n    Bijvoorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/65", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Je krijgt een string die een zin voorstelt,\n#     de zin bevat enkele woorden gescheiden door een spatie,\n#     en je moet een string teruggeven die de woorden uit de oorspronkelijke zin bevat,\n#     waarvan de lengtes priemgetallen zijn,\n#     de volgorde van de woorden in de nieuwe string moet hetzelfde zijn als in de oorspronkelijke zin.\n# \n#     Voorbeeld 1:\n#         Input: sentence = \"This is a test\"\n#         Output: \"is\"\n# \n#     Voorbeeld 2:\n#         Input: sentence = \"lets go for swimming\"\n#         Output: \"go for\"\n# \n#     Beperkingen:\n#         * 1 <= len(sentence) <= 100\n#         * sentence bevat alleen letters\n# \n#\nsub words_in_sentence\n{\n  my ($sentence) = @_;\n", "entry_point": "words_in_sentence", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"This is a test\";\nmy $x0 = words_in_sentence($arg00);\nmy $v0 = \"is\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"lets go for swimming\";\nmy $x1 = words_in_sentence($arg10);\nmy $v1 = \"go for\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"there is no place available here\";\nmy $x2 = words_in_sentence($arg20);\nmy $v2 = \"there is no place\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"Hi I am Hussein\";\nmy $x3 = words_in_sentence($arg30);\nmy $v3 = \"Hi am Hussein\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"go for it\";\nmy $x4 = words_in_sentence($arg40);\nmy $v4 = \"go for it\";\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"here\";\nmy $x5 = words_in_sentence($arg50);\nmy $v5 = \"\";\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"here is\";\nmy $x6 = words_in_sentence($arg60);\nmy $v6 = \"is\";\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "Je krijgt een string die een zin voorstelt,\n    de zin bevat enkele woorden gescheiden door een spatie,\n    en je moet een string teruggeven die de woorden uit de oorspronkelijke zin bevat,\n    waarvan de lengtes priemgetallen zijn,\n    de volgorde van de woorden in de nieuwe string moet hetzelfde zijn als in de oorspronkelijke zin.\n\n    Voorbeeld 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Voorbeeld 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Beperkingen:\n        * 1 <= len(sentence) <= 100\n        * sentence bevat alleen letters", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/66", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Je taak is om een functie te implementeren die de expressie x * n vereenvoudigt. De functie retourneert True als x * n evalueert naar een geheel getal en False anders. Zowel x als n zijn stringrepresentaties van een breuk en hebben het volgende formaat: <teller>/<noemer> waarbij zowel de teller als de noemer positieve gehele getallen zijn.\n# \n# Je kunt ervan uitgaan dat x en n geldige breuken zijn en geen nul als noemer hebben.\n# simplify(\"1/5\", \"5/1\") = True\n# simplify(\"1/6\", \"2/1\") = False\n# simplify(\"7/10\", \"10/2\") = False\n#\nsub simplify\n{\n  my ($x, $n) = @_;\n", "entry_point": "simplify", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"1/5\";\nmy $arg01 = \"5/1\";\nmy $x0 = simplify($arg00, $arg01);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"1/6\";\nmy $arg11 = \"2/1\";\nmy $x1 = simplify($arg10, $arg11);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"5/1\";\nmy $arg21 = \"3/1\";\nmy $x2 = simplify($arg20, $arg21);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"7/10\";\nmy $arg31 = \"10/2\";\nmy $x3 = simplify($arg30, $arg31);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"2/10\";\nmy $arg41 = \"50/10\";\nmy $x4 = simplify($arg40, $arg41);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"7/2\";\nmy $arg51 = \"4/2\";\nmy $x5 = simplify($arg50, $arg51);\nmy $v5 = 1;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"11/6\";\nmy $arg61 = \"6/1\";\nmy $x6 = simplify($arg60, $arg61);\nmy $v6 = 1;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = \"2/3\";\nmy $arg71 = \"5/2\";\nmy $x7 = simplify($arg70, $arg71);\nmy $v7 = 0;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = \"5/2\";\nmy $arg81 = \"3/5\";\nmy $x8 = simplify($arg80, $arg81);\nmy $v8 = 0;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = \"2/4\";\nmy $arg91 = \"8/4\";\nmy $x9 = simplify($arg90, $arg91);\nmy $v9 = 1;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\nmy $arg100 = \"2/4\";\nmy $arg101 = \"4/2\";\nmy $x10 = simplify($arg100, $arg101);\nmy $v10 = 1;\nunless(Compare($x10, $v10)) {\n    die \"Exception -- test case 10 did not pass.\";\n}\nmy $arg110 = \"1/5\";\nmy $arg111 = \"5/1\";\nmy $x11 = simplify($arg110, $arg111);\nmy $v11 = 1;\nunless(Compare($x11, $v11)) {\n    die \"Exception -- test case 11 did not pass.\";\n}\nmy $arg120 = \"1/5\";\nmy $arg121 = \"1/5\";\nmy $x12 = simplify($arg120, $arg121);\nmy $v12 = 0;\nunless(Compare($x12, $v12)) {\n    die \"Exception -- test case 12 did not pass.\";\n}\n", "description": "Je taak is om een functie te implementeren die de expressie x * n vereenvoudigt. De functie retourneert True als x * n evalueert naar een geheel getal en False anders. Zowel x als n zijn stringrepresentaties van een breuk en hebben het volgende formaat: <teller>/<noemer> waarbij zowel de teller als de noemer positieve gehele getallen zijn.\n\nJe kunt ervan uitgaan dat x en n geldige breuken zijn en geen nul als noemer hebben.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/67", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Schrijf een functie die de gegeven lijst van integers sorteert in oplopende volgorde op basis van de som van hun cijfers. Let op: als er meerdere items zijn met een vergelijkbare som van hun cijfers, sorteer ze dan op basis van hun index in de oorspronkelijke lijst.\n# \n# Bijvoorbeeld:\n# >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n# >>> order_by_points([]) == []\n#\nsub order_by_points\n{\n  my ($nums) = @_;\n", "entry_point": "order_by_points", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [1, 11, -1, -11, -12];\nmy $x0 = order_by_points($arg00);\nmy $v0 = [-1, -11, 1, -12, 11];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46];\nmy $x1 = order_by_points($arg10);\nmy $v1 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [];\nmy $x2 = order_by_points($arg20);\nmy $v2 = [];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [1, -11, -32, 43, 54, -98, 2, -3];\nmy $x3 = order_by_points($arg30);\nmy $v3 = [-3, -32, -98, -11, 1, 2, 43, 54];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\nmy $x4 = order_by_points($arg40);\nmy $v4 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [0, 6, 6, -76, -21, 23, 4];\nmy $x5 = order_by_points($arg50);\nmy $v5 = [-76, -21, 0, 4, 23, 6, 6];\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\n", "description": "Schrijf een functie die de gegeven lijst van integers sorteert in oplopende volgorde op basis van de som van hun cijfers. Let op: als er meerdere items zijn met een vergelijkbare som van hun cijfers, sorteer ze dan op basis van hun index in de oorspronkelijke lijst.\n\nBijvoorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/68", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Schrijf een functie die een array van getallen als invoer neemt en het aantal elementen in de array teruggeeft die groter zijn dan 10 en waarvan zowel het eerste als het laatste cijfer van een getal oneven zijn (1, 3, 5, 7, 9). Bijvoorbeeld:\n# \n# specialFilter([15, -73, 14, -15]) => 1 \n# specialFilter([33, -2, -3, 45, 21, 109]) => 2\n#\nsub specialfilter\n{\n  my ($nums) = @_;\n", "entry_point": "specialfilter", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [5, -2, 1, -5];\nmy $x0 = specialfilter($arg00);\nmy $v0 = 0;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [15, -73, 14, -15];\nmy $x1 = specialfilter($arg10);\nmy $v1 = 1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [33, -2, -3, 45, 21, 109];\nmy $x2 = specialfilter($arg20);\nmy $v2 = 2;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [43, -12, 93, 125, 121, 109];\nmy $x3 = specialfilter($arg30);\nmy $v3 = 4;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [71, -2, -33, 75, 21, 19];\nmy $x4 = specialfilter($arg40);\nmy $v4 = 3;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [1];\nmy $x5 = specialfilter($arg50);\nmy $v5 = 0;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = [];\nmy $x6 = specialfilter($arg60);\nmy $v6 = 0;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "Schrijf een functie die een array van getallen als invoer neemt en het aantal elementen in de array teruggeeft die groter zijn dan 10 en waarvan zowel het eerste als het laatste cijfer van een getal oneven zijn (1, 3, 5, 7, 9). Bijvoorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/69", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Je krijgt een positief geheel getal n. Je moet een geheel getallen array a maken met een lengte van n.\n#         Voor elk i (1 ≤ i ≤ n), is de waarde van a[i] = i * i - i + 1.\n#         Geef het aantal triples (a[i], a[j], a[k]) van a terug waarbij i < j < k, \n#     en a[i] + a[j] + a[k] een veelvoud is van 3.\n# \n#     Voorbeeld:\n#         Input: n = 5\n#         Output: 1\n#         Uitleg: \n#         a = [1, 3, 7, 13, 21]\n#         De enige geldige triple is (1, 7, 13).\n# \n#\nsub get_max_triples\n{\n  my ($n) = @_;\n", "entry_point": "get_max_triples", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 5;\nmy $x0 = get_max_triples($arg00);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 6;\nmy $x1 = get_max_triples($arg10);\nmy $v1 = 4;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 10;\nmy $x2 = get_max_triples($arg20);\nmy $v2 = 36;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 100;\nmy $x3 = get_max_triples($arg30);\nmy $v3 = 53361;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\n", "description": "Je krijgt een positief geheel getal n. Je moet een geheel getallen array a maken met een lengte van n.\n        Voor elk i (1 ≤ i ≤ n), is de waarde van a[i] = i * i - i + 1.\n        Geef het aantal triples (a[i], a[j], a[k]) van a terug waarbij i < j < k, \n    en a[i] + a[j] + a[k] een veelvoud is van 3.\n\n    Voorbeeld:\n        Input: n = 5\n        Output: 1\n        Uitleg: \n        a = [1, 3, 7, 13, 21]\n        De enige geldige triple is (1, 7, 13).", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/70", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Er zijn acht planeten in ons zonnestelsel: de dichtstbijzijnde bij de zon is Mercurius, de volgende is Venus, dan Aarde, Mars, Jupiter, Saturnus, Uranus, Neptunus. Schrijf een functie die twee planeetnamen als strings planet1 en planet2 neemt. De functie moet een tuple retourneren met alle planeten waarvan de banen zich bevinden tussen de baan van planeet1 en de baan van planeet2, gesorteerd op nabijheid tot de zon. De functie moet een lege tuple retourneren als planet1 of planet2 geen correcte planeetnamen zijn. Voorbeelden\n# \n# bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n# bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n# bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n#\nsub bf\n{\n  my ($planet1, $planet2) = @_;\n", "entry_point": "bf", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"Jupiter\";\nmy $arg01 = \"Neptune\";\nmy $x0 = bf($arg00, $arg01);\nmy $v0 = [\"Saturn\", \"Uranus\"];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"Earth\";\nmy $arg11 = \"Mercury\";\nmy $x1 = bf($arg10, $arg11);\nmy $v1 = [\"Venus\"];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"Mercury\";\nmy $arg21 = \"Uranus\";\nmy $x2 = bf($arg20, $arg21);\nmy $v2 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"Neptune\";\nmy $arg31 = \"Venus\";\nmy $x3 = bf($arg30, $arg31);\nmy $v3 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"Earth\";\nmy $arg41 = \"Earth\";\nmy $x4 = bf($arg40, $arg41);\nmy $v4 = [];\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"Mars\";\nmy $arg51 = \"Earth\";\nmy $x5 = bf($arg50, $arg51);\nmy $v5 = [];\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"Jupiter\";\nmy $arg61 = \"Makemake\";\nmy $x6 = bf($arg60, $arg61);\nmy $v6 = [];\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "Er zijn acht planeten in ons zonnestelsel: de dichtstbijzijnde bij de zon is Mercurius, de volgende is Venus, dan Aarde, Mars, Jupiter, Saturnus, Uranus, Neptunus. Schrijf een functie die twee planeetnamen als strings planet1 en planet2 neemt. De functie moet een tuple retourneren met alle planeten waarvan de banen zich bevinden tussen de baan van planeet1 en de baan van planeet2, gesorteerd op nabijheid tot de zon. De functie moet een lege tuple retourneren als planet1 of planet2 geen correcte planeetnamen zijn. Voorbeelden", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/71", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Een eenvoudig programma dat de waarde van x moet retourneren als n een priemgetal is en anders de waarde van y moet retourneren.\n# \n# Voorbeelden:\n# \n# for x_or_y(7, 34, 12) == 34\n# for x_or_y(15, 8, 5) == 5\n# \n#\nsub x_or_y\n{\n  my ($n, $x, $y) = @_;\n", "entry_point": "x_or_y", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 7;\nmy $arg01 = 34;\nmy $arg02 = 12;\nmy $x0 = x_or_y($arg00, $arg01, $arg02);\nmy $v0 = 34;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 15;\nmy $arg11 = 8;\nmy $arg12 = 5;\nmy $x1 = x_or_y($arg10, $arg11, $arg12);\nmy $v1 = 5;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 3;\nmy $arg21 = 33;\nmy $arg22 = 5212;\nmy $x2 = x_or_y($arg20, $arg21, $arg22);\nmy $v2 = 33;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 1259;\nmy $arg31 = 3;\nmy $arg32 = 52;\nmy $x3 = x_or_y($arg30, $arg31, $arg32);\nmy $v3 = 3;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 7919;\nmy $arg41 = -1;\nmy $arg42 = 12;\nmy $x4 = x_or_y($arg40, $arg41, $arg42);\nmy $v4 = -1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 3609;\nmy $arg51 = 1245;\nmy $arg52 = 583;\nmy $x5 = x_or_y($arg50, $arg51, $arg52);\nmy $v5 = 583;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 91;\nmy $arg61 = 56;\nmy $arg62 = 129;\nmy $x6 = x_or_y($arg60, $arg61, $arg62);\nmy $v6 = 129;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = 6;\nmy $arg71 = 34;\nmy $arg72 = 1234;\nmy $x7 = x_or_y($arg70, $arg71, $arg72);\nmy $v7 = 1234;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = 1;\nmy $arg81 = 2;\nmy $arg82 = 0;\nmy $x8 = x_or_y($arg80, $arg81, $arg82);\nmy $v8 = 0;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = 2;\nmy $arg91 = 2;\nmy $arg92 = 0;\nmy $x9 = x_or_y($arg90, $arg91, $arg92);\nmy $v9 = 2;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\n", "description": "Een eenvoudig programma dat de waarde van x moet retourneren als n een priemgetal is en anders de waarde van y moet retourneren.\n\nVoorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/72", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Gegeven een lijst van getallen, retourneer de som van de kwadraten van de getallen in de lijst die oneven zijn. Negeer getallen die negatief zijn of geen gehele getallen zijn.\n# \n#     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n#     double_the_difference([-1, -2, 0]) == 0\n#     double_the_difference([9, -2]) == 81\n#     double_the_difference([0]) == 0\n# \n#     Als de invoerlijst leeg is, retourneer dan 0.\n# \n#\nsub double_the_difference\n{\n  my ($lst) = @_;\n", "entry_point": "double_the_difference", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = [];\nmy $x0 = double_the_difference($arg00);\nmy $v0 = 0;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = [5, 4];\nmy $x1 = double_the_difference($arg10);\nmy $v1 = 25;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = [0.1, 0.2, 0.3];\nmy $x2 = double_the_difference($arg20);\nmy $v2 = 0;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = [-10, -20, -30];\nmy $x3 = double_the_difference($arg30);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = [-1, -2, 8];\nmy $x4 = double_the_difference($arg40);\nmy $v4 = 0;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = [0.2, 3, 5];\nmy $x5 = double_the_difference($arg50);\nmy $v5 = 34;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = [-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99];\nmy $x6 = double_the_difference($arg60);\nmy $v6 = 166650;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\n", "description": "Gegeven een lijst van getallen, retourneer de som van de kwadraten van de getallen in de lijst die oneven zijn. Negeer getallen die negatief zijn of geen gehele getallen zijn.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    Als de invoerlijst leeg is, retourneer dan 0.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/73", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Je krijgt de naam van een klasse (een string) en een lijst met extensies.\n#     De extensies worden gebruikt om extra klassen aan de klasse te laden. De sterkte van de extensie is als volgt: Laat CAP het aantal hoofdletters in de naam van de extensie zijn en laat SM het aantal kleine letters zijn in de naam van de extensie, de sterkte wordt gegeven door de breuk CAP - SM. \n#     Je moet de sterkste extensie vinden en een string retourneren in dit formaat: ClassName.SterksteExtensieNaam.\n#     Als er twee of meer extensies zijn met dezelfde sterkte, moet je degene kiezen die als eerste in de lijst voorkomt.\n#     Bijvoorbeeld, als je \"Slices\" als klasse krijgt en een lijst met extensies: ['SErviNGSliCes', 'Cheese', 'StuFfed'], dan moet je 'Slices.SErviNGSliCes' retourneren omdat 'SErviNGSliCes' de sterkste extensie is (zijn sterkte is -1).\n#     Voorbeeld:\n# \n# for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n#\nsub strongest_extension\n{\n  my ($class_name, $extensions) = @_;\n", "entry_point": "strongest_extension", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"Watashi\";\nmy $arg01 = [\"tEN\", \"niNE\", \"eIGHt8OKe\"];\nmy $x0 = strongest_extension($arg00, $arg01);\nmy $v0 = \"Watashi.eIGHt8OKe\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"Boku123\";\nmy $arg11 = [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"];\nmy $x1 = strongest_extension($arg10, $arg11);\nmy $v1 = \"Boku123.YEs.WeCaNe\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"__YESIMHERE\";\nmy $arg21 = [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"];\nmy $x2 = strongest_extension($arg20, $arg21);\nmy $v2 = \"__YESIMHERE.NuLl__\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"K\";\nmy $arg31 = [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"];\nmy $x3 = strongest_extension($arg30, $arg31);\nmy $v3 = \"K.TAR\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"__HAHA\";\nmy $arg41 = [\"Tab\", \"123\", \"781345\", \"-_-\"];\nmy $x4 = strongest_extension($arg40, $arg41);\nmy $v4 = \"__HAHA.123\";\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"YameRore\";\nmy $arg51 = [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"];\nmy $x5 = strongest_extension($arg50, $arg51);\nmy $v5 = \"YameRore.okIWILL123\";\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"finNNalLLly\";\nmy $arg61 = [\"Die\", \"NowW\", \"Wow\", \"WoW\"];\nmy $x6 = strongest_extension($arg60, $arg61);\nmy $v6 = \"finNNalLLly.WoW\";\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = \"_\";\nmy $arg71 = [\"Bb\", \"91245\"];\nmy $x7 = strongest_extension($arg70, $arg71);\nmy $v7 = \"_.Bb\";\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = \"Sp\";\nmy $arg81 = [\"671235\", \"Bb\"];\nmy $x8 = strongest_extension($arg80, $arg81);\nmy $v8 = \"Sp.671235\";\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\n", "description": "Je krijgt de naam van een klasse (een string) en een lijst met extensies.\n    De extensies worden gebruikt om extra klassen aan de klasse te laden. De sterkte van de extensie is als volgt: Laat CAP het aantal hoofdletters in de naam van de extensie zijn en laat SM het aantal kleine letters zijn in de naam van de extensie, de sterkte wordt gegeven door de breuk CAP - SM. \n    Je moet de sterkste extensie vinden en een string retourneren in dit formaat: ClassName.SterksteExtensieNaam.\n    Als er twee of meer extensies zijn met dezelfde sterkte, moet je degene kiezen die als eerste in de lijst voorkomt.\n    Bijvoorbeeld, als je \"Slices\" als klasse krijgt en een lijst met extensies: ['SErviNGSliCes', 'Cheese', 'StuFfed'], dan moet je 'Slices.SErviNGSliCes' retourneren omdat 'SErviNGSliCes' de sterkste extensie is (zijn sterkte is -1).\n    Voorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/74", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Je krijgt 2 woorden. Je moet True teruggeven als het tweede woord of een van zijn rotaties een substring is in het eerste woord.\n# cycpattern_check(\"abcd\",\"abd\") => False\n# cycpattern_check(\"hello\",\"ell\") => True\n# cycpattern_check(\"whassup\",\"psus\") => False\n# cycpattern_check(\"abab\",\"baa\") => True\n# cycpattern_check(\"efef\",\"eeff\") => False\n# cycpattern_check(\"himenss\",\"simen\") => True\n\n#\nsub cycpattern_check\n{\n  my ($a, $b) = @_;\n", "entry_point": "cycpattern_check", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"xyzw\";\nmy $arg01 = \"xyw\";\nmy $x0 = cycpattern_check($arg00, $arg01);\nmy $v0 = 0;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"yello\";\nmy $arg11 = \"ell\";\nmy $x1 = cycpattern_check($arg10, $arg11);\nmy $v1 = 1;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"whattup\";\nmy $arg21 = \"ptut\";\nmy $x2 = cycpattern_check($arg20, $arg21);\nmy $v2 = 0;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"efef\";\nmy $arg31 = \"fee\";\nmy $x3 = cycpattern_check($arg30, $arg31);\nmy $v3 = 1;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"abab\";\nmy $arg41 = \"aabb\";\nmy $x4 = cycpattern_check($arg40, $arg41);\nmy $v4 = 0;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"winemtt\";\nmy $arg51 = \"tinem\";\nmy $x5 = cycpattern_check($arg50, $arg51);\nmy $v5 = 1;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\n", "description": "Je krijgt 2 woorden. Je moet True teruggeven als het tweede woord of een van zijn rotaties een substring is in het eerste woord.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/75", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Gegeven een positief geheel getal, verkrijg de Romeinse cijfer equivalent als een string en retourneer het in kleine letters.\n# Beperkingen: 1 <= num <= 1000\n# \n# Voorbeelden:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\n#\nsub int_to_mini_roman\n{\n  my ($number) = @_;\n", "entry_point": "int_to_mini_roman", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 19;\nmy $x0 = int_to_mini_roman($arg00);\nmy $v0 = \"xix\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 152;\nmy $x1 = int_to_mini_roman($arg10);\nmy $v1 = \"clii\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 251;\nmy $x2 = int_to_mini_roman($arg20);\nmy $v2 = \"ccli\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 426;\nmy $x3 = int_to_mini_roman($arg30);\nmy $v3 = \"cdxxvi\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 500;\nmy $x4 = int_to_mini_roman($arg40);\nmy $v4 = \"d\";\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 1;\nmy $x5 = int_to_mini_roman($arg50);\nmy $v5 = \"i\";\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 4;\nmy $x6 = int_to_mini_roman($arg60);\nmy $v6 = \"iv\";\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = 43;\nmy $x7 = int_to_mini_roman($arg70);\nmy $v7 = \"xliii\";\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = 90;\nmy $x8 = int_to_mini_roman($arg80);\nmy $v8 = \"xc\";\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = 94;\nmy $x9 = int_to_mini_roman($arg90);\nmy $v9 = \"xciv\";\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\nmy $arg100 = 532;\nmy $x10 = int_to_mini_roman($arg100);\nmy $v10 = \"dxxxii\";\nunless(Compare($x10, $v10)) {\n    die \"Exception -- test case 10 did not pass.\";\n}\nmy $arg110 = 900;\nmy $x11 = int_to_mini_roman($arg110);\nmy $v11 = \"cm\";\nunless(Compare($x11, $v11)) {\n    die \"Exception -- test case 11 did not pass.\";\n}\nmy $arg120 = 994;\nmy $x12 = int_to_mini_roman($arg120);\nmy $v12 = \"cmxciv\";\nunless(Compare($x12, $v12)) {\n    die \"Exception -- test case 12 did not pass.\";\n}\nmy $arg130 = 1000;\nmy $x13 = int_to_mini_roman($arg130);\nmy $v13 = \"m\";\nunless(Compare($x13, $v13)) {\n    die \"Exception -- test case 13 did not pass.\";\n}\n", "description": "Gegeven een positief geheel getal, verkrijg de Romeinse cijfer equivalent als een string en retourneer het in kleine letters.\nBeperkingen: 1 <= num <= 1000\n\nVoorbeelden:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/76", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Gegeven de lengtes van de drie zijden van een driehoek. Geef True terug als de drie zijden een rechthoekige driehoek vormen, anders False. Een rechthoekige driehoek is een driehoek waarin één hoek een rechte hoek of 90 graden is. Voorbeeld:\n# \n# right_angle_triangle(3, 4, 5) == True\n# right_angle_triangle(1, 2, 3) == False\n#\nsub right_angle_triangle\n{\n  my ($a, $b, $c) = @_;\n", "entry_point": "right_angle_triangle", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 3;\nmy $arg01 = 4;\nmy $arg02 = 5;\nmy $x0 = right_angle_triangle($arg00, $arg01, $arg02);\nmy $v0 = 1;\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 1;\nmy $arg11 = 2;\nmy $arg12 = 3;\nmy $x1 = right_angle_triangle($arg10, $arg11, $arg12);\nmy $v1 = 0;\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 10;\nmy $arg21 = 6;\nmy $arg22 = 8;\nmy $x2 = right_angle_triangle($arg20, $arg21, $arg22);\nmy $v2 = 1;\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 2;\nmy $arg31 = 2;\nmy $arg32 = 2;\nmy $x3 = right_angle_triangle($arg30, $arg31, $arg32);\nmy $v3 = 0;\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = 7;\nmy $arg41 = 24;\nmy $arg42 = 25;\nmy $x4 = right_angle_triangle($arg40, $arg41, $arg42);\nmy $v4 = 1;\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = 10;\nmy $arg51 = 5;\nmy $arg52 = 7;\nmy $x5 = right_angle_triangle($arg50, $arg51, $arg52);\nmy $v5 = 0;\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = 5;\nmy $arg61 = 12;\nmy $arg62 = 13;\nmy $x6 = right_angle_triangle($arg60, $arg61, $arg62);\nmy $v6 = 1;\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = 15;\nmy $arg71 = 8;\nmy $arg72 = 17;\nmy $x7 = right_angle_triangle($arg70, $arg71, $arg72);\nmy $v7 = 1;\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\nmy $arg80 = 48;\nmy $arg81 = 55;\nmy $arg82 = 73;\nmy $x8 = right_angle_triangle($arg80, $arg81, $arg82);\nmy $v8 = 1;\nunless(Compare($x8, $v8)) {\n    die \"Exception -- test case 8 did not pass.\";\n}\nmy $arg90 = 1;\nmy $arg91 = 1;\nmy $arg92 = 1;\nmy $x9 = right_angle_triangle($arg90, $arg91, $arg92);\nmy $v9 = 0;\nunless(Compare($x9, $v9)) {\n    die \"Exception -- test case 9 did not pass.\";\n}\nmy $arg100 = 2;\nmy $arg101 = 2;\nmy $arg102 = 10;\nmy $x10 = right_angle_triangle($arg100, $arg101, $arg102);\nmy $v10 = 0;\nunless(Compare($x10, $v10)) {\n    die \"Exception -- test case 10 did not pass.\";\n}\n", "description": "Gegeven de lengtes van de drie zijden van een driehoek. Geef True terug als de drie zijden een rechthoekige driehoek vormen, anders False. Een rechthoekige driehoek is een driehoek waarin één hoek een rechte hoek of 90 graden is. Voorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/77", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# Je krijgt een string s.\n#     Als s[i] een letter is, keer dan de hoofdletter om naar kleine letter of andersom,\n#     anders laat het zoals het is.\n#     Als de string geen letters bevat, keer dan de string om.\n#     De functie moet de resulterende string retourneren.\n#     Voorbeelden\n# \n# solve(\"1234\") = \"4321\"\n# solve(\"ab\") = \"AB\"\n# solve(\"#a@C\") = \"#A@c\"\n#\nsub solve\n{\n  my ($s) = @_;\n", "entry_point": "solve", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"AsDf\";\nmy $x0 = solve($arg00);\nmy $v0 = \"aSdF\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"1234\";\nmy $x1 = solve($arg10);\nmy $v1 = \"4321\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"ab\";\nmy $x2 = solve($arg20);\nmy $v2 = \"AB\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"#a@C\";\nmy $x3 = solve($arg30);\nmy $v3 = \"#A@c\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\nmy $arg40 = \"#AsdfW^45\";\nmy $x4 = solve($arg40);\nmy $v4 = \"#aSDFw^45\";\nunless(Compare($x4, $v4)) {\n    die \"Exception -- test case 4 did not pass.\";\n}\nmy $arg50 = \"#6@2\";\nmy $x5 = solve($arg50);\nmy $v5 = \"2@6#\";\nunless(Compare($x5, $v5)) {\n    die \"Exception -- test case 5 did not pass.\";\n}\nmy $arg60 = \"#\\$a^D\";\nmy $x6 = solve($arg60);\nmy $v6 = \"#\\$A^d\";\nunless(Compare($x6, $v6)) {\n    die \"Exception -- test case 6 did not pass.\";\n}\nmy $arg70 = \"#ccc\";\nmy $x7 = solve($arg70);\nmy $v7 = \"#CCC\";\nunless(Compare($x7, $v7)) {\n    die \"Exception -- test case 7 did not pass.\";\n}\n", "description": "Je krijgt een string s.\n    Als s[i] een letter is, keer dan de hoofdletter om naar kleine letter of andersom,\n    anders laat het zoals het is.\n    Als de string geen letters bevat, keer dan de string om.\n    De functie moet de resulterende string retourneren.\n    Voorbeelden", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/78", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Gegeven een string 'text', retourneer de md5 hash equivalent string.\n# Als 'text' een lege string is, retourneer dan null.\n# >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n#\nsub string_to_md5\n{\n  my ($text) = @_;\n", "entry_point": "string_to_md5", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = \"Hello world\";\nmy $x0 = string_to_md5($arg00);\nmy $v0 = \"3e25960a79dbc69b674cd4ec67a72c62\";\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = \"\";\nmy $x1 = string_to_md5($arg10);\nmy $v1 = \"none\";\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = \"A B C\";\nmy $x2 = string_to_md5($arg20);\nmy $v2 = \"0ef78513b0cb8cef12743f5aeb35f888\";\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = \"password\";\nmy $x3 = string_to_md5($arg30);\nmy $v3 = \"5f4dcc3b5aa765d61d8327deb882cf99\";\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\n", "description": "Gegeven een string 'text', retourneer de md5 hash equivalent string.\nAls 'text' een lege string is, retourneer dan null.", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
{"task_id": "perl/79", "prompt": "\n# Je bent een ervaren Perl-programmeur en hier is je taak.\n# # Gegeven twee positieve gehele getallen a en b, retourneer de even cijfers tussen a en b, in oplopende volgorde.\n# \n# Bijvoorbeeld:\n# \n# generate_integers(2, 8) => [2, 4, 6, 8]\n# generate_integers(8, 2) => [2, 4, 6, 8]\n# generate_integers(10, 14) => []\n#\nsub generate_integers\n{\n  my ($a, $b) = @_;\n", "entry_point": "generate_integers", "test": "\n\nuse Data::Compare;\n\nmy $arg00 = 2;\nmy $arg01 = 10;\nmy $x0 = generate_integers($arg00, $arg01);\nmy $v0 = [2, 4, 6, 8];\nunless(Compare($x0, $v0)) {\n    die \"Exception -- test case 0 did not pass.\";\n}\nmy $arg10 = 10;\nmy $arg11 = 2;\nmy $x1 = generate_integers($arg10, $arg11);\nmy $v1 = [2, 4, 6, 8];\nunless(Compare($x1, $v1)) {\n    die \"Exception -- test case 1 did not pass.\";\n}\nmy $arg20 = 132;\nmy $arg21 = 2;\nmy $x2 = generate_integers($arg20, $arg21);\nmy $v2 = [2, 4, 6, 8];\nunless(Compare($x2, $v2)) {\n    die \"Exception -- test case 2 did not pass.\";\n}\nmy $arg30 = 17;\nmy $arg31 = 89;\nmy $x3 = generate_integers($arg30, $arg31);\nmy $v3 = [];\nunless(Compare($x3, $v3)) {\n    die \"Exception -- test case 3 did not pass.\";\n}\n", "description": "Gegeven twee positieve gehele getallen a en b, retourneer de even cijfers tussen a en b, in oplopende volgorde.\n\nBijvoorbeeld:", "language": "perl", "canonical_solution": NaN, "natural_language": "Dutch"}
