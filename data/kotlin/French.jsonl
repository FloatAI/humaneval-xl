{"task_id": "kotlin/0", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Vous disposez d'une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde de zéro. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit renvoyer True. Sinon, elle doit renvoyer False.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n *\n */\nfun belowZero(operations : List<Any>) : Boolean {\n", "entry_point": "belowZero", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf()\n    var x0 : Boolean = belowZero(arg00);\n    var v0 : Boolean = false;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(1, 2, -3, 1, 2, -3)\n    var x1 : Boolean = belowZero(arg10);\n    var v1 : Boolean = false;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf(1, 2, -4, 5, 6)\n    var x2 : Boolean = belowZero(arg20);\n    var v2 : Boolean = true;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Any> = mutableListOf(1, -1, 2, -2, 5, -5, 4, -4)\n    var x3 : Boolean = belowZero(arg30);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Any> = mutableListOf(1, -1, 2, -2, 5, -5, 4, -5)\n    var x4 : Boolean = belowZero(arg40);\n    var v4 : Boolean = true;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Any> = mutableListOf(1, -2, 2, -2, 5, -5, 4, -4)\n    var x5 : Boolean = belowZero(arg50);\n    var v5 : Boolean = true;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n\n}\n", "description": "Vous disposez d'une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde de zéro. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit renvoyer True. Sinon, elle doit renvoyer False.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/1", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Pour une liste donnée d'entiers, retourner un tuple composé d'une somme et d'un produit de tous les entiers de la liste. La somme vide doit être égale à 0 et le produit vide doit être égal à 1.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n *\n */\nfun sumProduct(numbers : List<Any>) : List<Int> {\n", "entry_point": "sumProduct", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf()\n    var x0 : List<Int> = sumProduct(arg00);\n    var v0 : List<Int> = mutableListOf(0, 1);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(1, 1, 1)\n    var x1 : List<Int> = sumProduct(arg10);\n    var v1 : List<Int> = mutableListOf(3, 1);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf(100, 0)\n    var x2 : List<Int> = sumProduct(arg20);\n    var v2 : List<Int> = mutableListOf(100, 0);\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Any> = mutableListOf(3, 5, 7)\n    var x3 : List<Int> = sumProduct(arg30);\n    var v3 : List<Int> = mutableListOf(15, 105);\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Any> = mutableListOf(10)\n    var x4 : List<Int> = sumProduct(arg40);\n    var v4 : List<Int> = mutableListOf(10, 10);\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "Pour une liste donnée d'entiers, retourner un tuple composé d'une somme et d'un produit de tous les entiers de la liste. La somme vide doit être égale à 0 et le produit vide doit être égal à 1.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/2", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Les entrées sont deux chaînes de caractères a et b composées uniquement de 1 et de 0.\n * Effectuez une opération XOR binaire sur ces entrées et renvoyez le résultat également sous forme de chaîne de caractères.\n * >>> string_xor('010', '110')\n * '100'\n *\n */\nfun stringXor(a : String, b : String) : String {\n", "entry_point": "stringXor", "test": "\nfun main() {\n    var arg00 : String = \"\"\"111000\"\"\"\n    var arg01 : String = \"\"\"101010\"\"\"\n    var x0 : String = stringXor(arg00, arg01);\n    var v0 : String = \"\"\"010010\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"1\"\"\"\n    var arg11 : String = \"\"\"1\"\"\"\n    var x1 : String = stringXor(arg10, arg11);\n    var v1 : String = \"\"\"0\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"0101\"\"\"\n    var arg21 : String = \"\"\"0000\"\"\"\n    var x2 : String = stringXor(arg20, arg21);\n    var v2 : String = \"\"\"0101\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n\n}\n", "description": "Les entrées sont deux chaînes de caractères a et b composées uniquement de 1 et de 0.\nEffectuez une opération XOR binaire sur ces entrées et renvoyez le résultat également sous forme de chaîne de caractères.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/3", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * À partir d'une liste de chaînes de caractères, renvoyer la plus longue. Renvoyer la première en cas de plusieurs chaînes de même longueur. Renvoyer null si la liste d'entrée est vide.\n * >>> longest([])\n\n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n *\n */\nfun longest(strings : List<Any>) : String? {\n", "entry_point": "longest", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf()\n    var x0 : String? = longest(arg00);\n    var v0 : String? = null;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(\"\"\"x\"\"\", \"\"\"y\"\"\", \"\"\"z\"\"\")\n    var x1 : String? = longest(arg10);\n    var v1 : String? = \"\"\"x\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf(\"\"\"x\"\"\", \"\"\"yyy\"\"\", \"\"\"zzzz\"\"\", \"\"\"www\"\"\", \"\"\"kkkk\"\"\", \"\"\"abc\"\"\")\n    var x2 : String? = longest(arg20);\n    var v2 : String? = \"\"\"zzzz\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n\n}\n", "description": "À partir d'une liste de chaînes de caractères, renvoyer la plus longue. Renvoyer la première en cas de plusieurs chaînes de même longueur. Renvoyer null si la liste d'entrée est vide.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/4", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Retourne le plus grand commun diviseur de deux entiers a et b.\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n *\n */\nfun greatestCommonDivisor(a : Int, b : Int) : Int {\n", "entry_point": "greatestCommonDivisor", "test": "\nfun main() {\n    var arg00 : Int = 3\n    var arg01 : Int = 7\n    var x0 : Int = greatestCommonDivisor(arg00, arg01);\n    var v0 : Int = 1;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 10\n    var arg11 : Int = 15\n    var x1 : Int = greatestCommonDivisor(arg10, arg11);\n    var v1 : Int = 5;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 49\n    var arg21 : Int = 14\n    var x2 : Int = greatestCommonDivisor(arg20, arg21);\n    var v2 : Int = 7;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 144\n    var arg31 : Int = 60\n    var x3 : Int = greatestCommonDivisor(arg30, arg31);\n    var v3 : Int = 12;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n\n}\n", "description": "Retourne le plus grand commun diviseur de deux entiers a et b.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/5", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * L'entrée est une chaîne de caractères séparée par des espaces contenant des chiffres de 'zéro' à 'neuf'.\n *     Les choix valides sont 'zéro', 'un', 'deux', 'trois', 'quatre', 'cinq', 'six', 'sept', 'huit' et 'neuf'.\n *     Renvoyer la chaîne avec les chiffres triés par ordre croissant.\n * >>> sort_numbers('three one five')\n * 'one three five'\n *\n */\nfun sortNumbers(numbers : String) : String {\n", "entry_point": "sortNumbers", "test": "\nfun main() {\n    var arg00 : String = \"\"\"\"\"\"\n    var x0 : String = sortNumbers(arg00);\n    var v0 : String = \"\"\"\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"three\"\"\"\n    var x1 : String = sortNumbers(arg10);\n    var v1 : String = \"\"\"three\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"three five nine\"\"\"\n    var x2 : String = sortNumbers(arg20);\n    var v2 : String = \"\"\"three five nine\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"five zero four seven nine eight\"\"\"\n    var x3 : String = sortNumbers(arg30);\n    var v3 : String = \"\"\"zero four five seven eight nine\"\"\";\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"six five four three two one zero\"\"\"\n    var x4 : String = sortNumbers(arg40);\n    var v4 : String = \"\"\"zero one two three four five six\"\"\";\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "L'entrée est une chaîne de caractères séparée par des espaces contenant des chiffres de 'zéro' à 'neuf'.\n    Les choix valides sont 'zéro', 'un', 'deux', 'trois', 'quatre', 'cinq', 'six', 'sept', 'huit' et 'neuf'.\n    Renvoyer la chaîne avec les chiffres triés par ordre croissant.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/6", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Étant donné une liste de nombres (d'au moins deux éléments), appliquez une transformation linéaire à cette liste, de sorte que le plus petit nombre devienne 0 et le plus grand devienne 1.\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n *\n */\nfun rescaleToUnit(numbers : List<Double>) : List<Double> {\n", "entry_point": "rescaleToUnit", "test": "\nfun main() {\n    var arg00 : List<Double> = mutableListOf(2.0, 49.9)\n    var x0 : List<Double> = rescaleToUnit(arg00);\n    var v0 : List<Double> = mutableListOf(0.0, 1.0);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Double> = mutableListOf(100.0, 49.9)\n    var x1 : List<Double> = rescaleToUnit(arg10);\n    var v1 : List<Double> = mutableListOf(1.0, 0.0);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Double> = mutableListOf(1.0, 2.0, 3.0, 4.0, 5.0)\n    var x2 : List<Double> = rescaleToUnit(arg20);\n    var v2 : List<Double> = mutableListOf(0.0, 0.25, 0.5, 0.75, 1.0);\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Double> = mutableListOf(2.0, 1.0, 5.0, 3.0, 4.0)\n    var x3 : List<Double> = rescaleToUnit(arg30);\n    var v3 : List<Double> = mutableListOf(0.25, 0.0, 1.0, 0.5, 0.75);\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Double> = mutableListOf(12.0, 11.0, 15.0, 13.0, 14.0)\n    var x4 : List<Double> = rescaleToUnit(arg40);\n    var v4 : List<Double> = mutableListOf(0.25, 0.0, 1.0, 0.5, 0.75);\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "Étant donné une liste de nombres (d'au moins deux éléments), appliquez une transformation linéaire à cette liste, de sorte que le plus petit nombre devienne 0 et le plus grand devienne 1.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/7", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Pour une chaîne de caractères donnée, inverser les caractères en minuscules en majuscules et les caractères en majuscules en minuscules.\n * >>> flip_case('Hello')\n * 'hELLO'\n *\n */\nfun flipCase(string : String) : String {\n", "entry_point": "flipCase", "test": "\nfun main() {\n    var arg00 : String = \"\"\"\"\"\"\n    var x0 : String = flipCase(arg00);\n    var v0 : String = \"\"\"\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"Hello!\"\"\"\n    var x1 : String = flipCase(arg10);\n    var v1 : String = \"\"\"hELLO!\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"These violent delights have violent ends\"\"\"\n    var x2 : String = flipCase(arg20);\n    var v2 : String = \"\"\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n\n}\n", "description": "Pour une chaîne de caractères donnée, inverser les caractères en minuscules en majuscules et les caractères en majuscules en minuscules.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/8", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Retourner seulement les nombres positifs dans la liste.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n *\n */\nfun getPositive(l : List<Any>) : List<Any> {\n", "entry_point": "getPositive", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf(-1, -2, 4, 5, 6)\n    var x0 : List<Any> = getPositive(arg00);\n    var v0 : List<Any> = mutableListOf(4, 5, 6);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10)\n    var x1 : List<Any> = getPositive(arg10);\n    var v1 : List<Any> = mutableListOf(5, 3, 2, 3, 3, 9, 123, 1);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf(-1, -2)\n    var x2 : List<Any> = getPositive(arg20);\n    var v2 : List<Any> = mutableListOf();\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Any> = mutableListOf()\n    var x3 : List<Any> = getPositive(arg30);\n    var v3 : List<Any> = mutableListOf();\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n\n}\n", "description": "Retourner seulement les nombres positifs dans la liste.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/9", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Retourne vrai si un nombre donné est premier, et faux sinon.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n *\n */\nfun isPrime(n : Int) : Boolean {\n", "entry_point": "isPrime", "test": "\nfun main() {\n    var arg00 : Int = 6\n    var x0 : Boolean = isPrime(arg00);\n    var v0 : Boolean = false;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 101\n    var x1 : Boolean = isPrime(arg10);\n    var v1 : Boolean = true;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 11\n    var x2 : Boolean = isPrime(arg20);\n    var v2 : Boolean = true;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 13441\n    var x3 : Boolean = isPrime(arg30);\n    var v3 : Boolean = true;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 61\n    var x4 : Boolean = isPrime(arg40);\n    var v4 : Boolean = true;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 4\n    var x5 : Boolean = isPrime(arg50);\n    var v5 : Boolean = false;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 1\n    var x6 : Boolean = isPrime(arg60);\n    var v6 : Boolean = false;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : Int = 5\n    var x7 : Boolean = isPrime(arg70);\n    var v7 : Boolean = true;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : Int = 11\n    var x8 : Boolean = isPrime(arg80);\n    var v8 : Boolean = true;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : Int = 17\n    var x9 : Boolean = isPrime(arg90);\n    var v9 : Boolean = true;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n    var arg100 : Int = 85\n    var x10 : Boolean = isPrime(arg100);\n    var v10 : Boolean = false;\n    if (x10 != v10) {\n        throw Exception(\"Exception -- test case 10 did not pass. x10 = \" + x10)\n    }\n\n    var arg110 : Int = 77\n    var x11 : Boolean = isPrime(arg110);\n    var v11 : Boolean = false;\n    if (x11 != v11) {\n        throw Exception(\"Exception -- test case 11 did not pass. x11 = \" + x11)\n    }\n\n    var arg120 : Int = 255379\n    var x12 : Boolean = isPrime(arg120);\n    var v12 : Boolean = false;\n    if (x12 != v12) {\n        throw Exception(\"Exception -- test case 12 did not pass. x12 = \" + x12)\n    }\n\n\n}\n", "description": "Retourne vrai si un nombre donné est premier, et faux sinon.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/10", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Retourner les éléments uniques triés dans une liste.\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n *\n */\nfun unique(l : List<Int>) : List<Int> {\n", "entry_point": "unique", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(5, 3, 5, 2, 3, 3, 9, 0, 123)\n    var x0 : List<Int> = unique(arg00);\n    var v0 : List<Int> = mutableListOf(0, 2, 3, 5, 9, 123);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n\n}\n", "description": "Retourner les éléments uniques triés dans une liste.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/11", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * prime_fib renvoie le n-ième nombre qui est à la fois un nombre de Fibonacci et un nombre premier.\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n *\n */\nfun primeFib(n : Int) : Int {\n", "entry_point": "primeFib", "test": "\nfun main() {\n    var arg00 : Int = 1\n    var x0 : Int = primeFib(arg00);\n    var v0 : Int = 2;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 2\n    var x1 : Int = primeFib(arg10);\n    var v1 : Int = 3;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 3\n    var x2 : Int = primeFib(arg20);\n    var v2 : Int = 5;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 4\n    var x3 : Int = primeFib(arg30);\n    var v3 : Int = 13;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 5\n    var x4 : Int = primeFib(arg40);\n    var v4 : Int = 89;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 6\n    var x5 : Int = primeFib(arg50);\n    var v5 : Int = 233;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 7\n    var x6 : Int = primeFib(arg60);\n    var v6 : Int = 1597;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : Int = 8\n    var x7 : Int = primeFib(arg70);\n    var v7 : Int = 28657;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : Int = 9\n    var x8 : Int = primeFib(arg80);\n    var v8 : Int = 514229;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : Int = 10\n    var x9 : Int = primeFib(arg90);\n    var v9 : Int = 433494437;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n\n}\n", "description": "prime_fib renvoie le n-ième nombre qui est à la fois un nombre de Fibonacci et un nombre premier.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/12", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * triples_sum_to_zero prend une liste d'entiers en entrée.\n *     Elle renvoie True s'il y a trois éléments distincts dans la liste qui\n *     s'additionnent à zéro, et False sinon.\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n *\n */\nfun triplesSumToZero(l : List<Int>) : Boolean {\n", "entry_point": "triplesSumToZero", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(1, 3, 5, 0)\n    var x0 : Boolean = triplesSumToZero(arg00);\n    var v0 : Boolean = false;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(1, 3, 5, -1)\n    var x1 : Boolean = triplesSumToZero(arg10);\n    var v1 : Boolean = false;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(1, 3, -2, 1)\n    var x2 : Boolean = triplesSumToZero(arg20);\n    var v2 : Boolean = true;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(1, 2, 3, 7)\n    var x3 : Boolean = triplesSumToZero(arg30);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Int> = mutableListOf(1, 2, 5, 7)\n    var x4 : Boolean = triplesSumToZero(arg40);\n    var v4 : Boolean = false;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Int> = mutableListOf(2, 4, -5, 3, 9, 7)\n    var x5 : Boolean = triplesSumToZero(arg50);\n    var v5 : Boolean = true;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : List<Int> = mutableListOf(1)\n    var x6 : Boolean = triplesSumToZero(arg60);\n    var v6 : Boolean = false;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : List<Int> = mutableListOf(1, 3, 5, -100)\n    var x7 : Boolean = triplesSumToZero(arg70);\n    var v7 : Boolean = false;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : List<Int> = mutableListOf(100, 3, 5, -100)\n    var x8 : Boolean = triplesSumToZero(arg80);\n    var v8 : Boolean = false;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n\n}\n", "description": "triples_sum_to_zero prend une liste d'entiers en entrée.\n    Elle renvoie True s'il y a trois éléments distincts dans la liste qui\n    s'additionnent à zéro, et False sinon.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/13", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * pairs_sum_to_zero prend une liste d'entiers en entrée.\n *     Elle renvoie True s'il y a deux éléments distincts dans la liste qui\n *     s'additionnent à zéro, et False sinon.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n *\n */\nfun pairsSumToZero(l : List<Int>) : Boolean {\n", "entry_point": "pairsSumToZero", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(1, 3, 5, 0)\n    var x0 : Boolean = pairsSumToZero(arg00);\n    var v0 : Boolean = false;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(1, 3, -2, 1)\n    var x1 : Boolean = pairsSumToZero(arg10);\n    var v1 : Boolean = false;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(1, 2, 3, 7)\n    var x2 : Boolean = pairsSumToZero(arg20);\n    var v2 : Boolean = false;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(2, 4, -5, 3, 5, 7)\n    var x3 : Boolean = pairsSumToZero(arg30);\n    var v3 : Boolean = true;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Int> = mutableListOf(1)\n    var x4 : Boolean = pairsSumToZero(arg40);\n    var v4 : Boolean = false;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Int> = mutableListOf(-3, 9, -1, 3, 2, 30)\n    var x5 : Boolean = pairsSumToZero(arg50);\n    var v5 : Boolean = true;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : List<Int> = mutableListOf(-3, 9, -1, 3, 2, 31)\n    var x6 : Boolean = pairsSumToZero(arg60);\n    var v6 : Boolean = true;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : List<Int> = mutableListOf(-3, 9, -1, 4, 2, 30)\n    var x7 : Boolean = pairsSumToZero(arg70);\n    var v7 : Boolean = false;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : List<Int> = mutableListOf(-3, 9, -1, 4, 2, 31)\n    var x8 : Boolean = pairsSumToZero(arg80);\n    var v8 : Boolean = false;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n\n}\n", "description": "pairs_sum_to_zero prend une liste d'entiers en entrée.\n    Elle renvoie True s'il y a deux éléments distincts dans la liste qui\n    s'additionnent à zéro, et False sinon.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/14", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * La séquence de nombres Fib4 est une séquence similaire à la séquence de Fibonacci définie comme suit:\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n *     Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres Fib4. N'utilisez pas la récursivité.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n *\n */\nfun fib4(n : Int) : Int {\n", "entry_point": "fib4", "test": "\nfun main() {\n    var arg00 : Int = 5\n    var x0 : Int = fib4(arg00);\n    var v0 : Int = 4;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 8\n    var x1 : Int = fib4(arg10);\n    var v1 : Int = 28;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 10\n    var x2 : Int = fib4(arg20);\n    var v2 : Int = 104;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 12\n    var x3 : Int = fib4(arg30);\n    var v3 : Int = 386;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n\n}\n", "description": "La séquence de nombres Fib4 est une séquence similaire à la séquence de Fibonacci définie comme suit:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres Fib4. N'utilisez pas la récursivité.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/15", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Retourne la médiane des éléments de la liste l.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n *\n */\nfun median(l : List<Int>) : Any {\n", "entry_point": "median", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(3, 1, 2, 4, 5)\n    var x0 : Any = median(arg00);\n    var v0 : Any = 3;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(-10, 4, 6, 1000, 10, 20)\n    var x1 : Any = median(arg10);\n    var v1 : Any = 8.0;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(5)\n    var x2 : Any = median(arg20);\n    var v2 : Any = 5;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(6, 5)\n    var x3 : Any = median(arg30);\n    var v3 : Any = 5.5;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Int> = mutableListOf(8, 1, 3, 9, 9, 2, 7)\n    var x4 : Any = median(arg40);\n    var v4 : Any = 7;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "Retourne la médiane des éléments de la liste l.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/16", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Vérifie si la chaîne de caractères donnée est un palindrome.\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n *\n */\nfun isPalindrome(text : String) : Boolean {\n", "entry_point": "isPalindrome", "test": "\nfun main() {\n    var arg00 : String = \"\"\"\"\"\"\n    var x0 : Boolean = isPalindrome(arg00);\n    var v0 : Boolean = true;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"aba\"\"\"\n    var x1 : Boolean = isPalindrome(arg10);\n    var v1 : Boolean = true;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"aaaaa\"\"\"\n    var x2 : Boolean = isPalindrome(arg20);\n    var v2 : Boolean = true;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"zbcd\"\"\"\n    var x3 : Boolean = isPalindrome(arg30);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"xywyx\"\"\"\n    var x4 : Boolean = isPalindrome(arg40);\n    var v4 : Boolean = true;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"xywyz\"\"\"\n    var x5 : Boolean = isPalindrome(arg50);\n    var v5 : Boolean = false;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"xywzx\"\"\"\n    var x6 : Boolean = isPalindrome(arg60);\n    var v6 : Boolean = false;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "Vérifie si la chaîne de caractères donnée est un palindrome.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/17", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * remove_vowels est une fonction qui prend une chaîne de caractères et renvoie une chaîne de caractères sans voyelles.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n *\n */\nfun removeVowels(text : String) : String {\n", "entry_point": "removeVowels", "test": "\nfun main() {\n    var arg00 : String = \"\"\"\"\"\"\n    var x0 : String = removeVowels(arg00);\n    var v0 : String = \"\"\"\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"abcdef\\nghijklm\"\"\"\n    var x1 : String = removeVowels(arg10);\n    var v1 : String = \"\"\"bcdf\\nghjklm\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"fedcba\"\"\"\n    var x2 : String = removeVowels(arg20);\n    var v2 : String = \"\"\"fdcb\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"eeeee\"\"\"\n    var x3 : String = removeVowels(arg30);\n    var v3 : String = \"\"\"\"\"\";\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"acBAA\"\"\"\n    var x4 : String = removeVowels(arg40);\n    var v4 : String = \"\"\"cB\"\"\";\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"EcBOO\"\"\"\n    var x5 : String = removeVowels(arg50);\n    var v5 : String = \"\"\"cB\"\"\";\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"ybcd\"\"\"\n    var x6 : String = removeVowels(arg60);\n    var v6 : String = \"\"\"ybcd\"\"\";\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "remove_vowels est une fonction qui prend une chaîne de caractères et renvoie une chaîne de caractères sans voyelles.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/18", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Retourne True si tous les nombres de la liste l sont en dessous du seuil t.\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n *\n */\nfun belowThreshold(l : List<Int>, t : Int) : Boolean {\n", "entry_point": "belowThreshold", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(1, 2, 4, 10)\n    var arg01 : Int = 100\n    var x0 : Boolean = belowThreshold(arg00, arg01);\n    var v0 : Boolean = true;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(1, 20, 4, 10)\n    var arg11 : Int = 5\n    var x1 : Boolean = belowThreshold(arg10, arg11);\n    var v1 : Boolean = false;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(1, 20, 4, 10)\n    var arg21 : Int = 21\n    var x2 : Boolean = belowThreshold(arg20, arg21);\n    var v2 : Boolean = true;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(1, 20, 4, 10)\n    var arg31 : Int = 22\n    var x3 : Boolean = belowThreshold(arg30, arg31);\n    var v3 : Boolean = true;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Int> = mutableListOf(1, 8, 4, 10)\n    var arg41 : Int = 11\n    var x4 : Boolean = belowThreshold(arg40, arg41);\n    var v4 : Boolean = true;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Int> = mutableListOf(1, 8, 4, 10)\n    var arg51 : Int = 10\n    var x5 : Boolean = belowThreshold(arg50, arg51);\n    var v5 : Boolean = false;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n\n}\n", "description": "Retourne True si tous les nombres de la liste l sont en dessous du seuil t.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/19", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Ajouter deux nombres x et y\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n *\n */\nfun add(x : Int, y : Int) : Int {\n", "entry_point": "add", "test": "\nfun main() {\n    var arg00 : Int = 0\n    var arg01 : Int = 1\n    var x0 : Int = add(arg00, arg01);\n    var v0 : Int = 1;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 1\n    var arg11 : Int = 0\n    var x1 : Int = add(arg10, arg11);\n    var v1 : Int = 1;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 2\n    var arg21 : Int = 3\n    var x2 : Int = add(arg20, arg21);\n    var v2 : Int = 5;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 5\n    var arg31 : Int = 7\n    var x3 : Int = add(arg30, arg31);\n    var v3 : Int = 12;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 7\n    var arg41 : Int = 5\n    var x4 : Int = add(arg40, arg41);\n    var v4 : Int = 12;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 572\n    var arg51 : Int = 725\n    var x5 : Int = add(arg50, arg51);\n    var v5 : Int = 1297;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 51\n    var arg61 : Int = 804\n    var x6 : Int = add(arg60, arg61);\n    var v6 : Int = 855;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : Int = 645\n    var arg71 : Int = 96\n    var x7 : Int = add(arg70, arg71);\n    var v7 : Int = 741;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : Int = 712\n    var arg81 : Int = 853\n    var x8 : Int = add(arg80, arg81);\n    var v8 : Int = 1565;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : Int = 223\n    var arg91 : Int = 101\n    var x9 : Int = add(arg90, arg91);\n    var v9 : Int = 324;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n    var arg100 : Int = 76\n    var arg101 : Int = 29\n    var x10 : Int = add(arg100, arg101);\n    var v10 : Int = 105;\n    if (x10 != v10) {\n        throw Exception(\"Exception -- test case 10 did not pass. x10 = \" + x10)\n    }\n\n    var arg110 : Int = 416\n    var arg111 : Int = 149\n    var x11 : Int = add(arg110, arg111);\n    var v11 : Int = 565;\n    if (x11 != v11) {\n        throw Exception(\"Exception -- test case 11 did not pass. x11 = \" + x11)\n    }\n\n    var arg120 : Int = 145\n    var arg121 : Int = 409\n    var x12 : Int = add(arg120, arg121);\n    var v12 : Int = 554;\n    if (x12 != v12) {\n        throw Exception(\"Exception -- test case 12 did not pass. x12 = \" + x12)\n    }\n\n    var arg130 : Int = 535\n    var arg131 : Int = 430\n    var x13 : Int = add(arg130, arg131);\n    var v13 : Int = 965;\n    if (x13 != v13) {\n        throw Exception(\"Exception -- test case 13 did not pass. x13 = \" + x13)\n    }\n\n    var arg140 : Int = 118\n    var arg141 : Int = 303\n    var x14 : Int = add(arg140, arg141);\n    var v14 : Int = 421;\n    if (x14 != v14) {\n        throw Exception(\"Exception -- test case 14 did not pass. x14 = \" + x14)\n    }\n\n    var arg150 : Int = 287\n    var arg151 : Int = 94\n    var x15 : Int = add(arg150, arg151);\n    var v15 : Int = 381;\n    if (x15 != v15) {\n        throw Exception(\"Exception -- test case 15 did not pass. x15 = \" + x15)\n    }\n\n    var arg160 : Int = 768\n    var arg161 : Int = 257\n    var x16 : Int = add(arg160, arg161);\n    var v16 : Int = 1025;\n    if (x16 != v16) {\n        throw Exception(\"Exception -- test case 16 did not pass. x16 = \" + x16)\n    }\n\n    var arg170 : Int = 421\n    var arg171 : Int = 677\n    var x17 : Int = add(arg170, arg171);\n    var v17 : Int = 1098;\n    if (x17 != v17) {\n        throw Exception(\"Exception -- test case 17 did not pass. x17 = \" + x17)\n    }\n\n    var arg180 : Int = 802\n    var arg181 : Int = 814\n    var x18 : Int = add(arg180, arg181);\n    var v18 : Int = 1616;\n    if (x18 != v18) {\n        throw Exception(\"Exception -- test case 18 did not pass. x18 = \" + x18)\n    }\n\n    var arg190 : Int = 510\n    var arg191 : Int = 922\n    var x19 : Int = add(arg190, arg191);\n    var v19 : Int = 1432;\n    if (x19 != v19) {\n        throw Exception(\"Exception -- test case 19 did not pass. x19 = \" + x19)\n    }\n\n    var arg200 : Int = 345\n    var arg201 : Int = 819\n    var x20 : Int = add(arg200, arg201);\n    var v20 : Int = 1164;\n    if (x20 != v20) {\n        throw Exception(\"Exception -- test case 20 did not pass. x20 = \" + x20)\n    }\n\n    var arg210 : Int = 895\n    var arg211 : Int = 436\n    var x21 : Int = add(arg210, arg211);\n    var v21 : Int = 1331;\n    if (x21 != v21) {\n        throw Exception(\"Exception -- test case 21 did not pass. x21 = \" + x21)\n    }\n\n    var arg220 : Int = 123\n    var arg221 : Int = 424\n    var x22 : Int = add(arg220, arg221);\n    var v22 : Int = 547;\n    if (x22 != v22) {\n        throw Exception(\"Exception -- test case 22 did not pass. x22 = \" + x22)\n    }\n\n    var arg230 : Int = 923\n    var arg231 : Int = 245\n    var x23 : Int = add(arg230, arg231);\n    var v23 : Int = 1168;\n    if (x23 != v23) {\n        throw Exception(\"Exception -- test case 23 did not pass. x23 = \" + x23)\n    }\n\n    var arg240 : Int = 23\n    var arg241 : Int = 438\n    var x24 : Int = add(arg240, arg241);\n    var v24 : Int = 461;\n    if (x24 != v24) {\n        throw Exception(\"Exception -- test case 24 did not pass. x24 = \" + x24)\n    }\n\n    var arg250 : Int = 565\n    var arg251 : Int = 133\n    var x25 : Int = add(arg250, arg251);\n    var v25 : Int = 698;\n    if (x25 != v25) {\n        throw Exception(\"Exception -- test case 25 did not pass. x25 = \" + x25)\n    }\n\n    var arg260 : Int = 945\n    var arg261 : Int = 925\n    var x26 : Int = add(arg260, arg261);\n    var v26 : Int = 1870;\n    if (x26 != v26) {\n        throw Exception(\"Exception -- test case 26 did not pass. x26 = \" + x26)\n    }\n\n    var arg270 : Int = 261\n    var arg271 : Int = 983\n    var x27 : Int = add(arg270, arg271);\n    var v27 : Int = 1244;\n    if (x27 != v27) {\n        throw Exception(\"Exception -- test case 27 did not pass. x27 = \" + x27)\n    }\n\n    var arg280 : Int = 139\n    var arg281 : Int = 577\n    var x28 : Int = add(arg280, arg281);\n    var v28 : Int = 716;\n    if (x28 != v28) {\n        throw Exception(\"Exception -- test case 28 did not pass. x28 = \" + x28)\n    }\n\n    var arg290 : Int = 763\n    var arg291 : Int = 178\n    var x29 : Int = add(arg290, arg291);\n    var v29 : Int = 941;\n    if (x29 != v29) {\n        throw Exception(\"Exception -- test case 29 did not pass. x29 = \" + x29)\n    }\n\n    var arg300 : Int = 147\n    var arg301 : Int = 892\n    var x30 : Int = add(arg300, arg301);\n    var v30 : Int = 1039;\n    if (x30 != v30) {\n        throw Exception(\"Exception -- test case 30 did not pass. x30 = \" + x30)\n    }\n\n    var arg310 : Int = 436\n    var arg311 : Int = 402\n    var x31 : Int = add(arg310, arg311);\n    var v31 : Int = 838;\n    if (x31 != v31) {\n        throw Exception(\"Exception -- test case 31 did not pass. x31 = \" + x31)\n    }\n\n    var arg320 : Int = 610\n    var arg321 : Int = 581\n    var x32 : Int = add(arg320, arg321);\n    var v32 : Int = 1191;\n    if (x32 != v32) {\n        throw Exception(\"Exception -- test case 32 did not pass. x32 = \" + x32)\n    }\n\n    var arg330 : Int = 103\n    var arg331 : Int = 416\n    var x33 : Int = add(arg330, arg331);\n    var v33 : Int = 519;\n    if (x33 != v33) {\n        throw Exception(\"Exception -- test case 33 did not pass. x33 = \" + x33)\n    }\n\n    var arg340 : Int = 339\n    var arg341 : Int = 990\n    var x34 : Int = add(arg340, arg341);\n    var v34 : Int = 1329;\n    if (x34 != v34) {\n        throw Exception(\"Exception -- test case 34 did not pass. x34 = \" + x34)\n    }\n\n    var arg350 : Int = 130\n    var arg351 : Int = 504\n    var x35 : Int = add(arg350, arg351);\n    var v35 : Int = 634;\n    if (x35 != v35) {\n        throw Exception(\"Exception -- test case 35 did not pass. x35 = \" + x35)\n    }\n\n    var arg360 : Int = 242\n    var arg361 : Int = 717\n    var x36 : Int = add(arg360, arg361);\n    var v36 : Int = 959;\n    if (x36 != v36) {\n        throw Exception(\"Exception -- test case 36 did not pass. x36 = \" + x36)\n    }\n\n    var arg370 : Int = 562\n    var arg371 : Int = 110\n    var x37 : Int = add(arg370, arg371);\n    var v37 : Int = 672;\n    if (x37 != v37) {\n        throw Exception(\"Exception -- test case 37 did not pass. x37 = \" + x37)\n    }\n\n    var arg380 : Int = 396\n    var arg381 : Int = 909\n    var x38 : Int = add(arg380, arg381);\n    var v38 : Int = 1305;\n    if (x38 != v38) {\n        throw Exception(\"Exception -- test case 38 did not pass. x38 = \" + x38)\n    }\n\n    var arg390 : Int = 887\n    var arg391 : Int = 703\n    var x39 : Int = add(arg390, arg391);\n    var v39 : Int = 1590;\n    if (x39 != v39) {\n        throw Exception(\"Exception -- test case 39 did not pass. x39 = \" + x39)\n    }\n\n    var arg400 : Int = 870\n    var arg401 : Int = 551\n    var x40 : Int = add(arg400, arg401);\n    var v40 : Int = 1421;\n    if (x40 != v40) {\n        throw Exception(\"Exception -- test case 40 did not pass. x40 = \" + x40)\n    }\n\n    var arg410 : Int = 422\n    var arg411 : Int = 391\n    var x41 : Int = add(arg410, arg411);\n    var v41 : Int = 813;\n    if (x41 != v41) {\n        throw Exception(\"Exception -- test case 41 did not pass. x41 = \" + x41)\n    }\n\n    var arg420 : Int = 299\n    var arg421 : Int = 505\n    var x42 : Int = add(arg420, arg421);\n    var v42 : Int = 804;\n    if (x42 != v42) {\n        throw Exception(\"Exception -- test case 42 did not pass. x42 = \" + x42)\n    }\n\n    var arg430 : Int = 346\n    var arg431 : Int = 56\n    var x43 : Int = add(arg430, arg431);\n    var v43 : Int = 402;\n    if (x43 != v43) {\n        throw Exception(\"Exception -- test case 43 did not pass. x43 = \" + x43)\n    }\n\n    var arg440 : Int = 36\n    var arg441 : Int = 706\n    var x44 : Int = add(arg440, arg441);\n    var v44 : Int = 742;\n    if (x44 != v44) {\n        throw Exception(\"Exception -- test case 44 did not pass. x44 = \" + x44)\n    }\n\n    var arg450 : Int = 738\n    var arg451 : Int = 411\n    var x45 : Int = add(arg450, arg451);\n    var v45 : Int = 1149;\n    if (x45 != v45) {\n        throw Exception(\"Exception -- test case 45 did not pass. x45 = \" + x45)\n    }\n\n    var arg460 : Int = 679\n    var arg461 : Int = 87\n    var x46 : Int = add(arg460, arg461);\n    var v46 : Int = 766;\n    if (x46 != v46) {\n        throw Exception(\"Exception -- test case 46 did not pass. x46 = \" + x46)\n    }\n\n    var arg470 : Int = 25\n    var arg471 : Int = 303\n    var x47 : Int = add(arg470, arg471);\n    var v47 : Int = 328;\n    if (x47 != v47) {\n        throw Exception(\"Exception -- test case 47 did not pass. x47 = \" + x47)\n    }\n\n    var arg480 : Int = 161\n    var arg481 : Int = 612\n    var x48 : Int = add(arg480, arg481);\n    var v48 : Int = 773;\n    if (x48 != v48) {\n        throw Exception(\"Exception -- test case 48 did not pass. x48 = \" + x48)\n    }\n\n    var arg490 : Int = 306\n    var arg491 : Int = 841\n    var x49 : Int = add(arg490, arg491);\n    var v49 : Int = 1147;\n    if (x49 != v49) {\n        throw Exception(\"Exception -- test case 49 did not pass. x49 = \" + x49)\n    }\n\n    var arg500 : Int = 973\n    var arg501 : Int = 411\n    var x50 : Int = add(arg500, arg501);\n    var v50 : Int = 1384;\n    if (x50 != v50) {\n        throw Exception(\"Exception -- test case 50 did not pass. x50 = \" + x50)\n    }\n\n    var arg510 : Int = 711\n    var arg511 : Int = 157\n    var x51 : Int = add(arg510, arg511);\n    var v51 : Int = 868;\n    if (x51 != v51) {\n        throw Exception(\"Exception -- test case 51 did not pass. x51 = \" + x51)\n    }\n\n    var arg520 : Int = 471\n    var arg521 : Int = 27\n    var x52 : Int = add(arg520, arg521);\n    var v52 : Int = 498;\n    if (x52 != v52) {\n        throw Exception(\"Exception -- test case 52 did not pass. x52 = \" + x52)\n    }\n\n    var arg530 : Int = 714\n    var arg531 : Int = 792\n    var x53 : Int = add(arg530, arg531);\n    var v53 : Int = 1506;\n    if (x53 != v53) {\n        throw Exception(\"Exception -- test case 53 did not pass. x53 = \" + x53)\n    }\n\n    var arg540 : Int = 38\n    var arg541 : Int = 206\n    var x54 : Int = add(arg540, arg541);\n    var v54 : Int = 244;\n    if (x54 != v54) {\n        throw Exception(\"Exception -- test case 54 did not pass. x54 = \" + x54)\n    }\n\n    var arg550 : Int = 907\n    var arg551 : Int = 343\n    var x55 : Int = add(arg550, arg551);\n    var v55 : Int = 1250;\n    if (x55 != v55) {\n        throw Exception(\"Exception -- test case 55 did not pass. x55 = \" + x55)\n    }\n\n    var arg560 : Int = 23\n    var arg561 : Int = 760\n    var x56 : Int = add(arg560, arg561);\n    var v56 : Int = 783;\n    if (x56 != v56) {\n        throw Exception(\"Exception -- test case 56 did not pass. x56 = \" + x56)\n    }\n\n    var arg570 : Int = 524\n    var arg571 : Int = 859\n    var x57 : Int = add(arg570, arg571);\n    var v57 : Int = 1383;\n    if (x57 != v57) {\n        throw Exception(\"Exception -- test case 57 did not pass. x57 = \" + x57)\n    }\n\n    var arg580 : Int = 30\n    var arg581 : Int = 529\n    var x58 : Int = add(arg580, arg581);\n    var v58 : Int = 559;\n    if (x58 != v58) {\n        throw Exception(\"Exception -- test case 58 did not pass. x58 = \" + x58)\n    }\n\n    var arg590 : Int = 341\n    var arg591 : Int = 691\n    var x59 : Int = add(arg590, arg591);\n    var v59 : Int = 1032;\n    if (x59 != v59) {\n        throw Exception(\"Exception -- test case 59 did not pass. x59 = \" + x59)\n    }\n\n    var arg600 : Int = 167\n    var arg601 : Int = 729\n    var x60 : Int = add(arg600, arg601);\n    var v60 : Int = 896;\n    if (x60 != v60) {\n        throw Exception(\"Exception -- test case 60 did not pass. x60 = \" + x60)\n    }\n\n    var arg610 : Int = 636\n    var arg611 : Int = 289\n    var x61 : Int = add(arg610, arg611);\n    var v61 : Int = 925;\n    if (x61 != v61) {\n        throw Exception(\"Exception -- test case 61 did not pass. x61 = \" + x61)\n    }\n\n    var arg620 : Int = 503\n    var arg621 : Int = 144\n    var x62 : Int = add(arg620, arg621);\n    var v62 : Int = 647;\n    if (x62 != v62) {\n        throw Exception(\"Exception -- test case 62 did not pass. x62 = \" + x62)\n    }\n\n    var arg630 : Int = 51\n    var arg631 : Int = 985\n    var x63 : Int = add(arg630, arg631);\n    var v63 : Int = 1036;\n    if (x63 != v63) {\n        throw Exception(\"Exception -- test case 63 did not pass. x63 = \" + x63)\n    }\n\n    var arg640 : Int = 287\n    var arg641 : Int = 149\n    var x64 : Int = add(arg640, arg641);\n    var v64 : Int = 436;\n    if (x64 != v64) {\n        throw Exception(\"Exception -- test case 64 did not pass. x64 = \" + x64)\n    }\n\n    var arg650 : Int = 659\n    var arg651 : Int = 75\n    var x65 : Int = add(arg650, arg651);\n    var v65 : Int = 734;\n    if (x65 != v65) {\n        throw Exception(\"Exception -- test case 65 did not pass. x65 = \" + x65)\n    }\n\n    var arg660 : Int = 462\n    var arg661 : Int = 797\n    var x66 : Int = add(arg660, arg661);\n    var v66 : Int = 1259;\n    if (x66 != v66) {\n        throw Exception(\"Exception -- test case 66 did not pass. x66 = \" + x66)\n    }\n\n    var arg670 : Int = 406\n    var arg671 : Int = 141\n    var x67 : Int = add(arg670, arg671);\n    var v67 : Int = 547;\n    if (x67 != v67) {\n        throw Exception(\"Exception -- test case 67 did not pass. x67 = \" + x67)\n    }\n\n    var arg680 : Int = 106\n    var arg681 : Int = 44\n    var x68 : Int = add(arg680, arg681);\n    var v68 : Int = 150;\n    if (x68 != v68) {\n        throw Exception(\"Exception -- test case 68 did not pass. x68 = \" + x68)\n    }\n\n    var arg690 : Int = 300\n    var arg691 : Int = 934\n    var x69 : Int = add(arg690, arg691);\n    var v69 : Int = 1234;\n    if (x69 != v69) {\n        throw Exception(\"Exception -- test case 69 did not pass. x69 = \" + x69)\n    }\n\n    var arg700 : Int = 471\n    var arg701 : Int = 524\n    var x70 : Int = add(arg700, arg701);\n    var v70 : Int = 995;\n    if (x70 != v70) {\n        throw Exception(\"Exception -- test case 70 did not pass. x70 = \" + x70)\n    }\n\n    var arg710 : Int = 122\n    var arg711 : Int = 429\n    var x71 : Int = add(arg710, arg711);\n    var v71 : Int = 551;\n    if (x71 != v71) {\n        throw Exception(\"Exception -- test case 71 did not pass. x71 = \" + x71)\n    }\n\n    var arg720 : Int = 735\n    var arg721 : Int = 195\n    var x72 : Int = add(arg720, arg721);\n    var v72 : Int = 930;\n    if (x72 != v72) {\n        throw Exception(\"Exception -- test case 72 did not pass. x72 = \" + x72)\n    }\n\n    var arg730 : Int = 335\n    var arg731 : Int = 484\n    var x73 : Int = add(arg730, arg731);\n    var v73 : Int = 819;\n    if (x73 != v73) {\n        throw Exception(\"Exception -- test case 73 did not pass. x73 = \" + x73)\n    }\n\n    var arg740 : Int = 28\n    var arg741 : Int = 809\n    var x74 : Int = add(arg740, arg741);\n    var v74 : Int = 837;\n    if (x74 != v74) {\n        throw Exception(\"Exception -- test case 74 did not pass. x74 = \" + x74)\n    }\n\n    var arg750 : Int = 430\n    var arg751 : Int = 20\n    var x75 : Int = add(arg750, arg751);\n    var v75 : Int = 450;\n    if (x75 != v75) {\n        throw Exception(\"Exception -- test case 75 did not pass. x75 = \" + x75)\n    }\n\n    var arg760 : Int = 916\n    var arg761 : Int = 635\n    var x76 : Int = add(arg760, arg761);\n    var v76 : Int = 1551;\n    if (x76 != v76) {\n        throw Exception(\"Exception -- test case 76 did not pass. x76 = \" + x76)\n    }\n\n    var arg770 : Int = 301\n    var arg771 : Int = 999\n    var x77 : Int = add(arg770, arg771);\n    var v77 : Int = 1300;\n    if (x77 != v77) {\n        throw Exception(\"Exception -- test case 77 did not pass. x77 = \" + x77)\n    }\n\n    var arg780 : Int = 454\n    var arg781 : Int = 466\n    var x78 : Int = add(arg780, arg781);\n    var v78 : Int = 920;\n    if (x78 != v78) {\n        throw Exception(\"Exception -- test case 78 did not pass. x78 = \" + x78)\n    }\n\n    var arg790 : Int = 905\n    var arg791 : Int = 259\n    var x79 : Int = add(arg790, arg791);\n    var v79 : Int = 1164;\n    if (x79 != v79) {\n        throw Exception(\"Exception -- test case 79 did not pass. x79 = \" + x79)\n    }\n\n    var arg800 : Int = 168\n    var arg801 : Int = 205\n    var x80 : Int = add(arg800, arg801);\n    var v80 : Int = 373;\n    if (x80 != v80) {\n        throw Exception(\"Exception -- test case 80 did not pass. x80 = \" + x80)\n    }\n\n    var arg810 : Int = 570\n    var arg811 : Int = 434\n    var x81 : Int = add(arg810, arg811);\n    var v81 : Int = 1004;\n    if (x81 != v81) {\n        throw Exception(\"Exception -- test case 81 did not pass. x81 = \" + x81)\n    }\n\n    var arg820 : Int = 64\n    var arg821 : Int = 959\n    var x82 : Int = add(arg820, arg821);\n    var v82 : Int = 1023;\n    if (x82 != v82) {\n        throw Exception(\"Exception -- test case 82 did not pass. x82 = \" + x82)\n    }\n\n    var arg830 : Int = 957\n    var arg831 : Int = 510\n    var x83 : Int = add(arg830, arg831);\n    var v83 : Int = 1467;\n    if (x83 != v83) {\n        throw Exception(\"Exception -- test case 83 did not pass. x83 = \" + x83)\n    }\n\n    var arg840 : Int = 722\n    var arg841 : Int = 598\n    var x84 : Int = add(arg840, arg841);\n    var v84 : Int = 1320;\n    if (x84 != v84) {\n        throw Exception(\"Exception -- test case 84 did not pass. x84 = \" + x84)\n    }\n\n    var arg850 : Int = 770\n    var arg851 : Int = 226\n    var x85 : Int = add(arg850, arg851);\n    var v85 : Int = 996;\n    if (x85 != v85) {\n        throw Exception(\"Exception -- test case 85 did not pass. x85 = \" + x85)\n    }\n\n    var arg860 : Int = 579\n    var arg861 : Int = 66\n    var x86 : Int = add(arg860, arg861);\n    var v86 : Int = 645;\n    if (x86 != v86) {\n        throw Exception(\"Exception -- test case 86 did not pass. x86 = \" + x86)\n    }\n\n    var arg870 : Int = 117\n    var arg871 : Int = 674\n    var x87 : Int = add(arg870, arg871);\n    var v87 : Int = 791;\n    if (x87 != v87) {\n        throw Exception(\"Exception -- test case 87 did not pass. x87 = \" + x87)\n    }\n\n    var arg880 : Int = 530\n    var arg881 : Int = 30\n    var x88 : Int = add(arg880, arg881);\n    var v88 : Int = 560;\n    if (x88 != v88) {\n        throw Exception(\"Exception -- test case 88 did not pass. x88 = \" + x88)\n    }\n\n    var arg890 : Int = 776\n    var arg891 : Int = 345\n    var x89 : Int = add(arg890, arg891);\n    var v89 : Int = 1121;\n    if (x89 != v89) {\n        throw Exception(\"Exception -- test case 89 did not pass. x89 = \" + x89)\n    }\n\n    var arg900 : Int = 327\n    var arg901 : Int = 389\n    var x90 : Int = add(arg900, arg901);\n    var v90 : Int = 716;\n    if (x90 != v90) {\n        throw Exception(\"Exception -- test case 90 did not pass. x90 = \" + x90)\n    }\n\n    var arg910 : Int = 596\n    var arg911 : Int = 12\n    var x91 : Int = add(arg910, arg911);\n    var v91 : Int = 608;\n    if (x91 != v91) {\n        throw Exception(\"Exception -- test case 91 did not pass. x91 = \" + x91)\n    }\n\n    var arg920 : Int = 599\n    var arg921 : Int = 511\n    var x92 : Int = add(arg920, arg921);\n    var v92 : Int = 1110;\n    if (x92 != v92) {\n        throw Exception(\"Exception -- test case 92 did not pass. x92 = \" + x92)\n    }\n\n    var arg930 : Int = 936\n    var arg931 : Int = 476\n    var x93 : Int = add(arg930, arg931);\n    var v93 : Int = 1412;\n    if (x93 != v93) {\n        throw Exception(\"Exception -- test case 93 did not pass. x93 = \" + x93)\n    }\n\n    var arg940 : Int = 461\n    var arg941 : Int = 14\n    var x94 : Int = add(arg940, arg941);\n    var v94 : Int = 475;\n    if (x94 != v94) {\n        throw Exception(\"Exception -- test case 94 did not pass. x94 = \" + x94)\n    }\n\n    var arg950 : Int = 966\n    var arg951 : Int = 157\n    var x95 : Int = add(arg950, arg951);\n    var v95 : Int = 1123;\n    if (x95 != v95) {\n        throw Exception(\"Exception -- test case 95 did not pass. x95 = \" + x95)\n    }\n\n    var arg960 : Int = 326\n    var arg961 : Int = 91\n    var x96 : Int = add(arg960, arg961);\n    var v96 : Int = 417;\n    if (x96 != v96) {\n        throw Exception(\"Exception -- test case 96 did not pass. x96 = \" + x96)\n    }\n\n    var arg970 : Int = 392\n    var arg971 : Int = 455\n    var x97 : Int = add(arg970, arg971);\n    var v97 : Int = 847;\n    if (x97 != v97) {\n        throw Exception(\"Exception -- test case 97 did not pass. x97 = \" + x97)\n    }\n\n    var arg980 : Int = 446\n    var arg981 : Int = 477\n    var x98 : Int = add(arg980, arg981);\n    var v98 : Int = 923;\n    if (x98 != v98) {\n        throw Exception(\"Exception -- test case 98 did not pass. x98 = \" + x98)\n    }\n\n    var arg990 : Int = 324\n    var arg991 : Int = 860\n    var x99 : Int = add(arg990, arg991);\n    var v99 : Int = 1184;\n    if (x99 != v99) {\n        throw Exception(\"Exception -- test case 99 did not pass. x99 = \" + x99)\n    }\n\n    var arg1000 : Int = 945\n    var arg1001 : Int = 85\n    var x100 : Int = add(arg1000, arg1001);\n    var v100 : Int = 1030;\n    if (x100 != v100) {\n        throw Exception(\"Exception -- test case 100 did not pass. x100 = \" + x100)\n    }\n\n    var arg1010 : Int = 886\n    var arg1011 : Int = 582\n    var x101 : Int = add(arg1010, arg1011);\n    var v101 : Int = 1468;\n    if (x101 != v101) {\n        throw Exception(\"Exception -- test case 101 did not pass. x101 = \" + x101)\n    }\n\n    var arg1020 : Int = 886\n    var arg1021 : Int = 712\n    var x102 : Int = add(arg1020, arg1021);\n    var v102 : Int = 1598;\n    if (x102 != v102) {\n        throw Exception(\"Exception -- test case 102 did not pass. x102 = \" + x102)\n    }\n\n    var arg1030 : Int = 842\n    var arg1031 : Int = 953\n    var x103 : Int = add(arg1030, arg1031);\n    var v103 : Int = 1795;\n    if (x103 != v103) {\n        throw Exception(\"Exception -- test case 103 did not pass. x103 = \" + x103)\n    }\n\n\n}\n", "description": "Ajouter deux nombres x et y", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/20", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Vérifiez si deux mots ont les mêmes caractères.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n *\n */\nfun sameChars(s0 : String, s1 : String) : Boolean {\n", "entry_point": "sameChars", "test": "\nfun main() {\n    var arg00 : String = \"\"\"eabcdzzzz\"\"\"\n    var arg01 : String = \"\"\"dddzzzzzzzddeddabc\"\"\"\n    var x0 : Boolean = sameChars(arg00, arg01);\n    var v0 : Boolean = true;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"abcd\"\"\"\n    var arg11 : String = \"\"\"dddddddabc\"\"\"\n    var x1 : Boolean = sameChars(arg10, arg11);\n    var v1 : Boolean = true;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"dddddddabc\"\"\"\n    var arg21 : String = \"\"\"abcd\"\"\"\n    var x2 : Boolean = sameChars(arg20, arg21);\n    var v2 : Boolean = true;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"eabcd\"\"\"\n    var arg31 : String = \"\"\"dddddddabc\"\"\"\n    var x3 : Boolean = sameChars(arg30, arg31);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"abcd\"\"\"\n    var arg41 : String = \"\"\"dddddddabcf\"\"\"\n    var x4 : Boolean = sameChars(arg40, arg41);\n    var v4 : Boolean = false;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"eabcdzzzz\"\"\"\n    var arg51 : String = \"\"\"dddzzzzzzzddddabc\"\"\"\n    var x5 : Boolean = sameChars(arg50, arg51);\n    var v5 : Boolean = false;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"aabb\"\"\"\n    var arg61 : String = \"\"\"aaccc\"\"\"\n    var x6 : Boolean = sameChars(arg60, arg61);\n    var v6 : Boolean = false;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "Vérifiez si deux mots ont les mêmes caractères.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/21", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Retourne le n-ième nombre de Fibonacci.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n *\n */\nfun fib(n : Int) : Int {\n", "entry_point": "fib", "test": "\nfun main() {\n    var arg00 : Int = 10\n    var x0 : Int = fib(arg00);\n    var v0 : Int = 55;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 1\n    var x1 : Int = fib(arg10);\n    var v1 : Int = 1;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 8\n    var x2 : Int = fib(arg20);\n    var v2 : Int = 21;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 11\n    var x3 : Int = fib(arg30);\n    var v3 : Int = 89;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 12\n    var x4 : Int = fib(arg40);\n    var v4 : Int = 144;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "Retourne le n-ième nombre de Fibonacci.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/22", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Retourne les éléments communs uniques triés pour deux listes.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n\n *\n */\nfun common(l1 : List<Int>, l2 : List<Any>) : List<Any> {\n", "entry_point": "common", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(1, 4, 3, 34, 653, 2, 5)\n    var arg01 : List<Any> = mutableListOf(5, 7, 1, 5, 9, 653, 121)\n    var x0 : List<Any> = common(arg00, arg01);\n    var v0 : List<Any> = mutableListOf(1, 5, 653);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(5, 3, 2, 8)\n    var arg11 : List<Any> = mutableListOf(3, 2)\n    var x1 : List<Any> = common(arg10, arg11);\n    var v1 : List<Any> = mutableListOf(2, 3);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(4, 3, 2, 8)\n    var arg21 : List<Any> = mutableListOf(3, 2, 4)\n    var x2 : List<Any> = common(arg20, arg21);\n    var v2 : List<Any> = mutableListOf(2, 3, 4);\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(4, 3, 2, 8)\n    var arg31 : List<Any> = mutableListOf()\n    var x3 : List<Any> = common(arg30, arg31);\n    var v3 : List<Any> = mutableListOf();\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n\n}\n", "description": "Retourne les éléments communs uniques triés pour deux listes.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/23", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Retourne le plus grand facteur premier de n. Supposons que n > 1 et n'est pas un nombre premier.\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n *\n */\nfun largestPrimeFactor(n : Int) : Int {\n", "entry_point": "largestPrimeFactor", "test": "\nfun main() {\n    var arg00 : Int = 15\n    var x0 : Int = largestPrimeFactor(arg00);\n    var v0 : Int = 5;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 27\n    var x1 : Int = largestPrimeFactor(arg10);\n    var v1 : Int = 3;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 63\n    var x2 : Int = largestPrimeFactor(arg20);\n    var v2 : Int = 7;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 330\n    var x3 : Int = largestPrimeFactor(arg30);\n    var v3 : Int = 11;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 13195\n    var x4 : Int = largestPrimeFactor(arg40);\n    var v4 : Int = 29;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "Retourne le plus grand facteur premier de n. Supposons que n > 1 et n'est pas un nombre premier.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/24", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * sum_to_n est une fonction qui additionne les nombres de 1 à n.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n *\n */\nfun sumToN(n : Int) : Int {\n", "entry_point": "sumToN", "test": "\nfun main() {\n    var arg00 : Int = 1\n    var x0 : Int = sumToN(arg00);\n    var v0 : Int = 1;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 6\n    var x1 : Int = sumToN(arg10);\n    var v1 : Int = 21;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 11\n    var x2 : Int = sumToN(arg20);\n    var v2 : Int = 66;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 30\n    var x3 : Int = sumToN(arg30);\n    var v3 : Int = 465;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 100\n    var x4 : Int = sumToN(arg40);\n    var v4 : Int = 5050;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "sum_to_n est une fonction qui additionne les nombres de 1 à n.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/25", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * xs représente les coefficients d'un polynôme.\n *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n *      Renvoyer la dérivée de ce polynôme sous la même forme.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n *\n */\nfun derivative(xs : List<Int>) : List<Any> {\n", "entry_point": "derivative", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(3, 1, 2, 4, 5)\n    var x0 : List<Any> = derivative(arg00);\n    var v0 : List<Any> = mutableListOf(1, 4, 12, 20);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(1, 2, 3)\n    var x1 : List<Any> = derivative(arg10);\n    var v1 : List<Any> = mutableListOf(2, 6);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(3, 2, 1)\n    var x2 : List<Any> = derivative(arg20);\n    var v2 : List<Any> = mutableListOf(2, 2);\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(3, 2, 1, 0, 4)\n    var x3 : List<Any> = derivative(arg30);\n    var v3 : List<Any> = mutableListOf(2, 2, 0, 16);\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Int> = mutableListOf(1)\n    var x4 : List<Any> = derivative(arg40);\n    var v4 : List<Any> = mutableListOf();\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "xs représente les coefficients d'un polynôme.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Renvoyer la dérivée de ce polynôme sous la même forme.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/26", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * La séquence de nombres FibFib est une séquence similaire à la séquence de Fibonacci définie comme suit :\n *     fibfib(0) == 0\n *     fibfib(1) == 0\n *     fibfib(2) == 1\n *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n *     Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres FibFib.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n *\n */\nfun fibfib(n : Int) : Int {\n", "entry_point": "fibfib", "test": "\nfun main() {\n    var arg00 : Int = 2\n    var x0 : Int = fibfib(arg00);\n    var v0 : Int = 1;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 1\n    var x1 : Int = fibfib(arg10);\n    var v1 : Int = 0;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 5\n    var x2 : Int = fibfib(arg20);\n    var v2 : Int = 4;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 8\n    var x3 : Int = fibfib(arg30);\n    var v3 : Int = 24;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 10\n    var x4 : Int = fibfib(arg40);\n    var v4 : Int = 81;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 12\n    var x5 : Int = fibfib(arg50);\n    var v5 : Int = 274;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 14\n    var x6 : Int = fibfib(arg60);\n    var v6 : Int = 927;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "La séquence de nombres FibFib est une séquence similaire à la séquence de Fibonacci définie comme suit :\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres FibFib.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/27", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Écrivez une fonction vowels_count qui prend une chaîne de caractères représentant un mot en entrée et renvoie le nombre de voyelles dans la chaîne. Les voyelles dans ce cas sont 'a', 'e', 'i', 'o', 'u'. Ici, 'y' est également une voyelle, mais seulement lorsqu'elle est à la fin du mot donné.\n * \n * Exemple :\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n *\n */\nfun vowelsCount(s : String) : Int {\n", "entry_point": "vowelsCount", "test": "\nfun main() {\n    var arg00 : String = \"\"\"abcde\"\"\"\n    var x0 : Int = vowelsCount(arg00);\n    var v0 : Int = 2;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"Alone\"\"\"\n    var x1 : Int = vowelsCount(arg10);\n    var v1 : Int = 3;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"key\"\"\"\n    var x2 : Int = vowelsCount(arg20);\n    var v2 : Int = 2;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"bye\"\"\"\n    var x3 : Int = vowelsCount(arg30);\n    var v3 : Int = 1;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"keY\"\"\"\n    var x4 : Int = vowelsCount(arg40);\n    var v4 : Int = 2;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"bYe\"\"\"\n    var x5 : Int = vowelsCount(arg50);\n    var v5 : Int = 1;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"ACEDY\"\"\"\n    var x6 : Int = vowelsCount(arg60);\n    var v6 : Int = 3;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "Écrivez une fonction vowels_count qui prend une chaîne de caractères représentant un mot en entrée et renvoie le nombre de voyelles dans la chaîne. Les voyelles dans ce cas sont 'a', 'e', 'i', 'o', 'u'. Ici, 'y' est également une voyelle, mais seulement lorsqu'elle est à la fin du mot donné.\n\nExemple :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/28", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Vous disposez d'une liste non vide d'entiers positifs. Renvoyez l'entier le plus grand qui est supérieur à zéro et dont la fréquence est supérieure ou égale à la valeur de l'entier lui-même. La fréquence d'un entier est le nombre de fois où il apparaît dans la liste. Si aucune valeur de ce type n'existe, renvoyez -1. Exemples :\n * \n *     search([4, 1, 2, 2, 3, 1]) == 2\n *     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n *     search([5, 5, 4, 4, 4]) == -1\n *\n */\nfun search(lst : List<Int>) : Int {\n", "entry_point": "search", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(5, 5, 5, 5, 1)\n    var x0 : Int = search(arg00);\n    var v0 : Int = 1;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(4, 1, 4, 1, 4, 4)\n    var x1 : Int = search(arg10);\n    var v1 : Int = 4;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(3, 3)\n    var x2 : Int = search(arg20);\n    var v2 : Int = -1;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(8, 8, 8, 8, 8, 8, 8, 8)\n    var x3 : Int = search(arg30);\n    var v3 : Int = 8;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Int> = mutableListOf(2, 3, 3, 2, 2)\n    var x4 : Int = search(arg40);\n    var v4 : Int = 2;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Int> = mutableListOf(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1)\n    var x5 : Int = search(arg50);\n    var v5 : Int = 1;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : List<Int> = mutableListOf(3, 2, 8, 2)\n    var x6 : Int = search(arg60);\n    var v6 : Int = 2;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : List<Int> = mutableListOf(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10)\n    var x7 : Int = search(arg70);\n    var v7 : Int = 1;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : List<Int> = mutableListOf(8, 8, 3, 6, 5, 6, 4)\n    var x8 : Int = search(arg80);\n    var v8 : Int = -1;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : List<Int> = mutableListOf(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9)\n    var x9 : Int = search(arg90);\n    var v9 : Int = 1;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n    var arg100 : List<Int> = mutableListOf(1, 9, 10, 1, 3)\n    var x10 : Int = search(arg100);\n    var v10 : Int = 1;\n    if (x10 != v10) {\n        throw Exception(\"Exception -- test case 10 did not pass. x10 = \" + x10)\n    }\n\n    var arg110 : List<Int> = mutableListOf(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10)\n    var x11 : Int = search(arg110);\n    var v11 : Int = 5;\n    if (x11 != v11) {\n        throw Exception(\"Exception -- test case 11 did not pass. x11 = \" + x11)\n    }\n\n    var arg120 : List<Int> = mutableListOf(1)\n    var x12 : Int = search(arg120);\n    var v12 : Int = 1;\n    if (x12 != v12) {\n        throw Exception(\"Exception -- test case 12 did not pass. x12 = \" + x12)\n    }\n\n    var arg130 : List<Int> = mutableListOf(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5)\n    var x13 : Int = search(arg130);\n    var v13 : Int = 4;\n    if (x13 != v13) {\n        throw Exception(\"Exception -- test case 13 did not pass. x13 = \" + x13)\n    }\n\n    var arg140 : List<Int> = mutableListOf(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10)\n    var x14 : Int = search(arg140);\n    var v14 : Int = 2;\n    if (x14 != v14) {\n        throw Exception(\"Exception -- test case 14 did not pass. x14 = \" + x14)\n    }\n\n    var arg150 : List<Int> = mutableListOf(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3)\n    var x15 : Int = search(arg150);\n    var v15 : Int = 1;\n    if (x15 != v15) {\n        throw Exception(\"Exception -- test case 15 did not pass. x15 = \" + x15)\n    }\n\n    var arg160 : List<Int> = mutableListOf(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4)\n    var x16 : Int = search(arg160);\n    var v16 : Int = 4;\n    if (x16 != v16) {\n        throw Exception(\"Exception -- test case 16 did not pass. x16 = \" + x16)\n    }\n\n    var arg170 : List<Int> = mutableListOf(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7)\n    var x17 : Int = search(arg170);\n    var v17 : Int = 4;\n    if (x17 != v17) {\n        throw Exception(\"Exception -- test case 17 did not pass. x17 = \" + x17)\n    }\n\n    var arg180 : List<Int> = mutableListOf(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1)\n    var x18 : Int = search(arg180);\n    var v18 : Int = 2;\n    if (x18 != v18) {\n        throw Exception(\"Exception -- test case 18 did not pass. x18 = \" + x18)\n    }\n\n    var arg190 : List<Int> = mutableListOf(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8)\n    var x19 : Int = search(arg190);\n    var v19 : Int = -1;\n    if (x19 != v19) {\n        throw Exception(\"Exception -- test case 19 did not pass. x19 = \" + x19)\n    }\n\n    var arg200 : List<Int> = mutableListOf(10)\n    var x20 : Int = search(arg200);\n    var v20 : Int = -1;\n    if (x20 != v20) {\n        throw Exception(\"Exception -- test case 20 did not pass. x20 = \" + x20)\n    }\n\n    var arg210 : List<Int> = mutableListOf(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2)\n    var x21 : Int = search(arg210);\n    var v21 : Int = 2;\n    if (x21 != v21) {\n        throw Exception(\"Exception -- test case 21 did not pass. x21 = \" + x21)\n    }\n\n    var arg220 : List<Int> = mutableListOf(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8)\n    var x22 : Int = search(arg220);\n    var v22 : Int = 1;\n    if (x22 != v22) {\n        throw Exception(\"Exception -- test case 22 did not pass. x22 = \" + x22)\n    }\n\n    var arg230 : List<Int> = mutableListOf(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6)\n    var x23 : Int = search(arg230);\n    var v23 : Int = 1;\n    if (x23 != v23) {\n        throw Exception(\"Exception -- test case 23 did not pass. x23 = \" + x23)\n    }\n\n    var arg240 : List<Int> = mutableListOf(3, 10, 10, 9, 2)\n    var x24 : Int = search(arg240);\n    var v24 : Int = -1;\n    if (x24 != v24) {\n        throw Exception(\"Exception -- test case 24 did not pass. x24 = \" + x24)\n    }\n\n\n}\n", "description": "Vous disposez d'une liste non vide d'entiers positifs. Renvoyez l'entier le plus grand qui est supérieur à zéro et dont la fréquence est supérieure ou égale à la valeur de l'entier lui-même. La fréquence d'un entier est le nombre de fois où il apparaît dans la liste. Si aucune valeur de ce type n'existe, renvoyez -1. Exemples :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/29", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Étant donné les longueurs des trois côtés d'un triangle. Renvoyer l'aire du triangle arrondie à 2 décimales si les trois côtés forment un triangle valide. Sinon, retourner -1. Trois côtés forment un triangle valide lorsque la somme de deux côtés est supérieure au troisième côté. Exemple :\n * \n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n *\n */\nfun triangleArea(a : Int, b : Int, c : Int) : Any {\n", "entry_point": "triangleArea", "test": "\nfun main() {\n    var arg00 : Int = 3\n    var arg01 : Int = 4\n    var arg02 : Int = 5\n    var x0 : Any = triangleArea(arg00, arg01, arg02);\n    var v0 : Any = 6.0;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 1\n    var arg11 : Int = 2\n    var arg12 : Int = 10\n    var x1 : Any = triangleArea(arg10, arg11, arg12);\n    var v1 : Any = -1;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 4\n    var arg21 : Int = 8\n    var arg22 : Int = 5\n    var x2 : Any = triangleArea(arg20, arg21, arg22);\n    var v2 : Any = 8.18;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 2\n    var arg31 : Int = 2\n    var arg32 : Int = 2\n    var x3 : Any = triangleArea(arg30, arg31, arg32);\n    var v3 : Any = 1.73;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 1\n    var arg41 : Int = 2\n    var arg42 : Int = 3\n    var x4 : Any = triangleArea(arg40, arg41, arg42);\n    var v4 : Any = -1;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 10\n    var arg51 : Int = 5\n    var arg52 : Int = 7\n    var x5 : Any = triangleArea(arg50, arg51, arg52);\n    var v5 : Any = 16.25;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 2\n    var arg61 : Int = 6\n    var arg62 : Int = 3\n    var x6 : Any = triangleArea(arg60, arg61, arg62);\n    var v6 : Any = -1;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : Int = 1\n    var arg71 : Int = 1\n    var arg72 : Int = 1\n    var x7 : Any = triangleArea(arg70, arg71, arg72);\n    var v7 : Any = 0.43;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : Int = 2\n    var arg81 : Int = 2\n    var arg82 : Int = 10\n    var x8 : Any = triangleArea(arg80, arg81, arg82);\n    var v8 : Any = -1;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n\n}\n", "description": "Étant donné les longueurs des trois côtés d'un triangle. Renvoyer l'aire du triangle arrondie à 2 décimales si les trois côtés forment un triangle valide. Sinon, retourner -1. Trois côtés forment un triangle valide lorsque la somme de deux côtés est supérieure au troisième côté. Exemple :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/30", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Écrivez une fonction qui renvoie True si l'objet q va voler, et False sinon.\n *     L'objet q volera s'il est équilibré (c'est une liste palindromique) et que la somme de ses éléments est inférieure ou égale au poids maximum possible w.\n * \n *     Exemple:\n *     will_it_fly([1, 2], 5) ➞ False \n *     # 1+2 est inférieur au poids maximum possible, mais c'est déséquilibré.\n * \n *     will_it_fly([3, 2, 3], 1) ➞ False\n *     # c'est équilibré, mais 3+2+3 est plus que le poids maximum possible.\n * \n *     will_it_fly([3, 2, 3], 9) ➞ True\n *     # 3+2+3 est inférieur au poids maximum possible, et c'est équilibré.\n * \n *     will_it_fly([3], 5) ➞ True\n *     # 3 est inférieur au poids maximum possible, et c'est équilibré.\n * \n *\n */\nfun willItFly(q : List<Int>, w : Int) : Boolean {\n", "entry_point": "willItFly", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(3, 2, 3)\n    var arg01 : Int = 9\n    var x0 : Boolean = willItFly(arg00, arg01);\n    var v0 : Boolean = true;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(1, 2)\n    var arg11 : Int = 5\n    var x1 : Boolean = willItFly(arg10, arg11);\n    var v1 : Boolean = false;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(3)\n    var arg21 : Int = 5\n    var x2 : Boolean = willItFly(arg20, arg21);\n    var v2 : Boolean = true;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(3, 2, 3)\n    var arg31 : Int = 1\n    var x3 : Boolean = willItFly(arg30, arg31);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Int> = mutableListOf(1, 2, 3)\n    var arg41 : Int = 6\n    var x4 : Boolean = willItFly(arg40, arg41);\n    var v4 : Boolean = false;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Int> = mutableListOf(5)\n    var arg51 : Int = 5\n    var x5 : Boolean = willItFly(arg50, arg51);\n    var v5 : Boolean = true;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n\n}\n", "description": "Écrivez une fonction qui renvoie True si l'objet q va voler, et False sinon.\n    L'objet q volera s'il est équilibré (c'est une liste palindromique) et que la somme de ses éléments est inférieure ou égale au poids maximum possible w.\n\n    Exemple:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 est inférieur au poids maximum possible, mais c'est déséquilibré.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # c'est équilibré, mais 3+2+3 est plus que le poids maximum possible.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 est inférieur au poids maximum possible, et c'est équilibré.\n\n    will_it_fly([3], 5) ➞ True\n    # 3 est inférieur au poids maximum possible, et c'est équilibré.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/31", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Écrivez une fonction qui renvoie vrai si le nombre donné est le produit de 3 nombres premiers\n *     et faux sinon.\n *     Sachant que (a) est inférieur à 100.\n *     Exemple:\n * \n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n *\n */\nfun isMultiplyPrime(a : Int) : Boolean {\n", "entry_point": "isMultiplyPrime", "test": "\nfun main() {\n    var arg00 : Int = 5\n    var x0 : Boolean = isMultiplyPrime(arg00);\n    var v0 : Boolean = false;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 30\n    var x1 : Boolean = isMultiplyPrime(arg10);\n    var v1 : Boolean = true;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 8\n    var x2 : Boolean = isMultiplyPrime(arg20);\n    var v2 : Boolean = true;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 10\n    var x3 : Boolean = isMultiplyPrime(arg30);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 125\n    var x4 : Boolean = isMultiplyPrime(arg40);\n    var v4 : Boolean = true;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 105\n    var x5 : Boolean = isMultiplyPrime(arg50);\n    var v5 : Boolean = true;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 126\n    var x6 : Boolean = isMultiplyPrime(arg60);\n    var v6 : Boolean = false;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : Int = 729\n    var x7 : Boolean = isMultiplyPrime(arg70);\n    var v7 : Boolean = false;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : Int = 891\n    var x8 : Boolean = isMultiplyPrime(arg80);\n    var v8 : Boolean = false;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : Int = 1001\n    var x9 : Boolean = isMultiplyPrime(arg90);\n    var v9 : Boolean = true;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n\n}\n", "description": "Écrivez une fonction qui renvoie vrai si le nombre donné est le produit de 3 nombres premiers\n    et faux sinon.\n    Sachant que (a) est inférieur à 100.\n    Exemple:", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/32", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Vous recevrez un nombre en forme décimale et votre tâche consiste à le convertir en format binaire. La fonction doit renvoyer une chaîne de caractères, chaque caractère représentant un nombre binaire. Chaque caractère dans la chaîne sera '0' ou '1'.\n * \n * Il y aura quelques caractères supplémentaires 'db' au début et à la fin de la chaîne. Les caractères supplémentaires sont là pour aider avec le format.\n * \n * Exemples :\n * \n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n *\n */\nfun decimalToBinary(decimal : Int) : String {\n", "entry_point": "decimalToBinary", "test": "\nfun main() {\n    var arg00 : Int = 0\n    var x0 : String = decimalToBinary(arg00);\n    var v0 : String = \"\"\"db0db\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 32\n    var x1 : String = decimalToBinary(arg10);\n    var v1 : String = \"\"\"db100000db\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 103\n    var x2 : String = decimalToBinary(arg20);\n    var v2 : String = \"\"\"db1100111db\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 15\n    var x3 : String = decimalToBinary(arg30);\n    var v3 : String = \"\"\"db1111db\"\"\";\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n\n}\n", "description": "Vous recevrez un nombre en forme décimale et votre tâche consiste à le convertir en format binaire. La fonction doit renvoyer une chaîne de caractères, chaque caractère représentant un nombre binaire. Chaque caractère dans la chaîne sera '0' ou '1'.\n\nIl y aura quelques caractères supplémentaires 'db' au début et à la fin de la chaîne. Les caractères supplémentaires sont là pour aider avec le format.\n\nExemples :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/33", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * On vous donne une chaîne de caractères s.\n *     Votre tâche est de vérifier si la chaîne est heureuse ou non.\n *     Une chaîne est heureuse si sa longueur est d'au moins 3 et que chaque groupe de 3 lettres consécutives est distinct.\n *     Par exemple :\n * \n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n *\n */\nfun isHappy(s : String) : Boolean {\n", "entry_point": "isHappy", "test": "\nfun main() {\n    var arg00 : String = \"\"\"a\"\"\"\n    var x0 : Boolean = isHappy(arg00);\n    var v0 : Boolean = false;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"aa\"\"\"\n    var x1 : Boolean = isHappy(arg10);\n    var v1 : Boolean = false;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"abcd\"\"\"\n    var x2 : Boolean = isHappy(arg20);\n    var v2 : Boolean = true;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"aabb\"\"\"\n    var x3 : Boolean = isHappy(arg30);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"adb\"\"\"\n    var x4 : Boolean = isHappy(arg40);\n    var v4 : Boolean = true;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"xyy\"\"\"\n    var x5 : Boolean = isHappy(arg50);\n    var v5 : Boolean = false;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"iopaxpoi\"\"\"\n    var x6 : Boolean = isHappy(arg60);\n    var v6 : Boolean = true;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : String = \"\"\"iopaxioi\"\"\"\n    var x7 : Boolean = isHappy(arg70);\n    var v7 : Boolean = false;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n\n}\n", "description": "On vous donne une chaîne de caractères s.\n    Votre tâche est de vérifier si la chaîne est heureuse ou non.\n    Une chaîne est heureuse si sa longueur est d'au moins 3 et que chaque groupe de 3 lettres consécutives est distinct.\n    Par exemple :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/34", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * C'est la dernière semaine du semestre et le professeur doit donner les notes aux étudiants. Le professeur a créé son propre algorithme pour noter. Le seul problème est qu'elle a perdu le code qu'elle utilisait pour noter. Elle vous a donné une liste de GPA pour certains étudiants et vous devez écrire une fonction qui peut produire une liste de notes en utilisant le tableau suivant :\n *              GPA       |    Note\n *               4.0                A+\n *             > 3.7                A \n *             > 3.3                A- \n *             > 3.0                B+\n *             > 2.7                B \n *             > 2.3                B-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                E\n *     \n * \n *     Exemple :\n * \n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n *\n */\nfun numericalLetterGrade(grades : List<Any>) : List<String> {\n", "entry_point": "numericalLetterGrade", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf(4.0, 3, 1.7, 2, 3.5)\n    var x0 : List<String> = numericalLetterGrade(arg00);\n    var v0 : List<String> = mutableListOf(\"\"\"A+\"\"\", \"\"\"B\"\"\", \"\"\"C-\"\"\", \"\"\"C\"\"\", \"\"\"A-\"\"\");\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(1.2)\n    var x1 : List<String> = numericalLetterGrade(arg10);\n    var v1 : List<String> = mutableListOf(\"\"\"D+\"\"\");\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf(0.5)\n    var x2 : List<String> = numericalLetterGrade(arg20);\n    var v2 : List<String> = mutableListOf(\"\"\"D-\"\"\");\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Any> = mutableListOf(0.0)\n    var x3 : List<String> = numericalLetterGrade(arg30);\n    var v3 : List<String> = mutableListOf(\"\"\"E\"\"\");\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Any> = mutableListOf(1, 0.3, 1.5, 2.8, 3.3)\n    var x4 : List<String> = numericalLetterGrade(arg40);\n    var v4 : List<String> = mutableListOf(\"\"\"D\"\"\", \"\"\"D-\"\"\", \"\"\"C-\"\"\", \"\"\"B\"\"\", \"\"\"B+\"\"\");\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Any> = mutableListOf(0, 0.7)\n    var x5 : List<String> = numericalLetterGrade(arg50);\n    var v5 : List<String> = mutableListOf(\"\"\"E\"\"\", \"\"\"D-\"\"\");\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n\n}\n", "description": "C'est la dernière semaine du semestre et le professeur doit donner les notes aux étudiants. Le professeur a créé son propre algorithme pour noter. Le seul problème est qu'elle a perdu le code qu'elle utilisait pour noter. Elle vous a donné une liste de GPA pour certains étudiants et vous devez écrire une fonction qui peut produire une liste de notes en utilisant le tableau suivant :\n             GPA       |    Note\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Exemple :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/35", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Écrivez une fonction qui prend une chaîne de caractères et renvoie True si la longueur de la chaîne est un nombre premier ou False sinon.\n * Exemples\n * \n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n *\n */\nfun primeLength(string : String) : Boolean {\n", "entry_point": "primeLength", "test": "\nfun main() {\n    var arg00 : String = \"\"\"Hello\"\"\"\n    var x0 : Boolean = primeLength(arg00);\n    var v0 : Boolean = true;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"abcdcba\"\"\"\n    var x1 : Boolean = primeLength(arg10);\n    var v1 : Boolean = true;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"kittens\"\"\"\n    var x2 : Boolean = primeLength(arg20);\n    var v2 : Boolean = true;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"orange\"\"\"\n    var x3 : Boolean = primeLength(arg30);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"wow\"\"\"\n    var x4 : Boolean = primeLength(arg40);\n    var v4 : Boolean = true;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"world\"\"\"\n    var x5 : Boolean = primeLength(arg50);\n    var v5 : Boolean = true;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"MadaM\"\"\"\n    var x6 : Boolean = primeLength(arg60);\n    var v6 : Boolean = true;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : String = \"\"\"Wow\"\"\"\n    var x7 : Boolean = primeLength(arg70);\n    var v7 : Boolean = true;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : String = \"\"\"\"\"\"\n    var x8 : Boolean = primeLength(arg80);\n    var v8 : Boolean = false;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : String = \"\"\"HI\"\"\"\n    var x9 : Boolean = primeLength(arg90);\n    var v9 : Boolean = true;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n    var arg100 : String = \"\"\"go\"\"\"\n    var x10 : Boolean = primeLength(arg100);\n    var v10 : Boolean = true;\n    if (x10 != v10) {\n        throw Exception(\"Exception -- test case 10 did not pass. x10 = \" + x10)\n    }\n\n    var arg110 : String = \"\"\"gogo\"\"\"\n    var x11 : Boolean = primeLength(arg110);\n    var v11 : Boolean = false;\n    if (x11 != v11) {\n        throw Exception(\"Exception -- test case 11 did not pass. x11 = \" + x11)\n    }\n\n    var arg120 : String = \"\"\"aaaaaaaaaaaaaaa\"\"\"\n    var x12 : Boolean = primeLength(arg120);\n    var v12 : Boolean = false;\n    if (x12 != v12) {\n        throw Exception(\"Exception -- test case 12 did not pass. x12 = \" + x12)\n    }\n\n    var arg130 : String = \"\"\"Madam\"\"\"\n    var x13 : Boolean = primeLength(arg130);\n    var v13 : Boolean = true;\n    if (x13 != v13) {\n        throw Exception(\"Exception -- test case 13 did not pass. x13 = \" + x13)\n    }\n\n    var arg140 : String = \"\"\"M\"\"\"\n    var x14 : Boolean = primeLength(arg140);\n    var v14 : Boolean = false;\n    if (x14 != v14) {\n        throw Exception(\"Exception -- test case 14 did not pass. x14 = \" + x14)\n    }\n\n    var arg150 : String = \"\"\"0\"\"\"\n    var x15 : Boolean = primeLength(arg150);\n    var v15 : Boolean = false;\n    if (x15 != v15) {\n        throw Exception(\"Exception -- test case 15 did not pass. x15 = \" + x15)\n    }\n\n\n}\n", "description": "Écrivez une fonction qui prend une chaîne de caractères et renvoie True si la longueur de la chaîne est un nombre premier ou False sinon.\nExemples", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/36", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Étant donné un entier positif N, retournez la somme totale de ses chiffres en binaire.\n * \n *     Exemple\n *         Pour N = 1000, la somme des chiffres sera 1, la sortie devrait être \"1\".\n *         Pour N = 150, la somme des chiffres sera 6, la sortie devrait être \"110\".\n *         Pour N = 147, la somme des chiffres sera 12, la sortie devrait être \"1100\".\n *     \n *     Variables:\n *         @N entier\n *              Contraintes : 0 ≤ N ≤ 10000.\n *     Sortie :\n *          une chaîne de nombre binaire\n * \n *\n */\nfun solve(n : Int) : String {\n", "entry_point": "solve", "test": "\nfun main() {\n    var arg00 : Int = 1000\n    var x0 : String = solve(arg00);\n    var v0 : String = \"\"\"1\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 150\n    var x1 : String = solve(arg10);\n    var v1 : String = \"\"\"110\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 147\n    var x2 : String = solve(arg20);\n    var v2 : String = \"\"\"1100\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 333\n    var x3 : String = solve(arg30);\n    var v3 : String = \"\"\"1001\"\"\";\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 963\n    var x4 : String = solve(arg40);\n    var v4 : String = \"\"\"10010\"\"\";\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "Étant donné un entier positif N, retournez la somme totale de ses chiffres en binaire.\n\n    Exemple\n        Pour N = 1000, la somme des chiffres sera 1, la sortie devrait être \"1\".\n        Pour N = 150, la somme des chiffres sera 6, la sortie devrait être \"110\".\n        Pour N = 147, la somme des chiffres sera 12, la sortie devrait être \"1100\".\n    \n    Variables:\n        @N entier\n             Contraintes : 0 ≤ N ≤ 10000.\n    Sortie :\n         une chaîne de nombre binaire", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/37", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * On vous donne des données en deux dimensions, sous forme de listes imbriquées,\n * qui ressemblent à une matrice, mais contrairement aux matrices,\n * chaque ligne peut contenir un nombre différent de colonnes.\n * Étant donné lst et un entier x, trouvez les entiers x dans la liste,\n * et renvoyez une liste de tuples, [(x1, y1), (x2, y2) ...] tels que\n * chaque tuple est une coordonnée - (ligne, colonnes), en commençant par 0.\n * Triez les coordonnées initialement par lignes par ordre croissant.\n * De plus, triez les coordonnées de la ligne par colonnes par ordre décroissant.\n * \n * Exemples :\n * \n * get_row([\n *   [1,2,3,4,5,6],\n *   [1,2,3,4,1,6],\n *   [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n *\n */\nfun getRow(lst : List<Any>, x : Int) : List<Any> {\n", "entry_point": "getRow", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf()\n    var arg01 : Int = 1\n    var x0 : List<Any> = getRow(arg00, arg01);\n    var v0 : List<Any> = mutableListOf();\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(mutableListOf(1))\n    var arg11 : Int = 2\n    var x1 : List<Any> = getRow(arg10, arg11);\n    var v1 : List<Any> = mutableListOf();\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf(mutableListOf(), mutableListOf(1), mutableListOf(1, 2, 3))\n    var arg21 : Int = 3\n    var x2 : List<Any> = getRow(arg20, arg21);\n    var v2 : List<Any> = mutableListOf(mutableListOf(2, 2));\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n\n}\n", "description": "On vous donne des données en deux dimensions, sous forme de listes imbriquées,\nqui ressemblent à une matrice, mais contrairement aux matrices,\nchaque ligne peut contenir un nombre différent de colonnes.\nÉtant donné lst et un entier x, trouvez les entiers x dans la liste,\net renvoyez une liste de tuples, [(x1, y1), (x2, y2) ...] tels que\nchaque tuple est une coordonnée - (ligne, colonnes), en commençant par 0.\nTriez les coordonnées initialement par lignes par ordre croissant.\nDe plus, triez les coordonnées de la ligne par colonnes par ordre décroissant.\n\nExemples :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/38", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Vous disposez d'une liste d'entiers.\n *     Écrivez une fonction next_smallest() qui renvoie le deuxième élément le plus petit de la liste.\n *     Renvoyez null s'il n'y a pas un tel élément.\n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n *\n */\nfun nextSmallest(lst : List<Any>) : Int? {\n", "entry_point": "nextSmallest", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf(1, 2, 3, 4, 5)\n    var x0 : Int? = nextSmallest(arg00);\n    var v0 : Int? = 2;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(5, 1, 4, 3, 2)\n    var x1 : Int? = nextSmallest(arg10);\n    var v1 : Int? = 2;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf()\n    var x2 : Int? = nextSmallest(arg20);\n    var v2 : Int? = null;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Any> = mutableListOf(1, 1)\n    var x3 : Int? = nextSmallest(arg30);\n    var v3 : Int? = null;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Any> = mutableListOf(1, 1, 1, 1, 0)\n    var x4 : Int? = nextSmallest(arg40);\n    var v4 : Int? = 1;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Any> = mutableListOf(1, 1)\n    var x5 : Int? = nextSmallest(arg50);\n    var v5 : Int? = null;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : List<Any> = mutableListOf(-35, 34, 12, -45)\n    var x6 : Int? = nextSmallest(arg60);\n    var v6 : Int? = -35;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "Vous disposez d'une liste d'entiers.\n    Écrivez une fonction next_smallest() qui renvoie le deuxième élément le plus petit de la liste.\n    Renvoyez null s'il n'y a pas un tel élément.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/39", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Vous recevrez une chaîne de mots et votre tâche consiste à compter le nombre d'ennuis. Un ennui est une phrase qui commence par le mot \"Je\". Les phrases sont délimitées par '.', '?' ou '!'.\n * \n * Par exemple:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n *\n */\nfun isBored(s : String) : Int {\n", "entry_point": "isBored", "test": "\nfun main() {\n    var arg00 : String = \"\"\"Hello world\"\"\"\n    var x0 : Int = isBored(arg00);\n    var v0 : Int = 0;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"Is the sky blue?\"\"\"\n    var x1 : Int = isBored(arg10);\n    var v1 : Int = 0;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"I love It !\"\"\"\n    var x2 : Int = isBored(arg20);\n    var v2 : Int = 1;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"bIt\"\"\"\n    var x3 : Int = isBored(arg30);\n    var v3 : Int = 0;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"I feel good today. I will be productive. will kill It\"\"\"\n    var x4 : Int = isBored(arg40);\n    var v4 : Int = 2;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"You and I are going for a walk\"\"\"\n    var x5 : Int = isBored(arg50);\n    var v5 : Int = 0;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n\n}\n", "description": "Vous recevrez une chaîne de mots et votre tâche consiste à compter le nombre d'ennuis. Un ennui est une phrase qui commence par le mot \"Je\". Les phrases sont délimitées par '.', '?' ou '!'.\n\nPar exemple:", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/40", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Vous avez une liste d'entiers.\n *     Vous devez trouver la plus grande valeur première et retourner la somme de ses chiffres.\n * \n *     Exemples:\n * \n * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n * For lst = [0,81,12,3,1,21] the output should be 3\n * For lst = [0,8,1,2,1,7] the output should be 7\n *\n */\nfun skjkasdkd(lst : List<Int>) : Int {\n", "entry_point": "skjkasdkd", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3)\n    var x0 : Int = skjkasdkd(arg00);\n    var v0 : Int = 10;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1)\n    var x1 : Int = skjkasdkd(arg10);\n    var v1 : Int = 25;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3)\n    var x2 : Int = skjkasdkd(arg20);\n    var v2 : Int = 13;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6)\n    var x3 : Int = skjkasdkd(arg30);\n    var v3 : Int = 11;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Int> = mutableListOf(0, 81, 12, 3, 1, 21)\n    var x4 : Int = skjkasdkd(arg40);\n    var v4 : Int = 3;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Int> = mutableListOf(0, 8, 1, 2, 1, 7)\n    var x5 : Int = skjkasdkd(arg50);\n    var v5 : Int = 7;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : List<Int> = mutableListOf(8191)\n    var x6 : Int = skjkasdkd(arg60);\n    var v6 : Int = 19;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : List<Int> = mutableListOf(8191, 123456, 127, 7)\n    var x7 : Int = skjkasdkd(arg70);\n    var v7 : Int = 19;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : List<Int> = mutableListOf(127, 97, 8192)\n    var x8 : Int = skjkasdkd(arg80);\n    var v8 : Int = 10;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n\n}\n", "description": "Vous avez une liste d'entiers.\n    Vous devez trouver la plus grande valeur première et retourner la somme de ses chiffres.\n\n    Exemples:", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/41", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Étant donné un dictionnaire, renvoyer True si toutes les clés sont des chaînes de caractères en minuscules ou toutes les clés sont des chaînes de caractères en majuscules, sinon renvoyer False. La fonction doit renvoyer False si le dictionnaire donné est vide. Exemples :\n * \n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n *\n */\nfun checkDictCase(dict : Map<Any?, Any?>) : Boolean {\n", "entry_point": "checkDictCase", "test": "\nfun main() {\n    var arg00 : Map<Any?, Any?> = mutableMapOf(\"\"\"p\"\"\" to \"\"\"pineapple\"\"\", \"\"\"b\"\"\" to \"\"\"banana\"\"\")\n    var x0 : Boolean = checkDictCase(arg00);\n    var v0 : Boolean = true;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Map<Any?, Any?> = mutableMapOf(\"\"\"p\"\"\" to \"\"\"pineapple\"\"\", \"\"\"A\"\"\" to \"\"\"banana\"\"\", \"\"\"B\"\"\" to \"\"\"banana\"\"\")\n    var x1 : Boolean = checkDictCase(arg10);\n    var v1 : Boolean = false;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Map<Any?, Any?> = mutableMapOf(\"\"\"p\"\"\" to \"\"\"pineapple\"\"\", 5 to \"\"\"banana\"\"\", \"\"\"a\"\"\" to \"\"\"apple\"\"\")\n    var x2 : Boolean = checkDictCase(arg20);\n    var v2 : Boolean = false;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Map<Any?, Any?> = mutableMapOf(\"\"\"Name\"\"\" to \"\"\"John\"\"\", \"\"\"Age\"\"\" to \"\"\"36\"\"\", \"\"\"City\"\"\" to \"\"\"Houston\"\"\")\n    var x3 : Boolean = checkDictCase(arg30);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Map<Any?, Any?> = mutableMapOf(\"\"\"STATE\"\"\" to \"\"\"NC\"\"\", \"\"\"ZIP\"\"\" to \"\"\"12345\"\"\")\n    var x4 : Boolean = checkDictCase(arg40);\n    var v4 : Boolean = true;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Map<Any?, Any?> = mutableMapOf(\"\"\"fruit\"\"\" to \"\"\"Orange\"\"\", \"\"\"taste\"\"\" to \"\"\"Sweet\"\"\")\n    var x5 : Boolean = checkDictCase(arg50);\n    var v5 : Boolean = true;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Map<Any?, Any?> = mutableMapOf()\n    var x6 : Boolean = checkDictCase(arg60);\n    var v6 : Boolean = false;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "Étant donné un dictionnaire, renvoyer True si toutes les clés sont des chaînes de caractères en minuscules ou toutes les clés sont des chaînes de caractères en majuscules, sinon renvoyer False. La fonction doit renvoyer False si le dictionnaire donné est vide. Exemples :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/42", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Créez une fonction qui prend une valeur (chaîne de caractères) représentant un nombre et renvoie l'entier le plus proche. Si le nombre est à égale distance de deux entiers, arrondissez-le à l'entier le plus éloigné de zéro.\n * \n * Exemples\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n\n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n *\n */\nfun closestInteger(value : String) : Int {\n", "entry_point": "closestInteger", "test": "\nfun main() {\n    var arg00 : String = \"\"\"10\"\"\"\n    var x0 : Int = closestInteger(arg00);\n    var v0 : Int = 10;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"14.5\"\"\"\n    var x1 : Int = closestInteger(arg10);\n    var v1 : Int = 15;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"-15.5\"\"\"\n    var x2 : Int = closestInteger(arg20);\n    var v2 : Int = -16;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"15.3\"\"\"\n    var x3 : Int = closestInteger(arg30);\n    var v3 : Int = 15;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"0\"\"\"\n    var x4 : Int = closestInteger(arg40);\n    var v4 : Int = 0;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "Créez une fonction qui prend une valeur (chaîne de caractères) représentant un nombre et renvoie l'entier le plus proche. Si le nombre est à égale distance de deux entiers, arrondissez-le à l'entier le plus éloigné de zéro.\n\nExemples", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/43", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Étant donné un entier positif n, vous devez faire une pile de n niveaux de pierres.\n *     Le premier niveau a n pierres.\n *     Le nombre de pierres dans le niveau suivant est:\n *         - le prochain nombre impair si n est impair.\n *         - le prochain nombre pair si n est pair.\n *     Retournez le nombre de pierres dans chaque niveau dans une liste, où l'élément à l'indice\n *     i représente le nombre de pierres dans le niveau (i+1).\n * \n *     Exemples:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n *\n */\nfun makeAPile(n : Int) : List<Int> {\n", "entry_point": "makeAPile", "test": "\nfun main() {\n    var arg00 : Int = 3\n    var x0 : List<Int> = makeAPile(arg00);\n    var v0 : List<Int> = mutableListOf(3, 5, 7);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 4\n    var x1 : List<Int> = makeAPile(arg10);\n    var v1 : List<Int> = mutableListOf(4, 6, 8, 10);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 5\n    var x2 : List<Int> = makeAPile(arg20);\n    var v2 : List<Int> = mutableListOf(5, 7, 9, 11, 13);\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 6\n    var x3 : List<Int> = makeAPile(arg30);\n    var v3 : List<Int> = mutableListOf(6, 8, 10, 12, 14, 16);\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 8\n    var x4 : List<Int> = makeAPile(arg40);\n    var v4 : List<Int> = mutableListOf(8, 10, 12, 14, 16, 18, 20, 22);\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "Étant donné un entier positif n, vous devez faire une pile de n niveaux de pierres.\n    Le premier niveau a n pierres.\n    Le nombre de pierres dans le niveau suivant est:\n        - le prochain nombre impair si n est impair.\n        - le prochain nombre pair si n est pair.\n    Retournez le nombre de pierres dans chaque niveau dans une liste, où l'élément à l'indice\n    i représente le nombre de pierres dans le niveau (i+1).\n\n    Exemples:", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/44", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Vous recevrez une chaîne de mots séparés par des virgules ou des espaces. Votre tâche est de diviser la chaîne en mots et de renvoyer un tableau des mots.\n * \n * Par exemple:\n * \n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n *\n */\nfun wordsString(s : String) : List<Any> {\n", "entry_point": "wordsString", "test": "\nfun main() {\n    var arg00 : String = \"\"\"Hi, my name is John\"\"\"\n    var x0 : List<Any> = wordsString(arg00);\n    var v0 : List<Any> = mutableListOf(\"\"\"Hi\"\"\", \"\"\"my\"\"\", \"\"\"name\"\"\", \"\"\"is\"\"\", \"\"\"John\"\"\");\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"One, two, three, four, five, six\"\"\"\n    var x1 : List<Any> = wordsString(arg10);\n    var v1 : List<Any> = mutableListOf(\"\"\"One\"\"\", \"\"\"two\"\"\", \"\"\"three\"\"\", \"\"\"four\"\"\", \"\"\"five\"\"\", \"\"\"six\"\"\");\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"Hi, my name\"\"\"\n    var x2 : List<Any> = wordsString(arg20);\n    var v2 : List<Any> = mutableListOf(\"\"\"Hi\"\"\", \"\"\"my\"\"\", \"\"\"name\"\"\");\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"One,, two, three, four, five, six,\"\"\"\n    var x3 : List<Any> = wordsString(arg30);\n    var v3 : List<Any> = mutableListOf(\"\"\"One\"\"\", \"\"\"two\"\"\", \"\"\"three\"\"\", \"\"\"four\"\"\", \"\"\"five\"\"\", \"\"\"six\"\"\");\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"\"\"\"\n    var x4 : List<Any> = wordsString(arg40);\n    var v4 : List<Any> = mutableListOf();\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"ahmed     , gamal\"\"\"\n    var x5 : List<Any> = wordsString(arg50);\n    var v5 : List<Any> = mutableListOf(\"\"\"ahmed\"\"\", \"\"\"gamal\"\"\");\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n\n}\n", "description": "Vous recevrez une chaîne de mots séparés par des virgules ou des espaces. Votre tâche est de diviser la chaîne en mots et de renvoyer un tableau des mots.\n\nPar exemple:", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/45", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Cette fonction prend deux nombres positifs x et y et renvoie le plus grand nombre entier pair qui se trouve dans l'intervalle [x, y] inclus. Si aucun nombre ne répond à cette condition, la fonction doit renvoyer -1.\n * \n * Par exemple :\n * \n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n *\n */\nfun chooseNum(x : Int, y : Int) : Int {\n", "entry_point": "chooseNum", "test": "\nfun main() {\n    var arg00 : Int = 12\n    var arg01 : Int = 15\n    var x0 : Int = chooseNum(arg00, arg01);\n    var v0 : Int = 14;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 13\n    var arg11 : Int = 12\n    var x1 : Int = chooseNum(arg10, arg11);\n    var v1 : Int = -1;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 33\n    var arg21 : Int = 12354\n    var x2 : Int = chooseNum(arg20, arg21);\n    var v2 : Int = 12354;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 5234\n    var arg31 : Int = 5233\n    var x3 : Int = chooseNum(arg30, arg31);\n    var v3 : Int = -1;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 6\n    var arg41 : Int = 29\n    var x4 : Int = chooseNum(arg40, arg41);\n    var v4 : Int = 28;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 27\n    var arg51 : Int = 10\n    var x5 : Int = chooseNum(arg50, arg51);\n    var v5 : Int = -1;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 7\n    var arg61 : Int = 7\n    var x6 : Int = chooseNum(arg60, arg61);\n    var v6 : Int = -1;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : Int = 546\n    var arg71 : Int = 546\n    var x7 : Int = chooseNum(arg70, arg71);\n    var v7 : Int = 546;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n\n}\n", "description": "Cette fonction prend deux nombres positifs x et y et renvoie le plus grand nombre entier pair qui se trouve dans l'intervalle [x, y] inclus. Si aucun nombre ne répond à cette condition, la fonction doit renvoyer -1.\n\nPar exemple :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/46", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * On vous donne deux entiers positifs n et m, et votre tâche est de calculer la moyenne des entiers de n à m (y compris n et m). Arrondissez la réponse à l'entier le plus proche et convertissez-le en binaire. Si n est supérieur à m, retournez -1. Exemple:\n * \n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n *\n */\nfun roundedAvg(n : Int, m : Int) : Any {\n", "entry_point": "roundedAvg", "test": "\nfun main() {\n    var arg00 : Int = 1\n    var arg01 : Int = 5\n    var x0 : Any = roundedAvg(arg00, arg01);\n    var v0 : Any = \"\"\"0b11\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 7\n    var arg11 : Int = 13\n    var x1 : Any = roundedAvg(arg10, arg11);\n    var v1 : Any = \"\"\"0b1010\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 964\n    var arg21 : Int = 977\n    var x2 : Any = roundedAvg(arg20, arg21);\n    var v2 : Any = \"\"\"0b1111001010\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 996\n    var arg31 : Int = 997\n    var x3 : Any = roundedAvg(arg30, arg31);\n    var v3 : Any = \"\"\"0b1111100100\"\"\";\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 560\n    var arg41 : Int = 851\n    var x4 : Any = roundedAvg(arg40, arg41);\n    var v4 : Any = \"\"\"0b1011000010\"\"\";\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 185\n    var arg51 : Int = 546\n    var x5 : Any = roundedAvg(arg50, arg51);\n    var v5 : Any = \"\"\"0b101101110\"\"\";\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 362\n    var arg61 : Int = 496\n    var x6 : Any = roundedAvg(arg60, arg61);\n    var v6 : Any = \"\"\"0b110101101\"\"\";\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : Int = 350\n    var arg71 : Int = 902\n    var x7 : Any = roundedAvg(arg70, arg71);\n    var v7 : Any = \"\"\"0b1001110010\"\"\";\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : Int = 197\n    var arg81 : Int = 233\n    var x8 : Any = roundedAvg(arg80, arg81);\n    var v8 : Any = \"\"\"0b11010111\"\"\";\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : Int = 7\n    var arg91 : Int = 5\n    var x9 : Any = roundedAvg(arg90, arg91);\n    var v9 : Any = -1;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n    var arg100 : Int = 5\n    var arg101 : Int = 1\n    var x10 : Any = roundedAvg(arg100, arg101);\n    var v10 : Any = -1;\n    if (x10 != v10) {\n        throw Exception(\"Exception -- test case 10 did not pass. x10 = \" + x10)\n    }\n\n    var arg110 : Int = 5\n    var arg111 : Int = 5\n    var x11 : Any = roundedAvg(arg110, arg111);\n    var v11 : Any = \"\"\"0b101\"\"\";\n    if (x11 != v11) {\n        throw Exception(\"Exception -- test case 11 did not pass. x11 = \" + x11)\n    }\n\n\n}\n", "description": "On vous donne deux entiers positifs n et m, et votre tâche est de calculer la moyenne des entiers de n à m (y compris n et m). Arrondissez la réponse à l'entier le plus proche et convertissez-le en binaire. Si n est supérieur à m, retournez -1. Exemple:", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/47", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Implémentez la fonction f qui prend n en paramètre et renvoie une liste de taille n, telle que la valeur de l'élément à l'index i soit le factoriel de i si i est pair ou la somme des nombres de 1 à i sinon. i commence à 1. Le factoriel de i est la multiplication des nombres de 1 à i (1 * 2 * ... * i). Exemple :\n * \n * f(5) == [1, 2, 6, 24, 15]\n *\n */\nfun f(n : Int) : List<Int> {\n", "entry_point": "f", "test": "\nfun main() {\n    var arg00 : Int = 5\n    var x0 : List<Int> = f(arg00);\n    var v0 : List<Int> = mutableListOf(1, 2, 6, 24, 15);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 7\n    var x1 : List<Int> = f(arg10);\n    var v1 : List<Int> = mutableListOf(1, 2, 6, 24, 15, 720, 28);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 1\n    var x2 : List<Int> = f(arg20);\n    var v2 : List<Int> = mutableListOf(1);\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 3\n    var x3 : List<Int> = f(arg30);\n    var v3 : List<Int> = mutableListOf(1, 2, 6);\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n\n}\n", "description": "Implémentez la fonction f qui prend n en paramètre et renvoie une liste de taille n, telle que la valeur de l'élément à l'index i soit le factoriel de i si i est pair ou la somme des nombres de 1 à i sinon. i commence à 1. Le factoriel de i est la multiplication des nombres de 1 à i (1 * 2 * ... * i). Exemple :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/48", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Étant donné un entier positif n, renvoyer un tuple qui contient le nombre de nombres palindromes pairs et impairs qui se trouvent dans la plage (1, n), inclus.\n * \n *     Exemple 1:\n * \n *         Entrée: 3\n *         Sortie: (1, 2)\n *         Explication:\n *         Les nombres palindromes sont 1, 2, 3. Un d'entre eux est pair et deux sont impairs.\n * \n *     Exemple 2:\n * \n *         Entrée: 12\n *         Sortie: (4, 6)\n *         Explication:\n *         Les nombres palindromes sont 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Quatre d'entre eux sont pairs et six sont impairs.\n * \n *     Remarque:\n *         1. 1 <= n <= 10^3\n *         2. Le tuple renvoyé contient respectivement le nombre de nombres palindromes pairs et impairs.\n * \n *\n */\nfun evenOddPalindrome(n : Int) : List<Int> {\n", "entry_point": "evenOddPalindrome", "test": "\nfun main() {\n    var arg00 : Int = 123\n    var x0 : List<Int> = evenOddPalindrome(arg00);\n    var v0 : List<Int> = mutableListOf(8, 13);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 12\n    var x1 : List<Int> = evenOddPalindrome(arg10);\n    var v1 : List<Int> = mutableListOf(4, 6);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 3\n    var x2 : List<Int> = evenOddPalindrome(arg20);\n    var v2 : List<Int> = mutableListOf(1, 2);\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 63\n    var x3 : List<Int> = evenOddPalindrome(arg30);\n    var v3 : List<Int> = mutableListOf(6, 8);\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 25\n    var x4 : List<Int> = evenOddPalindrome(arg40);\n    var v4 : List<Int> = mutableListOf(5, 6);\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 19\n    var x5 : List<Int> = evenOddPalindrome(arg50);\n    var v5 : List<Int> = mutableListOf(4, 6);\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 9\n    var x6 : List<Int> = evenOddPalindrome(arg60);\n    var v6 : List<Int> = mutableListOf(4, 5);\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : Int = 1\n    var x7 : List<Int> = evenOddPalindrome(arg70);\n    var v7 : List<Int> = mutableListOf(0, 1);\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n\n}\n", "description": "Étant donné un entier positif n, renvoyer un tuple qui contient le nombre de nombres palindromes pairs et impairs qui se trouvent dans la plage (1, n), inclus.\n\n    Exemple 1:\n\n        Entrée: 3\n        Sortie: (1, 2)\n        Explication:\n        Les nombres palindromes sont 1, 2, 3. Un d'entre eux est pair et deux sont impairs.\n\n    Exemple 2:\n\n        Entrée: 12\n        Sortie: (4, 6)\n        Explication:\n        Les nombres palindromes sont 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Quatre d'entre eux sont pairs et six sont impairs.\n\n    Remarque:\n        1. 1 <= n <= 10^3\n        2. Le tuple renvoyé contient respectivement le nombre de nombres palindromes pairs et impairs.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/49", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Nous avons un tableau 'arr' de N entiers arr[1], arr[2], ..., arr[N]. Les nombres dans le tableau seront dans un ordre aléatoire. Votre tâche est de déterminer s'il est possible d'obtenir un tableau trié dans l'ordre non décroissant en effectuant l'opération suivante sur le tableau donné :\n *         Vous êtes autorisé à effectuer une opération de décalage vers la droite un nombre quelconque de fois.\n *     \n *     Une opération de décalage vers la droite signifie décaler tous les éléments du tableau d'une position vers la droite. Le dernier élément du tableau sera déplacé à la position de départ dans le tableau, c'est-à-dire l'indice 0.\n * \n *     Si il est possible d'obtenir le tableau trié en effectuant l'opération ci-dessus, retournez True sinon retournez False.\n *     Si le tableau donné est vide, retournez True.\n * \n *     Remarque : La liste donnée est garantie d'avoir des éléments uniques.\n * \n *     Par exemple :\n *     \n *     move_one_ball([3, 4, 5, 1, 2])==>True\n *     Explication : En effectuant 2 opérations de décalage vers la droite, l'ordre non décroissant peut être obtenu pour le tableau donné.\n *     move_one_ball([3, 5, 4, 1, 2])==>False\n *     Explication : Il n'est pas possible d'obtenir un ordre non décroissant pour le tableau donné en effectuant un nombre quelconque d'opérations de décalage vers la droite.\n * \n *             \n *\n */\nfun moveOneBall(arr : List<Any>) : Boolean {\n", "entry_point": "moveOneBall", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf(3, 4, 5, 1, 2)\n    var x0 : Boolean = moveOneBall(arg00);\n    var v0 : Boolean = true;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(3, 5, 10, 1, 2)\n    var x1 : Boolean = moveOneBall(arg10);\n    var v1 : Boolean = true;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf(4, 3, 1, 2)\n    var x2 : Boolean = moveOneBall(arg20);\n    var v2 : Boolean = false;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Any> = mutableListOf(3, 5, 4, 1, 2)\n    var x3 : Boolean = moveOneBall(arg30);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Any> = mutableListOf()\n    var x4 : Boolean = moveOneBall(arg40);\n    var v4 : Boolean = true;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "Nous avons un tableau 'arr' de N entiers arr[1], arr[2], ..., arr[N]. Les nombres dans le tableau seront dans un ordre aléatoire. Votre tâche est de déterminer s'il est possible d'obtenir un tableau trié dans l'ordre non décroissant en effectuant l'opération suivante sur le tableau donné :\n        Vous êtes autorisé à effectuer une opération de décalage vers la droite un nombre quelconque de fois.\n    \n    Une opération de décalage vers la droite signifie décaler tous les éléments du tableau d'une position vers la droite. Le dernier élément du tableau sera déplacé à la position de départ dans le tableau, c'est-à-dire l'indice 0.\n\n    Si il est possible d'obtenir le tableau trié en effectuant l'opération ci-dessus, retournez True sinon retournez False.\n    Si le tableau donné est vide, retournez True.\n\n    Remarque : La liste donnée est garantie d'avoir des éléments uniques.\n\n    Par exemple :\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explication : En effectuant 2 opérations de décalage vers la droite, l'ordre non décroissant peut être obtenu pour le tableau donné.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explication : Il n'est pas possible d'obtenir un ordre non décroissant pour le tableau donné en effectuant un nombre quelconque d'opérations de décalage vers la droite.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/50", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Dans ce problème, vous implémenterez une fonction qui prend deux listes de nombres et détermine s'il est possible d'échanger des éléments entre elles pour faire de lst1 une liste de nombres pairs uniquement. Il n'y a pas de limite sur le nombre d'éléments échangés entre lst1 et lst2. Si il est possible d'échanger des éléments entre lst1 et lst2 pour que tous les éléments de lst1 soient pairs, retournez \"YES\". Sinon, retournez \"NO\". Par exemple: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". On suppose que les listes d'entrée ne seront pas vides.\n * \n *\n */\nfun exchange(lst1 : List<Int>, lst2 : List<Int>) : String {\n", "entry_point": "exchange", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(1, 2, 3, 4)\n    var arg01 : List<Int> = mutableListOf(1, 2, 3, 4)\n    var x0 : String = exchange(arg00, arg01);\n    var v0 : String = \"\"\"YES\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(1, 2, 3, 4)\n    var arg11 : List<Int> = mutableListOf(1, 5, 3, 4)\n    var x1 : String = exchange(arg10, arg11);\n    var v1 : String = \"\"\"NO\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(1, 2, 3, 4)\n    var arg21 : List<Int> = mutableListOf(2, 1, 4, 3)\n    var x2 : String = exchange(arg20, arg21);\n    var v2 : String = \"\"\"YES\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(5, 7, 3)\n    var arg31 : List<Int> = mutableListOf(2, 6, 4)\n    var x3 : String = exchange(arg30, arg31);\n    var v3 : String = \"\"\"YES\"\"\";\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Int> = mutableListOf(5, 7, 3)\n    var arg41 : List<Int> = mutableListOf(2, 6, 3)\n    var x4 : String = exchange(arg40, arg41);\n    var v4 : String = \"\"\"NO\"\"\";\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Int> = mutableListOf(3, 2, 6, 1, 8, 9)\n    var arg51 : List<Int> = mutableListOf(3, 5, 5, 1, 1, 1)\n    var x5 : String = exchange(arg50, arg51);\n    var v5 : String = \"\"\"NO\"\"\";\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : List<Int> = mutableListOf(100, 200)\n    var arg61 : List<Int> = mutableListOf(200, 200)\n    var x6 : String = exchange(arg60, arg61);\n    var v6 : String = \"\"\"YES\"\"\";\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "Dans ce problème, vous implémenterez une fonction qui prend deux listes de nombres et détermine s'il est possible d'échanger des éléments entre elles pour faire de lst1 une liste de nombres pairs uniquement. Il n'y a pas de limite sur le nombre d'éléments échangés entre lst1 et lst2. Si il est possible d'échanger des éléments entre lst1 et lst2 pour que tous les éléments de lst1 soient pairs, retournez \"YES\". Sinon, retournez \"NO\". Par exemple: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". On suppose que les listes d'entrée ne seront pas vides.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/51", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Tâche\n *     Nous avons deux chaînes de caractères s et c, vous devez supprimer tous les caractères de s qui sont égaux à n'importe quel caractère de c\n *     puis vérifier si la chaîne résultante est un palindrome.\n *     Une chaîne est appelée palindrome si elle se lit de la même manière de gauche à droite et de droite à gauche.\n *     Vous devez retourner un tuple contenant la chaîne résultante et True/False pour la vérification.\n *     Exemple\n *     Pour s = \"abcde\", c = \"ae\", le résultat devrait être ('bcd',False)\n *     Pour s = \"abcdef\", c = \"b\"  le résultat devrait être ('acdef',False)\n *     Pour s = \"abcdedcba\", c = \"ab\", le résultat devrait être ('cdedc',True)\n * \n *\n */\nfun reverseDelete(s : String, c : String) : List<Any> {\n", "entry_point": "reverseDelete", "test": "\nfun main() {\n    var arg00 : String = \"\"\"abcde\"\"\"\n    var arg01 : String = \"\"\"ae\"\"\"\n    var x0 : List<Any> = reverseDelete(arg00, arg01);\n    var v0 : List<Any> = mutableListOf(\"\"\"bcd\"\"\", false);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"abcdef\"\"\"\n    var arg11 : String = \"\"\"b\"\"\"\n    var x1 : List<Any> = reverseDelete(arg10, arg11);\n    var v1 : List<Any> = mutableListOf(\"\"\"acdef\"\"\", false);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"abcdedcba\"\"\"\n    var arg21 : String = \"\"\"ab\"\"\"\n    var x2 : List<Any> = reverseDelete(arg20, arg21);\n    var v2 : List<Any> = mutableListOf(\"\"\"cdedc\"\"\", true);\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"dwik\"\"\"\n    var arg31 : String = \"\"\"w\"\"\"\n    var x3 : List<Any> = reverseDelete(arg30, arg31);\n    var v3 : List<Any> = mutableListOf(\"\"\"dik\"\"\", false);\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"a\"\"\"\n    var arg41 : String = \"\"\"a\"\"\"\n    var x4 : List<Any> = reverseDelete(arg40, arg41);\n    var v4 : List<Any> = mutableListOf(\"\"\"\"\"\", true);\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"abcdedcba\"\"\"\n    var arg51 : String = \"\"\"\"\"\"\n    var x5 : List<Any> = reverseDelete(arg50, arg51);\n    var v5 : List<Any> = mutableListOf(\"\"\"abcdedcba\"\"\", true);\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"abcdedcba\"\"\"\n    var arg61 : String = \"\"\"v\"\"\"\n    var x6 : List<Any> = reverseDelete(arg60, arg61);\n    var v6 : List<Any> = mutableListOf(\"\"\"abcdedcba\"\"\", true);\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : String = \"\"\"vabba\"\"\"\n    var arg71 : String = \"\"\"v\"\"\"\n    var x7 : List<Any> = reverseDelete(arg70, arg71);\n    var v7 : List<Any> = mutableListOf(\"\"\"abba\"\"\", true);\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : String = \"\"\"mamma\"\"\"\n    var arg81 : String = \"\"\"mia\"\"\"\n    var x8 : List<Any> = reverseDelete(arg80, arg81);\n    var v8 : List<Any> = mutableListOf(\"\"\"\"\"\", true);\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n\n}\n", "description": "Tâche\n    Nous avons deux chaînes de caractères s et c, vous devez supprimer tous les caractères de s qui sont égaux à n'importe quel caractère de c\n    puis vérifier si la chaîne résultante est un palindrome.\n    Une chaîne est appelée palindrome si elle se lit de la même manière de gauche à droite et de droite à gauche.\n    Vous devez retourner un tuple contenant la chaîne résultante et True/False pour la vérification.\n    Exemple\n    Pour s = \"abcde\", c = \"ae\", le résultat devrait être ('bcd',False)\n    Pour s = \"abcdef\", c = \"b\"  le résultat devrait être ('acdef',False)\n    Pour s = \"abcdedcba\", c = \"ab\", le résultat devrait être ('cdedc',True)", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/52", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * On vous donne une grille rectangulaire de puits. Chaque ligne représente un seul puits, et chaque 1 dans une ligne représente une unité d'eau. Chaque puits a un seau correspondant qui peut être utilisé pour extraire de l'eau, et tous les seaux ont la même capacité. Votre tâche est d'utiliser les seaux pour vider les puits. Sortez le nombre de fois que vous devez abaisser les seaux.\n * \n * Exemple 1:\n *     Entrée:\n *         grille : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n *         capacité_du_seau : 1\n *     Sortie: 6\n * \n * Exemple 2:\n *     Entrée:\n *         grille : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n *         capacité_du_seau : 2\n *     Sortie: 5\n * \n * Exemple 3:\n *     Entrée:\n *         grille : [[0,0,0], [0,0,0]]\n *         capacité_du_seau : 5\n *     Sortie: 0\n * \n * Contraintes:\n *     * tous les puits ont la même longueur\n *     * 1 <= grille.longueur <= 10^2\n *     * 1 <= grille[:,1].longueur <= 10^2\n *     * grille[i][j] -> 0 | 1\n *     * 1 <= capacité <= 10\n * \n *\n */\nfun maxFill(grid : List<List<Int>>, capacity : Int) : Int {\n", "entry_point": "maxFill", "test": "\nfun main() {\n    var arg00 : List<List<Int>> = mutableListOf(mutableListOf(0, 0, 1, 0), mutableListOf(0, 1, 0, 0), mutableListOf(1, 1, 1, 1))\n    var arg01 : Int = 1\n    var x0 : Int = maxFill(arg00, arg01);\n    var v0 : Int = 6;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<List<Int>> = mutableListOf(mutableListOf(0, 0, 1, 1), mutableListOf(0, 0, 0, 0), mutableListOf(1, 1, 1, 1), mutableListOf(0, 1, 1, 1))\n    var arg11 : Int = 2\n    var x1 : Int = maxFill(arg10, arg11);\n    var v1 : Int = 5;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<List<Int>> = mutableListOf(mutableListOf(0, 0, 0), mutableListOf(0, 0, 0))\n    var arg21 : Int = 5\n    var x2 : Int = maxFill(arg20, arg21);\n    var v2 : Int = 0;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<List<Int>> = mutableListOf(mutableListOf(1, 1, 1, 1), mutableListOf(1, 1, 1, 1))\n    var arg31 : Int = 2\n    var x3 : Int = maxFill(arg30, arg31);\n    var v3 : Int = 4;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<List<Int>> = mutableListOf(mutableListOf(1, 1, 1, 1), mutableListOf(1, 1, 1, 1))\n    var arg41 : Int = 9\n    var x4 : Int = maxFill(arg40, arg41);\n    var v4 : Int = 2;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "On vous donne une grille rectangulaire de puits. Chaque ligne représente un seul puits, et chaque 1 dans une ligne représente une unité d'eau. Chaque puits a un seau correspondant qui peut être utilisé pour extraire de l'eau, et tous les seaux ont la même capacité. Votre tâche est d'utiliser les seaux pour vider les puits. Sortez le nombre de fois que vous devez abaisser les seaux.\n\nExemple 1:\n    Entrée:\n        grille : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        capacité_du_seau : 1\n    Sortie: 6\n\nExemple 2:\n    Entrée:\n        grille : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        capacité_du_seau : 2\n    Sortie: 5\n\nExemple 3:\n    Entrée:\n        grille : [[0,0,0], [0,0,0]]\n        capacité_du_seau : 5\n    Sortie: 0\n\nContraintes:\n    * tous les puits ont la même longueur\n    * 1 <= grille.longueur <= 10^2\n    * 1 <= grille[:,1].longueur <= 10^2\n    * grille[i][j] -> 0 | 1\n    * 1 <= capacité <= 10", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/53", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Étant donné une chaîne de caractères s et un nombre naturel n, vous avez été chargé d'implémenter une fonction qui renvoie une liste de tous les mots de la chaîne s qui contiennent exactement n consonnes, dans l'ordre où ces mots apparaissent dans la chaîne s. Si la chaîne s est vide, la fonction doit renvoyer une liste vide. Remarque : vous pouvez supposer que la chaîne d'entrée ne contient que des lettres et des espaces. Exemples :\n * \n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n *\n */\nfun selectWords(s : String, n : Int) : List<Any> {\n", "entry_point": "selectWords", "test": "\nfun main() {\n    var arg00 : String = \"\"\"Mary had a little lamb\"\"\"\n    var arg01 : Int = 4\n    var x0 : List<Any> = selectWords(arg00, arg01);\n    var v0 : List<Any> = mutableListOf(\"\"\"little\"\"\");\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"Mary had a little lamb\"\"\"\n    var arg11 : Int = 3\n    var x1 : List<Any> = selectWords(arg10, arg11);\n    var v1 : List<Any> = mutableListOf(\"\"\"Mary\"\"\", \"\"\"lamb\"\"\");\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"simple white space\"\"\"\n    var arg21 : Int = 2\n    var x2 : List<Any> = selectWords(arg20, arg21);\n    var v2 : List<Any> = mutableListOf();\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"Hello world\"\"\"\n    var arg31 : Int = 4\n    var x3 : List<Any> = selectWords(arg30, arg31);\n    var v3 : List<Any> = mutableListOf(\"\"\"world\"\"\");\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"Uncle sam\"\"\"\n    var arg41 : Int = 3\n    var x4 : List<Any> = selectWords(arg40, arg41);\n    var v4 : List<Any> = mutableListOf(\"\"\"Uncle\"\"\");\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"\"\"\"\n    var arg51 : Int = 4\n    var x5 : List<Any> = selectWords(arg50, arg51);\n    var v5 : List<Any> = mutableListOf();\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"a b c d e f\"\"\"\n    var arg61 : Int = 1\n    var x6 : List<Any> = selectWords(arg60, arg61);\n    var v6 : List<Any> = mutableListOf(\"\"\"b\"\"\", \"\"\"c\"\"\", \"\"\"d\"\"\", \"\"\"f\"\"\");\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "Étant donné une chaîne de caractères s et un nombre naturel n, vous avez été chargé d'implémenter une fonction qui renvoie une liste de tous les mots de la chaîne s qui contiennent exactement n consonnes, dans l'ordre où ces mots apparaissent dans la chaîne s. Si la chaîne s est vide, la fonction doit renvoyer une liste vide. Remarque : vous pouvez supposer que la chaîne d'entrée ne contient que des lettres et des espaces. Exemples :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/54", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Étant donné un tableau arr d'entiers et un entier positif k, renvoyer une liste triée de longueur k avec les k nombres maximum dans arr.\n * \n *     Exemple 1:\n * \n *         Input: arr = [-3, -4, 5], k = 3\n *         Output: [-4, -3, 5]\n * \n *     Exemple 2:\n * \n *         Input: arr = [4, -4, 4], k = 2\n *         Output: [4, 4]\n * \n *     Exemple 3:\n * \n *         Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n *         Output: [2]\n * \n *     Note:\n *         1. La longueur du tableau sera dans la plage de [1, 1000].\n *         2. Les éléments du tableau seront dans la plage de [-1000, 1000].\n *         3. 0 <= k <= len(arr)\n * \n *\n */\nfun maximum(arr : List<Int>, k : Int) : List<Any> {\n", "entry_point": "maximum", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(-3, -4, 5)\n    var arg01 : Int = 3\n    var x0 : List<Any> = maximum(arg00, arg01);\n    var v0 : List<Any> = mutableListOf(-4, -3, 5);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(4, -4, 4)\n    var arg11 : Int = 2\n    var x1 : List<Any> = maximum(arg10, arg11);\n    var v1 : List<Any> = mutableListOf(4, 4);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(-3, 2, 1, 2, -1, -2, 1)\n    var arg21 : Int = 1\n    var x2 : List<Any> = maximum(arg20, arg21);\n    var v2 : List<Any> = mutableListOf(2);\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(123, -123, 20, 0, 1, 2, -3)\n    var arg31 : Int = 3\n    var x3 : List<Any> = maximum(arg30, arg31);\n    var v3 : List<Any> = mutableListOf(2, 20, 123);\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Int> = mutableListOf(-123, 20, 0, 1, 2, -3)\n    var arg41 : Int = 4\n    var x4 : List<Any> = maximum(arg40, arg41);\n    var v4 : List<Any> = mutableListOf(0, 1, 2, 20);\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Int> = mutableListOf(5, 15, 0, 3, -13, -8, 0)\n    var arg51 : Int = 7\n    var x5 : List<Any> = maximum(arg50, arg51);\n    var v5 : List<Any> = mutableListOf(-13, -8, 0, 0, 3, 5, 15);\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : List<Int> = mutableListOf(-1, 0, 2, 5, 3, -10)\n    var arg61 : Int = 2\n    var x6 : List<Any> = maximum(arg60, arg61);\n    var v6 : List<Any> = mutableListOf(3, 5);\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : List<Int> = mutableListOf(1, 0, 5, -7)\n    var arg71 : Int = 1\n    var x7 : List<Any> = maximum(arg70, arg71);\n    var v7 : List<Any> = mutableListOf(5);\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : List<Int> = mutableListOf(4, -4)\n    var arg81 : Int = 2\n    var x8 : List<Any> = maximum(arg80, arg81);\n    var v8 : List<Any> = mutableListOf(-4, 4);\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : List<Int> = mutableListOf(-10, 10)\n    var arg91 : Int = 2\n    var x9 : List<Any> = maximum(arg90, arg91);\n    var v9 : List<Any> = mutableListOf(-10, 10);\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n    var arg100 : List<Int> = mutableListOf(1, 2, 3, -23, 243, -400, 0)\n    var arg101 : Int = 0\n    var x10 : List<Any> = maximum(arg100, arg101);\n    var v10 : List<Any> = mutableListOf();\n    if (x10 != v10) {\n        throw Exception(\"Exception -- test case 10 did not pass. x10 = \" + x10)\n    }\n\n\n}\n", "description": "Étant donné un tableau arr d'entiers et un entier positif k, renvoyer une liste triée de longueur k avec les k nombres maximum dans arr.\n\n    Exemple 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Exemple 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Exemple 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. La longueur du tableau sera dans la plage de [1, 1000].\n        2. Les éléments du tableau seront dans la plage de [-1000, 1000].\n        3. 0 <= k <= len(arr)", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/55", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Étant donné un tableau non vide d'entiers arr et un entier k, retournez la somme des éléments ayant au plus deux chiffres parmi les k premiers éléments de arr.\n * \n * Exemple :\n * \n *     Entrée : arr = [111,21,3,4000,5,6,7,8,9], k = 4\n *     Sortie : 24 # somme de 21 + 3\n * \n * Contraintes :\n *     1. 1 <= len(arr) <= 100\n *     2. 1 <= k <= len(arr)\n * \n *\n */\nfun addElements(arr : List<Int>, k : Int) : Int {\n", "entry_point": "addElements", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(1, -2, -3, 41, 57, 76, 87, 88, 99)\n    var arg01 : Int = 3\n    var x0 : Int = addElements(arg00, arg01);\n    var v0 : Int = -4;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(111, 121, 3, 4000, 5, 6)\n    var arg11 : Int = 2\n    var x1 : Int = addElements(arg10, arg11);\n    var v1 : Int = 0;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(11, 21, 3, 90, 5, 6, 7, 8, 9)\n    var arg21 : Int = 4\n    var x2 : Int = addElements(arg20, arg21);\n    var v2 : Int = 125;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(111, 21, 3, 4000, 5, 6, 7, 8, 9)\n    var arg31 : Int = 4\n    var x3 : Int = addElements(arg30, arg31);\n    var v3 : Int = 24;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Int> = mutableListOf(1)\n    var arg41 : Int = 1\n    var x4 : Int = addElements(arg40, arg41);\n    var v4 : Int = 1;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "Étant donné un tableau non vide d'entiers arr et un entier k, retournez la somme des éléments ayant au plus deux chiffres parmi les k premiers éléments de arr.\n\nExemple :\n\n    Entrée : arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Sortie : 24 # somme de 21 + 3\n\nContraintes :\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/56", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * On vous donne deux intervalles,\n *     où chaque intervalle est une paire d'entiers. Par exemple, intervalle = (début, fin) = (1, 2).\n *     Les intervalles donnés sont fermés, ce qui signifie que l'intervalle (début, fin)\n *     inclut à la fois le début et la fin.\n *     Pour chaque intervalle donné, on suppose que son début est inférieur ou égal à sa fin.\n *     Votre tâche est de déterminer si la longueur de l'intersection de ces deux\n *     intervalles est un nombre premier.\n *     Par exemple, l'intersection des intervalles (1, 3), (2, 4) est (2, 3)\n *     dont la longueur est 1, qui n'est pas un nombre premier.\n *     Si la longueur de l'intersection est un nombre premier, renvoyez \"YES\",\n *     sinon, renvoyez \"NO\".\n *     Si les deux intervalles ne se croisent pas, renvoyez \"NO\".\n * \n * \n *     [entrée/sortie] exemples:\n * \n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n *\n */\nfun intersection(interval1 : List<Int>, interval2 : List<Int>) : String {\n", "entry_point": "intersection", "test": "\nfun main() {\n    var arg00 : List<Int> = mutableListOf(1, 2)\n    var arg01 : List<Int> = mutableListOf(2, 3)\n    var x0 : String = intersection(arg00, arg01);\n    var v0 : String = \"\"\"NO\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Int> = mutableListOf(-1, 1)\n    var arg11 : List<Int> = mutableListOf(0, 4)\n    var x1 : String = intersection(arg10, arg11);\n    var v1 : String = \"\"\"NO\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Int> = mutableListOf(-3, -1)\n    var arg21 : List<Int> = mutableListOf(-5, 5)\n    var x2 : String = intersection(arg20, arg21);\n    var v2 : String = \"\"\"YES\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Int> = mutableListOf(-2, 2)\n    var arg31 : List<Int> = mutableListOf(-4, 0)\n    var x3 : String = intersection(arg30, arg31);\n    var v3 : String = \"\"\"YES\"\"\";\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Int> = mutableListOf(-11, 2)\n    var arg41 : List<Int> = mutableListOf(-1, -1)\n    var x4 : String = intersection(arg40, arg41);\n    var v4 : String = \"\"\"NO\"\"\";\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Int> = mutableListOf(1, 2)\n    var arg51 : List<Int> = mutableListOf(3, 5)\n    var x5 : String = intersection(arg50, arg51);\n    var v5 : String = \"\"\"NO\"\"\";\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : List<Int> = mutableListOf(1, 2)\n    var arg61 : List<Int> = mutableListOf(1, 2)\n    var x6 : String = intersection(arg60, arg61);\n    var v6 : String = \"\"\"NO\"\"\";\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : List<Int> = mutableListOf(-2, -2)\n    var arg71 : List<Int> = mutableListOf(-3, -2)\n    var x7 : String = intersection(arg70, arg71);\n    var v7 : String = \"\"\"NO\"\"\";\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n\n}\n", "description": "On vous donne deux intervalles,\n    où chaque intervalle est une paire d'entiers. Par exemple, intervalle = (début, fin) = (1, 2).\n    Les intervalles donnés sont fermés, ce qui signifie que l'intervalle (début, fin)\n    inclut à la fois le début et la fin.\n    Pour chaque intervalle donné, on suppose que son début est inférieur ou égal à sa fin.\n    Votre tâche est de déterminer si la longueur de l'intersection de ces deux\n    intervalles est un nombre premier.\n    Par exemple, l'intersection des intervalles (1, 3), (2, 4) est (2, 3)\n    dont la longueur est 1, qui n'est pas un nombre premier.\n    Si la longueur de l'intersection est un nombre premier, renvoyez \"YES\",\n    sinon, renvoyez \"NO\".\n    Si les deux intervalles ne se croisent pas, renvoyez \"NO\".\n\n\n    [entrée/sortie] exemples:", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/57", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Tout le monde connaît la suite de Fibonacci, qui a été étudiée en profondeur par les mathématiciens au cours des derniers siècles. Cependant, ce que les gens ne savent pas, c'est la suite de Tribonacci. La suite de Tribonacci est définie par la récurrence :\n * tri(1) = 3\n * tri(n) = 1 + n / 2, si n est pair.\n * tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n est impair.\n * Par exemple :\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n * = 2 + 3 + 3 = 8\n * Vous avez un nombre entier non négatif n, vous devez retourner une liste des n + 1 premiers nombres de la suite de Tribonacci.\n * Exemples :\n * tri(3) = [1, 3, 2, 8]\n * \n *\n */\nfun tri(n : Int) : List<Any> {\n", "entry_point": "tri", "test": "\nfun main() {\n    var arg00 : Int = 3\n    var x0 : List<Any> = tri(arg00);\n    var v0 : List<Any> = mutableListOf(1, 3, 2.0, 8.0);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 4\n    var x1 : List<Any> = tri(arg10);\n    var v1 : List<Any> = mutableListOf(1, 3, 2.0, 8.0, 3.0);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 5\n    var x2 : List<Any> = tri(arg20);\n    var v2 : List<Any> = mutableListOf(1, 3, 2.0, 8.0, 3.0, 15.0);\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 6\n    var x3 : List<Any> = tri(arg30);\n    var v3 : List<Any> = mutableListOf(1, 3, 2.0, 8.0, 3.0, 15.0, 4.0);\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 7\n    var x4 : List<Any> = tri(arg40);\n    var v4 : List<Any> = mutableListOf(1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0);\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 8\n    var x5 : List<Any> = tri(arg50);\n    var v5 : List<Any> = mutableListOf(1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0);\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 9\n    var x6 : List<Any> = tri(arg60);\n    var v6 : List<Any> = mutableListOf(1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0);\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : Int = 20\n    var x7 : List<Any> = tri(arg70);\n    var v7 : List<Any> = mutableListOf(1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0);\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : Int = 0\n    var x8 : List<Any> = tri(arg80);\n    var v8 : List<Any> = mutableListOf(1);\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : Int = 1\n    var x9 : List<Any> = tri(arg90);\n    var v9 : List<Any> = mutableListOf(1, 3);\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n\n}\n", "description": "Tout le monde connaît la suite de Fibonacci, qui a été étudiée en profondeur par les mathématiciens au cours des derniers siècles. Cependant, ce que les gens ne savent pas, c'est la suite de Tribonacci. La suite de Tribonacci est définie par la récurrence :\ntri(1) = 3\ntri(n) = 1 + n / 2, si n est pair.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n est impair.\nPar exemple :\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nVous avez un nombre entier non négatif n, vous devez retourner une liste des n + 1 premiers nombres de la suite de Tribonacci.\nExemples :\ntri(3) = [1, 3, 2, 8]", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/58", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Étant donné un entier positif n, renvoyer le produit des chiffres impairs.\n *     Renvoyer 0 si tous les chiffres sont pairs.\n *     Par exemple:\n * \n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n *\n */\nfun digits(n : Int) : Int {\n", "entry_point": "digits", "test": "\nfun main() {\n    var arg00 : Int = 5\n    var x0 : Int = digits(arg00);\n    var v0 : Int = 5;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 54\n    var x1 : Int = digits(arg10);\n    var v1 : Int = 5;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 120\n    var x2 : Int = digits(arg20);\n    var v2 : Int = 1;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 5014\n    var x3 : Int = digits(arg30);\n    var v3 : Int = 5;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 98765\n    var x4 : Int = digits(arg40);\n    var v4 : Int = 315;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 5576543\n    var x5 : Int = digits(arg50);\n    var v5 : Int = 2625;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 2468\n    var x6 : Int = digits(arg60);\n    var v6 : Int = 0;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "Étant donné un entier positif n, renvoyer le produit des chiffres impairs.\n    Renvoyer 0 si tous les chiffres sont pairs.\n    Par exemple:", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/59", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Créez une fonction qui prend une chaîne de caractères en entrée contenant uniquement des crochets carrés.\n * La fonction doit renvoyer True si et seulement s'il existe une sous-séquence valide de crochets où au moins un crochet dans la sous-séquence est imbriqué.\n * is_nested('[[]]') ➞ True\n * is_nested('[]]]]]]][[[[[]') ➞ False\n * is_nested('[][]') ➞ False\n * is_nested('[]') ➞ False\n * is_nested('[[][]]') ➞ True\n * is_nested('[[]][[') ➞ True\n *\n */\nfun isNested(string : String) : Boolean {\n", "entry_point": "isNested", "test": "\nfun main() {\n    var arg00 : String = \"\"\"[[]]\"\"\"\n    var x0 : Boolean = isNested(arg00);\n    var v0 : Boolean = true;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"[]]]]]]][[[[[]\"\"\"\n    var x1 : Boolean = isNested(arg10);\n    var v1 : Boolean = false;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"[][]\"\"\"\n    var x2 : Boolean = isNested(arg20);\n    var v2 : Boolean = false;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"[]\"\"\"\n    var x3 : Boolean = isNested(arg30);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"[[[[]]]]\"\"\"\n    var x4 : Boolean = isNested(arg40);\n    var v4 : Boolean = true;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"[]]]]]]]]]]\"\"\"\n    var x5 : Boolean = isNested(arg50);\n    var v5 : Boolean = false;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"[][][[]]\"\"\"\n    var x6 : Boolean = isNested(arg60);\n    var v6 : Boolean = true;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : String = \"\"\"[[]\"\"\"\n    var x7 : Boolean = isNested(arg70);\n    var v7 : Boolean = false;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : String = \"\"\"[]]\"\"\"\n    var x8 : Boolean = isNested(arg80);\n    var v8 : Boolean = false;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : String = \"\"\"[[]][[\"\"\"\n    var x9 : Boolean = isNested(arg90);\n    var v9 : Boolean = true;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n    var arg100 : String = \"\"\"[[][]]\"\"\"\n    var x10 : Boolean = isNested(arg100);\n    var v10 : Boolean = true;\n    if (x10 != v10) {\n        throw Exception(\"Exception -- test case 10 did not pass. x10 = \" + x10)\n    }\n\n    var arg110 : String = \"\"\"\"\"\"\n    var x11 : Boolean = isNested(arg110);\n    var v11 : Boolean = false;\n    if (x11 != v11) {\n        throw Exception(\"Exception -- test case 11 did not pass. x11 = \" + x11)\n    }\n\n    var arg120 : String = \"\"\"[[[[[[[[\"\"\"\n    var x12 : Boolean = isNested(arg120);\n    var v12 : Boolean = false;\n    if (x12 != v12) {\n        throw Exception(\"Exception -- test case 12 did not pass. x12 = \" + x12)\n    }\n\n    var arg130 : String = \"\"\"]]]]]]]]\"\"\"\n    var x13 : Boolean = isNested(arg130);\n    var v13 : Boolean = false;\n    if (x13 != v13) {\n        throw Exception(\"Exception -- test case 13 did not pass. x13 = \" + x13)\n    }\n\n\n}\n", "description": "Créez une fonction qui prend une chaîne de caractères en entrée contenant uniquement des crochets carrés.\nLa fonction doit renvoyer True si et seulement s'il existe une sous-séquence valide de crochets où au moins un crochet dans la sous-séquence est imbriqué.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/60", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Vous avez une liste de nombres.\n * Vous devez retourner la somme des carrés des nombres dans la liste donnée,\n * arrondir chaque élément de la liste à l'entier supérieur (plafond) d'abord.\n * Exemples:\n * Pour lst = [1,2,3], la sortie devrait être 14\n * Pour lst = [1,4,9], la sortie devrait être 98\n * Pour lst = [1,3,5,7], la sortie devrait être 84\n * Pour lst = [1.4,4.2,0], la sortie devrait être 29\n * Pour lst = [-2.4,1,1], la sortie devrait être 6\n * \n * \n\n *\n */\nfun sumSquares(lst : List<Any>) : Int {\n", "entry_point": "sumSquares", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf(1, 2, 3)\n    var x0 : Int = sumSquares(arg00);\n    var v0 : Int = 14;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(1.0, 2, 3)\n    var x1 : Int = sumSquares(arg10);\n    var v1 : Int = 14;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf(1, 3, 5, 7)\n    var x2 : Int = sumSquares(arg20);\n    var v2 : Int = 84;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Any> = mutableListOf(1.4, 4.2, 0)\n    var x3 : Int = sumSquares(arg30);\n    var v3 : Int = 29;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Any> = mutableListOf(-2.4, 1, 1)\n    var x4 : Int = sumSquares(arg40);\n    var v4 : Int = 6;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Any> = mutableListOf(100, 1, 15, 2)\n    var x5 : Int = sumSquares(arg50);\n    var v5 : Int = 10230;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : List<Any> = mutableListOf(10000, 10000)\n    var x6 : Int = sumSquares(arg60);\n    var v6 : Int = 200000000;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : List<Any> = mutableListOf(-1.4, 4.6, 6.3)\n    var x7 : Int = sumSquares(arg70);\n    var v7 : Int = 75;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : List<Any> = mutableListOf(-1.4, 17.9, 18.9, 19.9)\n    var x8 : Int = sumSquares(arg80);\n    var v8 : Int = 1086;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : List<Any> = mutableListOf(0)\n    var x9 : Int = sumSquares(arg90);\n    var v9 : Int = 0;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n    var arg100 : List<Any> = mutableListOf(-1)\n    var x10 : Int = sumSquares(arg100);\n    var v10 : Int = 1;\n    if (x10 != v10) {\n        throw Exception(\"Exception -- test case 10 did not pass. x10 = \" + x10)\n    }\n\n    var arg110 : List<Any> = mutableListOf(-1, 1, 0)\n    var x11 : Int = sumSquares(arg110);\n    var v11 : Int = 2;\n    if (x11 != v11) {\n        throw Exception(\"Exception -- test case 11 did not pass. x11 = \" + x11)\n    }\n\n\n}\n", "description": "Vous avez une liste de nombres.\nVous devez retourner la somme des carrés des nombres dans la liste donnée,\narrondir chaque élément de la liste à l'entier supérieur (plafond) d'abord.\nExemples:\nPour lst = [1,2,3], la sortie devrait être 14\nPour lst = [1,4,9], la sortie devrait être 98\nPour lst = [1,3,5,7], la sortie devrait être 84\nPour lst = [1.4,4.2,0], la sortie devrait être 29\nPour lst = [-2.4,1,1], la sortie devrait être 6", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/61", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Créez une fonction qui renvoie True si le dernier caractère d'une chaîne donnée est un caractère alphabétique et ne fait pas partie d'un mot, et False sinon.\n *     Remarque: un \"mot\" est un groupe de caractères séparés par un espace.\n * \n *     Exemples:\n * \n * check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n * check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n * check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n * check_if_last_char_is_a_letter(\"\") ➞ False \n *\n */\nfun checkIfLastCharIsALetter(txt : String) : Boolean {\n", "entry_point": "checkIfLastCharIsALetter", "test": "\nfun main() {\n    var arg00 : String = \"\"\"apple\"\"\"\n    var x0 : Boolean = checkIfLastCharIsALetter(arg00);\n    var v0 : Boolean = false;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"apple pi e\"\"\"\n    var x1 : Boolean = checkIfLastCharIsALetter(arg10);\n    var v1 : Boolean = true;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"eeeee\"\"\"\n    var x2 : Boolean = checkIfLastCharIsALetter(arg20);\n    var v2 : Boolean = false;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"A\"\"\"\n    var x3 : Boolean = checkIfLastCharIsALetter(arg30);\n    var v3 : Boolean = true;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"Pumpkin pie \"\"\"\n    var x4 : Boolean = checkIfLastCharIsALetter(arg40);\n    var v4 : Boolean = false;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"Pumpkin pie 1\"\"\"\n    var x5 : Boolean = checkIfLastCharIsALetter(arg50);\n    var v5 : Boolean = false;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"\"\"\"\n    var x6 : Boolean = checkIfLastCharIsALetter(arg60);\n    var v6 : Boolean = false;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : String = \"\"\"eeeee e \"\"\"\n    var x7 : Boolean = checkIfLastCharIsALetter(arg70);\n    var v7 : Boolean = false;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : String = \"\"\"apple pie\"\"\"\n    var x8 : Boolean = checkIfLastCharIsALetter(arg80);\n    var v8 : Boolean = false;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : String = \"\"\"apple pi e \"\"\"\n    var x9 : Boolean = checkIfLastCharIsALetter(arg90);\n    var v9 : Boolean = false;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n\n}\n", "description": "Créez une fonction qui renvoie True si le dernier caractère d'une chaîne donnée est un caractère alphabétique et ne fait pas partie d'un mot, et False sinon.\n    Remarque: un \"mot\" est un groupe de caractères séparés par un espace.\n\n    Exemples:", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/62", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Créez une fonction qui renvoie l'indice le plus grand d'un élément qui n'est pas supérieur ou égal à l'élément immédiatement précédent. Si aucun tel élément n'existe, retournez -1. Le tableau donné ne contiendra pas de valeurs en double.\n * \n * Exemples :\n * \n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n *\n */\nfun canArrange(arr : List<Any>) : Int {\n", "entry_point": "canArrange", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf(1, 2, 4, 3, 5)\n    var x0 : Int = canArrange(arg00);\n    var v0 : Int = 3;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(1, 2, 4, 5)\n    var x1 : Int = canArrange(arg10);\n    var v1 : Int = -1;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf(1, 4, 2, 5, 6, 7, 8, 9, 10)\n    var x2 : Int = canArrange(arg20);\n    var v2 : Int = 2;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Any> = mutableListOf(4, 8, 5, 7, 3)\n    var x3 : Int = canArrange(arg30);\n    var v3 : Int = 4;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Any> = mutableListOf()\n    var x4 : Int = canArrange(arg40);\n    var v4 : Int = -1;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n\n}\n", "description": "Créez une fonction qui renvoie l'indice le plus grand d'un élément qui n'est pas supérieur ou égal à l'élément immédiatement précédent. Si aucun tel élément n'existe, retournez -1. Le tableau donné ne contiendra pas de valeurs en double.\n\nExemples :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/63", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Créez une fonction qui renvoie un tuple (a, b), où 'a' est le plus grand des entiers négatifs et 'b' est le plus petit des entiers positifs dans une liste. Si aucun entier négatif ou positif n'est présent, renvoyez-les comme None.\n * \n * Exemples :\n * \n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n *\n */\nfun largestSmallestIntegers(lst : List<Any>) : List<Int?> {\n", "entry_point": "largestSmallestIntegers", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf(2, 4, 1, 3, 5, 7)\n    var x0 : List<Int?> = largestSmallestIntegers(arg00);\n    var v0 : List<Int?> = mutableListOf(null, 1);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(2, 4, 1, 3, 5, 7, 0)\n    var x1 : List<Int?> = largestSmallestIntegers(arg10);\n    var v1 : List<Int?> = mutableListOf(null, 1);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf(1, 3, 2, 4, 5, 6, -2)\n    var x2 : List<Int?> = largestSmallestIntegers(arg20);\n    var v2 : List<Int?> = mutableListOf(-2, 1);\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Any> = mutableListOf(4, 5, 3, 6, 2, 7, -7)\n    var x3 : List<Int?> = largestSmallestIntegers(arg30);\n    var v3 : List<Int?> = mutableListOf(-7, 2);\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Any> = mutableListOf(7, 3, 8, 4, 9, 2, 5, -9)\n    var x4 : List<Int?> = largestSmallestIntegers(arg40);\n    var v4 : List<Int?> = mutableListOf(-9, 2);\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Any> = mutableListOf()\n    var x5 : List<Int?> = largestSmallestIntegers(arg50);\n    var v5 : List<Int?> = mutableListOf(null, null);\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : List<Any> = mutableListOf(0)\n    var x6 : List<Int?> = largestSmallestIntegers(arg60);\n    var v6 : List<Int?> = mutableListOf(null, null);\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : List<Any> = mutableListOf(-1, -3, -5, -6)\n    var x7 : List<Int?> = largestSmallestIntegers(arg70);\n    var v7 : List<Int?> = mutableListOf(-1, null);\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : List<Any> = mutableListOf(-1, -3, -5, -6, 0)\n    var x8 : List<Int?> = largestSmallestIntegers(arg80);\n    var v8 : List<Int?> = mutableListOf(-1, null);\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : List<Any> = mutableListOf(-6, -4, -4, -3, 1)\n    var x9 : List<Int?> = largestSmallestIntegers(arg90);\n    var v9 : List<Int?> = mutableListOf(-3, 1);\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n    var arg100 : List<Any> = mutableListOf(-6, -4, -4, -3, -100, 1)\n    var x10 : List<Int?> = largestSmallestIntegers(arg100);\n    var v10 : List<Int?> = mutableListOf(-3, 1);\n    if (x10 != v10) {\n        throw Exception(\"Exception -- test case 10 did not pass. x10 = \" + x10)\n    }\n\n\n}\n", "description": "Créez une fonction qui renvoie un tuple (a, b), où 'a' est le plus grand des entiers négatifs et 'b' est le plus petit des entiers positifs dans une liste. Si aucun entier négatif ou positif n'est présent, renvoyez-les comme None.\n\nExemples :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/64", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Le factoriel brésilien est défini comme suit :\n *     factoriel_bresilien(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     où n > 0\n * \n *     Par exemple :\n * >>> special_factorial(4)\n * 288\n\n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n *\n */\nfun specialFactorial(n : Int) : Int {\n", "entry_point": "specialFactorial", "test": "\nfun main() {\n    var arg00 : Int = 4\n    var x0 : Int = specialFactorial(arg00);\n    var v0 : Int = 288;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 5\n    var x1 : Int = specialFactorial(arg10);\n    var v1 : Int = 34560;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 7\n    var x2 : Int = specialFactorial(arg20);\n    var v2 : Int = 125411328000;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 1\n    var x3 : Int = specialFactorial(arg30);\n    var v3 : Int = 1;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n\n}\n", "description": "Le factoriel brésilien est défini comme suit :\n    factoriel_bresilien(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    où n > 0\n\n    Par exemple :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/65", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * On vous donne une chaîne de caractères représentant une phrase,\n *     la phrase contient des mots séparés par un espace,\n *     et vous devez retourner une chaîne de caractères qui contient les mots de la phrase originale,\n *     dont les longueurs sont des nombres premiers,\n *     l'ordre des mots dans la nouvelle chaîne doit être le même que celui de la phrase originale.\n * \n *     Exemple 1:\n *         Entrée: sentence = \"This is a test\"\n *         Sortie: \"is\"\n * \n *     Exemple 2:\n *         Entrée: sentence = \"lets go for swimming\"\n *         Sortie: \"go for\"\n * \n *     Contraintes:\n *         * 1 <= len(sentence) <= 100\n *         * sentence ne contient que des lettres\n * \n *\n */\nfun wordsInSentence(sentence : String) : String {\n", "entry_point": "wordsInSentence", "test": "\nfun main() {\n    var arg00 : String = \"\"\"This is a test\"\"\"\n    var x0 : String = wordsInSentence(arg00);\n    var v0 : String = \"\"\"is\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"lets go for swimming\"\"\"\n    var x1 : String = wordsInSentence(arg10);\n    var v1 : String = \"\"\"go for\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"there is no place available here\"\"\"\n    var x2 : String = wordsInSentence(arg20);\n    var v2 : String = \"\"\"there is no place\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"Hi I am Hussein\"\"\"\n    var x3 : String = wordsInSentence(arg30);\n    var v3 : String = \"\"\"Hi am Hussein\"\"\";\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"go for it\"\"\"\n    var x4 : String = wordsInSentence(arg40);\n    var v4 : String = \"\"\"go for it\"\"\";\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"here\"\"\"\n    var x5 : String = wordsInSentence(arg50);\n    var v5 : String = \"\"\"\"\"\";\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"here is\"\"\"\n    var x6 : String = wordsInSentence(arg60);\n    var v6 : String = \"\"\"is\"\"\";\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "On vous donne une chaîne de caractères représentant une phrase,\n    la phrase contient des mots séparés par un espace,\n    et vous devez retourner une chaîne de caractères qui contient les mots de la phrase originale,\n    dont les longueurs sont des nombres premiers,\n    l'ordre des mots dans la nouvelle chaîne doit être le même que celui de la phrase originale.\n\n    Exemple 1:\n        Entrée: sentence = \"This is a test\"\n        Sortie: \"is\"\n\n    Exemple 2:\n        Entrée: sentence = \"lets go for swimming\"\n        Sortie: \"go for\"\n\n    Contraintes:\n        * 1 <= len(sentence) <= 100\n        * sentence ne contient que des lettres", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/66", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Votre tâche consiste à implémenter une fonction qui simplifiera l'expression x * n. La fonction renvoie True si x * n évalue à un nombre entier et False sinon. Les deux x et n sont des représentations de chaîne d'une fraction et ont le format suivant, <numérateur>/<dénominateur> où le numérateur et le dénominateur sont des nombres entiers positifs.\n * \n * Vous pouvez supposer que x et n sont des fractions valides et n'ont pas zéro comme dénominateur.\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n *\n */\nfun simplify(x : String, n : String) : Boolean {\n", "entry_point": "simplify", "test": "\nfun main() {\n    var arg00 : String = \"\"\"1/5\"\"\"\n    var arg01 : String = \"\"\"5/1\"\"\"\n    var x0 : Boolean = simplify(arg00, arg01);\n    var v0 : Boolean = true;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"1/6\"\"\"\n    var arg11 : String = \"\"\"2/1\"\"\"\n    var x1 : Boolean = simplify(arg10, arg11);\n    var v1 : Boolean = false;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"5/1\"\"\"\n    var arg21 : String = \"\"\"3/1\"\"\"\n    var x2 : Boolean = simplify(arg20, arg21);\n    var v2 : Boolean = true;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"7/10\"\"\"\n    var arg31 : String = \"\"\"10/2\"\"\"\n    var x3 : Boolean = simplify(arg30, arg31);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"2/10\"\"\"\n    var arg41 : String = \"\"\"50/10\"\"\"\n    var x4 : Boolean = simplify(arg40, arg41);\n    var v4 : Boolean = true;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"7/2\"\"\"\n    var arg51 : String = \"\"\"4/2\"\"\"\n    var x5 : Boolean = simplify(arg50, arg51);\n    var v5 : Boolean = true;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"11/6\"\"\"\n    var arg61 : String = \"\"\"6/1\"\"\"\n    var x6 : Boolean = simplify(arg60, arg61);\n    var v6 : Boolean = true;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : String = \"\"\"2/3\"\"\"\n    var arg71 : String = \"\"\"5/2\"\"\"\n    var x7 : Boolean = simplify(arg70, arg71);\n    var v7 : Boolean = false;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : String = \"\"\"5/2\"\"\"\n    var arg81 : String = \"\"\"3/5\"\"\"\n    var x8 : Boolean = simplify(arg80, arg81);\n    var v8 : Boolean = false;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : String = \"\"\"2/4\"\"\"\n    var arg91 : String = \"\"\"8/4\"\"\"\n    var x9 : Boolean = simplify(arg90, arg91);\n    var v9 : Boolean = true;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n    var arg100 : String = \"\"\"2/4\"\"\"\n    var arg101 : String = \"\"\"4/2\"\"\"\n    var x10 : Boolean = simplify(arg100, arg101);\n    var v10 : Boolean = true;\n    if (x10 != v10) {\n        throw Exception(\"Exception -- test case 10 did not pass. x10 = \" + x10)\n    }\n\n    var arg110 : String = \"\"\"1/5\"\"\"\n    var arg111 : String = \"\"\"5/1\"\"\"\n    var x11 : Boolean = simplify(arg110, arg111);\n    var v11 : Boolean = true;\n    if (x11 != v11) {\n        throw Exception(\"Exception -- test case 11 did not pass. x11 = \" + x11)\n    }\n\n    var arg120 : String = \"\"\"1/5\"\"\"\n    var arg121 : String = \"\"\"1/5\"\"\"\n    var x12 : Boolean = simplify(arg120, arg121);\n    var v12 : Boolean = false;\n    if (x12 != v12) {\n        throw Exception(\"Exception -- test case 12 did not pass. x12 = \" + x12)\n    }\n\n\n}\n", "description": "Votre tâche consiste à implémenter une fonction qui simplifiera l'expression x * n. La fonction renvoie True si x * n évalue à un nombre entier et False sinon. Les deux x et n sont des représentations de chaîne d'une fraction et ont le format suivant, <numérateur>/<dénominateur> où le numérateur et le dénominateur sont des nombres entiers positifs.\n\nVous pouvez supposer que x et n sont des fractions valides et n'ont pas zéro comme dénominateur.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/67", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Écrivez une fonction qui trie la liste donnée d'entiers\n *     dans l'ordre croissant en fonction de la somme de leurs chiffres.\n *     Remarque : s'il y a plusieurs éléments avec une somme de chiffres similaire,\n *     les trier en fonction de leur index dans la liste d'origine.\n * \n *     Par exemple:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n *\n */\nfun orderByPoints(nums : List<Any>) : List<Any> {\n", "entry_point": "orderByPoints", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf(1, 11, -1, -11, -12)\n    var x0 : List<Any> = orderByPoints(arg00);\n    var v0 : List<Any> = mutableListOf(-1, -11, 1, -12, 11);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46)\n    var x1 : List<Any> = orderByPoints(arg10);\n    var v1 : List<Any> = mutableListOf(0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf()\n    var x2 : List<Any> = orderByPoints(arg20);\n    var v2 : List<Any> = mutableListOf();\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Any> = mutableListOf(1, -11, -32, 43, 54, -98, 2, -3)\n    var x3 : List<Any> = orderByPoints(arg30);\n    var v3 : List<Any> = mutableListOf(-3, -32, -98, -11, 1, 2, 43, 54);\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Any> = mutableListOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)\n    var x4 : List<Any> = orderByPoints(arg40);\n    var v4 : List<Any> = mutableListOf(1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9);\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Any> = mutableListOf(0, 6, 6, -76, -21, 23, 4)\n    var x5 : List<Any> = orderByPoints(arg50);\n    var v5 : List<Any> = mutableListOf(-76, -21, 0, 4, 23, 6, 6);\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n\n}\n", "description": "Écrivez une fonction qui trie la liste donnée d'entiers\n    dans l'ordre croissant en fonction de la somme de leurs chiffres.\n    Remarque : s'il y a plusieurs éléments avec une somme de chiffres similaire,\n    les trier en fonction de leur index dans la liste d'origine.\n\n    Par exemple:", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/68", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Écrivez une fonction qui prend en entrée un tableau de nombres et renvoie le nombre d'éléments du tableau qui sont supérieurs à 10 et dont les premiers et derniers chiffres d'un nombre sont impairs (1, 3, 5, 7, 9). Par exemple :\n * \n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n *\n */\nfun specialfilter(nums : List<Any>) : Int {\n", "entry_point": "specialfilter", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf(5, -2, 1, -5)\n    var x0 : Int = specialfilter(arg00);\n    var v0 : Int = 0;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(15, -73, 14, -15)\n    var x1 : Int = specialfilter(arg10);\n    var v1 : Int = 1;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf(33, -2, -3, 45, 21, 109)\n    var x2 : Int = specialfilter(arg20);\n    var v2 : Int = 2;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Any> = mutableListOf(43, -12, 93, 125, 121, 109)\n    var x3 : Int = specialfilter(arg30);\n    var v3 : Int = 4;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Any> = mutableListOf(71, -2, -33, 75, 21, 19)\n    var x4 : Int = specialfilter(arg40);\n    var v4 : Int = 3;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Any> = mutableListOf(1)\n    var x5 : Int = specialfilter(arg50);\n    var v5 : Int = 0;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : List<Any> = mutableListOf()\n    var x6 : Int = specialfilter(arg60);\n    var v6 : Int = 0;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "Écrivez une fonction qui prend en entrée un tableau de nombres et renvoie le nombre d'éléments du tableau qui sont supérieurs à 10 et dont les premiers et derniers chiffres d'un nombre sont impairs (1, 3, 5, 7, 9). Par exemple :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/69", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * On vous donne un entier positif n. Vous devez créer un tableau d'entiers a de longueur n.\n *         Pour chaque i (1 ≤ i ≤ n), la valeur de a[i] = i * i - i + 1.\n *         Renvoyez le nombre de triplets (a[i], a[j], a[k]) de a où i < j < k, \n *     et a[i] + a[j] + a[k] est un multiple de 3.\n * \n *     Exemple :\n *         Entrée : n = 5\n *         Sortie : 1\n *         Explication : \n *         a = [1, 3, 7, 13, 21]\n *         Le seul triplet valide est (1, 7, 13).\n * \n *\n */\nfun getMaxTriples(n : Int) : Int {\n", "entry_point": "getMaxTriples", "test": "\nfun main() {\n    var arg00 : Int = 5\n    var x0 : Int = getMaxTriples(arg00);\n    var v0 : Int = 1;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 6\n    var x1 : Int = getMaxTriples(arg10);\n    var v1 : Int = 4;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 10\n    var x2 : Int = getMaxTriples(arg20);\n    var v2 : Int = 36;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 100\n    var x3 : Int = getMaxTriples(arg30);\n    var v3 : Int = 53361;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n\n}\n", "description": "On vous donne un entier positif n. Vous devez créer un tableau d'entiers a de longueur n.\n        Pour chaque i (1 ≤ i ≤ n), la valeur de a[i] = i * i - i + 1.\n        Renvoyez le nombre de triplets (a[i], a[j], a[k]) de a où i < j < k, \n    et a[i] + a[j] + a[k] est un multiple de 3.\n\n    Exemple :\n        Entrée : n = 5\n        Sortie : 1\n        Explication : \n        a = [1, 3, 7, 13, 21]\n        Le seul triplet valide est (1, 7, 13).", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/70", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Il y a huit planètes dans notre système solaire : la plus proche du Soleil est Mercure, la suivante est Vénus, puis la Terre, Mars, Jupiter, Saturne, Uranus, Neptune. Écrivez une fonction qui prend deux noms de planètes en tant que chaînes de caractères planet1 et planet2. La fonction devrait renvoyer un tuple contenant toutes les planètes dont les orbites sont situées entre l'orbite de planet1 et l'orbite de planet2, triées par proximité avec le soleil. La fonction devrait renvoyer un tuple vide si planet1 ou planet2 ne sont pas des noms de planètes corrects. Exemples.\n * \n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n *\n */\nfun bf(planet1 : String, planet2 : String) : List<Any> {\n", "entry_point": "bf", "test": "\nfun main() {\n    var arg00 : String = \"\"\"Jupiter\"\"\"\n    var arg01 : String = \"\"\"Neptune\"\"\"\n    var x0 : List<Any> = bf(arg00, arg01);\n    var v0 : List<Any> = mutableListOf(\"\"\"Saturn\"\"\", \"\"\"Uranus\"\"\");\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"Earth\"\"\"\n    var arg11 : String = \"\"\"Mercury\"\"\"\n    var x1 : List<Any> = bf(arg10, arg11);\n    var v1 : List<Any> = mutableListOf(\"\"\"Venus\"\"\");\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"Mercury\"\"\"\n    var arg21 : String = \"\"\"Uranus\"\"\"\n    var x2 : List<Any> = bf(arg20, arg21);\n    var v2 : List<Any> = mutableListOf(\"\"\"Venus\"\"\", \"\"\"Earth\"\"\", \"\"\"Mars\"\"\", \"\"\"Jupiter\"\"\", \"\"\"Saturn\"\"\");\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"Neptune\"\"\"\n    var arg31 : String = \"\"\"Venus\"\"\"\n    var x3 : List<Any> = bf(arg30, arg31);\n    var v3 : List<Any> = mutableListOf(\"\"\"Earth\"\"\", \"\"\"Mars\"\"\", \"\"\"Jupiter\"\"\", \"\"\"Saturn\"\"\", \"\"\"Uranus\"\"\");\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"Earth\"\"\"\n    var arg41 : String = \"\"\"Earth\"\"\"\n    var x4 : List<Any> = bf(arg40, arg41);\n    var v4 : List<Any> = mutableListOf();\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"Mars\"\"\"\n    var arg51 : String = \"\"\"Earth\"\"\"\n    var x5 : List<Any> = bf(arg50, arg51);\n    var v5 : List<Any> = mutableListOf();\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"Jupiter\"\"\"\n    var arg61 : String = \"\"\"Makemake\"\"\"\n    var x6 : List<Any> = bf(arg60, arg61);\n    var v6 : List<Any> = mutableListOf();\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "Il y a huit planètes dans notre système solaire : la plus proche du Soleil est Mercure, la suivante est Vénus, puis la Terre, Mars, Jupiter, Saturne, Uranus, Neptune. Écrivez une fonction qui prend deux noms de planètes en tant que chaînes de caractères planet1 et planet2. La fonction devrait renvoyer un tuple contenant toutes les planètes dont les orbites sont situées entre l'orbite de planet1 et l'orbite de planet2, triées par proximité avec le soleil. La fonction devrait renvoyer un tuple vide si planet1 ou planet2 ne sont pas des noms de planètes corrects. Exemples.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/71", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Un programme simple qui devrait renvoyer la valeur de x si n est un nombre premier et devrait renvoyer la valeur de y sinon.\n * \n * Exemples :\n * \n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n *\n */\nfun xOrY(n : Int, x : Int, y : Int) : Int {\n", "entry_point": "xOrY", "test": "\nfun main() {\n    var arg00 : Int = 7\n    var arg01 : Int = 34\n    var arg02 : Int = 12\n    var x0 : Int = xOrY(arg00, arg01, arg02);\n    var v0 : Int = 34;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 15\n    var arg11 : Int = 8\n    var arg12 : Int = 5\n    var x1 : Int = xOrY(arg10, arg11, arg12);\n    var v1 : Int = 5;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 3\n    var arg21 : Int = 33\n    var arg22 : Int = 5212\n    var x2 : Int = xOrY(arg20, arg21, arg22);\n    var v2 : Int = 33;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 1259\n    var arg31 : Int = 3\n    var arg32 : Int = 52\n    var x3 : Int = xOrY(arg30, arg31, arg32);\n    var v3 : Int = 3;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 7919\n    var arg41 : Int = -1\n    var arg42 : Int = 12\n    var x4 : Int = xOrY(arg40, arg41, arg42);\n    var v4 : Int = -1;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 3609\n    var arg51 : Int = 1245\n    var arg52 : Int = 583\n    var x5 : Int = xOrY(arg50, arg51, arg52);\n    var v5 : Int = 583;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 91\n    var arg61 : Int = 56\n    var arg62 : Int = 129\n    var x6 : Int = xOrY(arg60, arg61, arg62);\n    var v6 : Int = 129;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : Int = 6\n    var arg71 : Int = 34\n    var arg72 : Int = 1234\n    var x7 : Int = xOrY(arg70, arg71, arg72);\n    var v7 : Int = 1234;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : Int = 1\n    var arg81 : Int = 2\n    var arg82 : Int = 0\n    var x8 : Int = xOrY(arg80, arg81, arg82);\n    var v8 : Int = 0;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : Int = 2\n    var arg91 : Int = 2\n    var arg92 : Int = 0\n    var x9 : Int = xOrY(arg90, arg91, arg92);\n    var v9 : Int = 2;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n\n}\n", "description": "Un programme simple qui devrait renvoyer la valeur de x si n est un nombre premier et devrait renvoyer la valeur de y sinon.\n\nExemples :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/72", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Étant donné une liste de nombres, retournez la somme des carrés des nombres de la liste qui sont impairs. Ignorez les nombres négatifs ou non entiers.\n * \n *     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n *     double_the_difference([-1, -2, 0]) == 0\n *     double_the_difference([9, -2]) == 81\n *     double_the_difference([0]) == 0\n *     \n *     Si la liste d'entrée est vide, retournez 0.\n * \n *\n */\nfun doubleTheDifference(lst : List<Any>) : Int {\n", "entry_point": "doubleTheDifference", "test": "\nfun main() {\n    var arg00 : List<Any> = mutableListOf()\n    var x0 : Int = doubleTheDifference(arg00);\n    var v0 : Int = 0;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : List<Any> = mutableListOf(5, 4)\n    var x1 : Int = doubleTheDifference(arg10);\n    var v1 : Int = 25;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : List<Any> = mutableListOf(0.1, 0.2, 0.3)\n    var x2 : Int = doubleTheDifference(arg20);\n    var v2 : Int = 0;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : List<Any> = mutableListOf(-10, -20, -30)\n    var x3 : Int = doubleTheDifference(arg30);\n    var v3 : Int = 0;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : List<Any> = mutableListOf(-1, -2, 8)\n    var x4 : Int = doubleTheDifference(arg40);\n    var v4 : Int = 0;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : List<Any> = mutableListOf(0.2, 3, 5)\n    var x5 : Int = doubleTheDifference(arg50);\n    var v5 : Int = 34;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : List<Any> = mutableListOf(-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99)\n    var x6 : Int = doubleTheDifference(arg60);\n    var v6 : Int = 166650;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n\n}\n", "description": "Étant donné une liste de nombres, retournez la somme des carrés des nombres de la liste qui sont impairs. Ignorez les nombres négatifs ou non entiers.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n    \n    Si la liste d'entrée est vide, retournez 0.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/73", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Vous recevrez le nom d'une classe (une chaîne de caractères) et une liste d'extensions. Les extensions doivent être utilisées pour charger des classes supplémentaires dans la classe. La force de l'extension est déterminée comme suit : soit CAP le nombre de lettres majuscules dans le nom de l'extension, et SM le nombre de lettres minuscules dans le nom de l'extension, la force est donnée par la fraction CAP - SM. Vous devez trouver l'extension la plus forte et renvoyer une chaîne de caractères dans ce format : NomDeLaClasse.NomDeLExtensionLaPlusForte. S'il y a deux ou plusieurs extensions avec la même force, vous devez choisir celle qui vient en premier dans la liste. Par exemple, si vous recevez \"Slices\" comme classe et une liste d'extensions : ['SErviNGSliCes', 'Cheese', 'StuFfed'], vous devez renvoyer 'Slices.SErviNGSliCes' car 'SErviNGSliCes' est l'extension la plus forte (sa force est -1). Exemple :\n * \n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n *\n */\nfun strongestExtension(className : String, extensions : List<String>) : String {\n", "entry_point": "strongestExtension", "test": "\nfun main() {\n    var arg00 : String = \"\"\"Watashi\"\"\"\n    var arg01 : List<String> = mutableListOf(\"\"\"tEN\"\"\", \"\"\"niNE\"\"\", \"\"\"eIGHt8OKe\"\"\")\n    var x0 : String = strongestExtension(arg00, arg01);\n    var v0 : String = \"\"\"Watashi.eIGHt8OKe\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"Boku123\"\"\"\n    var arg11 : List<String> = mutableListOf(\"\"\"nani\"\"\", \"\"\"NazeDa\"\"\", \"\"\"YEs.WeCaNe\"\"\", \"\"\"32145tggg\"\"\")\n    var x1 : String = strongestExtension(arg10, arg11);\n    var v1 : String = \"\"\"Boku123.YEs.WeCaNe\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"__YESIMHERE\"\"\"\n    var arg21 : List<String> = mutableListOf(\"\"\"t\"\"\", \"\"\"eMptY\"\"\", \"\"\"nothing\"\"\", \"\"\"zeR00\"\"\", \"\"\"NuLl__\"\"\", \"\"\"123NoooneB321\"\"\")\n    var x2 : String = strongestExtension(arg20, arg21);\n    var v2 : String = \"\"\"__YESIMHERE.NuLl__\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"K\"\"\"\n    var arg31 : List<String> = mutableListOf(\"\"\"Ta\"\"\", \"\"\"TAR\"\"\", \"\"\"t234An\"\"\", \"\"\"cosSo\"\"\")\n    var x3 : String = strongestExtension(arg30, arg31);\n    var v3 : String = \"\"\"K.TAR\"\"\";\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"__HAHA\"\"\"\n    var arg41 : List<String> = mutableListOf(\"\"\"Tab\"\"\", \"\"\"123\"\"\", \"\"\"781345\"\"\", \"\"\"-_-\"\"\")\n    var x4 : String = strongestExtension(arg40, arg41);\n    var v4 : String = \"\"\"__HAHA.123\"\"\";\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"YameRore\"\"\"\n    var arg51 : List<String> = mutableListOf(\"\"\"HhAas\"\"\", \"\"\"okIWILL123\"\"\", \"\"\"WorkOut\"\"\", \"\"\"Fails\"\"\", \"\"\"-_-\"\"\")\n    var x5 : String = strongestExtension(arg50, arg51);\n    var v5 : String = \"\"\"YameRore.okIWILL123\"\"\";\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"finNNalLLly\"\"\"\n    var arg61 : List<String> = mutableListOf(\"\"\"Die\"\"\", \"\"\"NowW\"\"\", \"\"\"Wow\"\"\", \"\"\"WoW\"\"\")\n    var x6 : String = strongestExtension(arg60, arg61);\n    var v6 : String = \"\"\"finNNalLLly.WoW\"\"\";\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : String = \"\"\"_\"\"\"\n    var arg71 : List<String> = mutableListOf(\"\"\"Bb\"\"\", \"\"\"91245\"\"\")\n    var x7 : String = strongestExtension(arg70, arg71);\n    var v7 : String = \"\"\"_.Bb\"\"\";\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : String = \"\"\"Sp\"\"\"\n    var arg81 : List<String> = mutableListOf(\"\"\"671235\"\"\", \"\"\"Bb\"\"\")\n    var x8 : String = strongestExtension(arg80, arg81);\n    var v8 : String = \"\"\"Sp.671235\"\"\";\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n\n}\n", "description": "Vous recevrez le nom d'une classe (une chaîne de caractères) et une liste d'extensions. Les extensions doivent être utilisées pour charger des classes supplémentaires dans la classe. La force de l'extension est déterminée comme suit : soit CAP le nombre de lettres majuscules dans le nom de l'extension, et SM le nombre de lettres minuscules dans le nom de l'extension, la force est donnée par la fraction CAP - SM. Vous devez trouver l'extension la plus forte et renvoyer une chaîne de caractères dans ce format : NomDeLaClasse.NomDeLExtensionLaPlusForte. S'il y a deux ou plusieurs extensions avec la même force, vous devez choisir celle qui vient en premier dans la liste. Par exemple, si vous recevez \"Slices\" comme classe et une liste d'extensions : ['SErviNGSliCes', 'Cheese', 'StuFfed'], vous devez renvoyer 'Slices.SErviNGSliCes' car 'SErviNGSliCes' est l'extension la plus forte (sa force est -1). Exemple :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/74", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * Vous avez deux mots. Vous devez renvoyer True si le deuxième mot ou l'une de ses rotations est une sous-chaîne dans le premier mot.\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n\n *\n */\nfun cycpatternCheck(a : String, b : String) : Boolean {\n", "entry_point": "cycpatternCheck", "test": "\nfun main() {\n    var arg00 : String = \"\"\"xyzw\"\"\"\n    var arg01 : String = \"\"\"xyw\"\"\"\n    var x0 : Boolean = cycpatternCheck(arg00, arg01);\n    var v0 : Boolean = false;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"yello\"\"\"\n    var arg11 : String = \"\"\"ell\"\"\"\n    var x1 : Boolean = cycpatternCheck(arg10, arg11);\n    var v1 : Boolean = true;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"whattup\"\"\"\n    var arg21 : String = \"\"\"ptut\"\"\"\n    var x2 : Boolean = cycpatternCheck(arg20, arg21);\n    var v2 : Boolean = false;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"efef\"\"\"\n    var arg31 : String = \"\"\"fee\"\"\"\n    var x3 : Boolean = cycpatternCheck(arg30, arg31);\n    var v3 : Boolean = true;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"abab\"\"\"\n    var arg41 : String = \"\"\"aabb\"\"\"\n    var x4 : Boolean = cycpatternCheck(arg40, arg41);\n    var v4 : Boolean = false;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"winemtt\"\"\"\n    var arg51 : String = \"\"\"tinem\"\"\"\n    var x5 : Boolean = cycpatternCheck(arg50, arg51);\n    var v5 : Boolean = true;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n\n}\n", "description": "Vous avez deux mots. Vous devez renvoyer True si le deuxième mot ou l'une de ses rotations est une sous-chaîne dans le premier mot.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/75", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Étant donné un entier positif, obtenez son équivalent en chiffres romains sous forme de chaîne de caractères et retournez-le en minuscules.\n * Restrictions : 1 <= num <= 1000\n * \n * Exemples :\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n *\n */\nfun intToMiniRoman(number : Int) : String {\n", "entry_point": "intToMiniRoman", "test": "\nfun main() {\n    var arg00 : Int = 19\n    var x0 : String = intToMiniRoman(arg00);\n    var v0 : String = \"\"\"xix\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 152\n    var x1 : String = intToMiniRoman(arg10);\n    var v1 : String = \"\"\"clii\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 251\n    var x2 : String = intToMiniRoman(arg20);\n    var v2 : String = \"\"\"ccli\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 426\n    var x3 : String = intToMiniRoman(arg30);\n    var v3 : String = \"\"\"cdxxvi\"\"\";\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 500\n    var x4 : String = intToMiniRoman(arg40);\n    var v4 : String = \"\"\"d\"\"\";\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 1\n    var x5 : String = intToMiniRoman(arg50);\n    var v5 : String = \"\"\"i\"\"\";\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 4\n    var x6 : String = intToMiniRoman(arg60);\n    var v6 : String = \"\"\"iv\"\"\";\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : Int = 43\n    var x7 : String = intToMiniRoman(arg70);\n    var v7 : String = \"\"\"xliii\"\"\";\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : Int = 90\n    var x8 : String = intToMiniRoman(arg80);\n    var v8 : String = \"\"\"xc\"\"\";\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : Int = 94\n    var x9 : String = intToMiniRoman(arg90);\n    var v9 : String = \"\"\"xciv\"\"\";\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n    var arg100 : Int = 532\n    var x10 : String = intToMiniRoman(arg100);\n    var v10 : String = \"\"\"dxxxii\"\"\";\n    if (x10 != v10) {\n        throw Exception(\"Exception -- test case 10 did not pass. x10 = \" + x10)\n    }\n\n    var arg110 : Int = 900\n    var x11 : String = intToMiniRoman(arg110);\n    var v11 : String = \"\"\"cm\"\"\";\n    if (x11 != v11) {\n        throw Exception(\"Exception -- test case 11 did not pass. x11 = \" + x11)\n    }\n\n    var arg120 : Int = 994\n    var x12 : String = intToMiniRoman(arg120);\n    var v12 : String = \"\"\"cmxciv\"\"\";\n    if (x12 != v12) {\n        throw Exception(\"Exception -- test case 12 did not pass. x12 = \" + x12)\n    }\n\n    var arg130 : Int = 1000\n    var x13 : String = intToMiniRoman(arg130);\n    var v13 : String = \"\"\"m\"\"\";\n    if (x13 != v13) {\n        throw Exception(\"Exception -- test case 13 did not pass. x13 = \" + x13)\n    }\n\n\n}\n", "description": "Étant donné un entier positif, obtenez son équivalent en chiffres romains sous forme de chaîne de caractères et retournez-le en minuscules.\nRestrictions : 1 <= num <= 1000\n\nExemples :", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/76", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Étant donné les longueurs des trois côtés d'un triangle. Renvoyer True si les trois côtés forment un triangle rectangle, False sinon. Un triangle rectangle est un triangle dans lequel un angle est un angle droit ou de 90 degrés. Exemple:\n * \n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n *\n */\nfun rightAngleTriangle(a : Int, b : Int, c : Int) : Boolean {\n", "entry_point": "rightAngleTriangle", "test": "\nfun main() {\n    var arg00 : Int = 3\n    var arg01 : Int = 4\n    var arg02 : Int = 5\n    var x0 : Boolean = rightAngleTriangle(arg00, arg01, arg02);\n    var v0 : Boolean = true;\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 1\n    var arg11 : Int = 2\n    var arg12 : Int = 3\n    var x1 : Boolean = rightAngleTriangle(arg10, arg11, arg12);\n    var v1 : Boolean = false;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 10\n    var arg21 : Int = 6\n    var arg22 : Int = 8\n    var x2 : Boolean = rightAngleTriangle(arg20, arg21, arg22);\n    var v2 : Boolean = true;\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 2\n    var arg31 : Int = 2\n    var arg32 : Int = 2\n    var x3 : Boolean = rightAngleTriangle(arg30, arg31, arg32);\n    var v3 : Boolean = false;\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : Int = 7\n    var arg41 : Int = 24\n    var arg42 : Int = 25\n    var x4 : Boolean = rightAngleTriangle(arg40, arg41, arg42);\n    var v4 : Boolean = true;\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : Int = 10\n    var arg51 : Int = 5\n    var arg52 : Int = 7\n    var x5 : Boolean = rightAngleTriangle(arg50, arg51, arg52);\n    var v5 : Boolean = false;\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : Int = 5\n    var arg61 : Int = 12\n    var arg62 : Int = 13\n    var x6 : Boolean = rightAngleTriangle(arg60, arg61, arg62);\n    var v6 : Boolean = true;\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : Int = 15\n    var arg71 : Int = 8\n    var arg72 : Int = 17\n    var x7 : Boolean = rightAngleTriangle(arg70, arg71, arg72);\n    var v7 : Boolean = true;\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n    var arg80 : Int = 48\n    var arg81 : Int = 55\n    var arg82 : Int = 73\n    var x8 : Boolean = rightAngleTriangle(arg80, arg81, arg82);\n    var v8 : Boolean = true;\n    if (x8 != v8) {\n        throw Exception(\"Exception -- test case 8 did not pass. x8 = \" + x8)\n    }\n\n    var arg90 : Int = 1\n    var arg91 : Int = 1\n    var arg92 : Int = 1\n    var x9 : Boolean = rightAngleTriangle(arg90, arg91, arg92);\n    var v9 : Boolean = false;\n    if (x9 != v9) {\n        throw Exception(\"Exception -- test case 9 did not pass. x9 = \" + x9)\n    }\n\n    var arg100 : Int = 2\n    var arg101 : Int = 2\n    var arg102 : Int = 10\n    var x10 : Boolean = rightAngleTriangle(arg100, arg101, arg102);\n    var v10 : Boolean = false;\n    if (x10 != v10) {\n        throw Exception(\"Exception -- test case 10 did not pass. x10 = \" + x10)\n    }\n\n\n}\n", "description": "Étant donné les longueurs des trois côtés d'un triangle. Renvoyer True si les trois côtés forment un triangle rectangle, False sinon. Un triangle rectangle est un triangle dans lequel un angle est un angle droit ou de 90 degrés. Exemple:", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/77", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * On vous donne une chaîne de caractères s.\n *     Si s[i] est une lettre, inversez sa casse de minuscule à majuscule ou vice versa,\n *     sinon gardez-le tel quel.\n *     Si la chaîne ne contient pas de lettres, inversez la chaîne.\n *     La fonction doit renvoyer la chaîne résultante.\n *     Exemples\n * \n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n *\n */\nfun solve(s : String) : String {\n", "entry_point": "solve", "test": "\nfun main() {\n    var arg00 : String = \"\"\"AsDf\"\"\"\n    var x0 : String = solve(arg00);\n    var v0 : String = \"\"\"aSdF\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"1234\"\"\"\n    var x1 : String = solve(arg10);\n    var v1 : String = \"\"\"4321\"\"\";\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"ab\"\"\"\n    var x2 : String = solve(arg20);\n    var v2 : String = \"\"\"AB\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"#a@C\"\"\"\n    var x3 : String = solve(arg30);\n    var v3 : String = \"\"\"#A@c\"\"\";\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n    var arg40 : String = \"\"\"#AsdfW^45\"\"\"\n    var x4 : String = solve(arg40);\n    var v4 : String = \"\"\"#aSDFw^45\"\"\";\n    if (x4 != v4) {\n        throw Exception(\"Exception -- test case 4 did not pass. x4 = \" + x4)\n    }\n\n    var arg50 : String = \"\"\"#6@2\"\"\"\n    var x5 : String = solve(arg50);\n    var v5 : String = \"\"\"2@6#\"\"\";\n    if (x5 != v5) {\n        throw Exception(\"Exception -- test case 5 did not pass. x5 = \" + x5)\n    }\n\n    var arg60 : String = \"\"\"#\\$a^D\"\"\"\n    var x6 : String = solve(arg60);\n    var v6 : String = \"\"\"#\\$A^d\"\"\";\n    if (x6 != v6) {\n        throw Exception(\"Exception -- test case 6 did not pass. x6 = \" + x6)\n    }\n\n    var arg70 : String = \"\"\"#ccc\"\"\"\n    var x7 : String = solve(arg70);\n    var v7 : String = \"\"\"#CCC\"\"\";\n    if (x7 != v7) {\n        throw Exception(\"Exception -- test case 7 did not pass. x7 = \" + x7)\n    }\n\n\n}\n", "description": "On vous donne une chaîne de caractères s.\n    Si s[i] est une lettre, inversez sa casse de minuscule à majuscule ou vice versa,\n    sinon gardez-le tel quel.\n    Si la chaîne ne contient pas de lettres, inversez la chaîne.\n    La fonction doit renvoyer la chaîne résultante.\n    Exemples", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/78", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Étant donné une chaîne de caractères 'text', retournez sa chaîne équivalente de hachage md5. Si 'text' est une chaîne vide, retournez null.\n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n *\n */\nfun stringToMd5(text : String) : String? {\n", "entry_point": "stringToMd5", "test": "\nfun main() {\n    var arg00 : String = \"\"\"Hello world\"\"\"\n    var x0 : String? = stringToMd5(arg00);\n    var v0 : String? = \"\"\"3e25960a79dbc69b674cd4ec67a72c62\"\"\";\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : String = \"\"\"\"\"\"\n    var x1 : String? = stringToMd5(arg10);\n    var v1 : String? = null;\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : String = \"\"\"A B C\"\"\"\n    var x2 : String? = stringToMd5(arg20);\n    var v2 : String? = \"\"\"0ef78513b0cb8cef12743f5aeb35f888\"\"\";\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : String = \"\"\"password\"\"\"\n    var x3 : String? = stringToMd5(arg30);\n    var v3 : String? = \"\"\"5f4dcc3b5aa765d61d8327deb882cf99\"\"\";\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n\n}\n", "description": "Étant donné une chaîne de caractères 'text', retournez sa chaîne équivalente de hachage md5. Si 'text' est une chaîne vide, retournez null.", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "kotlin/79", "prompt": "/**\n * Vous êtes un programmeur Kotlin expert, et voici votre tâche.\n * * Étant donné deux entiers positifs a et b, renvoyer les chiffres pairs entre a et b, dans l'ordre croissant.\n * \n * Par exemple:\n * \n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n *\n */\nfun generateIntegers(a : Int, b : Int) : List<Any> {\n", "entry_point": "generateIntegers", "test": "\nfun main() {\n    var arg00 : Int = 2\n    var arg01 : Int = 10\n    var x0 : List<Any> = generateIntegers(arg00, arg01);\n    var v0 : List<Any> = mutableListOf(2, 4, 6, 8);\n    if (x0 != v0) {\n        throw Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0)\n    }\n\n    var arg10 : Int = 10\n    var arg11 : Int = 2\n    var x1 : List<Any> = generateIntegers(arg10, arg11);\n    var v1 : List<Any> = mutableListOf(2, 4, 6, 8);\n    if (x1 != v1) {\n        throw Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1)\n    }\n\n    var arg20 : Int = 132\n    var arg21 : Int = 2\n    var x2 : List<Any> = generateIntegers(arg20, arg21);\n    var v2 : List<Any> = mutableListOf(2, 4, 6, 8);\n    if (x2 != v2) {\n        throw Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2)\n    }\n\n    var arg30 : Int = 17\n    var arg31 : Int = 89\n    var x3 : List<Any> = generateIntegers(arg30, arg31);\n    var v3 : List<Any> = mutableListOf();\n    if (x3 != v3) {\n        throw Exception(\"Exception -- test case 3 did not pass. x3 = \" + x3)\n    }\n\n\n}\n", "description": "Étant donné deux entiers positifs a et b, renvoyer les chiffres pairs entre a et b, dans l'ordre croissant.\n\nPar exemple:", "language": "kotlin", "canonical_solution": NaN, "natural_language": "French"}
