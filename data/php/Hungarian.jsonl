{"task_id": "php/0", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Egy banki számla befizetéseinek és kivételeinek listáját kapod, amely nulláról indul. A feladatod az, hogy észleld, ha a számla egy adott pontján a mérleg nulla alá esik, és ebben az esetben a függvény True értéket kell, hogy adjon vissza. Ellenkező esetben False értéket kell visszaadnia.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n *\n */\nfunction belowZero($operations){\n", "entry_point": "belowZero", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [];\n$x0 = belowZero($arg00);\n$v0 = false;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1, 2, -3, 1, 2, -3];\n$x1 = belowZero($arg10);\n$v1 = false;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [1, 2, -4, 5, 6];\n$x2 = belowZero($arg20);\n$v2 = true;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [1, -1, 2, -2, 5, -5, 4, -4];\n$x3 = belowZero($arg30);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [1, -1, 2, -2, 5, -5, 4, -5];\n$x4 = belowZero($arg40);\n$v4 = true;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [1, -2, 2, -2, 5, -5, 4, -4];\n$x5 = belowZero($arg50);\n$v5 = true;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n", "description": "Egy banki számla befizetéseinek és kivételeinek listáját kapod, amely nulláról indul. A feladatod az, hogy észleld, ha a számla egy adott pontján a mérleg nulla alá esik, és ebben az esetben a függvény True értéket kell, hogy adjon vissza. Ellenkező esetben False értéket kell visszaadnia.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/1", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adott egy egész számok listája, adjon vissza egy tuple-t, amely egy összeget és egy szorzatot tartalmaz a listában található összes egész számról.\n * Az üres összegnek 0-nak kell lennie, az üres szorzatnak pedig 1-nek kell lennie.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n *\n */\nfunction sumProduct($numbers){\n", "entry_point": "sumProduct", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [];\n$x0 = sumProduct($arg00);\n$v0 = [0, 1];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1, 1, 1];\n$x1 = sumProduct($arg10);\n$v1 = [3, 1];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [100, 0];\n$x2 = sumProduct($arg20);\n$v2 = [100, 0];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [3, 5, 7];\n$x3 = sumProduct($arg30);\n$v3 = [15, 105];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [10];\n$x4 = sumProduct($arg40);\n$v4 = [10, 10];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Adott egy egész számok listája, adjon vissza egy tuple-t, amely egy összeget és egy szorzatot tartalmaz a listában található összes egész számról.\nAz üres összegnek 0-nak kell lennie, az üres szorzatnak pedig 1-nek kell lennie.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/2", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * A bemenet két, csak 1-ekből és 0-ákból álló karakterlánc, a és b.\n * Végezzen bináris XOR műveletet ezeken a bemeneteken, majd adja vissza az eredményt szintén karakterlánc formájában.\n * >>> string_xor('010', '110')\n * '100'\n *\n */\nfunction stringXor($a, $b){\n", "entry_point": "stringXor", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"111000\";\n$arg01 = \"101010\";\n$x0 = stringXor($arg00, $arg01);\n$v0 = \"010010\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"1\";\n$arg11 = \"1\";\n$x1 = stringXor($arg10, $arg11);\n$v1 = \"0\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"0101\";\n$arg21 = \"0000\";\n$x2 = stringXor($arg20, $arg21);\n$v2 = \"0101\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n", "description": "A bemenet két, csak 1-ekből és 0-ákból álló karakterlánc, a és b.\nVégezzen bináris XOR műveletet ezeken a bemeneteken, majd adja vissza az eredményt szintén karakterlánc formájában.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/3", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * A stringek listájából adja vissza a leghosszabbat. Több azonos hosszúságú string esetén az elsőt adja vissza. Üres bemeneti lista esetén null-t ad vissza.\n * >>> longest([])\n\n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n *\n */\nfunction longest($strings){\n", "entry_point": "longest", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [];\n$x0 = longest($arg00);\n$v0 = null;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [\"x\", \"y\", \"z\"];\n$x1 = longest($arg10);\n$v1 = \"x\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"];\n$x2 = longest($arg20);\n$v2 = \"zzzz\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n", "description": "A stringek listájából adja vissza a leghosszabbat. Több azonos hosszúságú string esetén az elsőt adja vissza. Üres bemeneti lista esetén null-t ad vissza.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/4", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adjon vissza két egész szám, a és b legnagyobb közös osztóját.\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n *\n */\nfunction greatestCommonDivisor($a, $b){\n", "entry_point": "greatestCommonDivisor", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 3;\n$arg01 = 7;\n$x0 = greatestCommonDivisor($arg00, $arg01);\n$v0 = 1;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 10;\n$arg11 = 15;\n$x1 = greatestCommonDivisor($arg10, $arg11);\n$v1 = 5;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 49;\n$arg21 = 14;\n$x2 = greatestCommonDivisor($arg20, $arg21);\n$v2 = 7;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 144;\n$arg31 = 60;\n$x3 = greatestCommonDivisor($arg30, $arg31);\n$v3 = 12;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n", "description": "Adjon vissza két egész szám, a és b legnagyobb közös osztóját.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/5", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * A bemenet egy szóközzel elválasztott számjegyekből álló karakterlánc, amely tartalmazza a \"zero\" és \"nine\" közötti számjegyeket. A helyes választások a következők: \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\" és \"nine\". A program a számokat a legkisebbtől a legnagyobbig rendezve adja vissza.\n * >>> sort_numbers('three one five')\n * 'one three five'\n *\n */\nfunction sortNumbers($numbers){\n", "entry_point": "sortNumbers", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"\";\n$x0 = sortNumbers($arg00);\n$v0 = \"\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"three\";\n$x1 = sortNumbers($arg10);\n$v1 = \"three\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"three five nine\";\n$x2 = sortNumbers($arg20);\n$v2 = \"three five nine\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"five zero four seven nine eight\";\n$x3 = sortNumbers($arg30);\n$v3 = \"zero four five seven eight nine\";\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"six five four three two one zero\";\n$x4 = sortNumbers($arg40);\n$v4 = \"zero one two three four five six\";\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "A bemenet egy szóközzel elválasztott számjegyekből álló karakterlánc, amely tartalmazza a \"zero\" és \"nine\" közötti számjegyeket. A helyes választások a következők: \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\" és \"nine\". A program a számokat a legkisebbtől a legnagyobbig rendezve adja vissza.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/6", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adott egy számok listája (legalább két elemű), alkalmazzunk egy lineáris transzformációt erre a listára, úgy hogy a legkisebb szám 0, a legnagyobb pedig 1 lesz.\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n *\n */\nfunction rescaleToUnit($numbers){\n", "entry_point": "rescaleToUnit", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [2.0, 49.9];\n$x0 = rescaleToUnit($arg00);\n$v0 = [0.0, 1.0];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [100.0, 49.9];\n$x1 = rescaleToUnit($arg10);\n$v1 = [1.0, 0.0];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [1.0, 2.0, 3.0, 4.0, 5.0];\n$x2 = rescaleToUnit($arg20);\n$v2 = [0.0, 0.25, 0.5, 0.75, 1.0];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [2.0, 1.0, 5.0, 3.0, 4.0];\n$x3 = rescaleToUnit($arg30);\n$v3 = [0.25, 0.0, 1.0, 0.5, 0.75];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [12.0, 11.0, 15.0, 13.0, 14.0];\n$x4 = rescaleToUnit($arg40);\n$v4 = [0.25, 0.0, 1.0, 0.5, 0.75];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Adott egy számok listája (legalább két elemű), alkalmazzunk egy lineáris transzformációt erre a listára, úgy hogy a legkisebb szám 0, a legnagyobb pedig 1 lesz.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/7", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adott karakterlánc esetén fordítsa meg a kisbetűket nagybetűkre és a nagybetűket kisbetűkre.\n * >>> flip_case('Hello')\n * 'hELLO'\n *\n */\nfunction flipCase($string){\n", "entry_point": "flipCase", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"\";\n$x0 = flipCase($arg00);\n$v0 = \"\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"Hello!\";\n$x1 = flipCase($arg10);\n$v1 = \"hELLO!\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"These violent delights have violent ends\";\n$x2 = flipCase($arg20);\n$v2 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n", "description": "Adott karakterlánc esetén fordítsa meg a kisbetűket nagybetűkre és a nagybetűket kisbetűkre.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/8", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Csak pozitív számokat adjon vissza a listában.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n *\n */\nfunction getPositive($l){\n", "entry_point": "getPositive", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [-1, -2, 4, 5, 6];\n$x0 = getPositive($arg00);\n$v0 = [4, 5, 6];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10];\n$x1 = getPositive($arg10);\n$v1 = [5, 3, 2, 3, 3, 9, 123, 1];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [-1, -2];\n$x2 = getPositive($arg20);\n$v2 = [];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [];\n$x3 = getPositive($arg30);\n$v3 = [];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n", "description": "Csak pozitív számokat adjon vissza a listában.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/9", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Ha a megadott szám prím, akkor igazat ad vissza, különben hamisat.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n *\n */\nfunction isPrime($n){\n", "entry_point": "isPrime", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 6;\n$x0 = isPrime($arg00);\n$v0 = false;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 101;\n$x1 = isPrime($arg10);\n$v1 = true;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 11;\n$x2 = isPrime($arg20);\n$v2 = true;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 13441;\n$x3 = isPrime($arg30);\n$v3 = true;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 61;\n$x4 = isPrime($arg40);\n$v4 = true;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 4;\n$x5 = isPrime($arg50);\n$v5 = false;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 1;\n$x6 = isPrime($arg60);\n$v6 = false;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = 5;\n$x7 = isPrime($arg70);\n$v7 = true;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = 11;\n$x8 = isPrime($arg80);\n$v8 = true;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = 17;\n$x9 = isPrime($arg90);\n$v9 = true;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n$arg100 = 85;\n$x10 = isPrime($arg100);\n$v10 = false;\nif (!compare($x10, $v10)) {\n    throw new Exception(\"Error at 11th assert statement.\");\n}\n$arg110 = 77;\n$x11 = isPrime($arg110);\n$v11 = false;\nif (!compare($x11, $v11)) {\n    throw new Exception(\"Error at 12th assert statement.\");\n}\n$arg120 = 255379;\n$x12 = isPrime($arg120);\n$v12 = false;\nif (!compare($x12, $v12)) {\n    throw new Exception(\"Error at 13th assert statement.\");\n}\n", "description": "Ha a megadott szám prím, akkor igazat ad vissza, különben hamisat.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/10", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Visszaadja a rendezett egyedi elemeket egy listában.\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n *\n */\nfunction unique($l){\n", "entry_point": "unique", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [5, 3, 5, 2, 3, 3, 9, 0, 123];\n$x0 = unique($arg00);\n$v0 = [0, 2, 3, 5, 9, 123];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n", "description": "Visszaadja a rendezett egyedi elemeket egy listában.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/11", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * prime_fib visszaadja az n-edik számot, ami Fibonacci-szám és egyben prím is.\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n *\n */\nfunction primeFib($n){\n", "entry_point": "primeFib", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 1;\n$x0 = primeFib($arg00);\n$v0 = 2;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 2;\n$x1 = primeFib($arg10);\n$v1 = 3;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 3;\n$x2 = primeFib($arg20);\n$v2 = 5;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 4;\n$x3 = primeFib($arg30);\n$v3 = 13;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 5;\n$x4 = primeFib($arg40);\n$v4 = 89;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 6;\n$x5 = primeFib($arg50);\n$v5 = 233;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 7;\n$x6 = primeFib($arg60);\n$v6 = 1597;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = 8;\n$x7 = primeFib($arg70);\n$v7 = 28657;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = 9;\n$x8 = primeFib($arg80);\n$v8 = 514229;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = 10;\n$x9 = primeFib($arg90);\n$v9 = 433494437;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n", "description": "prime_fib visszaadja az n-edik számot, ami Fibonacci-szám és egyben prím is.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/12", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * A \"triples_sum_to_zero\" egy egész számok listáját veszi bemenetként.\n *     Igazat ad vissza, ha a listában három különböző elem összege nulla,\n *     és hamisat, ha nem.\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n *\n */\nfunction triplesSumToZero($l){\n", "entry_point": "triplesSumToZero", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [1, 3, 5, 0];\n$x0 = triplesSumToZero($arg00);\n$v0 = false;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1, 3, 5, -1];\n$x1 = triplesSumToZero($arg10);\n$v1 = false;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [1, 3, -2, 1];\n$x2 = triplesSumToZero($arg20);\n$v2 = true;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [1, 2, 3, 7];\n$x3 = triplesSumToZero($arg30);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [1, 2, 5, 7];\n$x4 = triplesSumToZero($arg40);\n$v4 = false;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [2, 4, -5, 3, 9, 7];\n$x5 = triplesSumToZero($arg50);\n$v5 = true;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [1];\n$x6 = triplesSumToZero($arg60);\n$v6 = false;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = [1, 3, 5, -100];\n$x7 = triplesSumToZero($arg70);\n$v7 = false;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = [100, 3, 5, -100];\n$x8 = triplesSumToZero($arg80);\n$v8 = false;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n", "description": "A \"triples_sum_to_zero\" egy egész számok listáját veszi bemenetként.\n    Igazat ad vissza, ha a listában három különböző elem összege nulla,\n    és hamisat, ha nem.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/13", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * A pairs_sum_to_zero egy egész számok listáját veszi bemenetként.\n *     Igazat ad vissza, ha a listában két különböző elem összege nulla,\n *     és hamisat, ha nem.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n *\n */\nfunction pairsSumToZero($l){\n", "entry_point": "pairsSumToZero", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [1, 3, 5, 0];\n$x0 = pairsSumToZero($arg00);\n$v0 = false;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1, 3, -2, 1];\n$x1 = pairsSumToZero($arg10);\n$v1 = false;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [1, 2, 3, 7];\n$x2 = pairsSumToZero($arg20);\n$v2 = false;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [2, 4, -5, 3, 5, 7];\n$x3 = pairsSumToZero($arg30);\n$v3 = true;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [1];\n$x4 = pairsSumToZero($arg40);\n$v4 = false;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [-3, 9, -1, 3, 2, 30];\n$x5 = pairsSumToZero($arg50);\n$v5 = true;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [-3, 9, -1, 3, 2, 31];\n$x6 = pairsSumToZero($arg60);\n$v6 = true;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = [-3, 9, -1, 4, 2, 30];\n$x7 = pairsSumToZero($arg70);\n$v7 = false;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = [-3, 9, -1, 4, 2, 31];\n$x8 = pairsSumToZero($arg80);\n$v8 = false;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n", "description": "A pairs_sum_to_zero egy egész számok listáját veszi bemenetként.\n    Igazat ad vissza, ha a listában két különböző elem összege nulla,\n    és hamisat, ha nem.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/14", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * A Fib4 szám sorozat egy olyan sorozat, amely hasonló a Fibonacci sorozathoz, és a következőképpen van definiálva:\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n *     Kérjük, írjon egy függvényt a fib4 szám sorozat n-edik elemének hatékony kiszámításához. Ne használjon rekurziót.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n *\n */\nfunction fib4($n){\n", "entry_point": "fib4", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 5;\n$x0 = fib4($arg00);\n$v0 = 4;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 8;\n$x1 = fib4($arg10);\n$v1 = 28;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 10;\n$x2 = fib4($arg20);\n$v2 = 104;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 12;\n$x3 = fib4($arg30);\n$v3 = 386;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n", "description": "A Fib4 szám sorozat egy olyan sorozat, amely hasonló a Fibonacci sorozathoz, és a következőképpen van definiálva:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Kérjük, írjon egy függvényt a fib4 szám sorozat n-edik elemének hatékony kiszámításához. Ne használjon rekurziót.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/15", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adja vissza a lista l elemeinek mediánját.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n *\n */\nfunction median($l){\n", "entry_point": "median", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [3, 1, 2, 4, 5];\n$x0 = median($arg00);\n$v0 = 3;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [-10, 4, 6, 1000, 10, 20];\n$x1 = median($arg10);\n$v1 = 8.0;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [5];\n$x2 = median($arg20);\n$v2 = 5;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [6, 5];\n$x3 = median($arg30);\n$v3 = 5.5;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [8, 1, 3, 9, 9, 2, 7];\n$x4 = median($arg40);\n$v4 = 7;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Adja vissza a lista l elemeinek mediánját.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/16", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Ellenőrzi, hogy a megadott karakterlánc palindróma-e.\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n *\n */\nfunction isPalindrome($text){\n", "entry_point": "isPalindrome", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"\";\n$x0 = isPalindrome($arg00);\n$v0 = true;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"aba\";\n$x1 = isPalindrome($arg10);\n$v1 = true;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"aaaaa\";\n$x2 = isPalindrome($arg20);\n$v2 = true;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"zbcd\";\n$x3 = isPalindrome($arg30);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"xywyx\";\n$x4 = isPalindrome($arg40);\n$v4 = true;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"xywyz\";\n$x5 = isPalindrome($arg50);\n$v5 = false;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"xywzx\";\n$x6 = isPalindrome($arg60);\n$v6 = false;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "Ellenőrzi, hogy a megadott karakterlánc palindróma-e.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/17", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * remove_vowels egy olyan függvény, amely egy karakterláncot vesz át, és visszaadja azt a karakterláncot, amelyben nincsenek magánhangzók.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n *\n */\nfunction removeVowels($text){\n", "entry_point": "removeVowels", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"\";\n$x0 = removeVowels($arg00);\n$v0 = \"\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"abcdef\\nghijklm\";\n$x1 = removeVowels($arg10);\n$v1 = \"bcdf\\nghjklm\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"fedcba\";\n$x2 = removeVowels($arg20);\n$v2 = \"fdcb\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"eeeee\";\n$x3 = removeVowels($arg30);\n$v3 = \"\";\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"acBAA\";\n$x4 = removeVowels($arg40);\n$v4 = \"cB\";\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"EcBOO\";\n$x5 = removeVowels($arg50);\n$v5 = \"cB\";\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"ybcd\";\n$x6 = removeVowels($arg60);\n$v6 = \"ybcd\";\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "remove_vowels egy olyan függvény, amely egy karakterláncot vesz át, és visszaadja azt a karakterláncot, amelyben nincsenek magánhangzók.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/18", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Ha az l lista összes száma kisebb, mint a küszöbérték t, akkor igazat ad vissza.\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n *\n */\nfunction belowThreshold($l, $t){\n", "entry_point": "belowThreshold", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [1, 2, 4, 10];\n$arg01 = 100;\n$x0 = belowThreshold($arg00, $arg01);\n$v0 = true;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1, 20, 4, 10];\n$arg11 = 5;\n$x1 = belowThreshold($arg10, $arg11);\n$v1 = false;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [1, 20, 4, 10];\n$arg21 = 21;\n$x2 = belowThreshold($arg20, $arg21);\n$v2 = true;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [1, 20, 4, 10];\n$arg31 = 22;\n$x3 = belowThreshold($arg30, $arg31);\n$v3 = true;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [1, 8, 4, 10];\n$arg41 = 11;\n$x4 = belowThreshold($arg40, $arg41);\n$v4 = true;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [1, 8, 4, 10];\n$arg51 = 10;\n$x5 = belowThreshold($arg50, $arg51);\n$v5 = false;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n", "description": "Ha az l lista összes száma kisebb, mint a küszöbérték t, akkor igazat ad vissza.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/19", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adj hozzá két számot, x-et és y-t.\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n *\n */\nfunction add($x, $y){\n", "entry_point": "add", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 0;\n$arg01 = 1;\n$x0 = add($arg00, $arg01);\n$v0 = 1;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 1;\n$arg11 = 0;\n$x1 = add($arg10, $arg11);\n$v1 = 1;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 2;\n$arg21 = 3;\n$x2 = add($arg20, $arg21);\n$v2 = 5;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 5;\n$arg31 = 7;\n$x3 = add($arg30, $arg31);\n$v3 = 12;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 7;\n$arg41 = 5;\n$x4 = add($arg40, $arg41);\n$v4 = 12;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 572;\n$arg51 = 725;\n$x5 = add($arg50, $arg51);\n$v5 = 1297;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 51;\n$arg61 = 804;\n$x6 = add($arg60, $arg61);\n$v6 = 855;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = 645;\n$arg71 = 96;\n$x7 = add($arg70, $arg71);\n$v7 = 741;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = 712;\n$arg81 = 853;\n$x8 = add($arg80, $arg81);\n$v8 = 1565;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = 223;\n$arg91 = 101;\n$x9 = add($arg90, $arg91);\n$v9 = 324;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n$arg100 = 76;\n$arg101 = 29;\n$x10 = add($arg100, $arg101);\n$v10 = 105;\nif (!compare($x10, $v10)) {\n    throw new Exception(\"Error at 11th assert statement.\");\n}\n$arg110 = 416;\n$arg111 = 149;\n$x11 = add($arg110, $arg111);\n$v11 = 565;\nif (!compare($x11, $v11)) {\n    throw new Exception(\"Error at 12th assert statement.\");\n}\n$arg120 = 145;\n$arg121 = 409;\n$x12 = add($arg120, $arg121);\n$v12 = 554;\nif (!compare($x12, $v12)) {\n    throw new Exception(\"Error at 13th assert statement.\");\n}\n$arg130 = 535;\n$arg131 = 430;\n$x13 = add($arg130, $arg131);\n$v13 = 965;\nif (!compare($x13, $v13)) {\n    throw new Exception(\"Error at 14th assert statement.\");\n}\n$arg140 = 118;\n$arg141 = 303;\n$x14 = add($arg140, $arg141);\n$v14 = 421;\nif (!compare($x14, $v14)) {\n    throw new Exception(\"Error at 15th assert statement.\");\n}\n$arg150 = 287;\n$arg151 = 94;\n$x15 = add($arg150, $arg151);\n$v15 = 381;\nif (!compare($x15, $v15)) {\n    throw new Exception(\"Error at 16th assert statement.\");\n}\n$arg160 = 768;\n$arg161 = 257;\n$x16 = add($arg160, $arg161);\n$v16 = 1025;\nif (!compare($x16, $v16)) {\n    throw new Exception(\"Error at 17th assert statement.\");\n}\n$arg170 = 421;\n$arg171 = 677;\n$x17 = add($arg170, $arg171);\n$v17 = 1098;\nif (!compare($x17, $v17)) {\n    throw new Exception(\"Error at 18th assert statement.\");\n}\n$arg180 = 802;\n$arg181 = 814;\n$x18 = add($arg180, $arg181);\n$v18 = 1616;\nif (!compare($x18, $v18)) {\n    throw new Exception(\"Error at 19th assert statement.\");\n}\n$arg190 = 510;\n$arg191 = 922;\n$x19 = add($arg190, $arg191);\n$v19 = 1432;\nif (!compare($x19, $v19)) {\n    throw new Exception(\"Error at 20th assert statement.\");\n}\n$arg200 = 345;\n$arg201 = 819;\n$x20 = add($arg200, $arg201);\n$v20 = 1164;\nif (!compare($x20, $v20)) {\n    throw new Exception(\"Error at 21th assert statement.\");\n}\n$arg210 = 895;\n$arg211 = 436;\n$x21 = add($arg210, $arg211);\n$v21 = 1331;\nif (!compare($x21, $v21)) {\n    throw new Exception(\"Error at 22th assert statement.\");\n}\n$arg220 = 123;\n$arg221 = 424;\n$x22 = add($arg220, $arg221);\n$v22 = 547;\nif (!compare($x22, $v22)) {\n    throw new Exception(\"Error at 23th assert statement.\");\n}\n$arg230 = 923;\n$arg231 = 245;\n$x23 = add($arg230, $arg231);\n$v23 = 1168;\nif (!compare($x23, $v23)) {\n    throw new Exception(\"Error at 24th assert statement.\");\n}\n$arg240 = 23;\n$arg241 = 438;\n$x24 = add($arg240, $arg241);\n$v24 = 461;\nif (!compare($x24, $v24)) {\n    throw new Exception(\"Error at 25th assert statement.\");\n}\n$arg250 = 565;\n$arg251 = 133;\n$x25 = add($arg250, $arg251);\n$v25 = 698;\nif (!compare($x25, $v25)) {\n    throw new Exception(\"Error at 26th assert statement.\");\n}\n$arg260 = 945;\n$arg261 = 925;\n$x26 = add($arg260, $arg261);\n$v26 = 1870;\nif (!compare($x26, $v26)) {\n    throw new Exception(\"Error at 27th assert statement.\");\n}\n$arg270 = 261;\n$arg271 = 983;\n$x27 = add($arg270, $arg271);\n$v27 = 1244;\nif (!compare($x27, $v27)) {\n    throw new Exception(\"Error at 28th assert statement.\");\n}\n$arg280 = 139;\n$arg281 = 577;\n$x28 = add($arg280, $arg281);\n$v28 = 716;\nif (!compare($x28, $v28)) {\n    throw new Exception(\"Error at 29th assert statement.\");\n}\n$arg290 = 763;\n$arg291 = 178;\n$x29 = add($arg290, $arg291);\n$v29 = 941;\nif (!compare($x29, $v29)) {\n    throw new Exception(\"Error at 30th assert statement.\");\n}\n$arg300 = 147;\n$arg301 = 892;\n$x30 = add($arg300, $arg301);\n$v30 = 1039;\nif (!compare($x30, $v30)) {\n    throw new Exception(\"Error at 31th assert statement.\");\n}\n$arg310 = 436;\n$arg311 = 402;\n$x31 = add($arg310, $arg311);\n$v31 = 838;\nif (!compare($x31, $v31)) {\n    throw new Exception(\"Error at 32th assert statement.\");\n}\n$arg320 = 610;\n$arg321 = 581;\n$x32 = add($arg320, $arg321);\n$v32 = 1191;\nif (!compare($x32, $v32)) {\n    throw new Exception(\"Error at 33th assert statement.\");\n}\n$arg330 = 103;\n$arg331 = 416;\n$x33 = add($arg330, $arg331);\n$v33 = 519;\nif (!compare($x33, $v33)) {\n    throw new Exception(\"Error at 34th assert statement.\");\n}\n$arg340 = 339;\n$arg341 = 990;\n$x34 = add($arg340, $arg341);\n$v34 = 1329;\nif (!compare($x34, $v34)) {\n    throw new Exception(\"Error at 35th assert statement.\");\n}\n$arg350 = 130;\n$arg351 = 504;\n$x35 = add($arg350, $arg351);\n$v35 = 634;\nif (!compare($x35, $v35)) {\n    throw new Exception(\"Error at 36th assert statement.\");\n}\n$arg360 = 242;\n$arg361 = 717;\n$x36 = add($arg360, $arg361);\n$v36 = 959;\nif (!compare($x36, $v36)) {\n    throw new Exception(\"Error at 37th assert statement.\");\n}\n$arg370 = 562;\n$arg371 = 110;\n$x37 = add($arg370, $arg371);\n$v37 = 672;\nif (!compare($x37, $v37)) {\n    throw new Exception(\"Error at 38th assert statement.\");\n}\n$arg380 = 396;\n$arg381 = 909;\n$x38 = add($arg380, $arg381);\n$v38 = 1305;\nif (!compare($x38, $v38)) {\n    throw new Exception(\"Error at 39th assert statement.\");\n}\n$arg390 = 887;\n$arg391 = 703;\n$x39 = add($arg390, $arg391);\n$v39 = 1590;\nif (!compare($x39, $v39)) {\n    throw new Exception(\"Error at 40th assert statement.\");\n}\n$arg400 = 870;\n$arg401 = 551;\n$x40 = add($arg400, $arg401);\n$v40 = 1421;\nif (!compare($x40, $v40)) {\n    throw new Exception(\"Error at 41th assert statement.\");\n}\n$arg410 = 422;\n$arg411 = 391;\n$x41 = add($arg410, $arg411);\n$v41 = 813;\nif (!compare($x41, $v41)) {\n    throw new Exception(\"Error at 42th assert statement.\");\n}\n$arg420 = 299;\n$arg421 = 505;\n$x42 = add($arg420, $arg421);\n$v42 = 804;\nif (!compare($x42, $v42)) {\n    throw new Exception(\"Error at 43th assert statement.\");\n}\n$arg430 = 346;\n$arg431 = 56;\n$x43 = add($arg430, $arg431);\n$v43 = 402;\nif (!compare($x43, $v43)) {\n    throw new Exception(\"Error at 44th assert statement.\");\n}\n$arg440 = 36;\n$arg441 = 706;\n$x44 = add($arg440, $arg441);\n$v44 = 742;\nif (!compare($x44, $v44)) {\n    throw new Exception(\"Error at 45th assert statement.\");\n}\n$arg450 = 738;\n$arg451 = 411;\n$x45 = add($arg450, $arg451);\n$v45 = 1149;\nif (!compare($x45, $v45)) {\n    throw new Exception(\"Error at 46th assert statement.\");\n}\n$arg460 = 679;\n$arg461 = 87;\n$x46 = add($arg460, $arg461);\n$v46 = 766;\nif (!compare($x46, $v46)) {\n    throw new Exception(\"Error at 47th assert statement.\");\n}\n$arg470 = 25;\n$arg471 = 303;\n$x47 = add($arg470, $arg471);\n$v47 = 328;\nif (!compare($x47, $v47)) {\n    throw new Exception(\"Error at 48th assert statement.\");\n}\n$arg480 = 161;\n$arg481 = 612;\n$x48 = add($arg480, $arg481);\n$v48 = 773;\nif (!compare($x48, $v48)) {\n    throw new Exception(\"Error at 49th assert statement.\");\n}\n$arg490 = 306;\n$arg491 = 841;\n$x49 = add($arg490, $arg491);\n$v49 = 1147;\nif (!compare($x49, $v49)) {\n    throw new Exception(\"Error at 50th assert statement.\");\n}\n$arg500 = 973;\n$arg501 = 411;\n$x50 = add($arg500, $arg501);\n$v50 = 1384;\nif (!compare($x50, $v50)) {\n    throw new Exception(\"Error at 51th assert statement.\");\n}\n$arg510 = 711;\n$arg511 = 157;\n$x51 = add($arg510, $arg511);\n$v51 = 868;\nif (!compare($x51, $v51)) {\n    throw new Exception(\"Error at 52th assert statement.\");\n}\n$arg520 = 471;\n$arg521 = 27;\n$x52 = add($arg520, $arg521);\n$v52 = 498;\nif (!compare($x52, $v52)) {\n    throw new Exception(\"Error at 53th assert statement.\");\n}\n$arg530 = 714;\n$arg531 = 792;\n$x53 = add($arg530, $arg531);\n$v53 = 1506;\nif (!compare($x53, $v53)) {\n    throw new Exception(\"Error at 54th assert statement.\");\n}\n$arg540 = 38;\n$arg541 = 206;\n$x54 = add($arg540, $arg541);\n$v54 = 244;\nif (!compare($x54, $v54)) {\n    throw new Exception(\"Error at 55th assert statement.\");\n}\n$arg550 = 907;\n$arg551 = 343;\n$x55 = add($arg550, $arg551);\n$v55 = 1250;\nif (!compare($x55, $v55)) {\n    throw new Exception(\"Error at 56th assert statement.\");\n}\n$arg560 = 23;\n$arg561 = 760;\n$x56 = add($arg560, $arg561);\n$v56 = 783;\nif (!compare($x56, $v56)) {\n    throw new Exception(\"Error at 57th assert statement.\");\n}\n$arg570 = 524;\n$arg571 = 859;\n$x57 = add($arg570, $arg571);\n$v57 = 1383;\nif (!compare($x57, $v57)) {\n    throw new Exception(\"Error at 58th assert statement.\");\n}\n$arg580 = 30;\n$arg581 = 529;\n$x58 = add($arg580, $arg581);\n$v58 = 559;\nif (!compare($x58, $v58)) {\n    throw new Exception(\"Error at 59th assert statement.\");\n}\n$arg590 = 341;\n$arg591 = 691;\n$x59 = add($arg590, $arg591);\n$v59 = 1032;\nif (!compare($x59, $v59)) {\n    throw new Exception(\"Error at 60th assert statement.\");\n}\n$arg600 = 167;\n$arg601 = 729;\n$x60 = add($arg600, $arg601);\n$v60 = 896;\nif (!compare($x60, $v60)) {\n    throw new Exception(\"Error at 61th assert statement.\");\n}\n$arg610 = 636;\n$arg611 = 289;\n$x61 = add($arg610, $arg611);\n$v61 = 925;\nif (!compare($x61, $v61)) {\n    throw new Exception(\"Error at 62th assert statement.\");\n}\n$arg620 = 503;\n$arg621 = 144;\n$x62 = add($arg620, $arg621);\n$v62 = 647;\nif (!compare($x62, $v62)) {\n    throw new Exception(\"Error at 63th assert statement.\");\n}\n$arg630 = 51;\n$arg631 = 985;\n$x63 = add($arg630, $arg631);\n$v63 = 1036;\nif (!compare($x63, $v63)) {\n    throw new Exception(\"Error at 64th assert statement.\");\n}\n$arg640 = 287;\n$arg641 = 149;\n$x64 = add($arg640, $arg641);\n$v64 = 436;\nif (!compare($x64, $v64)) {\n    throw new Exception(\"Error at 65th assert statement.\");\n}\n$arg650 = 659;\n$arg651 = 75;\n$x65 = add($arg650, $arg651);\n$v65 = 734;\nif (!compare($x65, $v65)) {\n    throw new Exception(\"Error at 66th assert statement.\");\n}\n$arg660 = 462;\n$arg661 = 797;\n$x66 = add($arg660, $arg661);\n$v66 = 1259;\nif (!compare($x66, $v66)) {\n    throw new Exception(\"Error at 67th assert statement.\");\n}\n$arg670 = 406;\n$arg671 = 141;\n$x67 = add($arg670, $arg671);\n$v67 = 547;\nif (!compare($x67, $v67)) {\n    throw new Exception(\"Error at 68th assert statement.\");\n}\n$arg680 = 106;\n$arg681 = 44;\n$x68 = add($arg680, $arg681);\n$v68 = 150;\nif (!compare($x68, $v68)) {\n    throw new Exception(\"Error at 69th assert statement.\");\n}\n$arg690 = 300;\n$arg691 = 934;\n$x69 = add($arg690, $arg691);\n$v69 = 1234;\nif (!compare($x69, $v69)) {\n    throw new Exception(\"Error at 70th assert statement.\");\n}\n$arg700 = 471;\n$arg701 = 524;\n$x70 = add($arg700, $arg701);\n$v70 = 995;\nif (!compare($x70, $v70)) {\n    throw new Exception(\"Error at 71th assert statement.\");\n}\n$arg710 = 122;\n$arg711 = 429;\n$x71 = add($arg710, $arg711);\n$v71 = 551;\nif (!compare($x71, $v71)) {\n    throw new Exception(\"Error at 72th assert statement.\");\n}\n$arg720 = 735;\n$arg721 = 195;\n$x72 = add($arg720, $arg721);\n$v72 = 930;\nif (!compare($x72, $v72)) {\n    throw new Exception(\"Error at 73th assert statement.\");\n}\n$arg730 = 335;\n$arg731 = 484;\n$x73 = add($arg730, $arg731);\n$v73 = 819;\nif (!compare($x73, $v73)) {\n    throw new Exception(\"Error at 74th assert statement.\");\n}\n$arg740 = 28;\n$arg741 = 809;\n$x74 = add($arg740, $arg741);\n$v74 = 837;\nif (!compare($x74, $v74)) {\n    throw new Exception(\"Error at 75th assert statement.\");\n}\n$arg750 = 430;\n$arg751 = 20;\n$x75 = add($arg750, $arg751);\n$v75 = 450;\nif (!compare($x75, $v75)) {\n    throw new Exception(\"Error at 76th assert statement.\");\n}\n$arg760 = 916;\n$arg761 = 635;\n$x76 = add($arg760, $arg761);\n$v76 = 1551;\nif (!compare($x76, $v76)) {\n    throw new Exception(\"Error at 77th assert statement.\");\n}\n$arg770 = 301;\n$arg771 = 999;\n$x77 = add($arg770, $arg771);\n$v77 = 1300;\nif (!compare($x77, $v77)) {\n    throw new Exception(\"Error at 78th assert statement.\");\n}\n$arg780 = 454;\n$arg781 = 466;\n$x78 = add($arg780, $arg781);\n$v78 = 920;\nif (!compare($x78, $v78)) {\n    throw new Exception(\"Error at 79th assert statement.\");\n}\n$arg790 = 905;\n$arg791 = 259;\n$x79 = add($arg790, $arg791);\n$v79 = 1164;\nif (!compare($x79, $v79)) {\n    throw new Exception(\"Error at 80th assert statement.\");\n}\n$arg800 = 168;\n$arg801 = 205;\n$x80 = add($arg800, $arg801);\n$v80 = 373;\nif (!compare($x80, $v80)) {\n    throw new Exception(\"Error at 81th assert statement.\");\n}\n$arg810 = 570;\n$arg811 = 434;\n$x81 = add($arg810, $arg811);\n$v81 = 1004;\nif (!compare($x81, $v81)) {\n    throw new Exception(\"Error at 82th assert statement.\");\n}\n$arg820 = 64;\n$arg821 = 959;\n$x82 = add($arg820, $arg821);\n$v82 = 1023;\nif (!compare($x82, $v82)) {\n    throw new Exception(\"Error at 83th assert statement.\");\n}\n$arg830 = 957;\n$arg831 = 510;\n$x83 = add($arg830, $arg831);\n$v83 = 1467;\nif (!compare($x83, $v83)) {\n    throw new Exception(\"Error at 84th assert statement.\");\n}\n$arg840 = 722;\n$arg841 = 598;\n$x84 = add($arg840, $arg841);\n$v84 = 1320;\nif (!compare($x84, $v84)) {\n    throw new Exception(\"Error at 85th assert statement.\");\n}\n$arg850 = 770;\n$arg851 = 226;\n$x85 = add($arg850, $arg851);\n$v85 = 996;\nif (!compare($x85, $v85)) {\n    throw new Exception(\"Error at 86th assert statement.\");\n}\n$arg860 = 579;\n$arg861 = 66;\n$x86 = add($arg860, $arg861);\n$v86 = 645;\nif (!compare($x86, $v86)) {\n    throw new Exception(\"Error at 87th assert statement.\");\n}\n$arg870 = 117;\n$arg871 = 674;\n$x87 = add($arg870, $arg871);\n$v87 = 791;\nif (!compare($x87, $v87)) {\n    throw new Exception(\"Error at 88th assert statement.\");\n}\n$arg880 = 530;\n$arg881 = 30;\n$x88 = add($arg880, $arg881);\n$v88 = 560;\nif (!compare($x88, $v88)) {\n    throw new Exception(\"Error at 89th assert statement.\");\n}\n$arg890 = 776;\n$arg891 = 345;\n$x89 = add($arg890, $arg891);\n$v89 = 1121;\nif (!compare($x89, $v89)) {\n    throw new Exception(\"Error at 90th assert statement.\");\n}\n$arg900 = 327;\n$arg901 = 389;\n$x90 = add($arg900, $arg901);\n$v90 = 716;\nif (!compare($x90, $v90)) {\n    throw new Exception(\"Error at 91th assert statement.\");\n}\n$arg910 = 596;\n$arg911 = 12;\n$x91 = add($arg910, $arg911);\n$v91 = 608;\nif (!compare($x91, $v91)) {\n    throw new Exception(\"Error at 92th assert statement.\");\n}\n$arg920 = 599;\n$arg921 = 511;\n$x92 = add($arg920, $arg921);\n$v92 = 1110;\nif (!compare($x92, $v92)) {\n    throw new Exception(\"Error at 93th assert statement.\");\n}\n$arg930 = 936;\n$arg931 = 476;\n$x93 = add($arg930, $arg931);\n$v93 = 1412;\nif (!compare($x93, $v93)) {\n    throw new Exception(\"Error at 94th assert statement.\");\n}\n$arg940 = 461;\n$arg941 = 14;\n$x94 = add($arg940, $arg941);\n$v94 = 475;\nif (!compare($x94, $v94)) {\n    throw new Exception(\"Error at 95th assert statement.\");\n}\n$arg950 = 966;\n$arg951 = 157;\n$x95 = add($arg950, $arg951);\n$v95 = 1123;\nif (!compare($x95, $v95)) {\n    throw new Exception(\"Error at 96th assert statement.\");\n}\n$arg960 = 326;\n$arg961 = 91;\n$x96 = add($arg960, $arg961);\n$v96 = 417;\nif (!compare($x96, $v96)) {\n    throw new Exception(\"Error at 97th assert statement.\");\n}\n$arg970 = 392;\n$arg971 = 455;\n$x97 = add($arg970, $arg971);\n$v97 = 847;\nif (!compare($x97, $v97)) {\n    throw new Exception(\"Error at 98th assert statement.\");\n}\n$arg980 = 446;\n$arg981 = 477;\n$x98 = add($arg980, $arg981);\n$v98 = 923;\nif (!compare($x98, $v98)) {\n    throw new Exception(\"Error at 99th assert statement.\");\n}\n$arg990 = 324;\n$arg991 = 860;\n$x99 = add($arg990, $arg991);\n$v99 = 1184;\nif (!compare($x99, $v99)) {\n    throw new Exception(\"Error at 100th assert statement.\");\n}\n$arg1000 = 945;\n$arg1001 = 85;\n$x100 = add($arg1000, $arg1001);\n$v100 = 1030;\nif (!compare($x100, $v100)) {\n    throw new Exception(\"Error at 101th assert statement.\");\n}\n$arg1010 = 886;\n$arg1011 = 582;\n$x101 = add($arg1010, $arg1011);\n$v101 = 1468;\nif (!compare($x101, $v101)) {\n    throw new Exception(\"Error at 102th assert statement.\");\n}\n$arg1020 = 886;\n$arg1021 = 712;\n$x102 = add($arg1020, $arg1021);\n$v102 = 1598;\nif (!compare($x102, $v102)) {\n    throw new Exception(\"Error at 103th assert statement.\");\n}\n$arg1030 = 842;\n$arg1031 = 953;\n$x103 = add($arg1030, $arg1031);\n$v103 = 1795;\nif (!compare($x103, $v103)) {\n    throw new Exception(\"Error at 104th assert statement.\");\n}\n", "description": "Adj hozzá két számot, x-et és y-t.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/20", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Ellenőrizze, hogy két szó azonos karaktereket tartalmaz-e.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n *\n */\nfunction sameChars($s0, $s1){\n", "entry_point": "sameChars", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"eabcdzzzz\";\n$arg01 = \"dddzzzzzzzddeddabc\";\n$x0 = sameChars($arg00, $arg01);\n$v0 = true;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"abcd\";\n$arg11 = \"dddddddabc\";\n$x1 = sameChars($arg10, $arg11);\n$v1 = true;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"dddddddabc\";\n$arg21 = \"abcd\";\n$x2 = sameChars($arg20, $arg21);\n$v2 = true;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"eabcd\";\n$arg31 = \"dddddddabc\";\n$x3 = sameChars($arg30, $arg31);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"abcd\";\n$arg41 = \"dddddddabcf\";\n$x4 = sameChars($arg40, $arg41);\n$v4 = false;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"eabcdzzzz\";\n$arg51 = \"dddzzzzzzzddddabc\";\n$x5 = sameChars($arg50, $arg51);\n$v5 = false;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"aabb\";\n$arg61 = \"aaccc\";\n$x6 = sameChars($arg60, $arg61);\n$v6 = false;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "Ellenőrizze, hogy két szó azonos karaktereket tartalmaz-e.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/21", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adja vissza az n-edik Fibonacci számot.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n *\n */\nfunction fib($n){\n", "entry_point": "fib", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 10;\n$x0 = fib($arg00);\n$v0 = 55;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 1;\n$x1 = fib($arg10);\n$v1 = 1;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 8;\n$x2 = fib($arg20);\n$v2 = 21;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 11;\n$x3 = fib($arg30);\n$v3 = 89;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 12;\n$x4 = fib($arg40);\n$v4 = 144;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Adja vissza az n-edik Fibonacci számot.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/22", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adja vissza a két lista rendezett, egyedi közös elemeit.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n\n *\n */\nfunction common($l1, $l2){\n", "entry_point": "common", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [1, 4, 3, 34, 653, 2, 5];\n$arg01 = [5, 7, 1, 5, 9, 653, 121];\n$x0 = common($arg00, $arg01);\n$v0 = [1, 5, 653];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [5, 3, 2, 8];\n$arg11 = [3, 2];\n$x1 = common($arg10, $arg11);\n$v1 = [2, 3];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [4, 3, 2, 8];\n$arg21 = [3, 2, 4];\n$x2 = common($arg20, $arg21);\n$v2 = [2, 3, 4];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [4, 3, 2, 8];\n$arg31 = [];\n$x3 = common($arg30, $arg31);\n$v3 = [];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n", "description": "Adja vissza a két lista rendezett, egyedi közös elemeit.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/23", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adja vissza n legnagyobb prímosztóját. Feltételezzük, hogy n > 1 és nem prím.\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n *\n */\nfunction largestPrimeFactor($n){\n", "entry_point": "largestPrimeFactor", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 15;\n$x0 = largestPrimeFactor($arg00);\n$v0 = 5;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 27;\n$x1 = largestPrimeFactor($arg10);\n$v1 = 3;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 63;\n$x2 = largestPrimeFactor($arg20);\n$v2 = 7;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 330;\n$x3 = largestPrimeFactor($arg30);\n$v3 = 11;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 13195;\n$x4 = largestPrimeFactor($arg40);\n$v4 = 29;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Adja vissza n legnagyobb prímosztóját. Feltételezzük, hogy n > 1 és nem prím.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/24", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * sum_to_n egy olyan függvény, amely összeadja az 1-től n-ig terjedő számokat.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n *\n */\nfunction sumToN($n){\n", "entry_point": "sumToN", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 1;\n$x0 = sumToN($arg00);\n$v0 = 1;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 6;\n$x1 = sumToN($arg10);\n$v1 = 21;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 11;\n$x2 = sumToN($arg20);\n$v2 = 66;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 30;\n$x3 = sumToN($arg30);\n$v3 = 465;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 100;\n$x4 = sumToN($arg40);\n$v4 = 5050;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "sum_to_n egy olyan függvény, amely összeadja az 1-től n-ig terjedő számokat.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/25", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Az xs egy polinom együtthatóit jelöli.\n *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n *     A polinom deriváltját ugyanebben a formában kell visszaadni.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n *\n */\nfunction derivative($xs){\n", "entry_point": "derivative", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [3, 1, 2, 4, 5];\n$x0 = derivative($arg00);\n$v0 = [1, 4, 12, 20];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1, 2, 3];\n$x1 = derivative($arg10);\n$v1 = [2, 6];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [3, 2, 1];\n$x2 = derivative($arg20);\n$v2 = [2, 2];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [3, 2, 1, 0, 4];\n$x3 = derivative($arg30);\n$v3 = [2, 2, 0, 16];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [1];\n$x4 = derivative($arg40);\n$v4 = [];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Az xs egy polinom együtthatóit jelöli.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    A polinom deriváltját ugyanebben a formában kell visszaadni.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/26", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * A FibFib szám sorozat egy olyan sorozat, amely hasonló a Fibonacci sorozathoz, és a következőképpen van definiálva:\n *     fibfib(0) == 0\n *     fibfib(1) == 0\n *     fibfib(2) == 1\n *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n *     Kérjük, írjon egy függvényt a fibfib szám sorozat n-edik elemének hatékony kiszámításához.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n *\n */\nfunction fibfib($n){\n", "entry_point": "fibfib", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 2;\n$x0 = fibfib($arg00);\n$v0 = 1;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 1;\n$x1 = fibfib($arg10);\n$v1 = 0;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 5;\n$x2 = fibfib($arg20);\n$v2 = 4;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 8;\n$x3 = fibfib($arg30);\n$v3 = 24;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 10;\n$x4 = fibfib($arg40);\n$v4 = 81;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 12;\n$x5 = fibfib($arg50);\n$v5 = 274;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 14;\n$x6 = fibfib($arg60);\n$v6 = 927;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "A FibFib szám sorozat egy olyan sorozat, amely hasonló a Fibonacci sorozathoz, és a következőképpen van definiálva:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Kérjük, írjon egy függvényt a fibfib szám sorozat n-edik elemének hatékony kiszámításához.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/27", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Írj egy vowels_count függvényt, amely egy szót reprezentáló stringet vesz bemenetként, és visszaadja a stringben található magánhangzók számát. Magánhangzók ebben az esetben az 'a', 'e', 'i', 'o', 'u'. Itt a 'y' is magánhangzó, de csak akkor, ha a megadott szó végén van.\n * \n * Példa:\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n *\n */\nfunction vowelsCount($s){\n", "entry_point": "vowelsCount", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"abcde\";\n$x0 = vowelsCount($arg00);\n$v0 = 2;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"Alone\";\n$x1 = vowelsCount($arg10);\n$v1 = 3;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"key\";\n$x2 = vowelsCount($arg20);\n$v2 = 2;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"bye\";\n$x3 = vowelsCount($arg30);\n$v3 = 1;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"keY\";\n$x4 = vowelsCount($arg40);\n$v4 = 2;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"bYe\";\n$x5 = vowelsCount($arg50);\n$v5 = 1;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"ACEDY\";\n$x6 = vowelsCount($arg60);\n$v6 = 3;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "Írj egy vowels_count függvényt, amely egy szót reprezentáló stringet vesz bemenetként, és visszaadja a stringben található magánhangzók számát. Magánhangzók ebben az esetben az 'a', 'e', 'i', 'o', 'u'. Itt a 'y' is magánhangzó, de csak akkor, ha a megadott szó végén van.\n\nPélda:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/28", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy nem üres lista pozitív egész számokkal. Adjuk vissza a legnagyobb egész számot, ami nagyobb, mint nulla, és gyakorisága nagyobb vagy egyenlő az egész szám értékével. Az egész szám gyakorisága az, hogy hányszor szerepel a listában. Ha nincs ilyen érték, akkor -1-et adjunk vissza. Példák:\n * \n *     search([4, 1, 2, 2, 3, 1]) == 2\n *     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n *     search([5, 5, 4, 4, 4]) == -1\n *\n */\nfunction search($lst){\n", "entry_point": "search", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [5, 5, 5, 5, 1];\n$x0 = search($arg00);\n$v0 = 1;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [4, 1, 4, 1, 4, 4];\n$x1 = search($arg10);\n$v1 = 4;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [3, 3];\n$x2 = search($arg20);\n$v2 = -1;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [8, 8, 8, 8, 8, 8, 8, 8];\n$x3 = search($arg30);\n$v3 = 8;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [2, 3, 3, 2, 2];\n$x4 = search($arg40);\n$v4 = 2;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1];\n$x5 = search($arg50);\n$v5 = 1;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [3, 2, 8, 2];\n$x6 = search($arg60);\n$v6 = 2;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10];\n$x7 = search($arg70);\n$v7 = 1;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = [8, 8, 3, 6, 5, 6, 4];\n$x8 = search($arg80);\n$v8 = -1;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9];\n$x9 = search($arg90);\n$v9 = 1;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n$arg100 = [1, 9, 10, 1, 3];\n$x10 = search($arg100);\n$v10 = 1;\nif (!compare($x10, $v10)) {\n    throw new Exception(\"Error at 11th assert statement.\");\n}\n$arg110 = [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10];\n$x11 = search($arg110);\n$v11 = 5;\nif (!compare($x11, $v11)) {\n    throw new Exception(\"Error at 12th assert statement.\");\n}\n$arg120 = [1];\n$x12 = search($arg120);\n$v12 = 1;\nif (!compare($x12, $v12)) {\n    throw new Exception(\"Error at 13th assert statement.\");\n}\n$arg130 = [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5];\n$x13 = search($arg130);\n$v13 = 4;\nif (!compare($x13, $v13)) {\n    throw new Exception(\"Error at 14th assert statement.\");\n}\n$arg140 = [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10];\n$x14 = search($arg140);\n$v14 = 2;\nif (!compare($x14, $v14)) {\n    throw new Exception(\"Error at 15th assert statement.\");\n}\n$arg150 = [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3];\n$x15 = search($arg150);\n$v15 = 1;\nif (!compare($x15, $v15)) {\n    throw new Exception(\"Error at 16th assert statement.\");\n}\n$arg160 = [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4];\n$x16 = search($arg160);\n$v16 = 4;\nif (!compare($x16, $v16)) {\n    throw new Exception(\"Error at 17th assert statement.\");\n}\n$arg170 = [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7];\n$x17 = search($arg170);\n$v17 = 4;\nif (!compare($x17, $v17)) {\n    throw new Exception(\"Error at 18th assert statement.\");\n}\n$arg180 = [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1];\n$x18 = search($arg180);\n$v18 = 2;\nif (!compare($x18, $v18)) {\n    throw new Exception(\"Error at 19th assert statement.\");\n}\n$arg190 = [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8];\n$x19 = search($arg190);\n$v19 = -1;\nif (!compare($x19, $v19)) {\n    throw new Exception(\"Error at 20th assert statement.\");\n}\n$arg200 = [10];\n$x20 = search($arg200);\n$v20 = -1;\nif (!compare($x20, $v20)) {\n    throw new Exception(\"Error at 21th assert statement.\");\n}\n$arg210 = [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2];\n$x21 = search($arg210);\n$v21 = 2;\nif (!compare($x21, $v21)) {\n    throw new Exception(\"Error at 22th assert statement.\");\n}\n$arg220 = [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8];\n$x22 = search($arg220);\n$v22 = 1;\nif (!compare($x22, $v22)) {\n    throw new Exception(\"Error at 23th assert statement.\");\n}\n$arg230 = [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6];\n$x23 = search($arg230);\n$v23 = 1;\nif (!compare($x23, $v23)) {\n    throw new Exception(\"Error at 24th assert statement.\");\n}\n$arg240 = [3, 10, 10, 9, 2];\n$x24 = search($arg240);\n$v24 = -1;\nif (!compare($x24, $v24)) {\n    throw new Exception(\"Error at 25th assert statement.\");\n}\n", "description": "Adott egy nem üres lista pozitív egész számokkal. Adjuk vissza a legnagyobb egész számot, ami nagyobb, mint nulla, és gyakorisága nagyobb vagy egyenlő az egész szám értékével. Az egész szám gyakorisága az, hogy hányszor szerepel a listában. Ha nincs ilyen érték, akkor -1-et adjunk vissza. Példák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/29", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy háromszög három oldalának hossza. Ha a három oldal alkot egy érvényes háromszöget, akkor térjen vissza a háromszög területével, két tizedesjegyre kerekítve. Ellenkező esetben térjen vissza -1-gyel. Három oldal akkor alkot érvényes háromszöget, ha bármely két oldal összege nagyobb, mint a harmadik oldal. Példa:\n * \n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n *\n */\nfunction triangleArea($a, $b, $c){\n", "entry_point": "triangleArea", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 3;\n$arg01 = 4;\n$arg02 = 5;\n$x0 = triangleArea($arg00, $arg01, $arg02);\n$v0 = 6.0;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 1;\n$arg11 = 2;\n$arg12 = 10;\n$x1 = triangleArea($arg10, $arg11, $arg12);\n$v1 = -1;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 4;\n$arg21 = 8;\n$arg22 = 5;\n$x2 = triangleArea($arg20, $arg21, $arg22);\n$v2 = 8.18;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 2;\n$arg31 = 2;\n$arg32 = 2;\n$x3 = triangleArea($arg30, $arg31, $arg32);\n$v3 = 1.73;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 1;\n$arg41 = 2;\n$arg42 = 3;\n$x4 = triangleArea($arg40, $arg41, $arg42);\n$v4 = -1;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 10;\n$arg51 = 5;\n$arg52 = 7;\n$x5 = triangleArea($arg50, $arg51, $arg52);\n$v5 = 16.25;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 2;\n$arg61 = 6;\n$arg62 = 3;\n$x6 = triangleArea($arg60, $arg61, $arg62);\n$v6 = -1;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = 1;\n$arg71 = 1;\n$arg72 = 1;\n$x7 = triangleArea($arg70, $arg71, $arg72);\n$v7 = 0.43;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = 2;\n$arg81 = 2;\n$arg82 = 10;\n$x8 = triangleArea($arg80, $arg81, $arg82);\n$v8 = -1;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n", "description": "Adott egy háromszög három oldalának hossza. Ha a három oldal alkot egy érvényes háromszöget, akkor térjen vissza a háromszög területével, két tizedesjegyre kerekítve. Ellenkező esetben térjen vissza -1-gyel. Három oldal akkor alkot érvényes háromszöget, ha bármely két oldal összege nagyobb, mint a harmadik oldal. Példa:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/30", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Írj egy függvényt, amely igazat ad vissza, ha a q objektum repül, és hamisat, ha nem.\n *     Az q objektum akkor repül, ha kiegyensúlyozott (palindróm lista), és az elemeinek összege kisebb vagy egyenlő a maximális lehetséges súllyal w.\n * \n *     Példa:\n *     will_it_fly([1, 2], 5) ➞ False \n *     # 1+2 kisebb, mint a maximális lehetséges súly, de kiegyensúlyozatlan.\n * \n *     will_it_fly([3, 2, 3], 1) ➞ False\n *     # kiegyensúlyozott, de 3+2+3 több, mint a maximális lehetséges súly.\n * \n *     will_it_fly([3, 2, 3], 9) ➞ True\n *     # 3+2+3 kisebb, mint a maximális lehetséges súly, és kiegyensúlyozott.\n * \n *     will_it_fly([3], 5) ➞ True\n *     # 3 kisebb, mint a maximális lehetséges súly, és kiegyensúlyozott.\n * \n *\n */\nfunction willItFly($q, $w){\n", "entry_point": "willItFly", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [3, 2, 3];\n$arg01 = 9;\n$x0 = willItFly($arg00, $arg01);\n$v0 = true;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1, 2];\n$arg11 = 5;\n$x1 = willItFly($arg10, $arg11);\n$v1 = false;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [3];\n$arg21 = 5;\n$x2 = willItFly($arg20, $arg21);\n$v2 = true;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [3, 2, 3];\n$arg31 = 1;\n$x3 = willItFly($arg30, $arg31);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [1, 2, 3];\n$arg41 = 6;\n$x4 = willItFly($arg40, $arg41);\n$v4 = false;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [5];\n$arg51 = 5;\n$x5 = willItFly($arg50, $arg51);\n$v5 = true;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n", "description": "Írj egy függvényt, amely igazat ad vissza, ha a q objektum repül, és hamisat, ha nem.\n    Az q objektum akkor repül, ha kiegyensúlyozott (palindróm lista), és az elemeinek összege kisebb vagy egyenlő a maximális lehetséges súllyal w.\n\n    Példa:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 kisebb, mint a maximális lehetséges súly, de kiegyensúlyozatlan.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # kiegyensúlyozott, de 3+2+3 több, mint a maximális lehetséges súly.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 kisebb, mint a maximális lehetséges súly, és kiegyensúlyozott.\n\n    will_it_fly([3], 5) ➞ True\n    # 3 kisebb, mint a maximális lehetséges súly, és kiegyensúlyozott.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/31", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Írj egy függvényt, amely igazat ad vissza, ha a megadott szám három prímszám szorzata, és hamisat, ha nem. Tudva, hogy (a) kisebb, mint 100. Példa:\n * \n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n *\n */\nfunction isMultiplyPrime($a){\n", "entry_point": "isMultiplyPrime", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 5;\n$x0 = isMultiplyPrime($arg00);\n$v0 = false;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 30;\n$x1 = isMultiplyPrime($arg10);\n$v1 = true;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 8;\n$x2 = isMultiplyPrime($arg20);\n$v2 = true;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 10;\n$x3 = isMultiplyPrime($arg30);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 125;\n$x4 = isMultiplyPrime($arg40);\n$v4 = true;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 105;\n$x5 = isMultiplyPrime($arg50);\n$v5 = true;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 126;\n$x6 = isMultiplyPrime($arg60);\n$v6 = false;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = 729;\n$x7 = isMultiplyPrime($arg70);\n$v7 = false;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = 891;\n$x8 = isMultiplyPrime($arg80);\n$v8 = false;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = 1001;\n$x9 = isMultiplyPrime($arg90);\n$v9 = true;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n", "description": "Írj egy függvényt, amely igazat ad vissza, ha a megadott szám három prímszám szorzata, és hamisat, ha nem. Tudva, hogy (a) kisebb, mint 100. Példa:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/32", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Kapni fogsz egy számot decimális formában, és a feladatod az, hogy átalakítsd bináris formátumra. A függvénynek egy karakterláncot kell visszaadnia, ahol minden karakter egy bináris számot képvisel. A karakterláncban minden karakter '0' vagy '1' lesz.\n * \n * Az elején és a végén is lesz néhány extra karakter 'db' formájában. Az extra karakterek a formázáshoz szükségesek.\n * \n * Példák:\n * \n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n *\n */\nfunction decimalToBinary($decimal){\n", "entry_point": "decimalToBinary", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 0;\n$x0 = decimalToBinary($arg00);\n$v0 = \"db0db\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 32;\n$x1 = decimalToBinary($arg10);\n$v1 = \"db100000db\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 103;\n$x2 = decimalToBinary($arg20);\n$v2 = \"db1100111db\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 15;\n$x3 = decimalToBinary($arg30);\n$v3 = \"db1111db\";\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n", "description": "Kapni fogsz egy számot decimális formában, és a feladatod az, hogy átalakítsd bináris formátumra. A függvénynek egy karakterláncot kell visszaadnia, ahol minden karakter egy bináris számot képvisel. A karakterláncban minden karakter '0' vagy '1' lesz.\n\nAz elején és a végén is lesz néhány extra karakter 'db' formájában. Az extra karakterek a formázáshoz szükségesek.\n\nPéldák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/33", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adott egy s karakterlánc.\n *     A feladatod az, hogy ellenőrizd, boldog-e a karakterlánc.\n *     Egy karakterlánc boldog, ha legalább 3 karakter hosszú, és minden 3 egymást követő karakter különböző.\n *     Például:\n * \n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n *\n */\nfunction isHappy($s){\n", "entry_point": "isHappy", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"a\";\n$x0 = isHappy($arg00);\n$v0 = false;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"aa\";\n$x1 = isHappy($arg10);\n$v1 = false;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"abcd\";\n$x2 = isHappy($arg20);\n$v2 = true;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"aabb\";\n$x3 = isHappy($arg30);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"adb\";\n$x4 = isHappy($arg40);\n$v4 = true;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"xyy\";\n$x5 = isHappy($arg50);\n$v5 = false;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"iopaxpoi\";\n$x6 = isHappy($arg60);\n$v6 = true;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = \"iopaxioi\";\n$x7 = isHappy($arg70);\n$v7 = false;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n", "description": "Adott egy s karakterlánc.\n    A feladatod az, hogy ellenőrizd, boldog-e a karakterlánc.\n    Egy karakterlánc boldog, ha legalább 3 karakter hosszú, és minden 3 egymást követő karakter különböző.\n    Például:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/34", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * A félév utolsó hete van, és a tanárnőnek osztályzatokat kell adnia a diákoknak. A tanárnő saját algoritmust készített az osztályzásra. Az egyetlen probléma az, hogy elvesztette az osztályzásához használt kódot. Adott neked néhány diák GPA-jának listáját, és írnod kell egy függvényt, amely a következő táblázatot használva ki tudja írni az osztályzatok listáját:\n * \n *              GPA       |    Letter grade\n *               4.0                A+\n *             > 3.7                A \n *             > 3.3                A- \n *             > 3.0                B+\n *             > 2.7                B \n *             > 2.3                B-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                E\n *     \n * \n *     Példa:\n * \n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n *\n */\nfunction numericalLetterGrade($grades){\n", "entry_point": "numericalLetterGrade", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [4.0, 3, 1.7, 2, 3.5];\n$x0 = numericalLetterGrade($arg00);\n$v0 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1.2];\n$x1 = numericalLetterGrade($arg10);\n$v1 = [\"D+\"];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [0.5];\n$x2 = numericalLetterGrade($arg20);\n$v2 = [\"D-\"];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [0.0];\n$x3 = numericalLetterGrade($arg30);\n$v3 = [\"E\"];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [1, 0.3, 1.5, 2.8, 3.3];\n$x4 = numericalLetterGrade($arg40);\n$v4 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [0, 0.7];\n$x5 = numericalLetterGrade($arg50);\n$v5 = [\"E\", \"D-\"];\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n", "description": "A félév utolsó hete van, és a tanárnőnek osztályzatokat kell adnia a diákoknak. A tanárnő saját algoritmust készített az osztályzásra. Az egyetlen probléma az, hogy elvesztette az osztályzásához használt kódot. Adott neked néhány diák GPA-jának listáját, és írnod kell egy függvényt, amely a következő táblázatot használva ki tudja írni az osztályzatok listáját:\n\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Példa:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/35", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Írj egy függvényt, amely egy karakterláncot vesz át, és igazat ad vissza, ha a karakterlánc hossza prímszám, egyébként hamisat. Példák:\n * \n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n *\n */\nfunction primeLength($string){\n", "entry_point": "primeLength", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"Hello\";\n$x0 = primeLength($arg00);\n$v0 = true;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"abcdcba\";\n$x1 = primeLength($arg10);\n$v1 = true;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"kittens\";\n$x2 = primeLength($arg20);\n$v2 = true;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"orange\";\n$x3 = primeLength($arg30);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"wow\";\n$x4 = primeLength($arg40);\n$v4 = true;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"world\";\n$x5 = primeLength($arg50);\n$v5 = true;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"MadaM\";\n$x6 = primeLength($arg60);\n$v6 = true;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = \"Wow\";\n$x7 = primeLength($arg70);\n$v7 = true;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = \"\";\n$x8 = primeLength($arg80);\n$v8 = false;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = \"HI\";\n$x9 = primeLength($arg90);\n$v9 = true;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n$arg100 = \"go\";\n$x10 = primeLength($arg100);\n$v10 = true;\nif (!compare($x10, $v10)) {\n    throw new Exception(\"Error at 11th assert statement.\");\n}\n$arg110 = \"gogo\";\n$x11 = primeLength($arg110);\n$v11 = false;\nif (!compare($x11, $v11)) {\n    throw new Exception(\"Error at 12th assert statement.\");\n}\n$arg120 = \"aaaaaaaaaaaaaaa\";\n$x12 = primeLength($arg120);\n$v12 = false;\nif (!compare($x12, $v12)) {\n    throw new Exception(\"Error at 13th assert statement.\");\n}\n$arg130 = \"Madam\";\n$x13 = primeLength($arg130);\n$v13 = true;\nif (!compare($x13, $v13)) {\n    throw new Exception(\"Error at 14th assert statement.\");\n}\n$arg140 = \"M\";\n$x14 = primeLength($arg140);\n$v14 = false;\nif (!compare($x14, $v14)) {\n    throw new Exception(\"Error at 15th assert statement.\");\n}\n$arg150 = \"0\";\n$x15 = primeLength($arg150);\n$v15 = false;\nif (!compare($x15, $v15)) {\n    throw new Exception(\"Error at 16th assert statement.\");\n}\n", "description": "Írj egy függvényt, amely egy karakterláncot vesz át, és igazat ad vissza, ha a karakterlánc hossza prímszám, egyébként hamisat. Példák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/36", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adott egy pozitív egész szám N, térj vissza a számjegyeinek összegével binárisan.\n * \n *     Példa:\n *         Ha N = 1000, akkor a számjegyek összege 1 lesz, az eredmény \"1\" kell legyen.\n *         Ha N = 150, akkor a számjegyek összege 6 lesz, az eredmény \"110\" kell legyen.\n *         Ha N = 147, akkor a számjegyek összege 12 lesz, az eredmény \"1100\" kell legyen.\n *     \n *     Változók:\n *         @N egész szám\n *              Korlátok: 0 ≤ N ≤ 10000.\n *     Kimenet:\n *          egy bináris szám string formájában.\n * \n *\n */\nfunction solve($n){\n", "entry_point": "solve", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 1000;\n$x0 = solve($arg00);\n$v0 = \"1\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 150;\n$x1 = solve($arg10);\n$v1 = \"110\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 147;\n$x2 = solve($arg20);\n$v2 = \"1100\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 333;\n$x3 = solve($arg30);\n$v3 = \"1001\";\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 963;\n$x4 = solve($arg40);\n$v4 = \"10010\";\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Adott egy pozitív egész szám N, térj vissza a számjegyeinek összegével binárisan.\n\n    Példa:\n        Ha N = 1000, akkor a számjegyek összege 1 lesz, az eredmény \"1\" kell legyen.\n        Ha N = 150, akkor a számjegyek összege 6 lesz, az eredmény \"110\" kell legyen.\n        Ha N = 147, akkor a számjegyek összege 12 lesz, az eredmény \"1100\" kell legyen.\n    \n    Változók:\n        @N egész szám\n             Korlátok: 0 ≤ N ≤ 10000.\n    Kimenet:\n         egy bináris szám string formájában.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/37", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy 2 dimenziós adat, mint egy beágyazott lista, amely hasonló a mátrixhoz, azonban, ellentétben a mátrixokkal, minden sorban lehet különböző számú oszlop. Adott lst és x egész szám, keressük meg az x egész számokat a listában, majd térjünk vissza egy [(x1, y1), (x2, y2) ...] tuple listával, amelyek mindegyike egy koordináta - (sor, oszlop), kezdve 0-tól. A koordinátákat kezdetben soronként növekvő sorrendben rendezzük. Emellett a sor koordinátáit oszlopok szerint csökkenő sorrendben rendezzük.\n * \n * Példák:\n * \n * get_row([\n *   [1,2,3,4,5,6],\n *   [1,2,3,4,1,6],\n *   [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n *\n */\nfunction getRow($lst, $x){\n", "entry_point": "getRow", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [];\n$arg01 = 1;\n$x0 = getRow($arg00, $arg01);\n$v0 = [];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [[1]];\n$arg11 = 2;\n$x1 = getRow($arg10, $arg11);\n$v1 = [];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [[], [1], [1, 2, 3]];\n$arg21 = 3;\n$x2 = getRow($arg20, $arg21);\n$v2 = [[2, 2]];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n", "description": "Adott egy 2 dimenziós adat, mint egy beágyazott lista, amely hasonló a mátrixhoz, azonban, ellentétben a mátrixokkal, minden sorban lehet különböző számú oszlop. Adott lst és x egész szám, keressük meg az x egész számokat a listában, majd térjünk vissza egy [(x1, y1), (x2, y2) ...] tuple listával, amelyek mindegyike egy koordináta - (sor, oszlop), kezdve 0-tól. A koordinátákat kezdetben soronként növekvő sorrendben rendezzük. Emellett a sor koordinátáit oszlopok szerint csökkenő sorrendben rendezzük.\n\nPéldák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/38", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy egész számok listája.\n * Írj egy next_smallest() függvényt, amely visszaadja a lista második legkisebb elemét.\n * Ha nincs ilyen elem, akkor null-t adjon vissza.\n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n *\n */\nfunction nextSmallest($lst){\n", "entry_point": "nextSmallest", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [1, 2, 3, 4, 5];\n$x0 = nextSmallest($arg00);\n$v0 = 2;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [5, 1, 4, 3, 2];\n$x1 = nextSmallest($arg10);\n$v1 = 2;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [];\n$x2 = nextSmallest($arg20);\n$v2 = null;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [1, 1];\n$x3 = nextSmallest($arg30);\n$v3 = null;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [1, 1, 1, 1, 0];\n$x4 = nextSmallest($arg40);\n$v4 = 1;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [1, 1];\n$x5 = nextSmallest($arg50);\n$v5 = null;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [-35, 34, 12, -45];\n$x6 = nextSmallest($arg60);\n$v6 = -35;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "Adott egy egész számok listája.\nÍrj egy next_smallest() függvényt, amely visszaadja a lista második legkisebb elemét.\nHa nincs ilyen elem, akkor null-t adjon vissza.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/39", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy szósztring, és a feladatod az unalomok számának megszámlálása. Az unalom olyan mondat, amely az \"I\" szóval kezdődik. A mondatokat '.' vagy '?' vagy '!' határolja.\n * \n * Például:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n *\n */\nfunction isBored($s){\n", "entry_point": "isBored", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"Hello world\";\n$x0 = isBored($arg00);\n$v0 = 0;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"Is the sky blue?\";\n$x1 = isBored($arg10);\n$v1 = 0;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"I love It !\";\n$x2 = isBored($arg20);\n$v2 = 1;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"bIt\";\n$x3 = isBored($arg30);\n$v3 = 0;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"I feel good today. I will be productive. will kill It\";\n$x4 = isBored($arg40);\n$v4 = 2;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"You and I are going for a walk\";\n$x5 = isBored($arg50);\n$v5 = 0;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n", "description": "Adott egy szósztring, és a feladatod az unalomok számának megszámlálása. Az unalom olyan mondat, amely az \"I\" szóval kezdődik. A mondatokat '.' vagy '?' vagy '!' határolja.\n\nPéldául:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/40", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adott egy egész számok listája.\n *     Meg kell találnod a legnagyobb prímszámot és vissza kell adnod annak számjegyeinek összegét.\n * \n *     Példák:\n * \n * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n * For lst = [0,81,12,3,1,21] the output should be 3\n * For lst = [0,8,1,2,1,7] the output should be 7\n *\n */\nfunction skjkasdkd($lst){\n", "entry_point": "skjkasdkd", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3];\n$x0 = skjkasdkd($arg00);\n$v0 = 10;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1];\n$x1 = skjkasdkd($arg10);\n$v1 = 25;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3];\n$x2 = skjkasdkd($arg20);\n$v2 = 13;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6];\n$x3 = skjkasdkd($arg30);\n$v3 = 11;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [0, 81, 12, 3, 1, 21];\n$x4 = skjkasdkd($arg40);\n$v4 = 3;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [0, 8, 1, 2, 1, 7];\n$x5 = skjkasdkd($arg50);\n$v5 = 7;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [8191];\n$x6 = skjkasdkd($arg60);\n$v6 = 19;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = [8191, 123456, 127, 7];\n$x7 = skjkasdkd($arg70);\n$v7 = 19;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = [127, 97, 8192];\n$x8 = skjkasdkd($arg80);\n$v8 = 10;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n", "description": "Adott egy egész számok listája.\n    Meg kell találnod a legnagyobb prímszámot és vissza kell adnod annak számjegyeinek összegét.\n\n    Példák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/41", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy szótár, térjen vissza igazzal, ha az összes kulcs kisbetűs string vagy az összes kulcs nagybetűs string, különben térjen vissza hamissal. A függvény hamissal térjen vissza, ha a megadott szótár üres. Példák:\n * \n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n *\n */\nfunction checkDictCase($dict){\n", "entry_point": "checkDictCase", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [\"p\" => \"pineapple\", \"b\" => \"banana\"];\n$x0 = checkDictCase($arg00);\n$v0 = true;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"];\n$x1 = checkDictCase($arg10);\n$v1 = false;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [\"p\" => \"pineapple\", 5 => \"banana\", \"a\" => \"apple\"];\n$x2 = checkDictCase($arg20);\n$v2 = false;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"];\n$x3 = checkDictCase($arg30);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [\"STATE\" => \"NC\", \"ZIP\" => \"12345\"];\n$x4 = checkDictCase($arg40);\n$v4 = true;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"];\n$x5 = checkDictCase($arg50);\n$v5 = true;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [];\n$x6 = checkDictCase($arg60);\n$v6 = false;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "Adott egy szótár, térjen vissza igazzal, ha az összes kulcs kisbetűs string vagy az összes kulcs nagybetűs string, különben térjen vissza hamissal. A függvény hamissal térjen vissza, ha a megadott szótár üres. Példák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/42", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Hozz létre egy függvényt, amely egy számot reprezentáló értéket (string) vesz át, és visszaadja a legközelebbi egész számot. Ha a szám két egész szám között egyenlő távolságra van, akkor kerekítse azt távolabb a zérótól.\n * \n *     Példák\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n\n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n *\n */\nfunction closestInteger($value){\n", "entry_point": "closestInteger", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"10\";\n$x0 = closestInteger($arg00);\n$v0 = 10;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"14.5\";\n$x1 = closestInteger($arg10);\n$v1 = 15;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"-15.5\";\n$x2 = closestInteger($arg20);\n$v2 = -16;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"15.3\";\n$x3 = closestInteger($arg30);\n$v3 = 15;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"0\";\n$x4 = closestInteger($arg40);\n$v4 = 0;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Hozz létre egy függvényt, amely egy számot reprezentáló értéket (string) vesz át, és visszaadja a legközelebbi egész számot. Ha a szám két egész szám között egyenlő távolságra van, akkor kerekítse azt távolabb a zérótól.\n\n    Példák", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/43", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy pozitív egész szám n, és egy n szintű kőhalomot kell létrehoznod.\n * Az első szinten n darab kő van.\n * A következő szinten a következő számú kövek vannak:\n * - a következő páratlan szám, ha n páratlan.\n * - a következő páros szám, ha n páros.\n * Egy listában vissza kell adni a szintenkénti kövek számát, ahol az i. indexű elem a (i+1). szinten lévő kövek számát jelenti.\n * \n * Példák:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n *\n */\nfunction makeAPile($n){\n", "entry_point": "makeAPile", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 3;\n$x0 = makeAPile($arg00);\n$v0 = [3, 5, 7];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 4;\n$x1 = makeAPile($arg10);\n$v1 = [4, 6, 8, 10];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 5;\n$x2 = makeAPile($arg20);\n$v2 = [5, 7, 9, 11, 13];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 6;\n$x3 = makeAPile($arg30);\n$v3 = [6, 8, 10, 12, 14, 16];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 8;\n$x4 = makeAPile($arg40);\n$v4 = [8, 10, 12, 14, 16, 18, 20, 22];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Adott egy pozitív egész szám n, és egy n szintű kőhalomot kell létrehoznod.\nAz első szinten n darab kő van.\nA következő szinten a következő számú kövek vannak:\n- a következő páratlan szám, ha n páratlan.\n- a következő páros szám, ha n páros.\nEgy listában vissza kell adni a szintenkénti kövek számát, ahol az i. indexű elem a (i+1). szinten lévő kövek számát jelenti.\n\nPéldák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/44", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott lesz egy szóközökkel vagy vesszőkkel elválasztott szavakból álló karakterlánc. A feladatod az, hogy szétválaszd a karakterláncot szavakra, majd visszatérj egy tömbbel, amely a szavakat tartalmazza.\n * \n * Példa:\n * \n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n *\n */\nfunction wordsString($s){\n", "entry_point": "wordsString", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"Hi, my name is John\";\n$x0 = wordsString($arg00);\n$v0 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"One, two, three, four, five, six\";\n$x1 = wordsString($arg10);\n$v1 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"Hi, my name\";\n$x2 = wordsString($arg20);\n$v2 = [\"Hi\", \"my\", \"name\"];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"One,, two, three, four, five, six,\";\n$x3 = wordsString($arg30);\n$v3 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"\";\n$x4 = wordsString($arg40);\n$v4 = [];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"ahmed     , gamal\";\n$x5 = wordsString($arg50);\n$v5 = [\"ahmed\", \"gamal\"];\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n", "description": "Adott lesz egy szóközökkel vagy vesszőkkel elválasztott szavakból álló karakterlánc. A feladatod az, hogy szétválaszd a karakterláncot szavakra, majd visszatérj egy tömbbel, amely a szavakat tartalmazza.\n\nPélda:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/45", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Ez a függvény két pozitív számot, x-et és y-t vesz át, majd visszaadja a legnagyobb páros egész számot, amely az [x, y] tartományba esik. Ha nincs ilyen szám, akkor a függvény -1-et ad vissza.\n * \n * Példa:\n * \n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n *\n */\nfunction chooseNum($x, $y){\n", "entry_point": "chooseNum", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 12;\n$arg01 = 15;\n$x0 = chooseNum($arg00, $arg01);\n$v0 = 14;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 13;\n$arg11 = 12;\n$x1 = chooseNum($arg10, $arg11);\n$v1 = -1;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 33;\n$arg21 = 12354;\n$x2 = chooseNum($arg20, $arg21);\n$v2 = 12354;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 5234;\n$arg31 = 5233;\n$x3 = chooseNum($arg30, $arg31);\n$v3 = -1;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 6;\n$arg41 = 29;\n$x4 = chooseNum($arg40, $arg41);\n$v4 = 28;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 27;\n$arg51 = 10;\n$x5 = chooseNum($arg50, $arg51);\n$v5 = -1;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 7;\n$arg61 = 7;\n$x6 = chooseNum($arg60, $arg61);\n$v6 = -1;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = 546;\n$arg71 = 546;\n$x7 = chooseNum($arg70, $arg71);\n$v7 = 546;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n", "description": "Ez a függvény két pozitív számot, x-et és y-t vesz át, majd visszaadja a legnagyobb páros egész számot, amely az [x, y] tartományba esik. Ha nincs ilyen szám, akkor a függvény -1-et ad vissza.\n\nPélda:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/46", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Két pozitív egész számot, n-et és m-et adnak meg neked, és a feladatod az, hogy kiszámold az egész számok átlagát n-től m-ig (beleértve n-et és m-et). Kerekítsd az eredményt a legközelebbi egészre, majd konvertáld azt binárisra. Ha n nagyobb, mint m, térj vissza -1-gyel. Példa:\n * \n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n *\n */\nfunction roundedAvg($n, $m){\n", "entry_point": "roundedAvg", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 1;\n$arg01 = 5;\n$x0 = roundedAvg($arg00, $arg01);\n$v0 = \"0b11\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 7;\n$arg11 = 13;\n$x1 = roundedAvg($arg10, $arg11);\n$v1 = \"0b1010\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 964;\n$arg21 = 977;\n$x2 = roundedAvg($arg20, $arg21);\n$v2 = \"0b1111001010\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 996;\n$arg31 = 997;\n$x3 = roundedAvg($arg30, $arg31);\n$v3 = \"0b1111100100\";\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 560;\n$arg41 = 851;\n$x4 = roundedAvg($arg40, $arg41);\n$v4 = \"0b1011000010\";\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 185;\n$arg51 = 546;\n$x5 = roundedAvg($arg50, $arg51);\n$v5 = \"0b101101110\";\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 362;\n$arg61 = 496;\n$x6 = roundedAvg($arg60, $arg61);\n$v6 = \"0b110101101\";\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = 350;\n$arg71 = 902;\n$x7 = roundedAvg($arg70, $arg71);\n$v7 = \"0b1001110010\";\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = 197;\n$arg81 = 233;\n$x8 = roundedAvg($arg80, $arg81);\n$v8 = \"0b11010111\";\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = 7;\n$arg91 = 5;\n$x9 = roundedAvg($arg90, $arg91);\n$v9 = -1;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n$arg100 = 5;\n$arg101 = 1;\n$x10 = roundedAvg($arg100, $arg101);\n$v10 = -1;\nif (!compare($x10, $v10)) {\n    throw new Exception(\"Error at 11th assert statement.\");\n}\n$arg110 = 5;\n$arg111 = 5;\n$x11 = roundedAvg($arg110, $arg111);\n$v11 = \"0b101\";\nif (!compare($x11, $v11)) {\n    throw new Exception(\"Error at 12th assert statement.\");\n}\n", "description": "Két pozitív egész számot, n-et és m-et adnak meg neked, és a feladatod az, hogy kiszámold az egész számok átlagát n-től m-ig (beleértve n-et és m-et). Kerekítsd az eredményt a legközelebbi egészre, majd konvertáld azt binárisra. Ha n nagyobb, mint m, térj vissza -1-gyel. Példa:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/47", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Valósítsa meg a függvényt, amely n paramétert vesz át,\n *     és visszaad egy n méretű listát, úgy hogy az i indexű elem értéke az i faktoriálisa, ha i páros,\n *     vagy az 1-től i-ig terjedő számok összege, ha i páratlan.\n *     Az i 1-től indul.\n *     Az i faktoriálisa az 1-től i-ig terjedő számok szorzata (1 * 2 * ... * i).\n *     Példa:\n * \n * f(5) == [1, 2, 6, 24, 15]\n *\n */\nfunction f($n){\n", "entry_point": "f", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 5;\n$x0 = f($arg00);\n$v0 = [1, 2, 6, 24, 15];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 7;\n$x1 = f($arg10);\n$v1 = [1, 2, 6, 24, 15, 720, 28];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 1;\n$x2 = f($arg20);\n$v2 = [1];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 3;\n$x3 = f($arg30);\n$v3 = [1, 2, 6];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n", "description": "Valósítsa meg a függvényt, amely n paramétert vesz át,\n    és visszaad egy n méretű listát, úgy hogy az i indexű elem értéke az i faktoriálisa, ha i páros,\n    vagy az 1-től i-ig terjedő számok összege, ha i páratlan.\n    Az i 1-től indul.\n    Az i faktoriálisa az 1-től i-ig terjedő számok szorzata (1 * 2 * ... * i).\n    Példa:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/48", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adjon meg egy pozitív egész számot n, és térjen vissza egy tuple-el, amely tartalmazza a páros és páratlan egész szám palindrómok számát a (1, n) tartományban, beleértve a határokat.\n * \n *     Példa 1:\n * \n *         Bemenet: 3\n *         Kimenet: (1, 2)\n *         Magyarázat:\n *         Az egész szám palindrómok 1, 2, 3. Egyikük páros, és kettőjük páratlan.\n * \n *     Példa 2:\n * \n *         Bemenet: 12\n *         Kimenet: (4, 6)\n *         Magyarázat:\n *         Az egész szám palindrómok 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Négy páros és hat páratlan.\n * \n *     Megjegyzés:\n *         1. 1 <= n <= 10^3\n *         2. A visszatérő tuple a páros és páratlan egész szám palindrómok számát tartalmazza.\n * \n *\n */\nfunction evenOddPalindrome($n){\n", "entry_point": "evenOddPalindrome", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 123;\n$x0 = evenOddPalindrome($arg00);\n$v0 = [8, 13];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 12;\n$x1 = evenOddPalindrome($arg10);\n$v1 = [4, 6];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 3;\n$x2 = evenOddPalindrome($arg20);\n$v2 = [1, 2];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 63;\n$x3 = evenOddPalindrome($arg30);\n$v3 = [6, 8];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 25;\n$x4 = evenOddPalindrome($arg40);\n$v4 = [5, 6];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 19;\n$x5 = evenOddPalindrome($arg50);\n$v5 = [4, 6];\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 9;\n$x6 = evenOddPalindrome($arg60);\n$v6 = [4, 5];\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = 1;\n$x7 = evenOddPalindrome($arg70);\n$v7 = [0, 1];\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n", "description": "Adjon meg egy pozitív egész számot n, és térjen vissza egy tuple-el, amely tartalmazza a páros és páratlan egész szám palindrómok számát a (1, n) tartományban, beleértve a határokat.\n\n    Példa 1:\n\n        Bemenet: 3\n        Kimenet: (1, 2)\n        Magyarázat:\n        Az egész szám palindrómok 1, 2, 3. Egyikük páros, és kettőjük páratlan.\n\n    Példa 2:\n\n        Bemenet: 12\n        Kimenet: (4, 6)\n        Magyarázat:\n        Az egész szám palindrómok 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Négy páros és hat páratlan.\n\n    Megjegyzés:\n        1. 1 <= n <= 10^3\n        2. A visszatérő tuple a páros és páratlan egész szám palindrómok számát tartalmazza.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/49", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Van egy N elemű 'arr' tömbünk, melynek elemei arr[1], arr[2], ..., arr[N] véletlenszerűen rendezettek. A feladatod az, hogy eldöntsd, lehetséges-e egy nem-csökkenő sorrendbe rendezett tömböt kapni a következő művelettel:\n *         Lehetőséged van bármennyi jobbra tolás műveletet végrehajtani.\n *     \n *     Egy jobbra tolás művelet azt jelenti, hogy az összes tömb elemet egy pozícióval jobbra tolod. A tömb utolsó eleme a tömb kezdő pozíciójába kerül, azaz az 0. indexre.\n * \n *     Ha a fenti művelettel lehetséges a rendezett tömb megszerzése, akkor igaz értéket kell visszaadni, különben hamisat. Ha a megadott tömb üres, akkor igazat kell visszaadni.\n * \n *     Megjegyzés: A megadott lista garantáltan egyedi elemeket tartalmaz.\n * \n *     Példa:\n *     \n *     move_one_ball([3, 4, 5, 1, 2])==>True\n *     Magyarázat: 2 jobbra tolás művelettel elérhető a nem-csökkenő sorrend a megadott tömbben.\n *     move_one_ball([3, 5, 4, 1, 2])==>False\n *     Magyarázat: Nem lehetséges bármennyi jobbra tolás művelettel a nem-csökkenő sorrend elérése a megadott tömbben.\n * \n *             \n *\n */\nfunction moveOneBall($arr){\n", "entry_point": "moveOneBall", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [3, 4, 5, 1, 2];\n$x0 = moveOneBall($arg00);\n$v0 = true;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [3, 5, 10, 1, 2];\n$x1 = moveOneBall($arg10);\n$v1 = true;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [4, 3, 1, 2];\n$x2 = moveOneBall($arg20);\n$v2 = false;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [3, 5, 4, 1, 2];\n$x3 = moveOneBall($arg30);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [];\n$x4 = moveOneBall($arg40);\n$v4 = true;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Van egy N elemű 'arr' tömbünk, melynek elemei arr[1], arr[2], ..., arr[N] véletlenszerűen rendezettek. A feladatod az, hogy eldöntsd, lehetséges-e egy nem-csökkenő sorrendbe rendezett tömböt kapni a következő művelettel:\n        Lehetőséged van bármennyi jobbra tolás műveletet végrehajtani.\n    \n    Egy jobbra tolás művelet azt jelenti, hogy az összes tömb elemet egy pozícióval jobbra tolod. A tömb utolsó eleme a tömb kezdő pozíciójába kerül, azaz az 0. indexre.\n\n    Ha a fenti művelettel lehetséges a rendezett tömb megszerzése, akkor igaz értéket kell visszaadni, különben hamisat. Ha a megadott tömb üres, akkor igazat kell visszaadni.\n\n    Megjegyzés: A megadott lista garantáltan egyedi elemeket tartalmaz.\n\n    Példa:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Magyarázat: 2 jobbra tolás művelettel elérhető a nem-csökkenő sorrend a megadott tömbben.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Magyarázat: Nem lehetséges bármennyi jobbra tolás művelettel a nem-csökkenő sorrend elérése a megadott tömbben.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/50", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Ebben a feladatban egy olyan függvényt kell megvalósítania, amely két számok listáját veszi,\n *     és meghatározza, hogy lehetséges-e elemek cseréje\n *     közöttük, hogy lst1 csak páros számok listája legyen.\n *     Nincs korlátozás a lst1 és lst2 közötti cserélt elemek számára.\n *     Ha lehetséges elemeket cserélni a lst1 és lst2 között, hogy\n *     lst1 összes eleme páros legyen, akkor \"YES\"-t adjon vissza.\n *     Ellenkező esetben \"NO\"-t adjon vissza.\n *     Például:\n *     exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n *     exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n *     Feltételezhető, hogy a bemeneti listák nem üresek.\n * \n *\n */\nfunction exchange($lst1, $lst2){\n", "entry_point": "exchange", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [1, 2, 3, 4];\n$arg01 = [1, 2, 3, 4];\n$x0 = exchange($arg00, $arg01);\n$v0 = \"YES\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1, 2, 3, 4];\n$arg11 = [1, 5, 3, 4];\n$x1 = exchange($arg10, $arg11);\n$v1 = \"NO\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [1, 2, 3, 4];\n$arg21 = [2, 1, 4, 3];\n$x2 = exchange($arg20, $arg21);\n$v2 = \"YES\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [5, 7, 3];\n$arg31 = [2, 6, 4];\n$x3 = exchange($arg30, $arg31);\n$v3 = \"YES\";\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [5, 7, 3];\n$arg41 = [2, 6, 3];\n$x4 = exchange($arg40, $arg41);\n$v4 = \"NO\";\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [3, 2, 6, 1, 8, 9];\n$arg51 = [3, 5, 5, 1, 1, 1];\n$x5 = exchange($arg50, $arg51);\n$v5 = \"NO\";\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [100, 200];\n$arg61 = [200, 200];\n$x6 = exchange($arg60, $arg61);\n$v6 = \"YES\";\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "Ebben a feladatban egy olyan függvényt kell megvalósítania, amely két számok listáját veszi,\n    és meghatározza, hogy lehetséges-e elemek cseréje\n    közöttük, hogy lst1 csak páros számok listája legyen.\n    Nincs korlátozás a lst1 és lst2 közötti cserélt elemek számára.\n    Ha lehetséges elemeket cserélni a lst1 és lst2 között, hogy\n    lst1 összes eleme páros legyen, akkor \"YES\"-t adjon vissza.\n    Ellenkező esetben \"NO\"-t adjon vissza.\n    Például:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    Feltételezhető, hogy a bemeneti listák nem üresek.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/51", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Feladat\n *     Két karakterláncot kapunk, s és c. Törölni kell az összes s karakterláncban található karaktert, amely megegyezik bármely karakterrel c-ben,\n *     majd ellenőrizni kell, hogy az eredmény karakterlánc palindrom-e.\n *     Egy karakterlánc akkor nevezhető palindromnak, ha ugyanazt olvassuk előre és visszafelé.\n *     Egy tuple-t kell visszaadni, amely tartalmazza az eredmény karakterláncot és az igaz/hamis értéket az ellenőrzéshez.\n *     Példa\n *     Ha s = \"abcde\", c = \"ae\", akkor az eredmény ('bcd',False) kell legyen.\n *     Ha s = \"abcdef\", c = \"b\", akkor az eredmény ('acdef',False) kell legyen.\n *     Ha s = \"abcdedcba\", c = \"ab\", akkor az eredmény ('cdedc',True) kell legyen.\n * \n *\n */\nfunction reverseDelete($s, $c){\n", "entry_point": "reverseDelete", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"abcde\";\n$arg01 = \"ae\";\n$x0 = reverseDelete($arg00, $arg01);\n$v0 = [\"bcd\", false];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"abcdef\";\n$arg11 = \"b\";\n$x1 = reverseDelete($arg10, $arg11);\n$v1 = [\"acdef\", false];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"abcdedcba\";\n$arg21 = \"ab\";\n$x2 = reverseDelete($arg20, $arg21);\n$v2 = [\"cdedc\", true];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"dwik\";\n$arg31 = \"w\";\n$x3 = reverseDelete($arg30, $arg31);\n$v3 = [\"dik\", false];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"a\";\n$arg41 = \"a\";\n$x4 = reverseDelete($arg40, $arg41);\n$v4 = [\"\", true];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"abcdedcba\";\n$arg51 = \"\";\n$x5 = reverseDelete($arg50, $arg51);\n$v5 = [\"abcdedcba\", true];\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"abcdedcba\";\n$arg61 = \"v\";\n$x6 = reverseDelete($arg60, $arg61);\n$v6 = [\"abcdedcba\", true];\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = \"vabba\";\n$arg71 = \"v\";\n$x7 = reverseDelete($arg70, $arg71);\n$v7 = [\"abba\", true];\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = \"mamma\";\n$arg81 = \"mia\";\n$x8 = reverseDelete($arg80, $arg81);\n$v8 = [\"\", true];\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n", "description": "Feladat\n    Két karakterláncot kapunk, s és c. Törölni kell az összes s karakterláncban található karaktert, amely megegyezik bármely karakterrel c-ben,\n    majd ellenőrizni kell, hogy az eredmény karakterlánc palindrom-e.\n    Egy karakterlánc akkor nevezhető palindromnak, ha ugyanazt olvassuk előre és visszafelé.\n    Egy tuple-t kell visszaadni, amely tartalmazza az eredmény karakterláncot és az igaz/hamis értéket az ellenőrzéshez.\n    Példa\n    Ha s = \"abcde\", c = \"ae\", akkor az eredmény ('bcd',False) kell legyen.\n    Ha s = \"abcdef\", c = \"b\", akkor az eredmény ('acdef',False) kell legyen.\n    Ha s = \"abcdedcba\", c = \"ab\", akkor az eredmény ('cdedc',True) kell legyen.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/52", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Egy téglalap alakú kút rácsot kapsz. Minden sor egy kút, és minden 1 a sorban egy egység vizet jelent. Minden kútnak van egy megfelelő vödör, amelyet használhatsz a víz kivonására, és minden vödörnek azonos kapacitása van. A feladatod az, hogy a vödröket használva kiürítsd a kutakat. Azt kell kimenetként megadni, hogy hányszor kell leengedni a vödröket.\n * \n * Példa 1:\n *     Bemenet:\n *         rács : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n *         vödör kapacitása : 1\n *     Kimenet: 6\n * \n * Példa 2:\n *     Bemenet:\n *         rács : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n *         vödör kapacitása : 2\n *     Kimenet: 5\n * \n * Példa 3:\n *     Bemenet:\n *         rács : [[0,0,0], [0,0,0]]\n *         vödör kapacitása : 5\n *     Kimenet: 0\n * \n * Korlátok:\n *     * minden kútnak azonos hossza van\n *     * 1 <= rács.hossza <= 10^2\n *     * 1 <= rács[:,1].hossza <= 10^2\n *     * rács[i][j] -> 0 | 1\n *     * 1 <= kapacitás <= 10\n * \n *\n */\nfunction maxFill($grid, $capacity){\n", "entry_point": "maxFill", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]];\n$arg01 = 1;\n$x0 = maxFill($arg00, $arg01);\n$v0 = 6;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]];\n$arg11 = 2;\n$x1 = maxFill($arg10, $arg11);\n$v1 = 5;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [[0, 0, 0], [0, 0, 0]];\n$arg21 = 5;\n$x2 = maxFill($arg20, $arg21);\n$v2 = 0;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [[1, 1, 1, 1], [1, 1, 1, 1]];\n$arg31 = 2;\n$x3 = maxFill($arg30, $arg31);\n$v3 = 4;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [[1, 1, 1, 1], [1, 1, 1, 1]];\n$arg41 = 9;\n$x4 = maxFill($arg40, $arg41);\n$v4 = 2;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Egy téglalap alakú kút rácsot kapsz. Minden sor egy kút, és minden 1 a sorban egy egység vizet jelent. Minden kútnak van egy megfelelő vödör, amelyet használhatsz a víz kivonására, és minden vödörnek azonos kapacitása van. A feladatod az, hogy a vödröket használva kiürítsd a kutakat. Azt kell kimenetként megadni, hogy hányszor kell leengedni a vödröket.\n\nPélda 1:\n    Bemenet:\n        rács : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        vödör kapacitása : 1\n    Kimenet: 6\n\nPélda 2:\n    Bemenet:\n        rács : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        vödör kapacitása : 2\n    Kimenet: 5\n\nPélda 3:\n    Bemenet:\n        rács : [[0,0,0], [0,0,0]]\n        vödör kapacitása : 5\n    Kimenet: 0\n\nKorlátok:\n    * minden kútnak azonos hossza van\n    * 1 <= rács.hossza <= 10^2\n    * 1 <= rács[:,1].hossza <= 10^2\n    * rács[i][j] -> 0 | 1\n    * 1 <= kapacitás <= 10", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/53", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adott egy s karakterlánc és egy természetes szám n, feladatod egy olyan függvény megvalósítása, amely visszaad egy listát az összes olyan szóról a s karakterláncból, amely pontosan n mássalhangzót tartalmaz, azok sorrendjében, ahogy azok a s karakterláncban megjelennek. Ha az s karakterlánc üres, akkor a függvény üres listát kell visszaadjon. Megjegyzés: feltételezheted, hogy a bemeneti karakterlánc csak betűket és szóközöket tartalmaz. Példák:\n * \n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n *\n */\nfunction selectWords($s, $n){\n", "entry_point": "selectWords", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"Mary had a little lamb\";\n$arg01 = 4;\n$x0 = selectWords($arg00, $arg01);\n$v0 = [\"little\"];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"Mary had a little lamb\";\n$arg11 = 3;\n$x1 = selectWords($arg10, $arg11);\n$v1 = [\"Mary\", \"lamb\"];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"simple white space\";\n$arg21 = 2;\n$x2 = selectWords($arg20, $arg21);\n$v2 = [];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"Hello world\";\n$arg31 = 4;\n$x3 = selectWords($arg30, $arg31);\n$v3 = [\"world\"];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"Uncle sam\";\n$arg41 = 3;\n$x4 = selectWords($arg40, $arg41);\n$v4 = [\"Uncle\"];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"\";\n$arg51 = 4;\n$x5 = selectWords($arg50, $arg51);\n$v5 = [];\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"a b c d e f\";\n$arg61 = 1;\n$x6 = selectWords($arg60, $arg61);\n$v6 = [\"b\", \"c\", \"d\", \"f\"];\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "Adott egy s karakterlánc és egy természetes szám n, feladatod egy olyan függvény megvalósítása, amely visszaad egy listát az összes olyan szóról a s karakterláncból, amely pontosan n mássalhangzót tartalmaz, azok sorrendjében, ahogy azok a s karakterláncban megjelennek. Ha az s karakterlánc üres, akkor a függvény üres listát kell visszaadjon. Megjegyzés: feltételezheted, hogy a bemeneti karakterlánc csak betűket és szóközöket tartalmaz. Példák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/54", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy arr nevű egész számokat tartalmazó tömb és egy pozitív egész szám k. Adj vissza egy rendezett listát, amelynek hossza k és amely az arr tömb k legnagyobb számát tartalmazza.\n * \n * Példa 1:\n * \n *     Bemenet: arr = [-3, -4, 5], k = 3\n *     Kimenet: [-4, -3, 5]\n * \n * Példa 2:\n * \n *     Bemenet: arr = [4, -4, 4], k = 2\n *     Kimenet: [4, 4]\n * \n * Példa 3:\n * \n *     Bemenet: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n *     Kimenet: [2]\n * \n * Megjegyzés:\n *     1. A tömb hossza [1, 1000] tartományban lesz.\n *     2. A tömb elemei [-1000, 1000] tartományban lesznek.\n *     3. 0 <= k <= len(arr)\n * \n *\n */\nfunction maximum($arr, $k){\n", "entry_point": "maximum", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [-3, -4, 5];\n$arg01 = 3;\n$x0 = maximum($arg00, $arg01);\n$v0 = [-4, -3, 5];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [4, -4, 4];\n$arg11 = 2;\n$x1 = maximum($arg10, $arg11);\n$v1 = [4, 4];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [-3, 2, 1, 2, -1, -2, 1];\n$arg21 = 1;\n$x2 = maximum($arg20, $arg21);\n$v2 = [2];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [123, -123, 20, 0, 1, 2, -3];\n$arg31 = 3;\n$x3 = maximum($arg30, $arg31);\n$v3 = [2, 20, 123];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [-123, 20, 0, 1, 2, -3];\n$arg41 = 4;\n$x4 = maximum($arg40, $arg41);\n$v4 = [0, 1, 2, 20];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [5, 15, 0, 3, -13, -8, 0];\n$arg51 = 7;\n$x5 = maximum($arg50, $arg51);\n$v5 = [-13, -8, 0, 0, 3, 5, 15];\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [-1, 0, 2, 5, 3, -10];\n$arg61 = 2;\n$x6 = maximum($arg60, $arg61);\n$v6 = [3, 5];\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = [1, 0, 5, -7];\n$arg71 = 1;\n$x7 = maximum($arg70, $arg71);\n$v7 = [5];\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = [4, -4];\n$arg81 = 2;\n$x8 = maximum($arg80, $arg81);\n$v8 = [-4, 4];\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = [-10, 10];\n$arg91 = 2;\n$x9 = maximum($arg90, $arg91);\n$v9 = [-10, 10];\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n$arg100 = [1, 2, 3, -23, 243, -400, 0];\n$arg101 = 0;\n$x10 = maximum($arg100, $arg101);\n$v10 = [];\nif (!compare($x10, $v10)) {\n    throw new Exception(\"Error at 11th assert statement.\");\n}\n", "description": "Adott egy arr nevű egész számokat tartalmazó tömb és egy pozitív egész szám k. Adj vissza egy rendezett listát, amelynek hossza k és amely az arr tömb k legnagyobb számát tartalmazza.\n\nPélda 1:\n\n    Bemenet: arr = [-3, -4, 5], k = 3\n    Kimenet: [-4, -3, 5]\n\nPélda 2:\n\n    Bemenet: arr = [4, -4, 4], k = 2\n    Kimenet: [4, 4]\n\nPélda 3:\n\n    Bemenet: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Kimenet: [2]\n\nMegjegyzés:\n    1. A tömb hossza [1, 1000] tartományban lesz.\n    2. A tömb elemei [-1000, 1000] tartományban lesznek.\n    3. 0 <= k <= len(arr)", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/55", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy nem üres egész számok tömbje (arr) és egy egész szám (k). Adjuk vissza azoknak az elemeknek az összegét, amelyeknek legfeljebb két számjegyük van az arr első k eleme között.\n * \n *     Példa:\n * \n *         Bemenet: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n *         Kimenet: 24 # 21 + 3 összege\n * \n *     Megkötések:\n *         1. 1 <= len(arr) <= 100\n *         2. 1 <= k <= len(arr)\n * \n *\n */\nfunction addElements($arr, $k){\n", "entry_point": "addElements", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [1, -2, -3, 41, 57, 76, 87, 88, 99];\n$arg01 = 3;\n$x0 = addElements($arg00, $arg01);\n$v0 = -4;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [111, 121, 3, 4000, 5, 6];\n$arg11 = 2;\n$x1 = addElements($arg10, $arg11);\n$v1 = 0;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [11, 21, 3, 90, 5, 6, 7, 8, 9];\n$arg21 = 4;\n$x2 = addElements($arg20, $arg21);\n$v2 = 125;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [111, 21, 3, 4000, 5, 6, 7, 8, 9];\n$arg31 = 4;\n$x3 = addElements($arg30, $arg31);\n$v3 = 24;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [1];\n$arg41 = 1;\n$x4 = addElements($arg40, $arg41);\n$v4 = 1;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Adott egy nem üres egész számok tömbje (arr) és egy egész szám (k). Adjuk vissza azoknak az elemeknek az összegét, amelyeknek legfeljebb két számjegyük van az arr első k eleme között.\n\n    Példa:\n\n        Bemenet: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Kimenet: 24 # 21 + 3 összege\n\n    Megkötések:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/56", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Két intervallumot kapsz,\n *     ahol minden intervallum egy egész számpárból áll. Például, intervallum = (kezdő, vég) = (1, 2).\n *     A megadott intervallumok zártak, ami azt jelenti, hogy az intervallum (kezdő, vég)\n *     mindkét végpontját tartalmazza.\n *     Minden intervallum esetében feltételezzük, hogy a kezdő értéke kisebb vagy egyenlő a végével.\n *     A feladatod az, hogy meghatározd, az adott két intervallum metszetének hossza prímszám-e.\n *     Például, az intervallumok (1, 3), (2, 4) metszete (2, 3) és annak hossza 1, ami nem prímszám.\n *     Ha a metszet hossza prímszám, térj vissza \"YES\"-sel,\n *     különben térj vissza \"NO\"-val.\n *     Ha a két intervallum nem metszi egymást, térj vissza \"NO\"-val.\n * \n * \n *     [bemenet/kimenet] példák:\n * \n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n *\n */\nfunction intersection($interval1, $interval2){\n", "entry_point": "intersection", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [1, 2];\n$arg01 = [2, 3];\n$x0 = intersection($arg00, $arg01);\n$v0 = \"NO\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [-1, 1];\n$arg11 = [0, 4];\n$x1 = intersection($arg10, $arg11);\n$v1 = \"NO\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [-3, -1];\n$arg21 = [-5, 5];\n$x2 = intersection($arg20, $arg21);\n$v2 = \"YES\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [-2, 2];\n$arg31 = [-4, 0];\n$x3 = intersection($arg30, $arg31);\n$v3 = \"YES\";\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [-11, 2];\n$arg41 = [-1, -1];\n$x4 = intersection($arg40, $arg41);\n$v4 = \"NO\";\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [1, 2];\n$arg51 = [3, 5];\n$x5 = intersection($arg50, $arg51);\n$v5 = \"NO\";\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [1, 2];\n$arg61 = [1, 2];\n$x6 = intersection($arg60, $arg61);\n$v6 = \"NO\";\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = [-2, -2];\n$arg71 = [-3, -2];\n$x7 = intersection($arg70, $arg71);\n$v7 = \"NO\";\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n", "description": "Két intervallumot kapsz,\n    ahol minden intervallum egy egész számpárból áll. Például, intervallum = (kezdő, vég) = (1, 2).\n    A megadott intervallumok zártak, ami azt jelenti, hogy az intervallum (kezdő, vég)\n    mindkét végpontját tartalmazza.\n    Minden intervallum esetében feltételezzük, hogy a kezdő értéke kisebb vagy egyenlő a végével.\n    A feladatod az, hogy meghatározd, az adott két intervallum metszetének hossza prímszám-e.\n    Például, az intervallumok (1, 3), (2, 4) metszete (2, 3) és annak hossza 1, ami nem prímszám.\n    Ha a metszet hossza prímszám, térj vissza \"YES\"-sel,\n    különben térj vissza \"NO\"-val.\n    Ha a két intervallum nem metszi egymást, térj vissza \"NO\"-val.\n\n\n    [bemenet/kimenet] példák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/57", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Mindenki ismeri a Fibonacci sorozatot, amelyet az elmúlt évszázadokban mélyen tanulmányoztak a matematikusok. Azonban amit az emberek nem tudnak, az a Tribonacci sorozat. A Tribonacci sorozatot a következő visszatérő érték határozza meg: tri(1) = 3, tri(n) = 1 + n / 2, ha n páros, tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ha n páratlan. Például: tri(2) = 1 + (2 / 2) = 2, tri(4) = 3, tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8. Adott egy nem-negatív egész szám n, és vissza kell adnia a Tribonacci sorozat első n + 1 számát tartalmazó listát. Példák: tri(3) = [1, 3, 2, 8].\n * \n *\n */\nfunction tri($n){\n", "entry_point": "tri", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 3;\n$x0 = tri($arg00);\n$v0 = [1, 3, 2.0, 8.0];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 4;\n$x1 = tri($arg10);\n$v1 = [1, 3, 2.0, 8.0, 3.0];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 5;\n$x2 = tri($arg20);\n$v2 = [1, 3, 2.0, 8.0, 3.0, 15.0];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 6;\n$x3 = tri($arg30);\n$v3 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 7;\n$x4 = tri($arg40);\n$v4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 8;\n$x5 = tri($arg50);\n$v5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0];\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 9;\n$x6 = tri($arg60);\n$v6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0];\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = 20;\n$x7 = tri($arg70);\n$v7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0];\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = 0;\n$x8 = tri($arg80);\n$v8 = [1];\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = 1;\n$x9 = tri($arg90);\n$v9 = [1, 3];\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n", "description": "Mindenki ismeri a Fibonacci sorozatot, amelyet az elmúlt évszázadokban mélyen tanulmányoztak a matematikusok. Azonban amit az emberek nem tudnak, az a Tribonacci sorozat. A Tribonacci sorozatot a következő visszatérő érték határozza meg: tri(1) = 3, tri(n) = 1 + n / 2, ha n páros, tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ha n páratlan. Például: tri(2) = 1 + (2 / 2) = 2, tri(4) = 3, tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8. Adott egy nem-negatív egész szám n, és vissza kell adnia a Tribonacci sorozat első n + 1 számát tartalmazó listát. Példák: tri(3) = [1, 3, 2, 8].", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/58", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adott egy pozitív egész szám n, térjen vissza az páratlan számjegyek szorzatával.\n * Ha az összes számjegy páros, akkor térjen vissza 0-val.\n * Példa:\n * \n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n *\n */\nfunction digits($n){\n", "entry_point": "digits", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 5;\n$x0 = digits($arg00);\n$v0 = 5;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 54;\n$x1 = digits($arg10);\n$v1 = 5;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 120;\n$x2 = digits($arg20);\n$v2 = 1;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 5014;\n$x3 = digits($arg30);\n$v3 = 5;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 98765;\n$x4 = digits($arg40);\n$v4 = 315;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 5576543;\n$x5 = digits($arg50);\n$v5 = 2625;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 2468;\n$x6 = digits($arg60);\n$v6 = 0;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "Adott egy pozitív egész szám n, térjen vissza az páratlan számjegyek szorzatával.\nHa az összes számjegy páros, akkor térjen vissza 0-val.\nPélda:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/59", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Hozzon létre egy függvényt, amely egy olyan karakterláncot vesz bemenetként, amely csak szögletes zárójeleket tartalmaz.\n *     A függvény akkor kell, hogy igazat adjon vissza, ha és csak ha van egy érvényes zárójel-alminta, \n *     ahol legalább egy zárójel beágyazott.\n * is_nested('[[]]') ➞ True\n * is_nested('[]]]]]]][[[[[]') ➞ False\n * is_nested('[][]') ➞ False\n * is_nested('[]') ➞ False\n * is_nested('[[][]]') ➞ True\n * is_nested('[[]][[') ➞ True\n *\n */\nfunction isNested($string){\n", "entry_point": "isNested", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"[[]]\";\n$x0 = isNested($arg00);\n$v0 = true;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"[]]]]]]][[[[[]\";\n$x1 = isNested($arg10);\n$v1 = false;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"[][]\";\n$x2 = isNested($arg20);\n$v2 = false;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"[]\";\n$x3 = isNested($arg30);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"[[[[]]]]\";\n$x4 = isNested($arg40);\n$v4 = true;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"[]]]]]]]]]]\";\n$x5 = isNested($arg50);\n$v5 = false;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"[][][[]]\";\n$x6 = isNested($arg60);\n$v6 = true;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = \"[[]\";\n$x7 = isNested($arg70);\n$v7 = false;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = \"[]]\";\n$x8 = isNested($arg80);\n$v8 = false;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = \"[[]][[\";\n$x9 = isNested($arg90);\n$v9 = true;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n$arg100 = \"[[][]]\";\n$x10 = isNested($arg100);\n$v10 = true;\nif (!compare($x10, $v10)) {\n    throw new Exception(\"Error at 11th assert statement.\");\n}\n$arg110 = \"\";\n$x11 = isNested($arg110);\n$v11 = false;\nif (!compare($x11, $v11)) {\n    throw new Exception(\"Error at 12th assert statement.\");\n}\n$arg120 = \"[[[[[[[[\";\n$x12 = isNested($arg120);\n$v12 = false;\nif (!compare($x12, $v12)) {\n    throw new Exception(\"Error at 13th assert statement.\");\n}\n$arg130 = \"]]]]]]]]\";\n$x13 = isNested($arg130);\n$v13 = false;\nif (!compare($x13, $v13)) {\n    throw new Exception(\"Error at 14th assert statement.\");\n}\n", "description": "Hozzon létre egy függvényt, amely egy olyan karakterláncot vesz bemenetként, amely csak szögletes zárójeleket tartalmaz.\n    A függvény akkor kell, hogy igazat adjon vissza, ha és csak ha van egy érvényes zárójel-alminta, \n    ahol legalább egy zárójel beágyazott.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/60", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adott egy számok listája.\n *     Vissza kell adnod a lista négyzetes elemeinek összegét,\n *     minden elemet a listában felfelé kell kerekíteni az egész számok felé.\n *     Példák:\n *     Ha lst = [1,2,3], akkor a kimenet 14 legyen\n *     Ha lst = [1,4,9], akkor a kimenet 98 legyen\n *     Ha lst = [1,3,5,7], akkor a kimenet 84 legyen\n *     Ha lst = [1.4,4.2,0], akkor a kimenet 29 legyen\n *     Ha lst = [-2.4,1,1], akkor a kimenet 6 legyen\n * \n * \n\n *\n */\nfunction sumSquares($lst){\n", "entry_point": "sumSquares", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [1, 2, 3];\n$x0 = sumSquares($arg00);\n$v0 = 14;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1.0, 2, 3];\n$x1 = sumSquares($arg10);\n$v1 = 14;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [1, 3, 5, 7];\n$x2 = sumSquares($arg20);\n$v2 = 84;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [1.4, 4.2, 0];\n$x3 = sumSquares($arg30);\n$v3 = 29;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [-2.4, 1, 1];\n$x4 = sumSquares($arg40);\n$v4 = 6;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [100, 1, 15, 2];\n$x5 = sumSquares($arg50);\n$v5 = 10230;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [10000, 10000];\n$x6 = sumSquares($arg60);\n$v6 = 200000000;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = [-1.4, 4.6, 6.3];\n$x7 = sumSquares($arg70);\n$v7 = 75;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = [-1.4, 17.9, 18.9, 19.9];\n$x8 = sumSquares($arg80);\n$v8 = 1086;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = [0];\n$x9 = sumSquares($arg90);\n$v9 = 0;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n$arg100 = [-1];\n$x10 = sumSquares($arg100);\n$v10 = 1;\nif (!compare($x10, $v10)) {\n    throw new Exception(\"Error at 11th assert statement.\");\n}\n$arg110 = [-1, 1, 0];\n$x11 = sumSquares($arg110);\n$v11 = 2;\nif (!compare($x11, $v11)) {\n    throw new Exception(\"Error at 12th assert statement.\");\n}\n", "description": "Adott egy számok listája.\n    Vissza kell adnod a lista négyzetes elemeinek összegét,\n    minden elemet a listában felfelé kell kerekíteni az egész számok felé.\n    Példák:\n    Ha lst = [1,2,3], akkor a kimenet 14 legyen\n    Ha lst = [1,4,9], akkor a kimenet 98 legyen\n    Ha lst = [1,3,5,7], akkor a kimenet 84 legyen\n    Ha lst = [1.4,4.2,0], akkor a kimenet 29 legyen\n    Ha lst = [-2.4,1,1], akkor a kimenet 6 legyen", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/61", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Hozzon létre egy függvényt, amely igazat ad vissza, ha a megadott karakterlánc utolsó karaktere betű és nem része egy szónak, és hamisat ad vissza egyébként.\n * Megjegyzés: \"szó\" egy karakterek csoportja, amelyek szóközzel vannak elválasztva.\n * \n * Példák:\n * \n * check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n * check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n * check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n * check_if_last_char_is_a_letter(\"\") ➞ False \n *\n */\nfunction checkIfLastCharIsALetter($txt){\n", "entry_point": "checkIfLastCharIsALetter", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"apple\";\n$x0 = checkIfLastCharIsALetter($arg00);\n$v0 = false;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"apple pi e\";\n$x1 = checkIfLastCharIsALetter($arg10);\n$v1 = true;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"eeeee\";\n$x2 = checkIfLastCharIsALetter($arg20);\n$v2 = false;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"A\";\n$x3 = checkIfLastCharIsALetter($arg30);\n$v3 = true;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"Pumpkin pie \";\n$x4 = checkIfLastCharIsALetter($arg40);\n$v4 = false;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"Pumpkin pie 1\";\n$x5 = checkIfLastCharIsALetter($arg50);\n$v5 = false;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"\";\n$x6 = checkIfLastCharIsALetter($arg60);\n$v6 = false;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = \"eeeee e \";\n$x7 = checkIfLastCharIsALetter($arg70);\n$v7 = false;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = \"apple pie\";\n$x8 = checkIfLastCharIsALetter($arg80);\n$v8 = false;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = \"apple pi e \";\n$x9 = checkIfLastCharIsALetter($arg90);\n$v9 = false;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n", "description": "Hozzon létre egy függvényt, amely igazat ad vissza, ha a megadott karakterlánc utolsó karaktere betű és nem része egy szónak, és hamisat ad vissza egyébként.\nMegjegyzés: \"szó\" egy karakterek csoportja, amelyek szóközzel vannak elválasztva.\n\nPéldák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/62", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Hozzon létre egy függvényt, amely visszaadja a legnagyobb indexet azon elemnek, amely nem nagyobb vagy egyenlő az előtte álló elemmel. Ha nincs ilyen elem, akkor -1-et adjon vissza. A megadott tömb nem tartalmaz ismétlődő értékeket.\n * \n * Példák:\n * \n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n *\n */\nfunction canArrange($arr){\n", "entry_point": "canArrange", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [1, 2, 4, 3, 5];\n$x0 = canArrange($arg00);\n$v0 = 3;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1, 2, 4, 5];\n$x1 = canArrange($arg10);\n$v1 = -1;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [1, 4, 2, 5, 6, 7, 8, 9, 10];\n$x2 = canArrange($arg20);\n$v2 = 2;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [4, 8, 5, 7, 3];\n$x3 = canArrange($arg30);\n$v3 = 4;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [];\n$x4 = canArrange($arg40);\n$v4 = -1;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n", "description": "Hozzon létre egy függvényt, amely visszaadja a legnagyobb indexet azon elemnek, amely nem nagyobb vagy egyenlő az előtte álló elemmel. Ha nincs ilyen elem, akkor -1-et adjon vissza. A megadott tömb nem tartalmaz ismétlődő értékeket.\n\nPéldák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/63", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Hozzon létre egy függvényt, amely egy tuple-t (a, b) ad vissza, ahol 'a' a negatív egész számok legnagyobbika, és 'b' a pozitív egész számok legkisebbike egy listában. Ha nincs negatív vagy pozitív egész szám, akkor None-ként térjen vissza.\n * \n * Példák:\n * \n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n *\n */\nfunction largestSmallestIntegers($lst){\n", "entry_point": "largestSmallestIntegers", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [2, 4, 1, 3, 5, 7];\n$x0 = largestSmallestIntegers($arg00);\n$v0 = [null, 1];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [2, 4, 1, 3, 5, 7, 0];\n$x1 = largestSmallestIntegers($arg10);\n$v1 = [null, 1];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [1, 3, 2, 4, 5, 6, -2];\n$x2 = largestSmallestIntegers($arg20);\n$v2 = [-2, 1];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [4, 5, 3, 6, 2, 7, -7];\n$x3 = largestSmallestIntegers($arg30);\n$v3 = [-7, 2];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [7, 3, 8, 4, 9, 2, 5, -9];\n$x4 = largestSmallestIntegers($arg40);\n$v4 = [-9, 2];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [];\n$x5 = largestSmallestIntegers($arg50);\n$v5 = [null, null];\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [0];\n$x6 = largestSmallestIntegers($arg60);\n$v6 = [null, null];\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = [-1, -3, -5, -6];\n$x7 = largestSmallestIntegers($arg70);\n$v7 = [-1, null];\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = [-1, -3, -5, -6, 0];\n$x8 = largestSmallestIntegers($arg80);\n$v8 = [-1, null];\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = [-6, -4, -4, -3, 1];\n$x9 = largestSmallestIntegers($arg90);\n$v9 = [-3, 1];\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n$arg100 = [-6, -4, -4, -3, -100, 1];\n$x10 = largestSmallestIntegers($arg100);\n$v10 = [-3, 1];\nif (!compare($x10, $v10)) {\n    throw new Exception(\"Error at 11th assert statement.\");\n}\n", "description": "Hozzon létre egy függvényt, amely egy tuple-t (a, b) ad vissza, ahol 'a' a negatív egész számok legnagyobbika, és 'b' a pozitív egész számok legkisebbike egy listában. Ha nincs negatív vagy pozitív egész szám, akkor None-ként térjen vissza.\n\nPéldák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/64", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * A brazil faktoriális a következőképpen van definiálva:\n *     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     ahol n > 0\n * \n *     Például:\n * >>> special_factorial(4)\n * 288\n\n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n *\n */\nfunction specialFactorial($n){\n", "entry_point": "specialFactorial", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 4;\n$x0 = specialFactorial($arg00);\n$v0 = 288;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 5;\n$x1 = specialFactorial($arg10);\n$v1 = 34560;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 7;\n$x2 = specialFactorial($arg20);\n$v2 = 125411328000;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 1;\n$x3 = specialFactorial($arg30);\n$v3 = 1;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n", "description": "A brazil faktoriális a következőképpen van definiálva:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    ahol n > 0\n\n    Például:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/65", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Kap egy karakterláncot, amely egy mondatot reprezentál,\n *     a mondat néhány szót tartalmaz, amelyek szóközzel vannak elválasztva,\n *     és vissza kell adnia egy karakterláncot, amely tartalmazza az eredeti mondat szavait,\n *     amelyek hosszai prím számok,\n *     az új karakterláncban a szavak sorrendje ugyanaz kell legyen, mint az eredeti mondatban.\n * \n *     Példa 1:\n *         Bemenet: sentence = \"This is a test\"\n *         Kimenet: \"is\"\n * \n *     Példa 2:\n *         Bemenet: sentence = \"lets go for swimming\"\n *         Kimenet: \"go for\"\n * \n *     Korlátok:\n *         * 1 <= len(sentence) <= 100\n *         * a mondat csak betűket tartalmaz\n * \n *\n */\nfunction wordsInSentence($sentence){\n", "entry_point": "wordsInSentence", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"This is a test\";\n$x0 = wordsInSentence($arg00);\n$v0 = \"is\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"lets go for swimming\";\n$x1 = wordsInSentence($arg10);\n$v1 = \"go for\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"there is no place available here\";\n$x2 = wordsInSentence($arg20);\n$v2 = \"there is no place\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"Hi I am Hussein\";\n$x3 = wordsInSentence($arg30);\n$v3 = \"Hi am Hussein\";\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"go for it\";\n$x4 = wordsInSentence($arg40);\n$v4 = \"go for it\";\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"here\";\n$x5 = wordsInSentence($arg50);\n$v5 = \"\";\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"here is\";\n$x6 = wordsInSentence($arg60);\n$v6 = \"is\";\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "Kap egy karakterláncot, amely egy mondatot reprezentál,\n    a mondat néhány szót tartalmaz, amelyek szóközzel vannak elválasztva,\n    és vissza kell adnia egy karakterláncot, amely tartalmazza az eredeti mondat szavait,\n    amelyek hosszai prím számok,\n    az új karakterláncban a szavak sorrendje ugyanaz kell legyen, mint az eredeti mondatban.\n\n    Példa 1:\n        Bemenet: sentence = \"This is a test\"\n        Kimenet: \"is\"\n\n    Példa 2:\n        Bemenet: sentence = \"lets go for swimming\"\n        Kimenet: \"go for\"\n\n    Korlátok:\n        * 1 <= len(sentence) <= 100\n        * a mondat csak betűket tartalmaz", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/66", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * A feladatod az, hogy megvalósíts egy függvényt, amely egyszerűsíti a kifejezést\n *     x * n. A függvény True értéket ad vissza, ha x * n egész számra értékelődik ki, és False-t\n *     egyébként. Mind x, mind n egy tört sztring reprezentációja, és a következő formátumot követik,\n *     <számláló>/<nevező>, ahol mind a számláló, mind a nevező pozitív egész számok.\n * \n *     Feltételezheted, hogy x és n érvényes törtek, és nem rendelkeznek nullával nevezőként.\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n *\n */\nfunction simplify($x, $n){\n", "entry_point": "simplify", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"1/5\";\n$arg01 = \"5/1\";\n$x0 = simplify($arg00, $arg01);\n$v0 = true;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"1/6\";\n$arg11 = \"2/1\";\n$x1 = simplify($arg10, $arg11);\n$v1 = false;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"5/1\";\n$arg21 = \"3/1\";\n$x2 = simplify($arg20, $arg21);\n$v2 = true;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"7/10\";\n$arg31 = \"10/2\";\n$x3 = simplify($arg30, $arg31);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"2/10\";\n$arg41 = \"50/10\";\n$x4 = simplify($arg40, $arg41);\n$v4 = true;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"7/2\";\n$arg51 = \"4/2\";\n$x5 = simplify($arg50, $arg51);\n$v5 = true;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"11/6\";\n$arg61 = \"6/1\";\n$x6 = simplify($arg60, $arg61);\n$v6 = true;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = \"2/3\";\n$arg71 = \"5/2\";\n$x7 = simplify($arg70, $arg71);\n$v7 = false;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = \"5/2\";\n$arg81 = \"3/5\";\n$x8 = simplify($arg80, $arg81);\n$v8 = false;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = \"2/4\";\n$arg91 = \"8/4\";\n$x9 = simplify($arg90, $arg91);\n$v9 = true;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n$arg100 = \"2/4\";\n$arg101 = \"4/2\";\n$x10 = simplify($arg100, $arg101);\n$v10 = true;\nif (!compare($x10, $v10)) {\n    throw new Exception(\"Error at 11th assert statement.\");\n}\n$arg110 = \"1/5\";\n$arg111 = \"5/1\";\n$x11 = simplify($arg110, $arg111);\n$v11 = true;\nif (!compare($x11, $v11)) {\n    throw new Exception(\"Error at 12th assert statement.\");\n}\n$arg120 = \"1/5\";\n$arg121 = \"1/5\";\n$x12 = simplify($arg120, $arg121);\n$v12 = false;\nif (!compare($x12, $v12)) {\n    throw new Exception(\"Error at 13th assert statement.\");\n}\n", "description": "A feladatod az, hogy megvalósíts egy függvényt, amely egyszerűsíti a kifejezést\n    x * n. A függvény True értéket ad vissza, ha x * n egész számra értékelődik ki, és False-t\n    egyébként. Mind x, mind n egy tört sztring reprezentációja, és a következő formátumot követik,\n    <számláló>/<nevező>, ahol mind a számláló, mind a nevező pozitív egész számok.\n\n    Feltételezheted, hogy x és n érvényes törtek, és nem rendelkeznek nullával nevezőként.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/67", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Írj egy függvényt, amely rendezni tudja a megadott egész számok listáját növekvő sorrendben a számjegyeik összege alapján. Megjegyzés: ha több elemnek van hasonló számjegyek összege, rendezd őket az eredeti lista indexe szerint. \n * \n * Példa:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n *\n */\nfunction orderByPoints($nums){\n", "entry_point": "orderByPoints", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [1, 11, -1, -11, -12];\n$x0 = orderByPoints($arg00);\n$v0 = [-1, -11, 1, -12, 11];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46];\n$x1 = orderByPoints($arg10);\n$v1 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [];\n$x2 = orderByPoints($arg20);\n$v2 = [];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [1, -11, -32, 43, 54, -98, 2, -3];\n$x3 = orderByPoints($arg30);\n$v3 = [-3, -32, -98, -11, 1, 2, 43, 54];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n$x4 = orderByPoints($arg40);\n$v4 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [0, 6, 6, -76, -21, 23, 4];\n$x5 = orderByPoints($arg50);\n$v5 = [-76, -21, 0, 4, 23, 6, 6];\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n", "description": "Írj egy függvényt, amely rendezni tudja a megadott egész számok listáját növekvő sorrendben a számjegyeik összege alapján. Megjegyzés: ha több elemnek van hasonló számjegyek összege, rendezd őket az eredeti lista indexe szerint. \n\nPélda:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/68", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Írj egy függvényt, amely egy számokból álló tömböt vesz bemenetként, és visszaadja a tömbben található olyan elemek számát, amelyek nagyobbak, mint 10, és az adott szám első és utolsó számjegye is páratlan (1, 3, 5, 7, 9). Például:\n * \n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n *\n */\nfunction specialfilter($nums){\n", "entry_point": "specialfilter", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [5, -2, 1, -5];\n$x0 = specialfilter($arg00);\n$v0 = 0;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [15, -73, 14, -15];\n$x1 = specialfilter($arg10);\n$v1 = 1;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [33, -2, -3, 45, 21, 109];\n$x2 = specialfilter($arg20);\n$v2 = 2;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [43, -12, 93, 125, 121, 109];\n$x3 = specialfilter($arg30);\n$v3 = 4;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [71, -2, -33, 75, 21, 19];\n$x4 = specialfilter($arg40);\n$v4 = 3;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [1];\n$x5 = specialfilter($arg50);\n$v5 = 0;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [];\n$x6 = specialfilter($arg60);\n$v6 = 0;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "Írj egy függvényt, amely egy számokból álló tömböt vesz bemenetként, és visszaadja a tömbben található olyan elemek számát, amelyek nagyobbak, mint 10, és az adott szám első és utolsó számjegye is páratlan (1, 3, 5, 7, 9). Például:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/69", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy pozitív egész szám n. Létre kell hoznod egy n hosszú egész tömböt, a.\n *         Minden i-re (1 ≤ i ≤ n), a[i] értéke legyen i * i - i + 1.\n *         Add vissza az a tömbben található olyan hármasok (a[i], a[j], a[k]) számát, ahol i < j < k, \n *     és a[i] + a[j] + a[k] hárommal osztható.\n * \n *     Példa :\n *         Bemenet: n = 5\n *         Kimenet: 1\n *         Magyarázat: \n *         a = [1, 3, 7, 13, 21]\n *         Az egyetlen érvényes hármas (1, 7, 13).\n * \n *\n */\nfunction getMaxTriples($n){\n", "entry_point": "getMaxTriples", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 5;\n$x0 = getMaxTriples($arg00);\n$v0 = 1;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 6;\n$x1 = getMaxTriples($arg10);\n$v1 = 4;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 10;\n$x2 = getMaxTriples($arg20);\n$v2 = 36;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 100;\n$x3 = getMaxTriples($arg30);\n$v3 = 53361;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n", "description": "Adott egy pozitív egész szám n. Létre kell hoznod egy n hosszú egész tömböt, a.\n        Minden i-re (1 ≤ i ≤ n), a[i] értéke legyen i * i - i + 1.\n        Add vissza az a tömbben található olyan hármasok (a[i], a[j], a[k]) számát, ahol i < j < k, \n    és a[i] + a[j] + a[k] hárommal osztható.\n\n    Példa :\n        Bemenet: n = 5\n        Kimenet: 1\n        Magyarázat: \n        a = [1, 3, 7, 13, 21]\n        Az egyetlen érvényes hármas (1, 7, 13).", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/70", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * A Naprendszerünkben nyolc bolygó van: a legközelebbi a Naphoz a Merkúr, \n *     utána jön a Vénusz, majd a Föld, a Mars, a Jupiter, a Szaturnusz, \n *     az Uránusz és a Neptunusz.\n *     Írj egy függvényt, amely két bolygó nevét tartalmazza stringként, planet1 és planet2. \n *     A függvénynek egy tuple-t kell visszaadnia, amely tartalmazza az összes bolygót, \n *     amelyeknek az orbitája planet1 és planet2 orbitája között található, a Nap közeléhez \n *     rendezve. \n *     A függvény egy üres tuple-t kell visszaadjon, ha planet1 vagy planet2 nem megfelelő bolygónevek. \n *     Példák\n * \n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n *\n */\nfunction bf($planet1, $planet2){\n", "entry_point": "bf", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"Jupiter\";\n$arg01 = \"Neptune\";\n$x0 = bf($arg00, $arg01);\n$v0 = [\"Saturn\", \"Uranus\"];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"Earth\";\n$arg11 = \"Mercury\";\n$x1 = bf($arg10, $arg11);\n$v1 = [\"Venus\"];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"Mercury\";\n$arg21 = \"Uranus\";\n$x2 = bf($arg20, $arg21);\n$v2 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"Neptune\";\n$arg31 = \"Venus\";\n$x3 = bf($arg30, $arg31);\n$v3 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"Earth\";\n$arg41 = \"Earth\";\n$x4 = bf($arg40, $arg41);\n$v4 = [];\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"Mars\";\n$arg51 = \"Earth\";\n$x5 = bf($arg50, $arg51);\n$v5 = [];\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"Jupiter\";\n$arg61 = \"Makemake\";\n$x6 = bf($arg60, $arg61);\n$v6 = [];\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "A Naprendszerünkben nyolc bolygó van: a legközelebbi a Naphoz a Merkúr, \n    utána jön a Vénusz, majd a Föld, a Mars, a Jupiter, a Szaturnusz, \n    az Uránusz és a Neptunusz.\n    Írj egy függvényt, amely két bolygó nevét tartalmazza stringként, planet1 és planet2. \n    A függvénynek egy tuple-t kell visszaadnia, amely tartalmazza az összes bolygót, \n    amelyeknek az orbitája planet1 és planet2 orbitája között található, a Nap közeléhez \n    rendezve. \n    A függvény egy üres tuple-t kell visszaadjon, ha planet1 vagy planet2 nem megfelelő bolygónevek. \n    Példák", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/71", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Egy egyszerű program, amely visszaadja az x értékét, ha n prímszám, és az y értékét, ha nem.\n * \n * Példák:\n * \n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n *\n */\nfunction xOrY($n, $x, $y){\n", "entry_point": "xOrY", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 7;\n$arg01 = 34;\n$arg02 = 12;\n$x0 = xOrY($arg00, $arg01, $arg02);\n$v0 = 34;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 15;\n$arg11 = 8;\n$arg12 = 5;\n$x1 = xOrY($arg10, $arg11, $arg12);\n$v1 = 5;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 3;\n$arg21 = 33;\n$arg22 = 5212;\n$x2 = xOrY($arg20, $arg21, $arg22);\n$v2 = 33;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 1259;\n$arg31 = 3;\n$arg32 = 52;\n$x3 = xOrY($arg30, $arg31, $arg32);\n$v3 = 3;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 7919;\n$arg41 = -1;\n$arg42 = 12;\n$x4 = xOrY($arg40, $arg41, $arg42);\n$v4 = -1;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 3609;\n$arg51 = 1245;\n$arg52 = 583;\n$x5 = xOrY($arg50, $arg51, $arg52);\n$v5 = 583;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 91;\n$arg61 = 56;\n$arg62 = 129;\n$x6 = xOrY($arg60, $arg61, $arg62);\n$v6 = 129;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = 6;\n$arg71 = 34;\n$arg72 = 1234;\n$x7 = xOrY($arg70, $arg71, $arg72);\n$v7 = 1234;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = 1;\n$arg81 = 2;\n$arg82 = 0;\n$x8 = xOrY($arg80, $arg81, $arg82);\n$v8 = 0;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = 2;\n$arg91 = 2;\n$arg92 = 0;\n$x9 = xOrY($arg90, $arg91, $arg92);\n$v9 = 2;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n", "description": "Egy egyszerű program, amely visszaadja az x értékét, ha n prímszám, és az y értékét, ha nem.\n\nPéldák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/72", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy számok listája, térj vissza a listában található páratlan számok négyzetösszegével. Figyelmen kívül hagyja a negatív vagy nem egész számokat.\n * \n *     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n *     double_the_difference([-1, -2, 0]) == 0\n *     double_the_difference([9, -2]) == 81\n *     double_the_difference([0]) == 0\n * \n * Ha a bemeneti lista üres, térjen vissza 0-val.\n * \n *\n */\nfunction doubleTheDifference($lst){\n", "entry_point": "doubleTheDifference", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = [];\n$x0 = doubleTheDifference($arg00);\n$v0 = 0;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = [5, 4];\n$x1 = doubleTheDifference($arg10);\n$v1 = 25;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = [0.1, 0.2, 0.3];\n$x2 = doubleTheDifference($arg20);\n$v2 = 0;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = [-10, -20, -30];\n$x3 = doubleTheDifference($arg30);\n$v3 = 0;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = [-1, -2, 8];\n$x4 = doubleTheDifference($arg40);\n$v4 = 0;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = [0.2, 3, 5];\n$x5 = doubleTheDifference($arg50);\n$v5 = 34;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = [-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99];\n$x6 = doubleTheDifference($arg60);\n$v6 = 166650;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n", "description": "Adott egy számok listája, térj vissza a listában található páratlan számok négyzetösszegével. Figyelmen kívül hagyja a negatív vagy nem egész számokat.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\nHa a bemeneti lista üres, térjen vissza 0-val.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/73", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adjon meg egy osztály nevet (string) és egy kiterjesztés listát.\n *     A kiterjesztéseket az osztályhoz való további osztályok betöltésére kell használni. A\n *     kiterjesztés ereje a következő: Legyen CAP a kiterjesztés nevében található nagybetűk száma, és legyen SM a kisbetűk száma\n *     a kiterjesztés nevében, az erő a CAP - SM törttel van meghatározva. \n *     Meg kell találnod a legerősebb kiterjesztést, és vissza kell adnod egy stringet ebben a\n *     formátumban: ClassName.StrongestExtensionName.\n *     Ha két vagy több kiterjesztésnek azonos az ereje, akkor azt kell választani, amelyik először szerepel a listában.\n *     Például, ha \"Slices\"-t kapja meg az osztálynak és egy kiterjesztés listát: ['SErviNGSliCes', 'Cheese', 'StuFfed'], akkor\n *     vissza kell adnia 'Slices.SErviNGSliCes'-t, mivel 'SErviNGSliCes' a legerősebb kiterjesztés (az ereje -1).\n *     Példa:\n * \n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n *\n */\nfunction strongestExtension($classname, $extensions){\n", "entry_point": "strongestExtension", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"Watashi\";\n$arg01 = [\"tEN\", \"niNE\", \"eIGHt8OKe\"];\n$x0 = strongestExtension($arg00, $arg01);\n$v0 = \"Watashi.eIGHt8OKe\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"Boku123\";\n$arg11 = [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"];\n$x1 = strongestExtension($arg10, $arg11);\n$v1 = \"Boku123.YEs.WeCaNe\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"__YESIMHERE\";\n$arg21 = [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"];\n$x2 = strongestExtension($arg20, $arg21);\n$v2 = \"__YESIMHERE.NuLl__\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"K\";\n$arg31 = [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"];\n$x3 = strongestExtension($arg30, $arg31);\n$v3 = \"K.TAR\";\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"__HAHA\";\n$arg41 = [\"Tab\", \"123\", \"781345\", \"-_-\"];\n$x4 = strongestExtension($arg40, $arg41);\n$v4 = \"__HAHA.123\";\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"YameRore\";\n$arg51 = [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"];\n$x5 = strongestExtension($arg50, $arg51);\n$v5 = \"YameRore.okIWILL123\";\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"finNNalLLly\";\n$arg61 = [\"Die\", \"NowW\", \"Wow\", \"WoW\"];\n$x6 = strongestExtension($arg60, $arg61);\n$v6 = \"finNNalLLly.WoW\";\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = \"_\";\n$arg71 = [\"Bb\", \"91245\"];\n$x7 = strongestExtension($arg70, $arg71);\n$v7 = \"_.Bb\";\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = \"Sp\";\n$arg81 = [\"671235\", \"Bb\"];\n$x8 = strongestExtension($arg80, $arg81);\n$v8 = \"Sp.671235\";\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n", "description": "Adjon meg egy osztály nevet (string) és egy kiterjesztés listát.\n    A kiterjesztéseket az osztályhoz való további osztályok betöltésére kell használni. A\n    kiterjesztés ereje a következő: Legyen CAP a kiterjesztés nevében található nagybetűk száma, és legyen SM a kisbetűk száma\n    a kiterjesztés nevében, az erő a CAP - SM törttel van meghatározva. \n    Meg kell találnod a legerősebb kiterjesztést, és vissza kell adnod egy stringet ebben a\n    formátumban: ClassName.StrongestExtensionName.\n    Ha két vagy több kiterjesztésnek azonos az ereje, akkor azt kell választani, amelyik először szerepel a listában.\n    Például, ha \"Slices\"-t kapja meg az osztálynak és egy kiterjesztés listát: ['SErviNGSliCes', 'Cheese', 'StuFfed'], akkor\n    vissza kell adnia 'Slices.SErviNGSliCes'-t, mivel 'SErviNGSliCes' a legerősebb kiterjesztés (az ereje -1).\n    Példa:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/74", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Két szót kapsz. Ha a második szó vagy bármelyik forgatása részsztring a első szóban, akkor igazat kell visszaadni.\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n\n *\n */\nfunction cycpatternCheck($a, $b){\n", "entry_point": "cycpatternCheck", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"xyzw\";\n$arg01 = \"xyw\";\n$x0 = cycpatternCheck($arg00, $arg01);\n$v0 = false;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"yello\";\n$arg11 = \"ell\";\n$x1 = cycpatternCheck($arg10, $arg11);\n$v1 = true;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"whattup\";\n$arg21 = \"ptut\";\n$x2 = cycpatternCheck($arg20, $arg21);\n$v2 = false;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"efef\";\n$arg31 = \"fee\";\n$x3 = cycpatternCheck($arg30, $arg31);\n$v3 = true;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"abab\";\n$arg41 = \"aabb\";\n$x4 = cycpatternCheck($arg40, $arg41);\n$v4 = false;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"winemtt\";\n$arg51 = \"tinem\";\n$x5 = cycpatternCheck($arg50, $arg51);\n$v5 = true;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n", "description": "Két szót kapsz. Ha a második szó vagy bármelyik forgatása részsztring a első szóban, akkor igazat kell visszaadni.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/75", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy pozitív egész szám, állapítsa meg a római számjegyekkel való ekvivalensét string formában, és térjen vissza kisbetűkkel.\n * Korlátozások: 1 <= num <= 1000\n * \n * Példák:\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n *\n */\nfunction intToMiniRoman($number){\n", "entry_point": "intToMiniRoman", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 19;\n$x0 = intToMiniRoman($arg00);\n$v0 = \"xix\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 152;\n$x1 = intToMiniRoman($arg10);\n$v1 = \"clii\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 251;\n$x2 = intToMiniRoman($arg20);\n$v2 = \"ccli\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 426;\n$x3 = intToMiniRoman($arg30);\n$v3 = \"cdxxvi\";\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 500;\n$x4 = intToMiniRoman($arg40);\n$v4 = \"d\";\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 1;\n$x5 = intToMiniRoman($arg50);\n$v5 = \"i\";\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 4;\n$x6 = intToMiniRoman($arg60);\n$v6 = \"iv\";\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = 43;\n$x7 = intToMiniRoman($arg70);\n$v7 = \"xliii\";\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = 90;\n$x8 = intToMiniRoman($arg80);\n$v8 = \"xc\";\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = 94;\n$x9 = intToMiniRoman($arg90);\n$v9 = \"xciv\";\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n$arg100 = 532;\n$x10 = intToMiniRoman($arg100);\n$v10 = \"dxxxii\";\nif (!compare($x10, $v10)) {\n    throw new Exception(\"Error at 11th assert statement.\");\n}\n$arg110 = 900;\n$x11 = intToMiniRoman($arg110);\n$v11 = \"cm\";\nif (!compare($x11, $v11)) {\n    throw new Exception(\"Error at 12th assert statement.\");\n}\n$arg120 = 994;\n$x12 = intToMiniRoman($arg120);\n$v12 = \"cmxciv\";\nif (!compare($x12, $v12)) {\n    throw new Exception(\"Error at 13th assert statement.\");\n}\n$arg130 = 1000;\n$x13 = intToMiniRoman($arg130);\n$v13 = \"m\";\nif (!compare($x13, $v13)) {\n    throw new Exception(\"Error at 14th assert statement.\");\n}\n", "description": "Adott egy pozitív egész szám, állapítsa meg a római számjegyekkel való ekvivalensét string formában, és térjen vissza kisbetűkkel.\nKorlátozások: 1 <= num <= 1000\n\nPéldák:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/76", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy háromszög oldalainak hossza. Ha a három oldal alkot egy derékszögű háromszöget, akkor igazat, egyébként hamisat adjon vissza. Egy derékszögű háromszög az a háromszög, amelyben egy szög derékszögű, vagyis 90 fokos. Példa:\n * \n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n *\n */\nfunction rightAngleTriangle($a, $b, $c){\n", "entry_point": "rightAngleTriangle", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 3;\n$arg01 = 4;\n$arg02 = 5;\n$x0 = rightAngleTriangle($arg00, $arg01, $arg02);\n$v0 = true;\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 1;\n$arg11 = 2;\n$arg12 = 3;\n$x1 = rightAngleTriangle($arg10, $arg11, $arg12);\n$v1 = false;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 10;\n$arg21 = 6;\n$arg22 = 8;\n$x2 = rightAngleTriangle($arg20, $arg21, $arg22);\n$v2 = true;\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 2;\n$arg31 = 2;\n$arg32 = 2;\n$x3 = rightAngleTriangle($arg30, $arg31, $arg32);\n$v3 = false;\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = 7;\n$arg41 = 24;\n$arg42 = 25;\n$x4 = rightAngleTriangle($arg40, $arg41, $arg42);\n$v4 = true;\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = 10;\n$arg51 = 5;\n$arg52 = 7;\n$x5 = rightAngleTriangle($arg50, $arg51, $arg52);\n$v5 = false;\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = 5;\n$arg61 = 12;\n$arg62 = 13;\n$x6 = rightAngleTriangle($arg60, $arg61, $arg62);\n$v6 = true;\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = 15;\n$arg71 = 8;\n$arg72 = 17;\n$x7 = rightAngleTriangle($arg70, $arg71, $arg72);\n$v7 = true;\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n$arg80 = 48;\n$arg81 = 55;\n$arg82 = 73;\n$x8 = rightAngleTriangle($arg80, $arg81, $arg82);\n$v8 = true;\nif (!compare($x8, $v8)) {\n    throw new Exception(\"Error at 9th assert statement.\");\n}\n$arg90 = 1;\n$arg91 = 1;\n$arg92 = 1;\n$x9 = rightAngleTriangle($arg90, $arg91, $arg92);\n$v9 = false;\nif (!compare($x9, $v9)) {\n    throw new Exception(\"Error at 10th assert statement.\");\n}\n$arg100 = 2;\n$arg101 = 2;\n$arg102 = 10;\n$x10 = rightAngleTriangle($arg100, $arg101, $arg102);\n$v10 = false;\nif (!compare($x10, $v10)) {\n    throw new Exception(\"Error at 11th assert statement.\");\n}\n", "description": "Adott egy háromszög oldalainak hossza. Ha a három oldal alkot egy derékszögű háromszöget, akkor igazat, egyébként hamisat adjon vissza. Egy derékszögű háromszög az a háromszög, amelyben egy szög derékszögű, vagyis 90 fokos. Példa:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/77", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * Adott egy s karakterlánc.\n *     Ha s[i] egy betű, fordítsa meg az esetét kisbetűről nagybetűre vagy fordítva,\n *     különben hagyja változatlanul.\n *     Ha a karakterlánc nem tartalmaz betűket, fordítsa meg a karakterláncot.\n *     A függvény visszaadja az eredményezett karakterláncot.\n *     Példák\n * \n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n *\n */\nfunction solve($s){\n", "entry_point": "solve", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"AsDf\";\n$x0 = solve($arg00);\n$v0 = \"aSdF\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"1234\";\n$x1 = solve($arg10);\n$v1 = \"4321\";\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"ab\";\n$x2 = solve($arg20);\n$v2 = \"AB\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"#a@C\";\n$x3 = solve($arg30);\n$v3 = \"#A@c\";\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n$arg40 = \"#AsdfW^45\";\n$x4 = solve($arg40);\n$v4 = \"#aSDFw^45\";\nif (!compare($x4, $v4)) {\n    throw new Exception(\"Error at 5th assert statement.\");\n}\n$arg50 = \"#6@2\";\n$x5 = solve($arg50);\n$v5 = \"2@6#\";\nif (!compare($x5, $v5)) {\n    throw new Exception(\"Error at 6th assert statement.\");\n}\n$arg60 = \"#\\$a^D\";\n$x6 = solve($arg60);\n$v6 = \"#\\$A^d\";\nif (!compare($x6, $v6)) {\n    throw new Exception(\"Error at 7th assert statement.\");\n}\n$arg70 = \"#ccc\";\n$x7 = solve($arg70);\n$v7 = \"#CCC\";\nif (!compare($x7, $v7)) {\n    throw new Exception(\"Error at 8th assert statement.\");\n}\n", "description": "Adott egy s karakterlánc.\n    Ha s[i] egy betű, fordítsa meg az esetét kisbetűről nagybetűre vagy fordítva,\n    különben hagyja változatlanul.\n    Ha a karakterlánc nem tartalmaz betűket, fordítsa meg a karakterláncot.\n    A függvény visszaadja az eredményezett karakterláncot.\n    Példák", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/78", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott egy 'szöveg' karakterlánc, térj vissza az md5 hash ekvivalens karakterláncával.\n * Ha a 'szöveg' üres karakterlánc, térj vissza null értékkel.\n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n *\n */\nfunction stringToMd5($text){\n", "entry_point": "stringToMd5", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = \"Hello world\";\n$x0 = stringToMd5($arg00);\n$v0 = \"3e25960a79dbc69b674cd4ec67a72c62\";\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = \"\";\n$x1 = stringToMd5($arg10);\n$v1 = null;\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = \"A B C\";\n$x2 = stringToMd5($arg20);\n$v2 = \"0ef78513b0cb8cef12743f5aeb35f888\";\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = \"password\";\n$x3 = stringToMd5($arg30);\n$v3 = \"5f4dcc3b5aa765d61d8327deb882cf99\";\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n", "description": "Adott egy 'szöveg' karakterlánc, térj vissza az md5 hash ekvivalens karakterláncával.\nHa a 'szöveg' üres karakterlánc, térj vissza null értékkel.", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
{"task_id": "php/79", "prompt": "<?php\n\n/**\n * Te egy szakértő PHP programozó vagy, és itt van a feladatod.\n * * Adott két pozitív egész szám, a és b, térjen vissza az a és b közötti páros számjegyekkel növekvő sorrendben.\n * \n * Például:\n * \n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n *\n */\nfunction generateIntegers($a, $b){\n", "entry_point": "generateIntegers", "test": "\n\nfunction compare($x, $y) {\n    return $x == $y;\n}\n\n$arg00 = 2;\n$arg01 = 10;\n$x0 = generateIntegers($arg00, $arg01);\n$v0 = [2, 4, 6, 8];\nif (!compare($x0, $v0)) {\n    throw new Exception(\"Error at 1th assert statement.\");\n}\n$arg10 = 10;\n$arg11 = 2;\n$x1 = generateIntegers($arg10, $arg11);\n$v1 = [2, 4, 6, 8];\nif (!compare($x1, $v1)) {\n    throw new Exception(\"Error at 2th assert statement.\");\n}\n$arg20 = 132;\n$arg21 = 2;\n$x2 = generateIntegers($arg20, $arg21);\n$v2 = [2, 4, 6, 8];\nif (!compare($x2, $v2)) {\n    throw new Exception(\"Error at 3th assert statement.\");\n}\n$arg30 = 17;\n$arg31 = 89;\n$x3 = generateIntegers($arg30, $arg31);\n$v3 = [];\nif (!compare($x3, $v3)) {\n    throw new Exception(\"Error at 4th assert statement.\");\n}\n", "description": "Adott két pozitív egész szám, a és b, térjen vissza az a és b közötti páros számjegyekkel növekvő sorrendben.\n\nPéldául:", "language": "php", "canonical_solution": NaN, "natural_language": "Hungarian"}
