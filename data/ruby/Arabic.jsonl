{"task_id": "ruby/0", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# تم تزويدك بقائمة عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفري. مهمتك هي الكشف عما إذا كان رصيد الحساب ينخفض دون الصفر في أي نقطة، وفي ذلك الوقت يجب أن تعيد الدالة True. وإلا يجب أن تعيد False.\n# >>> below_zero([1, 2, 3])\n# False\n# >>> below_zero([1, 2, -4, 5])\n# True\n#\ndef below_zero(operations)", "entry_point": "below_zero", "test": "\n\narg00 = []\nx0 = below_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, -3, 1, 2, -3]\nx1 = below_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, -4, 5, 6]\nx2 = below_zero(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, -1, 2, -2, 5, -5, 4, -4]\nx3 = below_zero(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, -1, 2, -2, 5, -5, 4, -5]\nx4 = below_zero(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, -2, 2, -2, 5, -5, 4, -4]\nx5 = below_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "تم تزويدك بقائمة عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفري. مهمتك هي الكشف عما إذا كان رصيد الحساب ينخفض دون الصفر في أي نقطة، وفي ذلك الوقت يجب أن تعيد الدالة True. وإلا يجب أن تعيد False.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/1", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# لقائمة معينة من الأعداد الصحيحة، أرجع tuple يتكون من مجموع وضرب جميع الأعداد في القائمة.\n# يجب أن يكون مجموع القائمة الفارغة يساوي 0 وضربها الفارغ يساوي 1.\n# >>> sum_product([])\n# (0, 1)\n# >>> sum_product([1, 2, 3, 4])\n# (10, 24)\n#\ndef sum_product(numbers)", "entry_point": "sum_product", "test": "\n\narg00 = []\nx0 = sum_product(arg00)\nv0 = [0, 1]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 1, 1]\nx1 = sum_product(arg10)\nv1 = [3, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [100, 0]\nx2 = sum_product(arg20)\nv2 = [100, 0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 5, 7]\nx3 = sum_product(arg30)\nv3 = [15, 105]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [10]\nx4 = sum_product(arg40)\nv4 = [10, 10]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "لقائمة معينة من الأعداد الصحيحة، أرجع tuple يتكون من مجموع وضرب جميع الأعداد في القائمة.\nيجب أن يكون مجموع القائمة الفارغة يساوي 0 وضربها الفارغ يساوي 1.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/2", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# المدخلات هي سلسلتان a و b تتكونان فقط من 1 و 0.\n#     قم بتنفيذ عملية XOR الثنائية على هذه المدخلات وإرجاع النتيجة أيضًا كسلسلة.\n# >>> string_xor('010', '110')\n# '100'\n#\ndef string_xor(a, b)", "entry_point": "string_xor", "test": "\n\narg00 = \"111000\"\narg01 = \"101010\"\nx0 = string_xor(arg00, arg01)\nv0 = \"010010\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1\"\narg11 = \"1\"\nx1 = string_xor(arg10, arg11)\nv1 = \"0\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"0101\"\narg21 = \"0000\"\nx2 = string_xor(arg20, arg21)\nv2 = \"0101\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "المدخلات هي سلسلتان a و b تتكونان فقط من 1 و 0.\n    قم بتنفيذ عملية XOR الثنائية على هذه المدخلات وإرجاع النتيجة أيضًا كسلسلة.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/3", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# من بين قائمة السلاسل، ارجع الأطول. ارجع الأولى في حالة وجود عدة سلاسل بنفس الطول. ارجع قيمة فارغة في حالة أن القائمة الدخلية فارغة.\n# >>> longest([])\n\n# >>> longest(['a', 'b', 'c'])\n# 'a'\n# >>> longest(['a', 'bb', 'ccc'])\n# 'ccc'\n#\ndef longest(strings)", "entry_point": "longest", "test": "\n\narg00 = []\nx0 = longest(arg00)\nv0 = nil\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [\"x\", \"y\", \"z\"]\nx1 = longest(arg10)\nv1 = \"x\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]\nx2 = longest(arg20)\nv2 = \"zzzz\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "من بين قائمة السلاسل، ارجع الأطول. ارجع الأولى في حالة وجود عدة سلاسل بنفس الطول. ارجع قيمة فارغة في حالة أن القائمة الدخلية فارغة.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/4", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# إرجاع أكبر مقسوم مشترك بين عددين a و b\n# >>> greatest_common_divisor(3, 5)\n# 1\n# >>> greatest_common_divisor(25, 15)\n# 5\n#\ndef greatest_common_divisor(a, b)", "entry_point": "greatest_common_divisor", "test": "\n\narg00 = 3\narg01 = 7\nx0 = greatest_common_divisor(arg00, arg01)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 10\narg11 = 15\nx1 = greatest_common_divisor(arg10, arg11)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 49\narg21 = 14\nx2 = greatest_common_divisor(arg20, arg21)\nv2 = 7\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 144\narg31 = 60\nx3 = greatest_common_divisor(arg30, arg31)\nv3 = 12\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "إرجاع أكبر مقسوم مشترك بين عددين a و b", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/5", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# المدخلات هي سلسلة من الأرقام المفصولة بمسافة من \"صفر\" إلى \"تسعة\".\n# الخيارات الصالحة هي \"صفر\"، \"واحد\"، \"اثنان\"، \"ثلاثة\"، \"أربعة\"، \"خمسة\"، \"ستة\"، \"سبعة\"، \"ثمانية\" و \"تسعة\".\n# إرجاع السلسلة مع الأرقام مرتبة من الأصغر إلى الأكبر.\n# >>> sort_numbers('three one five')\n# 'one three five'\n#\ndef sort_numbers(numbers)", "entry_point": "sort_numbers", "test": "\n\narg00 = \"\"\nx0 = sort_numbers(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"three\"\nx1 = sort_numbers(arg10)\nv1 = \"three\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"three five nine\"\nx2 = sort_numbers(arg20)\nv2 = \"three five nine\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"five zero four seven nine eight\"\nx3 = sort_numbers(arg30)\nv3 = \"zero four five seven eight nine\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"six five four three two one zero\"\nx4 = sort_numbers(arg40)\nv4 = \"zero one two three four five six\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "المدخلات هي سلسلة من الأرقام المفصولة بمسافة من \"صفر\" إلى \"تسعة\".\nالخيارات الصالحة هي \"صفر\"، \"واحد\"، \"اثنان\"، \"ثلاثة\"، \"أربعة\"، \"خمسة\"، \"ستة\"، \"سبعة\"، \"ثمانية\" و \"تسعة\".\nإرجاع السلسلة مع الأرقام مرتبة من الأصغر إلى الأكبر.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/6", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# عندما يتم إعطاء قائمة من الأرقام (تحتوي على على الأقل عنصرين)، يتم تطبيق تحويل خطي على تلك القائمة، بحيث يتم جعل العدد الأصغر يصبح 0 والأكبر يصبح 1.\n# >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\n#\ndef rescale_to_unit(numbers)", "entry_point": "rescale_to_unit", "test": "\n\narg00 = [2.0, 49.9]\nx0 = rescale_to_unit(arg00)\nv0 = [0.0, 1.0]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [100.0, 49.9]\nx1 = rescale_to_unit(arg10)\nv1 = [1.0, 0.0]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1.0, 2.0, 3.0, 4.0, 5.0]\nx2 = rescale_to_unit(arg20)\nv2 = [0.0, 0.25, 0.5, 0.75, 1.0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [2.0, 1.0, 5.0, 3.0, 4.0]\nx3 = rescale_to_unit(arg30)\nv3 = [0.25, 0.0, 1.0, 0.5, 0.75]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [12.0, 11.0, 15.0, 13.0, 14.0]\nx4 = rescale_to_unit(arg40)\nv4 = [0.25, 0.0, 1.0, 0.5, 0.75]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "عندما يتم إعطاء قائمة من الأرقام (تحتوي على على الأقل عنصرين)، يتم تطبيق تحويل خطي على تلك القائمة، بحيث يتم جعل العدد الأصغر يصبح 0 والأكبر يصبح 1.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/7", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# لسلسلة محددة، قم بتبديل الأحرف الصغيرة إلى أحرف كبيرة والأحرف الكبيرة إلى أحرف صغيرة.\n# >>> flip_case('Hello')\n# 'hELLO'\n#\ndef flip_case(string)", "entry_point": "flip_case", "test": "\n\narg00 = \"\"\nx0 = flip_case(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Hello!\"\nx1 = flip_case(arg10)\nv1 = \"hELLO!\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"These violent delights have violent ends\"\nx2 = flip_case(arg20)\nv2 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "لسلسلة محددة، قم بتبديل الأحرف الصغيرة إلى أحرف كبيرة والأحرف الكبيرة إلى أحرف صغيرة.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/8", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# ارجع فقط الأرقام الإيجابية في القائمة.\n# >>> get_positive([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\n#\ndef get_positive(l)", "entry_point": "get_positive", "test": "\n\narg00 = [-1, -2, 4, 5, 6]\nx0 = get_positive(arg00)\nv0 = [4, 5, 6]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]\nx1 = get_positive(arg10)\nv1 = [5, 3, 2, 3, 3, 9, 123, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-1, -2]\nx2 = get_positive(arg20)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = []\nx3 = get_positive(arg30)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "ارجع فقط الأرقام الإيجابية في القائمة.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/9", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# إرجاع صحيح إذا كان الرقم المعطى هو عدد أولي، وإلا فهو خطأ.\n# >>> is_prime(6)\n# False\n# >>> is_prime(101)\n# True\n# >>> is_prime(11)\n# True\n# >>> is_prime(13441)\n# True\n# >>> is_prime(61)\n# True\n# >>> is_prime(4)\n# False\n# >>> is_prime(1)\n# False\n#\ndef is_prime(n)", "entry_point": "is_prime", "test": "\n\narg00 = 6\nx0 = is_prime(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 101\nx1 = is_prime(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 11\nx2 = is_prime(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 13441\nx3 = is_prime(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 61\nx4 = is_prime(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 4\nx5 = is_prime(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 1\nx6 = is_prime(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 5\nx7 = is_prime(arg70)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 11\nx8 = is_prime(arg80)\nv8 = true\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 17\nx9 = is_prime(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 85\nx10 = is_prime(arg100)\nv10 = false\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 77\nx11 = is_prime(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 255379\nx12 = is_prime(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\n", "description": "إرجاع صحيح إذا كان الرقم المعطى هو عدد أولي، وإلا فهو خطأ.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/10", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# إرجاع عناصر فريدة مرتبة في قائمة\n# >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\n#\ndef unique(l)", "entry_point": "unique", "test": "\n\narg00 = [5, 3, 5, 2, 3, 3, 9, 0, 123]\nx0 = unique(arg00)\nv0 = [0, 2, 3, 5, 9, 123]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\n", "description": "إرجاع عناصر فريدة مرتبة في قائمة", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/11", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # prime_fib يعيد العدد رقم n الذي هو عدد فيبوناتشي وهو أيضًا عدد أولي.\n# >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n# 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n# 89\n#\ndef prime_fib(n)", "entry_point": "prime_fib", "test": "\n\narg00 = 1\nx0 = prime_fib(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 2\nx1 = prime_fib(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\nx2 = prime_fib(arg20)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 4\nx3 = prime_fib(arg30)\nv3 = 13\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 5\nx4 = prime_fib(arg40)\nv4 = 89\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 6\nx5 = prime_fib(arg50)\nv5 = 233\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 7\nx6 = prime_fib(arg60)\nv6 = 1597\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 8\nx7 = prime_fib(arg70)\nv7 = 28657\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 9\nx8 = prime_fib(arg80)\nv8 = 514229\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 10\nx9 = prime_fib(arg90)\nv9 = 433494437\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "prime_fib يعيد العدد رقم n الذي هو عدد فيبوناتشي وهو أيضًا عدد أولي.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/12", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # تأخذ triples_sum_to_zero قائمة من الأعداد الصحيحة كمدخلات.\n#     يعيد True إذا كان هناك ثلاثة عناصر متميزة في القائمة تجمع إلى الصفر ، و False في الحالة الأخرى.\n# >>> triples_sum_to_zero([1, 3, 5, 0])\n# False\n# >>> triples_sum_to_zero([1, 3, -2, 1])\n# True\n# >>> triples_sum_to_zero([1, 2, 3, 7])\n# False\n# >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n# True\n# >>> triples_sum_to_zero([1])\n# False\n#\ndef triples_sum_to_zero(l)", "entry_point": "triples_sum_to_zero", "test": "\n\narg00 = [1, 3, 5, 0]\nx0 = triples_sum_to_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 3, 5, -1]\nx1 = triples_sum_to_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, -2, 1]\nx2 = triples_sum_to_zero(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 2, 3, 7]\nx3 = triples_sum_to_zero(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 5, 7]\nx4 = triples_sum_to_zero(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [2, 4, -5, 3, 9, 7]\nx5 = triples_sum_to_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [1]\nx6 = triples_sum_to_zero(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [1, 3, 5, -100]\nx7 = triples_sum_to_zero(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [100, 3, 5, -100]\nx8 = triples_sum_to_zero(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "تأخذ triples_sum_to_zero قائمة من الأعداد الصحيحة كمدخلات.\n    يعيد True إذا كان هناك ثلاثة عناصر متميزة في القائمة تجمع إلى الصفر ، و False في الحالة الأخرى.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/13", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # يأخذ pairs_sum_to_zero قائمة من الأعداد الصحيحة كمدخلات.\n# يعيد True إذا كان هناك عنصران متميزان في القائمة يجمعان إلى الصفر ، و False في الحالة الأخرى.\n# >>> pairs_sum_to_zero([1, 3, 5, 0])\n# False\n# >>> pairs_sum_to_zero([1, 3, -2, 1])\n# False\n# >>> pairs_sum_to_zero([1, 2, 3, 7])\n# False\n# >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n# True\n# >>> pairs_sum_to_zero([1])\n# False\n#\ndef pairs_sum_to_zero(l)", "entry_point": "pairs_sum_to_zero", "test": "\n\narg00 = [1, 3, 5, 0]\nx0 = pairs_sum_to_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 3, -2, 1]\nx1 = pairs_sum_to_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, 3, 7]\nx2 = pairs_sum_to_zero(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [2, 4, -5, 3, 5, 7]\nx3 = pairs_sum_to_zero(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\nx4 = pairs_sum_to_zero(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [-3, 9, -1, 3, 2, 30]\nx5 = pairs_sum_to_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-3, 9, -1, 3, 2, 31]\nx6 = pairs_sum_to_zero(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-3, 9, -1, 4, 2, 30]\nx7 = pairs_sum_to_zero(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-3, 9, -1, 4, 2, 31]\nx8 = pairs_sum_to_zero(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "يأخذ pairs_sum_to_zero قائمة من الأعداد الصحيحة كمدخلات.\nيعيد True إذا كان هناك عنصران متميزان في القائمة يجمعان إلى الصفر ، و False في الحالة الأخرى.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/14", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# تتمثل متتابعة أرقام Fib4 في متتابعة مشابهة لمتتابعة فيبوناتشي والتي تعرف على النحو التالي:\n#     fib4(0) -> 0\n#     fib4(1) -> 0\n#     fib4(2) -> 2\n#     fib4(3) -> 0\n#     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n#     يرجى كتابة وظيفة لحساب العنصر الثامن من متتابعة أرقام Fib4 بكفاءة. لا تستخدم الاستدعاء العكسي.\n# >>> fib4(5)\n# 4\n# >>> fib4(6)\n# 8\n# >>> fib4(7)\n# 14\n#\ndef fib4(n)", "entry_point": "fib4", "test": "\n\narg00 = 5\nx0 = fib4(arg00)\nv0 = 4\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 8\nx1 = fib4(arg10)\nv1 = 28\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\nx2 = fib4(arg20)\nv2 = 104\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 12\nx3 = fib4(arg30)\nv3 = 386\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "تتمثل متتابعة أرقام Fib4 في متتابعة مشابهة لمتتابعة فيبوناتشي والتي تعرف على النحو التالي:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    يرجى كتابة وظيفة لحساب العنصر الثامن من متتابعة أرقام Fib4 بكفاءة. لا تستخدم الاستدعاء العكسي.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/15", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# إرجاع الوسيط لعناصر القائمة l.\n# >>> median([3, 1, 2, 4, 5])\n# 3\n# >>> median([-10, 4, 6, 1000, 10, 20])\n# 15.0\n#\ndef median(l)", "entry_point": "median", "test": "\n\narg00 = [3, 1, 2, 4, 5]\nx0 = median(arg00)\nv0 = 3\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [-10, 4, 6, 1000, 10, 20]\nx1 = median(arg10)\nv1 = 8.0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [5]\nx2 = median(arg20)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [6, 5]\nx3 = median(arg30)\nv3 = 5.5\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [8, 1, 3, 9, 9, 2, 7]\nx4 = median(arg40)\nv4 = 7\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "إرجاع الوسيط لعناصر القائمة l.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/16", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # يتحقق مما إذا كانت السلسلة المعطاة هي باليندروم.\n# >>> is_palindrome('')\n# True\n# >>> is_palindrome('aba')\n# True\n# >>> is_palindrome('aaaaa')\n# True\n# >>> is_palindrome('zbcd')\n# False\n#\ndef is_palindrome(text)", "entry_point": "is_palindrome", "test": "\n\narg00 = \"\"\nx0 = is_palindrome(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"aba\"\nx1 = is_palindrome(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"aaaaa\"\nx2 = is_palindrome(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"zbcd\"\nx3 = is_palindrome(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"xywyx\"\nx4 = is_palindrome(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"xywyz\"\nx5 = is_palindrome(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"xywzx\"\nx6 = is_palindrome(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "يتحقق مما إذا كانت السلسلة المعطاة هي باليندروم.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/17", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # remove_vowels هي وظيفة تأخذ سلسلة نصية وتعيد سلسلة نصية بدون حروف العلة.\n# >>> remove_vowels('')\n# ''\n# >>> remove_vowels(\"abcdef\\nghijklm\")\n# 'bcdf\\nghjklm'\n# >>> remove_vowels('abcdef')\n# 'bcdf'\n# >>> remove_vowels('aaaaa')\n# ''\n# >>> remove_vowels('aaBAA')\n# 'B'\n# >>> remove_vowels('zbcd')\n# 'zbcd'\n#\ndef remove_vowels(text)", "entry_point": "remove_vowels", "test": "\n\narg00 = \"\"\nx0 = remove_vowels(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdef\\nghijklm\"\nx1 = remove_vowels(arg10)\nv1 = \"bcdf\\nghjklm\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"fedcba\"\nx2 = remove_vowels(arg20)\nv2 = \"fdcb\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"eeeee\"\nx3 = remove_vowels(arg30)\nv3 = \"\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"acBAA\"\nx4 = remove_vowels(arg40)\nv4 = \"cB\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"EcBOO\"\nx5 = remove_vowels(arg50)\nv5 = \"cB\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"ybcd\"\nx6 = remove_vowels(arg60)\nv6 = \"ybcd\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "remove_vowels هي وظيفة تأخذ سلسلة نصية وتعيد سلسلة نصية بدون حروف العلة.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/18", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# \"ارجع صحيح إذا كانت جميع الأرقام في القائمة l أقل من الحد t.\"\n# >>> below_threshold([1, 2, 4, 10], 100)\n# True\n# >>> below_threshold([1, 20, 4, 10], 5)\n# False\n#\ndef below_threshold(l, t)", "entry_point": "below_threshold", "test": "\n\narg00 = [1, 2, 4, 10]\narg01 = 100\nx0 = below_threshold(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 20, 4, 10]\narg11 = 5\nx1 = below_threshold(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 20, 4, 10]\narg21 = 21\nx2 = below_threshold(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 20, 4, 10]\narg31 = 22\nx3 = below_threshold(arg30, arg31)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 8, 4, 10]\narg41 = 11\nx4 = below_threshold(arg40, arg41)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 8, 4, 10]\narg51 = 10\nx5 = below_threshold(arg50, arg51)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "\"ارجع صحيح إذا كانت جميع الأرقام في القائمة l أقل من الحد t.\"", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/19", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# إضافة رقمين x و y\n# >>> add(2, 3)\n# 5\n# >>> add(5, 7)\n# 12\n#\ndef add(x, y)", "entry_point": "add", "test": "\n\narg00 = 0\narg01 = 1\nx0 = add(arg00, arg01)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 0\nx1 = add(arg10, arg11)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 2\narg21 = 3\nx2 = add(arg20, arg21)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5\narg31 = 7\nx3 = add(arg30, arg31)\nv3 = 12\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\narg41 = 5\nx4 = add(arg40, arg41)\nv4 = 12\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 572\narg51 = 725\nx5 = add(arg50, arg51)\nv5 = 1297\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 51\narg61 = 804\nx6 = add(arg60, arg61)\nv6 = 855\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 645\narg71 = 96\nx7 = add(arg70, arg71)\nv7 = 741\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 712\narg81 = 853\nx8 = add(arg80, arg81)\nv8 = 1565\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 223\narg91 = 101\nx9 = add(arg90, arg91)\nv9 = 324\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 76\narg101 = 29\nx10 = add(arg100, arg101)\nv10 = 105\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 416\narg111 = 149\nx11 = add(arg110, arg111)\nv11 = 565\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 145\narg121 = 409\nx12 = add(arg120, arg121)\nv12 = 554\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = 535\narg131 = 430\nx13 = add(arg130, arg131)\nv13 = 965\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = 118\narg141 = 303\nx14 = add(arg140, arg141)\nv14 = 421\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = 287\narg151 = 94\nx15 = add(arg150, arg151)\nv15 = 381\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\narg160 = 768\narg161 = 257\nx16 = add(arg160, arg161)\nv16 = 1025\nif x16 != v16\n    raise StandardError, \"Error at test case 17\"\nend\n\narg170 = 421\narg171 = 677\nx17 = add(arg170, arg171)\nv17 = 1098\nif x17 != v17\n    raise StandardError, \"Error at test case 18\"\nend\n\narg180 = 802\narg181 = 814\nx18 = add(arg180, arg181)\nv18 = 1616\nif x18 != v18\n    raise StandardError, \"Error at test case 19\"\nend\n\narg190 = 510\narg191 = 922\nx19 = add(arg190, arg191)\nv19 = 1432\nif x19 != v19\n    raise StandardError, \"Error at test case 20\"\nend\n\narg200 = 345\narg201 = 819\nx20 = add(arg200, arg201)\nv20 = 1164\nif x20 != v20\n    raise StandardError, \"Error at test case 21\"\nend\n\narg210 = 895\narg211 = 436\nx21 = add(arg210, arg211)\nv21 = 1331\nif x21 != v21\n    raise StandardError, \"Error at test case 22\"\nend\n\narg220 = 123\narg221 = 424\nx22 = add(arg220, arg221)\nv22 = 547\nif x22 != v22\n    raise StandardError, \"Error at test case 23\"\nend\n\narg230 = 923\narg231 = 245\nx23 = add(arg230, arg231)\nv23 = 1168\nif x23 != v23\n    raise StandardError, \"Error at test case 24\"\nend\n\narg240 = 23\narg241 = 438\nx24 = add(arg240, arg241)\nv24 = 461\nif x24 != v24\n    raise StandardError, \"Error at test case 25\"\nend\n\narg250 = 565\narg251 = 133\nx25 = add(arg250, arg251)\nv25 = 698\nif x25 != v25\n    raise StandardError, \"Error at test case 26\"\nend\n\narg260 = 945\narg261 = 925\nx26 = add(arg260, arg261)\nv26 = 1870\nif x26 != v26\n    raise StandardError, \"Error at test case 27\"\nend\n\narg270 = 261\narg271 = 983\nx27 = add(arg270, arg271)\nv27 = 1244\nif x27 != v27\n    raise StandardError, \"Error at test case 28\"\nend\n\narg280 = 139\narg281 = 577\nx28 = add(arg280, arg281)\nv28 = 716\nif x28 != v28\n    raise StandardError, \"Error at test case 29\"\nend\n\narg290 = 763\narg291 = 178\nx29 = add(arg290, arg291)\nv29 = 941\nif x29 != v29\n    raise StandardError, \"Error at test case 30\"\nend\n\narg300 = 147\narg301 = 892\nx30 = add(arg300, arg301)\nv30 = 1039\nif x30 != v30\n    raise StandardError, \"Error at test case 31\"\nend\n\narg310 = 436\narg311 = 402\nx31 = add(arg310, arg311)\nv31 = 838\nif x31 != v31\n    raise StandardError, \"Error at test case 32\"\nend\n\narg320 = 610\narg321 = 581\nx32 = add(arg320, arg321)\nv32 = 1191\nif x32 != v32\n    raise StandardError, \"Error at test case 33\"\nend\n\narg330 = 103\narg331 = 416\nx33 = add(arg330, arg331)\nv33 = 519\nif x33 != v33\n    raise StandardError, \"Error at test case 34\"\nend\n\narg340 = 339\narg341 = 990\nx34 = add(arg340, arg341)\nv34 = 1329\nif x34 != v34\n    raise StandardError, \"Error at test case 35\"\nend\n\narg350 = 130\narg351 = 504\nx35 = add(arg350, arg351)\nv35 = 634\nif x35 != v35\n    raise StandardError, \"Error at test case 36\"\nend\n\narg360 = 242\narg361 = 717\nx36 = add(arg360, arg361)\nv36 = 959\nif x36 != v36\n    raise StandardError, \"Error at test case 37\"\nend\n\narg370 = 562\narg371 = 110\nx37 = add(arg370, arg371)\nv37 = 672\nif x37 != v37\n    raise StandardError, \"Error at test case 38\"\nend\n\narg380 = 396\narg381 = 909\nx38 = add(arg380, arg381)\nv38 = 1305\nif x38 != v38\n    raise StandardError, \"Error at test case 39\"\nend\n\narg390 = 887\narg391 = 703\nx39 = add(arg390, arg391)\nv39 = 1590\nif x39 != v39\n    raise StandardError, \"Error at test case 40\"\nend\n\narg400 = 870\narg401 = 551\nx40 = add(arg400, arg401)\nv40 = 1421\nif x40 != v40\n    raise StandardError, \"Error at test case 41\"\nend\n\narg410 = 422\narg411 = 391\nx41 = add(arg410, arg411)\nv41 = 813\nif x41 != v41\n    raise StandardError, \"Error at test case 42\"\nend\n\narg420 = 299\narg421 = 505\nx42 = add(arg420, arg421)\nv42 = 804\nif x42 != v42\n    raise StandardError, \"Error at test case 43\"\nend\n\narg430 = 346\narg431 = 56\nx43 = add(arg430, arg431)\nv43 = 402\nif x43 != v43\n    raise StandardError, \"Error at test case 44\"\nend\n\narg440 = 36\narg441 = 706\nx44 = add(arg440, arg441)\nv44 = 742\nif x44 != v44\n    raise StandardError, \"Error at test case 45\"\nend\n\narg450 = 738\narg451 = 411\nx45 = add(arg450, arg451)\nv45 = 1149\nif x45 != v45\n    raise StandardError, \"Error at test case 46\"\nend\n\narg460 = 679\narg461 = 87\nx46 = add(arg460, arg461)\nv46 = 766\nif x46 != v46\n    raise StandardError, \"Error at test case 47\"\nend\n\narg470 = 25\narg471 = 303\nx47 = add(arg470, arg471)\nv47 = 328\nif x47 != v47\n    raise StandardError, \"Error at test case 48\"\nend\n\narg480 = 161\narg481 = 612\nx48 = add(arg480, arg481)\nv48 = 773\nif x48 != v48\n    raise StandardError, \"Error at test case 49\"\nend\n\narg490 = 306\narg491 = 841\nx49 = add(arg490, arg491)\nv49 = 1147\nif x49 != v49\n    raise StandardError, \"Error at test case 50\"\nend\n\narg500 = 973\narg501 = 411\nx50 = add(arg500, arg501)\nv50 = 1384\nif x50 != v50\n    raise StandardError, \"Error at test case 51\"\nend\n\narg510 = 711\narg511 = 157\nx51 = add(arg510, arg511)\nv51 = 868\nif x51 != v51\n    raise StandardError, \"Error at test case 52\"\nend\n\narg520 = 471\narg521 = 27\nx52 = add(arg520, arg521)\nv52 = 498\nif x52 != v52\n    raise StandardError, \"Error at test case 53\"\nend\n\narg530 = 714\narg531 = 792\nx53 = add(arg530, arg531)\nv53 = 1506\nif x53 != v53\n    raise StandardError, \"Error at test case 54\"\nend\n\narg540 = 38\narg541 = 206\nx54 = add(arg540, arg541)\nv54 = 244\nif x54 != v54\n    raise StandardError, \"Error at test case 55\"\nend\n\narg550 = 907\narg551 = 343\nx55 = add(arg550, arg551)\nv55 = 1250\nif x55 != v55\n    raise StandardError, \"Error at test case 56\"\nend\n\narg560 = 23\narg561 = 760\nx56 = add(arg560, arg561)\nv56 = 783\nif x56 != v56\n    raise StandardError, \"Error at test case 57\"\nend\n\narg570 = 524\narg571 = 859\nx57 = add(arg570, arg571)\nv57 = 1383\nif x57 != v57\n    raise StandardError, \"Error at test case 58\"\nend\n\narg580 = 30\narg581 = 529\nx58 = add(arg580, arg581)\nv58 = 559\nif x58 != v58\n    raise StandardError, \"Error at test case 59\"\nend\n\narg590 = 341\narg591 = 691\nx59 = add(arg590, arg591)\nv59 = 1032\nif x59 != v59\n    raise StandardError, \"Error at test case 60\"\nend\n\narg600 = 167\narg601 = 729\nx60 = add(arg600, arg601)\nv60 = 896\nif x60 != v60\n    raise StandardError, \"Error at test case 61\"\nend\n\narg610 = 636\narg611 = 289\nx61 = add(arg610, arg611)\nv61 = 925\nif x61 != v61\n    raise StandardError, \"Error at test case 62\"\nend\n\narg620 = 503\narg621 = 144\nx62 = add(arg620, arg621)\nv62 = 647\nif x62 != v62\n    raise StandardError, \"Error at test case 63\"\nend\n\narg630 = 51\narg631 = 985\nx63 = add(arg630, arg631)\nv63 = 1036\nif x63 != v63\n    raise StandardError, \"Error at test case 64\"\nend\n\narg640 = 287\narg641 = 149\nx64 = add(arg640, arg641)\nv64 = 436\nif x64 != v64\n    raise StandardError, \"Error at test case 65\"\nend\n\narg650 = 659\narg651 = 75\nx65 = add(arg650, arg651)\nv65 = 734\nif x65 != v65\n    raise StandardError, \"Error at test case 66\"\nend\n\narg660 = 462\narg661 = 797\nx66 = add(arg660, arg661)\nv66 = 1259\nif x66 != v66\n    raise StandardError, \"Error at test case 67\"\nend\n\narg670 = 406\narg671 = 141\nx67 = add(arg670, arg671)\nv67 = 547\nif x67 != v67\n    raise StandardError, \"Error at test case 68\"\nend\n\narg680 = 106\narg681 = 44\nx68 = add(arg680, arg681)\nv68 = 150\nif x68 != v68\n    raise StandardError, \"Error at test case 69\"\nend\n\narg690 = 300\narg691 = 934\nx69 = add(arg690, arg691)\nv69 = 1234\nif x69 != v69\n    raise StandardError, \"Error at test case 70\"\nend\n\narg700 = 471\narg701 = 524\nx70 = add(arg700, arg701)\nv70 = 995\nif x70 != v70\n    raise StandardError, \"Error at test case 71\"\nend\n\narg710 = 122\narg711 = 429\nx71 = add(arg710, arg711)\nv71 = 551\nif x71 != v71\n    raise StandardError, \"Error at test case 72\"\nend\n\narg720 = 735\narg721 = 195\nx72 = add(arg720, arg721)\nv72 = 930\nif x72 != v72\n    raise StandardError, \"Error at test case 73\"\nend\n\narg730 = 335\narg731 = 484\nx73 = add(arg730, arg731)\nv73 = 819\nif x73 != v73\n    raise StandardError, \"Error at test case 74\"\nend\n\narg740 = 28\narg741 = 809\nx74 = add(arg740, arg741)\nv74 = 837\nif x74 != v74\n    raise StandardError, \"Error at test case 75\"\nend\n\narg750 = 430\narg751 = 20\nx75 = add(arg750, arg751)\nv75 = 450\nif x75 != v75\n    raise StandardError, \"Error at test case 76\"\nend\n\narg760 = 916\narg761 = 635\nx76 = add(arg760, arg761)\nv76 = 1551\nif x76 != v76\n    raise StandardError, \"Error at test case 77\"\nend\n\narg770 = 301\narg771 = 999\nx77 = add(arg770, arg771)\nv77 = 1300\nif x77 != v77\n    raise StandardError, \"Error at test case 78\"\nend\n\narg780 = 454\narg781 = 466\nx78 = add(arg780, arg781)\nv78 = 920\nif x78 != v78\n    raise StandardError, \"Error at test case 79\"\nend\n\narg790 = 905\narg791 = 259\nx79 = add(arg790, arg791)\nv79 = 1164\nif x79 != v79\n    raise StandardError, \"Error at test case 80\"\nend\n\narg800 = 168\narg801 = 205\nx80 = add(arg800, arg801)\nv80 = 373\nif x80 != v80\n    raise StandardError, \"Error at test case 81\"\nend\n\narg810 = 570\narg811 = 434\nx81 = add(arg810, arg811)\nv81 = 1004\nif x81 != v81\n    raise StandardError, \"Error at test case 82\"\nend\n\narg820 = 64\narg821 = 959\nx82 = add(arg820, arg821)\nv82 = 1023\nif x82 != v82\n    raise StandardError, \"Error at test case 83\"\nend\n\narg830 = 957\narg831 = 510\nx83 = add(arg830, arg831)\nv83 = 1467\nif x83 != v83\n    raise StandardError, \"Error at test case 84\"\nend\n\narg840 = 722\narg841 = 598\nx84 = add(arg840, arg841)\nv84 = 1320\nif x84 != v84\n    raise StandardError, \"Error at test case 85\"\nend\n\narg850 = 770\narg851 = 226\nx85 = add(arg850, arg851)\nv85 = 996\nif x85 != v85\n    raise StandardError, \"Error at test case 86\"\nend\n\narg860 = 579\narg861 = 66\nx86 = add(arg860, arg861)\nv86 = 645\nif x86 != v86\n    raise StandardError, \"Error at test case 87\"\nend\n\narg870 = 117\narg871 = 674\nx87 = add(arg870, arg871)\nv87 = 791\nif x87 != v87\n    raise StandardError, \"Error at test case 88\"\nend\n\narg880 = 530\narg881 = 30\nx88 = add(arg880, arg881)\nv88 = 560\nif x88 != v88\n    raise StandardError, \"Error at test case 89\"\nend\n\narg890 = 776\narg891 = 345\nx89 = add(arg890, arg891)\nv89 = 1121\nif x89 != v89\n    raise StandardError, \"Error at test case 90\"\nend\n\narg900 = 327\narg901 = 389\nx90 = add(arg900, arg901)\nv90 = 716\nif x90 != v90\n    raise StandardError, \"Error at test case 91\"\nend\n\narg910 = 596\narg911 = 12\nx91 = add(arg910, arg911)\nv91 = 608\nif x91 != v91\n    raise StandardError, \"Error at test case 92\"\nend\n\narg920 = 599\narg921 = 511\nx92 = add(arg920, arg921)\nv92 = 1110\nif x92 != v92\n    raise StandardError, \"Error at test case 93\"\nend\n\narg930 = 936\narg931 = 476\nx93 = add(arg930, arg931)\nv93 = 1412\nif x93 != v93\n    raise StandardError, \"Error at test case 94\"\nend\n\narg940 = 461\narg941 = 14\nx94 = add(arg940, arg941)\nv94 = 475\nif x94 != v94\n    raise StandardError, \"Error at test case 95\"\nend\n\narg950 = 966\narg951 = 157\nx95 = add(arg950, arg951)\nv95 = 1123\nif x95 != v95\n    raise StandardError, \"Error at test case 96\"\nend\n\narg960 = 326\narg961 = 91\nx96 = add(arg960, arg961)\nv96 = 417\nif x96 != v96\n    raise StandardError, \"Error at test case 97\"\nend\n\narg970 = 392\narg971 = 455\nx97 = add(arg970, arg971)\nv97 = 847\nif x97 != v97\n    raise StandardError, \"Error at test case 98\"\nend\n\narg980 = 446\narg981 = 477\nx98 = add(arg980, arg981)\nv98 = 923\nif x98 != v98\n    raise StandardError, \"Error at test case 99\"\nend\n\narg990 = 324\narg991 = 860\nx99 = add(arg990, arg991)\nv99 = 1184\nif x99 != v99\n    raise StandardError, \"Error at test case 100\"\nend\n\narg1000 = 945\narg1001 = 85\nx100 = add(arg1000, arg1001)\nv100 = 1030\nif x100 != v100\n    raise StandardError, \"Error at test case 101\"\nend\n\narg1010 = 886\narg1011 = 582\nx101 = add(arg1010, arg1011)\nv101 = 1468\nif x101 != v101\n    raise StandardError, \"Error at test case 102\"\nend\n\narg1020 = 886\narg1021 = 712\nx102 = add(arg1020, arg1021)\nv102 = 1598\nif x102 != v102\n    raise StandardError, \"Error at test case 103\"\nend\n\narg1030 = 842\narg1031 = 953\nx103 = add(arg1030, arg1031)\nv103 = 1795\nif x103 != v103\n    raise StandardError, \"Error at test case 104\"\nend\n\n", "description": "إضافة رقمين x و y", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/20", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # تحقق مما إذا كانت كلمتان لديهما نفس الأحرف.\n# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n# True\n# >>> same_chars('abcd', 'dddddddabc')\n# True\n# >>> same_chars('dddddddabc', 'abcd')\n# True\n# >>> same_chars('eabcd', 'dddddddabc')\n# False\n# >>> same_chars('abcd', 'dddddddabce')\n# False\n# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n# False\n#\ndef same_chars(s0, s1)", "entry_point": "same_chars", "test": "\n\narg00 = \"eabcdzzzz\"\narg01 = \"dddzzzzzzzddeddabc\"\nx0 = same_chars(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcd\"\narg11 = \"dddddddabc\"\nx1 = same_chars(arg10, arg11)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"dddddddabc\"\narg21 = \"abcd\"\nx2 = same_chars(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"eabcd\"\narg31 = \"dddddddabc\"\nx3 = same_chars(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"abcd\"\narg41 = \"dddddddabcf\"\nx4 = same_chars(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"eabcdzzzz\"\narg51 = \"dddzzzzzzzddddabc\"\nx5 = same_chars(arg50, arg51)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"aabb\"\narg61 = \"aaccc\"\nx6 = same_chars(arg60, arg61)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "تحقق مما إذا كانت كلمتان لديهما نفس الأحرف.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/21", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# إرجاع العدد الفيبوناتشي رقم n.\n# >>> fib(10)\n# 55\n# >>> fib(1)\n# 1\n# >>> fib(8)\n# 21\n#\ndef fib(n)", "entry_point": "fib", "test": "\n\narg00 = 10\nx0 = fib(arg00)\nv0 = 55\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\nx1 = fib(arg10)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 8\nx2 = fib(arg20)\nv2 = 21\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 11\nx3 = fib(arg30)\nv3 = 89\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 12\nx4 = fib(arg40)\nv4 = 144\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "إرجاع العدد الفيبوناتشي رقم n.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/22", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# إرجاع العناصر المشتركة الفريدة المرتبة لاثنين من القوائم.\n# >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5, 3, 2, 8], [3, 2])\n# [2, 3]\n\n#\ndef common(l1, l2)", "entry_point": "common", "test": "\n\narg00 = [1, 4, 3, 34, 653, 2, 5]\narg01 = [5, 7, 1, 5, 9, 653, 121]\nx0 = common(arg00, arg01)\nv0 = [1, 5, 653]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 3, 2, 8]\narg11 = [3, 2]\nx1 = common(arg10, arg11)\nv1 = [2, 3]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [4, 3, 2, 8]\narg21 = [3, 2, 4]\nx2 = common(arg20, arg21)\nv2 = [2, 3, 4]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 3, 2, 8]\narg31 = []\nx3 = common(arg30, arg31)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "إرجاع العناصر المشتركة الفريدة المرتبة لاثنين من القوائم.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/23", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# \"ارجع أكبر عامل أولي لـ n. افترض أن n> 1 وليس عددًا أوليًا.\"\n# >>> largest_prime_factor(13195)\n# 29\n# >>> largest_prime_factor(2048)\n# 2\n#\ndef largest_prime_factor(n)", "entry_point": "largest_prime_factor", "test": "\n\narg00 = 15\nx0 = largest_prime_factor(arg00)\nv0 = 5\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 27\nx1 = largest_prime_factor(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 63\nx2 = largest_prime_factor(arg20)\nv2 = 7\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 330\nx3 = largest_prime_factor(arg30)\nv3 = 11\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 13195\nx4 = largest_prime_factor(arg40)\nv4 = 29\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "\"ارجع أكبر عامل أولي لـ n. افترض أن n> 1 وليس عددًا أوليًا.\"", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/24", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# sum_to_n هي وظيفة تجمع الأرقام من 1 إلى n.\n# >>> sum_to_n(30)\n# 465\n# >>> sum_to_n(100)\n# 5050\n# >>> sum_to_n(5)\n# 15\n# >>> sum_to_n(10)\n# 55\n# >>> sum_to_n(1)\n# 1\n#\ndef sum_to_n(n)", "entry_point": "sum_to_n", "test": "\n\narg00 = 1\nx0 = sum_to_n(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 6\nx1 = sum_to_n(arg10)\nv1 = 21\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 11\nx2 = sum_to_n(arg20)\nv2 = 66\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 30\nx3 = sum_to_n(arg30)\nv3 = 465\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 100\nx4 = sum_to_n(arg40)\nv4 = 5050\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "sum_to_n هي وظيفة تجمع الأرقام من 1 إلى n.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/25", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# xs تمثل معاملات متعددة الحدود.\n# xs[0] + xs[1] * x + xs[2] * x^2 + ....\n# إرجاع المشتقة لهذه المعادلة متعددة الحدود بنفس الصيغة.\n# >>> derivative([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative([1, 2, 3])\n# [2, 6]\n#\ndef derivative(xs)", "entry_point": "derivative", "test": "\n\narg00 = [3, 1, 2, 4, 5]\nx0 = derivative(arg00)\nv0 = [1, 4, 12, 20]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 3]\nx1 = derivative(arg10)\nv1 = [2, 6]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3, 2, 1]\nx2 = derivative(arg20)\nv2 = [2, 2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 2, 1, 0, 4]\nx3 = derivative(arg30)\nv3 = [2, 2, 0, 16]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\nx4 = derivative(arg40)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "xs تمثل معاملات متعددة الحدود.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\nإرجاع المشتقة لهذه المعادلة متعددة الحدود بنفس الصيغة.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/26", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# تتبع سلسلة أرقام فيبفيب هي سلسلة مشابهة لسلسلة فيبوناتشي التي تعرف على النحو التالي:\n#     فيبفيب(0) == 0\n#     فيبفيب(1) == 0\n#     فيبفيب(2) == 1\n#     فيبفيب(n) == فيبفيب(n-1) + فيبفيب(n-2) + فيبفيب(n-3).\n#     يرجى كتابة وظيفة لحساب العنصر الثالث عشر بكفاءة في سلسلة أرقام فيبفيب.\n# >>> fibfib(1)\n# 0\n# >>> fibfib(5)\n# 4\n# >>> fibfib(8)\n# 24\n#\ndef fibfib(n)", "entry_point": "fibfib", "test": "\n\narg00 = 2\nx0 = fibfib(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\nx1 = fibfib(arg10)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = fibfib(arg20)\nv2 = 4\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 8\nx3 = fibfib(arg30)\nv3 = 24\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 10\nx4 = fibfib(arg40)\nv4 = 81\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 12\nx5 = fibfib(arg50)\nv5 = 274\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 14\nx6 = fibfib(arg60)\nv6 = 927\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "تتبع سلسلة أرقام فيبفيب هي سلسلة مشابهة لسلسلة فيبوناتشي التي تعرف على النحو التالي:\n    فيبفيب(0) == 0\n    فيبفيب(1) == 0\n    فيبفيب(2) == 1\n    فيبفيب(n) == فيبفيب(n-1) + فيبفيب(n-2) + فيبفيب(n-3).\n    يرجى كتابة وظيفة لحساب العنصر الثالث عشر بكفاءة في سلسلة أرقام فيبفيب.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/27", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# اكتب دالة تسمى vowels_count تأخذ سلسلة نصية تمثل كلمة كإدخال وتعيد عدد الحروف الصوتية في السلسلة. الحروف الصوتية في هذه الحالة هي 'a'، 'e'، 'i'، 'o'، 'u'. هنا، 'y' هو أيضًا حرف صوتي، ولكن فقط عندما يكون في نهاية الكلمة المعطاة.\n# \n# مثال:\n# >>> vowels_count(\"abcde\")\n# 2\n# >>> vowels_count(\"ACEDY\")\n# 3\n#\ndef vowels_count(s)", "entry_point": "vowels_count", "test": "\n\narg00 = \"abcde\"\nx0 = vowels_count(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Alone\"\nx1 = vowels_count(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"key\"\nx2 = vowels_count(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"bye\"\nx3 = vowels_count(arg30)\nv3 = 1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"keY\"\nx4 = vowels_count(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"bYe\"\nx5 = vowels_count(arg50)\nv5 = 1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"ACEDY\"\nx6 = vowels_count(arg60)\nv6 = 3\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "اكتب دالة تسمى vowels_count تأخذ سلسلة نصية تمثل كلمة كإدخال وتعيد عدد الحروف الصوتية في السلسلة. الحروف الصوتية في هذه الحالة هي 'a'، 'e'، 'i'، 'o'، 'u'. هنا، 'y' هو أيضًا حرف صوتي، ولكن فقط عندما يكون في نهاية الكلمة المعطاة.\n\nمثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/28", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # يتم تزويدك بقائمة غير فارغة من الأعداد الصحيحة الإيجابية. يجب إرجاع أكبر عدد صحيح يكون أكبر من الصفر وله تكرار أكبر من أو يساوي قيمة العدد الصحيح نفسه. تكرار العدد الصحيح هو عدد مرات ظهوره في القائمة. إذا لم يكن هناك قيمة كهذه ، فأرجع -1. أمثلة:\n# \n#     search([4, 1, 2, 2, 3, 1]) == 2\n#     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n#     search([5, 5, 4, 4, 4]) == -1\n#\ndef search(lst)", "entry_point": "search", "test": "\n\narg00 = [5, 5, 5, 5, 1]\nx0 = search(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [4, 1, 4, 1, 4, 4]\nx1 = search(arg10)\nv1 = 4\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3, 3]\nx2 = search(arg20)\nv2 = -1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [8, 8, 8, 8, 8, 8, 8, 8]\nx3 = search(arg30)\nv3 = 8\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [2, 3, 3, 2, 2]\nx4 = search(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]\nx5 = search(arg50)\nv5 = 1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [3, 2, 8, 2]\nx6 = search(arg60)\nv6 = 2\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]\nx7 = search(arg70)\nv7 = 1\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [8, 8, 3, 6, 5, 6, 4]\nx8 = search(arg80)\nv8 = -1\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]\nx9 = search(arg90)\nv9 = 1\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [1, 9, 10, 1, 3]\nx10 = search(arg100)\nv10 = 1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]\nx11 = search(arg110)\nv11 = 5\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = [1]\nx12 = search(arg120)\nv12 = 1\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]\nx13 = search(arg130)\nv13 = 4\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]\nx14 = search(arg140)\nv14 = 2\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]\nx15 = search(arg150)\nv15 = 1\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\narg160 = [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]\nx16 = search(arg160)\nv16 = 4\nif x16 != v16\n    raise StandardError, \"Error at test case 17\"\nend\n\narg170 = [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]\nx17 = search(arg170)\nv17 = 4\nif x17 != v17\n    raise StandardError, \"Error at test case 18\"\nend\n\narg180 = [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]\nx18 = search(arg180)\nv18 = 2\nif x18 != v18\n    raise StandardError, \"Error at test case 19\"\nend\n\narg190 = [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]\nx19 = search(arg190)\nv19 = -1\nif x19 != v19\n    raise StandardError, \"Error at test case 20\"\nend\n\narg200 = [10]\nx20 = search(arg200)\nv20 = -1\nif x20 != v20\n    raise StandardError, \"Error at test case 21\"\nend\n\narg210 = [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]\nx21 = search(arg210)\nv21 = 2\nif x21 != v21\n    raise StandardError, \"Error at test case 22\"\nend\n\narg220 = [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]\nx22 = search(arg220)\nv22 = 1\nif x22 != v22\n    raise StandardError, \"Error at test case 23\"\nend\n\narg230 = [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]\nx23 = search(arg230)\nv23 = 1\nif x23 != v23\n    raise StandardError, \"Error at test case 24\"\nend\n\narg240 = [3, 10, 10, 9, 2]\nx24 = search(arg240)\nv24 = -1\nif x24 != v24\n    raise StandardError, \"Error at test case 25\"\nend\n\n", "description": "يتم تزويدك بقائمة غير فارغة من الأعداد الصحيحة الإيجابية. يجب إرجاع أكبر عدد صحيح يكون أكبر من الصفر وله تكرار أكبر من أو يساوي قيمة العدد الصحيح نفسه. تكرار العدد الصحيح هو عدد مرات ظهوره في القائمة. إذا لم يكن هناك قيمة كهذه ، فأرجع -1. أمثلة:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/29", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # بالنظر إلى أطوال الأضلاع الثلاثة لمثلث. يرجى إرجاع مساحة المثلث مستديرة إلى 2 نقطة عشرية إذا كانت الأضلاع الثلاثة تشكل مثلثًا صالحًا. وإلا، يرجى إرجاع -1. تشكل الأضلاع الثلاثة مثلثًا صالحًا عندما يكون مجموع أي ضلعين أكبر من الضلع الثالث. مثال:\n# \n# triangle_area(3, 4, 5) == 6.00\n# triangle_area(1, 2, 10) == -1\n#\ndef triangle_area(a, b, c)", "entry_point": "triangle_area", "test": "\n\narg00 = 3\narg01 = 4\narg02 = 5\nx0 = triangle_area(arg00, arg01, arg02)\nv0 = 6.0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 2\narg12 = 10\nx1 = triangle_area(arg10, arg11, arg12)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 4\narg21 = 8\narg22 = 5\nx2 = triangle_area(arg20, arg21, arg22)\nv2 = 8.18\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 2\narg31 = 2\narg32 = 2\nx3 = triangle_area(arg30, arg31, arg32)\nv3 = 1.73\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 1\narg41 = 2\narg42 = 3\nx4 = triangle_area(arg40, arg41, arg42)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 10\narg51 = 5\narg52 = 7\nx5 = triangle_area(arg50, arg51, arg52)\nv5 = 16.25\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 2\narg61 = 6\narg62 = 3\nx6 = triangle_area(arg60, arg61, arg62)\nv6 = -1\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 1\narg71 = 1\narg72 = 1\nx7 = triangle_area(arg70, arg71, arg72)\nv7 = 0.43\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 2\narg81 = 2\narg82 = 10\nx8 = triangle_area(arg80, arg81, arg82)\nv8 = -1\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "بالنظر إلى أطوال الأضلاع الثلاثة لمثلث. يرجى إرجاع مساحة المثلث مستديرة إلى 2 نقطة عشرية إذا كانت الأضلاع الثلاثة تشكل مثلثًا صالحًا. وإلا، يرجى إرجاع -1. تشكل الأضلاع الثلاثة مثلثًا صالحًا عندما يكون مجموع أي ضلعين أكبر من الضلع الثالث. مثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/30", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # اكتب دالة تعيد القيمة صحيحة إذا كان الكائن q سيطير، وخطأ في حالة عدم ذلك.\n# سيطير الكائن q إذا كان متوازنًا (هو قائمة متناظرة) ومجموع عناصره أقل من أو يساوي الحد الأقصى الممكن للوزن w.\n# \n# مثال:\n# will_it_fly([1، 2]، 5) ➞ خطأ\n# # 1 + 2 أقل من الحد الأقصى الممكن للوزن ، لكنه غير متوازن.\n# \n# will_it_fly([3، 2، 3]، 1) ➞ خطأ\n# # إنه متوازن ، لكن 3 + 2 + 3 أكثر من الحد الأقصى الممكن للوزن.\n# \n# will_it_fly([3، 2، 3]، 9) ➞ صحيح\n# # 3 + 2 + 3 أقل من الحد الأقصى الممكن للوزن ، وهو متوازن.\n# \n# will_it_fly([3]، 5) ➞ صحيح\n# # 3 أقل من الحد الأقصى الممكن للوزن ، وهو متوازن.\n# \n#\ndef will_it_fly(q, w)", "entry_point": "will_it_fly", "test": "\n\narg00 = [3, 2, 3]\narg01 = 9\nx0 = will_it_fly(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2]\narg11 = 5\nx1 = will_it_fly(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3]\narg21 = 5\nx2 = will_it_fly(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 2, 3]\narg31 = 1\nx3 = will_it_fly(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 3]\narg41 = 6\nx4 = will_it_fly(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [5]\narg51 = 5\nx5 = will_it_fly(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "اكتب دالة تعيد القيمة صحيحة إذا كان الكائن q سيطير، وخطأ في حالة عدم ذلك.\nسيطير الكائن q إذا كان متوازنًا (هو قائمة متناظرة) ومجموع عناصره أقل من أو يساوي الحد الأقصى الممكن للوزن w.\n\nمثال:\nwill_it_fly([1، 2]، 5) ➞ خطأ\n# 1 + 2 أقل من الحد الأقصى الممكن للوزن ، لكنه غير متوازن.\n\nwill_it_fly([3، 2، 3]، 1) ➞ خطأ\n# إنه متوازن ، لكن 3 + 2 + 3 أكثر من الحد الأقصى الممكن للوزن.\n\nwill_it_fly([3، 2، 3]، 9) ➞ صحيح\n# 3 + 2 + 3 أقل من الحد الأقصى الممكن للوزن ، وهو متوازن.\n\nwill_it_fly([3]، 5) ➞ صحيح\n# 3 أقل من الحد الأقصى الممكن للوزن ، وهو متوازن.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/31", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# اكتب دالة تعيد القيمة الصحيحة إذا كان الرقم المعطى هو ضرب 3 أعداد أولية، وإلا فهي تعيد القيمة الخاطئة. علمًا بأن (أ) أقل من 100. \n# \n# مثال:\n# \n# is_multiply_prime(30) == True\n# 30 = 2 * 3 * 5\n#\ndef is_multiply_prime(a)", "entry_point": "is_multiply_prime", "test": "\n\narg00 = 5\nx0 = is_multiply_prime(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 30\nx1 = is_multiply_prime(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 8\nx2 = is_multiply_prime(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 10\nx3 = is_multiply_prime(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 125\nx4 = is_multiply_prime(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 105\nx5 = is_multiply_prime(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 126\nx6 = is_multiply_prime(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 729\nx7 = is_multiply_prime(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 891\nx8 = is_multiply_prime(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1001\nx9 = is_multiply_prime(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "اكتب دالة تعيد القيمة الصحيحة إذا كان الرقم المعطى هو ضرب 3 أعداد أولية، وإلا فهي تعيد القيمة الخاطئة. علمًا بأن (أ) أقل من 100. \n\nمثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/32", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# سيتم إعطاؤك رقمًا بالشكل العشري ومهمتك هي تحويله إلى الشكل الثنائي. يجب أن تعيد الدالة سلسلة نصية، حيث يمثل كل حرف رقمًا ثنائيًا. سيكون كل حرف في السلسلة هو '0' أو '1'.\n# \n# سيكون هناك حرفان إضافيان 'db' في بداية ونهاية السلسلة. الحروف الإضافية موجودة للمساعدة في التنسيق.\n# \n# أمثلة:\n# \n# decimal_to_binary(15)   # returns \"db1111db\"\n# decimal_to_binary(32)   # returns \"db100000db\"\n#\ndef decimal_to_binary(decimal)", "entry_point": "decimal_to_binary", "test": "\n\narg00 = 0\nx0 = decimal_to_binary(arg00)\nv0 = \"db0db\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 32\nx1 = decimal_to_binary(arg10)\nv1 = \"db100000db\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 103\nx2 = decimal_to_binary(arg20)\nv2 = \"db1100111db\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 15\nx3 = decimal_to_binary(arg30)\nv3 = \"db1111db\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "سيتم إعطاؤك رقمًا بالشكل العشري ومهمتك هي تحويله إلى الشكل الثنائي. يجب أن تعيد الدالة سلسلة نصية، حيث يمثل كل حرف رقمًا ثنائيًا. سيكون كل حرف في السلسلة هو '0' أو '1'.\n\nسيكون هناك حرفان إضافيان 'db' في بداية ونهاية السلسلة. الحروف الإضافية موجودة للمساعدة في التنسيق.\n\nأمثلة:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/33", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# يتم إعطاؤك سلسلة s.\n# مهمتك هي التحقق مما إذا كانت السلسلة سعيدة أم لا.\n# تعتبر السلسلة سعيدة إذا كان طولها على الأقل 3 وكانت كل 3 أحرف متتالية مختلفة.\n# على سبيل المثال:\n# \n# is_happy(a) => False\n# is_happy(aa) => False\n# is_happy(abcd) => True\n# is_happy(aabb) => False\n# is_happy(adb) => True\n# is_happy(xyy) => False\n#\ndef is_happy(s)", "entry_point": "is_happy", "test": "\n\narg00 = \"a\"\nx0 = is_happy(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"aa\"\nx1 = is_happy(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"abcd\"\nx2 = is_happy(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"aabb\"\nx3 = is_happy(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"adb\"\nx4 = is_happy(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"xyy\"\nx5 = is_happy(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"iopaxpoi\"\nx6 = is_happy(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"iopaxioi\"\nx7 = is_happy(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "يتم إعطاؤك سلسلة s.\nمهمتك هي التحقق مما إذا كانت السلسلة سعيدة أم لا.\nتعتبر السلسلة سعيدة إذا كان طولها على الأقل 3 وكانت كل 3 أحرف متتالية مختلفة.\nعلى سبيل المثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/34", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# هذا هو الأسبوع الأخير من الفصل الدراسي ويجب على المعلم إعطاء الدرجات للطلاب. كان المعلم يقوم بإنشاء خوارزمية خاصة به لتقييم الدرجات. المشكلة الوحيدة هي أنها فقدت الكود الذي استخدمته للتقييم. لقد قدمت لك قائمة بمعدلات النجاح لبعض الطلاب ويجب عليك كتابة وظيفة يمكنها إخراج قائمة بالدرجات الحرفية باستخدام الجدول التالي:\n#              GPA       |    Letter grade\n#               4.0                A+\n#             > 3.7                A \n#             > 3.3                A- \n#             > 3.0                B+\n#             > 2.7                B \n#             > 2.3                B-\n#             > 2.0                C+\n#             > 1.7                C\n#             > 1.3                C-\n#             > 1.0                D+ \n#             > 0.7                D \n#             > 0.0                D-\n#               0.0                E\n#     \n# \n#     مثال:\n# \n# grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n#\ndef numerical_letter_grade(grades)", "entry_point": "numerical_letter_grade", "test": "\n\narg00 = [4.0, 3, 1.7, 2, 3.5]\nx0 = numerical_letter_grade(arg00)\nv0 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1.2]\nx1 = numerical_letter_grade(arg10)\nv1 = [\"D+\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [0.5]\nx2 = numerical_letter_grade(arg20)\nv2 = [\"D-\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [0.0]\nx3 = numerical_letter_grade(arg30)\nv3 = [\"E\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 0.3, 1.5, 2.8, 3.3]\nx4 = numerical_letter_grade(arg40)\nv4 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 0.7]\nx5 = numerical_letter_grade(arg50)\nv5 = [\"E\", \"D-\"]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "هذا هو الأسبوع الأخير من الفصل الدراسي ويجب على المعلم إعطاء الدرجات للطلاب. كان المعلم يقوم بإنشاء خوارزمية خاصة به لتقييم الدرجات. المشكلة الوحيدة هي أنها فقدت الكود الذي استخدمته للتقييم. لقد قدمت لك قائمة بمعدلات النجاح لبعض الطلاب ويجب عليك كتابة وظيفة يمكنها إخراج قائمة بالدرجات الحرفية باستخدام الجدول التالي:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    مثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/35", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# اكتب دالة تأخذ سلسلة نصية وتعيد True إذا كان طول السلسلة عددًا أوليًا أو False في حالة عكس ذلك\n#     أمثلة\n# \n# prime_length('Hello') == True\n# prime_length('abcdcba') == True\n# prime_length('kittens') == True\n# prime_length('orange') == False\n#\ndef prime_length(string)", "entry_point": "prime_length", "test": "\n\narg00 = \"Hello\"\nx0 = prime_length(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdcba\"\nx1 = prime_length(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"kittens\"\nx2 = prime_length(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"orange\"\nx3 = prime_length(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"wow\"\nx4 = prime_length(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"world\"\nx5 = prime_length(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"MadaM\"\nx6 = prime_length(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"Wow\"\nx7 = prime_length(arg70)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"\"\nx8 = prime_length(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"HI\"\nx9 = prime_length(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"go\"\nx10 = prime_length(arg100)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"gogo\"\nx11 = prime_length(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"aaaaaaaaaaaaaaa\"\nx12 = prime_length(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = \"Madam\"\nx13 = prime_length(arg130)\nv13 = true\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = \"M\"\nx14 = prime_length(arg140)\nv14 = false\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = \"0\"\nx15 = prime_length(arg150)\nv15 = false\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\n", "description": "اكتب دالة تأخذ سلسلة نصية وتعيد True إذا كان طول السلسلة عددًا أوليًا أو False في حالة عكس ذلك\n    أمثلة", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/36", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# بالنظر إلى عدد صحيح موجب N، يتم إرجاع إجمالي مجموع أرقامه في النظام الثنائي.\n# \n# مثال:\n#     بالنسبة لـ N = 1000، سيكون مجموع الأرقام 1 ويجب أن يكون الإخراج \"1\".\n#     بالنسبة لـ N = 150، سيكون مجموع الأرقام 6 ويجب أن يكون الإخراج \"110\".\n#     بالنسبة لـ N = 147، سيكون مجموع الأرقام 12 ويجب أن يكون الإخراج \"1100\".\n# \n# المتغيرات:\n#     @N عدد صحيح\n#          القيود: 0 ≤ N ≤ 10000.\n# الإخراج:\n#      سلسلة من الأرقام الثنائية.\n# \n#\ndef solve(n)", "entry_point": "solve", "test": "\n\narg00 = 1000\nx0 = solve(arg00)\nv0 = \"1\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 150\nx1 = solve(arg10)\nv1 = \"110\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 147\nx2 = solve(arg20)\nv2 = \"1100\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 333\nx3 = solve(arg30)\nv3 = \"1001\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 963\nx4 = solve(arg40)\nv4 = \"10010\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "بالنظر إلى عدد صحيح موجب N، يتم إرجاع إجمالي مجموع أرقامه في النظام الثنائي.\n\nمثال:\n    بالنسبة لـ N = 1000، سيكون مجموع الأرقام 1 ويجب أن يكون الإخراج \"1\".\n    بالنسبة لـ N = 150، سيكون مجموع الأرقام 6 ويجب أن يكون الإخراج \"110\".\n    بالنسبة لـ N = 147، سيكون مجموع الأرقام 12 ويجب أن يكون الإخراج \"1100\".\n\nالمتغيرات:\n    @N عدد صحيح\n         القيود: 0 ≤ N ≤ 10000.\nالإخراج:\n     سلسلة من الأرقام الثنائية.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/37", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # يتم تزويدك ببيانات ثنائية الأبعاد، على شكل قوائم متداخلة،\n#     والتي تشبه المصفوفة، ولكن على عكس المصفوفات،\n#     قد تحتوي كل صف على عدد مختلف من الأعمدة.\n#     بالنظر إلى lst و x عدد صحيح، ابحث عن الأعداد الصحيحة x في القائمة،\n#     وأرجع قائمة من الأزواج، [(x1، y1)، (x2، y2) ...] بحيث\n#     يكون كل زوج إحداثيات - (صف، أعمدة)، بدءًا من 0.\n#     فرز الإحداثيات في البداية حسب الصفوف بترتيب تصاعدي.\n#     أيضًا، فرز إحداثيات الصف حسب الأعمدة بترتيب تنازلي.\n#     \n#     أمثلة:\n# \n# get_row([\n#   [1,2,3,4,5,6],\n#   [1,2,3,4,1,6],\n#   [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([], 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n#\ndef get_row(lst, x)", "entry_point": "get_row", "test": "\n\narg00 = []\narg01 = 1\nx0 = get_row(arg00, arg01)\nv0 = []\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [[1]]\narg11 = 2\nx1 = get_row(arg10, arg11)\nv1 = []\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [[], [1], [1, 2, 3]]\narg21 = 3\nx2 = get_row(arg20, arg21)\nv2 = [[2, 2]]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "يتم تزويدك ببيانات ثنائية الأبعاد، على شكل قوائم متداخلة،\n    والتي تشبه المصفوفة، ولكن على عكس المصفوفات،\n    قد تحتوي كل صف على عدد مختلف من الأعمدة.\n    بالنظر إلى lst و x عدد صحيح، ابحث عن الأعداد الصحيحة x في القائمة،\n    وأرجع قائمة من الأزواج، [(x1، y1)، (x2، y2) ...] بحيث\n    يكون كل زوج إحداثيات - (صف، أعمدة)، بدءًا من 0.\n    فرز الإحداثيات في البداية حسب الصفوف بترتيب تصاعدي.\n    أيضًا، فرز إحداثيات الصف حسب الأعمدة بترتيب تنازلي.\n    \n    أمثلة:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/38", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # تمنحك قائمة من الأعداد الصحيحة.\n# اكتب دالة next_smallest() التي تعيد العنصر الثاني الأصغر في القائمة.\n# إرجاع قيمة فارغة إذا لم يكن هناك عنصر من هذا النوع.\n# next_smallest([1, 2, 3, 4, 5]) == 2\n# next_smallest([5, 1, 4, 3, 2]) == 2\n# next_smallest([]) == None\n# next_smallest([1, 1]) == None\n#\ndef next_smallest(lst)", "entry_point": "next_smallest", "test": "\n\narg00 = [1, 2, 3, 4, 5]\nx0 = next_smallest(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 1, 4, 3, 2]\nx1 = next_smallest(arg10)\nv1 = 2\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = []\nx2 = next_smallest(arg20)\nv2 = nil\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 1]\nx3 = next_smallest(arg30)\nv3 = nil\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 1, 1, 1, 0]\nx4 = next_smallest(arg40)\nv4 = 1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 1]\nx5 = next_smallest(arg50)\nv5 = nil\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-35, 34, 12, -45]\nx6 = next_smallest(arg60)\nv6 = -35\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "تمنحك قائمة من الأعداد الصحيحة.\nاكتب دالة next_smallest() التي تعيد العنصر الثاني الأصغر في القائمة.\nإرجاع قيمة فارغة إذا لم يكن هناك عنصر من هذا النوع.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/39", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # سيتم تزويدك بسلسلة من الكلمات، ومهمتك هي عدد الملل. الملل هو جملة تبدأ بكلمة \"أنا\". تتم فصل الجمل بواسطة '.' أو '?' أو '!'.\n# \n# على سبيل المثال:\n# >>> is_bored(\"Hello world\")\n# 0\n# >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\n#\ndef is_bored(s)", "entry_point": "is_bored", "test": "\n\narg00 = \"Hello world\"\nx0 = is_bored(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Is the sky blue?\"\nx1 = is_bored(arg10)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"I love It !\"\nx2 = is_bored(arg20)\nv2 = 1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"bIt\"\nx3 = is_bored(arg30)\nv3 = 0\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"I feel good today. I will be productive. will kill It\"\nx4 = is_bored(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"You and I are going for a walk\"\nx5 = is_bored(arg50)\nv5 = 0\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "سيتم تزويدك بسلسلة من الكلمات، ومهمتك هي عدد الملل. الملل هو جملة تبدأ بكلمة \"أنا\". تتم فصل الجمل بواسطة '.' أو '?' أو '!'.\n\nعلى سبيل المثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/40", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# تمنحك قائمة من الأعداد الصحيحة.\n#     تحتاج إلى العثور على أكبر قيمة أولية وإرجاع مجموع أرقامها.\n# \n#     أمثلة:\n# \n# For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n# For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n# For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n# For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n# For lst = [0,81,12,3,1,21] the output should be 3\n# For lst = [0,8,1,2,1,7] the output should be 7\n#\ndef skjkasdkd(lst)", "entry_point": "skjkasdkd", "test": "\n\narg00 = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]\nx0 = skjkasdkd(arg00)\nv0 = 10\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]\nx1 = skjkasdkd(arg10)\nv1 = 25\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]\nx2 = skjkasdkd(arg20)\nv2 = 13\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]\nx3 = skjkasdkd(arg30)\nv3 = 11\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [0, 81, 12, 3, 1, 21]\nx4 = skjkasdkd(arg40)\nv4 = 3\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 8, 1, 2, 1, 7]\nx5 = skjkasdkd(arg50)\nv5 = 7\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [8191]\nx6 = skjkasdkd(arg60)\nv6 = 19\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [8191, 123456, 127, 7]\nx7 = skjkasdkd(arg70)\nv7 = 19\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [127, 97, 8192]\nx8 = skjkasdkd(arg80)\nv8 = 10\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "تمنحك قائمة من الأعداد الصحيحة.\n    تحتاج إلى العثور على أكبر قيمة أولية وإرجاع مجموع أرقامها.\n\n    أمثلة:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/41", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # بالنظر إلى قاموس، إرجاع قيمة True إذا كانت جميع المفاتيح هي سلاسل نصية في الحالة الصغيرة أو جميع المفاتيح هي سلاسل نصية في الحالة الكبيرة، وإلا فإنه يجب إرجاع False. يجب أن يعيد الدالة False إذا كان القاموس المعطى فارغًا. أمثلة:\n# \n# check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n# check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n# check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n# check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n# check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n#\ndef check_dict_case(dict)", "entry_point": "check_dict_case", "test": "\n\narg00 = {\"p\"=>\"pineapple\", \"b\"=>\"banana\"}\nx0 = check_dict_case(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = {\"p\"=>\"pineapple\", \"A\"=>\"banana\", \"B\"=>\"banana\"}\nx1 = check_dict_case(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = {\"p\"=>\"pineapple\", 5=>\"banana\", \"a\"=>\"apple\"}\nx2 = check_dict_case(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = {\"Name\"=>\"John\", \"Age\"=>\"36\", \"City\"=>\"Houston\"}\nx3 = check_dict_case(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = {\"STATE\"=>\"NC\", \"ZIP\"=>\"12345\"}\nx4 = check_dict_case(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = {\"fruit\"=>\"Orange\", \"taste\"=>\"Sweet\"}\nx5 = check_dict_case(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = {}\nx6 = check_dict_case(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "بالنظر إلى قاموس، إرجاع قيمة True إذا كانت جميع المفاتيح هي سلاسل نصية في الحالة الصغيرة أو جميع المفاتيح هي سلاسل نصية في الحالة الكبيرة، وإلا فإنه يجب إرجاع False. يجب أن يعيد الدالة False إذا كان القاموس المعطى فارغًا. أمثلة:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/42", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # أنشئ دالة تأخذ قيمة (سلسلة نصية) تمثل رقمًا وتعيد أقرب عدد صحيح إليه. إذا كان الرقم على بعد مسافة متساوية من عددين صحيحين ، فقم بتقريبه بعيدًا عن الصفر.\n# \n#     أمثلة\n# >>> closest_integer(\"10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\n#\ndef closest_integer(value)", "entry_point": "closest_integer", "test": "\n\narg00 = \"10\"\nx0 = closest_integer(arg00)\nv0 = 10\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"14.5\"\nx1 = closest_integer(arg10)\nv1 = 15\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"-15.5\"\nx2 = closest_integer(arg20)\nv2 = -16\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"15.3\"\nx3 = closest_integer(arg30)\nv3 = 15\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"0\"\nx4 = closest_integer(arg40)\nv4 = 0\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "أنشئ دالة تأخذ قيمة (سلسلة نصية) تمثل رقمًا وتعيد أقرب عدد صحيح إليه. إذا كان الرقم على بعد مسافة متساوية من عددين صحيحين ، فقم بتقريبه بعيدًا عن الصفر.\n\n    أمثلة", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/43", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # بالنظر إلى عدد صحيح موجب n، يجب عليك إنشاء كومة من n مستويات من الحجارة.\n# المستوى الأول يحتوي على n حجرًا.\n# عدد الحجارة في المستوى التالي هو:\n# - العدد الفردي التالي إذا كان n فرديًا.\n# - العدد الزوجي التالي إذا كان n زوجيًا.\n# يرجع عدد الحجارة في كل مستوى في قائمة، حيث يمثل العنصر في المؤشر i عدد الحجارة في المستوى (i + 1).\n# \n# أمثلة:\n# >>> make_a_pile(3)\n# [3, 5, 7]\n#\ndef make_a_pile(n)", "entry_point": "make_a_pile", "test": "\n\narg00 = 3\nx0 = make_a_pile(arg00)\nv0 = [3, 5, 7]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 4\nx1 = make_a_pile(arg10)\nv1 = [4, 6, 8, 10]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = make_a_pile(arg20)\nv2 = [5, 7, 9, 11, 13]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 6\nx3 = make_a_pile(arg30)\nv3 = [6, 8, 10, 12, 14, 16]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 8\nx4 = make_a_pile(arg40)\nv4 = [8, 10, 12, 14, 16, 18, 20, 22]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "بالنظر إلى عدد صحيح موجب n، يجب عليك إنشاء كومة من n مستويات من الحجارة.\nالمستوى الأول يحتوي على n حجرًا.\nعدد الحجارة في المستوى التالي هو:\n- العدد الفردي التالي إذا كان n فرديًا.\n- العدد الزوجي التالي إذا كان n زوجيًا.\nيرجع عدد الحجارة في كل مستوى في قائمة، حيث يمثل العنصر في المؤشر i عدد الحجارة في المستوى (i + 1).\n\nأمثلة:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/44", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # سيتم إعطاؤك سلسلة من الكلمات مفصولة بفواصل أو مسافات. مهمتك هي تقسيم السلسلة إلى كلمات وإرجاع مصفوفة من الكلمات.\n# \n# على سبيل المثال:\n# \n# words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n#\ndef words_string(s)", "entry_point": "words_string", "test": "\n\narg00 = \"Hi, my name is John\"\nx0 = words_string(arg00)\nv0 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"One, two, three, four, five, six\"\nx1 = words_string(arg10)\nv1 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"Hi, my name\"\nx2 = words_string(arg20)\nv2 = [\"Hi\", \"my\", \"name\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"One,, two, three, four, five, six,\"\nx3 = words_string(arg30)\nv3 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"\"\nx4 = words_string(arg40)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"ahmed     , gamal\"\nx5 = words_string(arg50)\nv5 = [\"ahmed\", \"gamal\"]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "سيتم إعطاؤك سلسلة من الكلمات مفصولة بفواصل أو مسافات. مهمتك هي تقسيم السلسلة إلى كلمات وإرجاع مصفوفة من الكلمات.\n\nعلى سبيل المثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/45", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# هذه الدالة تأخذ رقمين موجبين x و y وتعيد أكبر عدد صحيح زوجي يقع في النطاق [x، y] بما في ذلك. إذا لم يكن هناك عدد كهذا ، يجب أن تعيد الدالة -1.\n# \n# على سبيل المثال:\n# \n# choose_num(12, 15) = 14\n# choose_num(13, 12) = -1\n#\ndef choose_num(x, y)", "entry_point": "choose_num", "test": "\n\narg00 = 12\narg01 = 15\nx0 = choose_num(arg00, arg01)\nv0 = 14\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 13\narg11 = 12\nx1 = choose_num(arg10, arg11)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 33\narg21 = 12354\nx2 = choose_num(arg20, arg21)\nv2 = 12354\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5234\narg31 = 5233\nx3 = choose_num(arg30, arg31)\nv3 = -1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 6\narg41 = 29\nx4 = choose_num(arg40, arg41)\nv4 = 28\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 27\narg51 = 10\nx5 = choose_num(arg50, arg51)\nv5 = -1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 7\narg61 = 7\nx6 = choose_num(arg60, arg61)\nv6 = -1\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 546\narg71 = 546\nx7 = choose_num(arg70, arg71)\nv7 = 546\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "هذه الدالة تأخذ رقمين موجبين x و y وتعيد أكبر عدد صحيح زوجي يقع في النطاق [x، y] بما في ذلك. إذا لم يكن هناك عدد كهذا ، يجب أن تعيد الدالة -1.\n\nعلى سبيل المثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/46", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# يتم إعطاؤك عددين صحيحين موجبين n و m ، ومهمتك هي حساب المتوسط ​​للأعداد الصحيحة من n إلى m (بما في ذلك n و m). قم بتقريب الإجابة إلى أقرب عدد صحيح وتحويلها إلى النظام الثنائي. إذا كان n أكبر من m ، فأرجع -1. مثال:\n# \n# rounded_avg(1, 5) => \"0b11\"\n# rounded_avg(7, 5) => -1\n# rounded_avg(10, 20) => \"0b1111\"\n# rounded_avg(20, 33) => \"0b11010\"\n#\ndef rounded_avg(n, m)", "entry_point": "rounded_avg", "test": "\n\narg00 = 1\narg01 = 5\nx0 = rounded_avg(arg00, arg01)\nv0 = \"0b11\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 7\narg11 = 13\nx1 = rounded_avg(arg10, arg11)\nv1 = \"0b1010\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 964\narg21 = 977\nx2 = rounded_avg(arg20, arg21)\nv2 = \"0b1111001010\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 996\narg31 = 997\nx3 = rounded_avg(arg30, arg31)\nv3 = \"0b1111100100\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 560\narg41 = 851\nx4 = rounded_avg(arg40, arg41)\nv4 = \"0b1011000010\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 185\narg51 = 546\nx5 = rounded_avg(arg50, arg51)\nv5 = \"0b101101110\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 362\narg61 = 496\nx6 = rounded_avg(arg60, arg61)\nv6 = \"0b110101101\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 350\narg71 = 902\nx7 = rounded_avg(arg70, arg71)\nv7 = \"0b1001110010\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 197\narg81 = 233\nx8 = rounded_avg(arg80, arg81)\nv8 = \"0b11010111\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 7\narg91 = 5\nx9 = rounded_avg(arg90, arg91)\nv9 = -1\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 5\narg101 = 1\nx10 = rounded_avg(arg100, arg101)\nv10 = -1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 5\narg111 = 5\nx11 = rounded_avg(arg110, arg111)\nv11 = \"0b101\"\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\n", "description": "يتم إعطاؤك عددين صحيحين موجبين n و m ، ومهمتك هي حساب المتوسط ​​للأعداد الصحيحة من n إلى m (بما في ذلك n و m). قم بتقريب الإجابة إلى أقرب عدد صحيح وتحويلها إلى النظام الثنائي. إذا كان n أكبر من m ، فأرجع -1. مثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/47", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# قم بتنفيذ الدالة f التي تأخذ n كمعلمة،\n# وترجع قائمة بحجم n، بحيث يكون قيمة العنصر في المؤشر i هو عاملي الرقم i إذا كان i فرديًا،\n# أو مجموع الأرقام من 1 إلى i في حالة أخرى.\n# i يبدأ من 1.\n# عاملي الرقم i هو الضرب من الأرقام من 1 إلى i (1 * 2 * ... * i).\n# مثال:\n# \n# f(5) == [1, 2, 6, 24, 15]\n#\ndef f(n)", "entry_point": "f", "test": "\n\narg00 = 5\nx0 = f(arg00)\nv0 = [1, 2, 6, 24, 15]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 7\nx1 = f(arg10)\nv1 = [1, 2, 6, 24, 15, 720, 28]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 1\nx2 = f(arg20)\nv2 = [1]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 3\nx3 = f(arg30)\nv3 = [1, 2, 6]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "قم بتنفيذ الدالة f التي تأخذ n كمعلمة،\nوترجع قائمة بحجم n، بحيث يكون قيمة العنصر في المؤشر i هو عاملي الرقم i إذا كان i فرديًا،\nأو مجموع الأرقام من 1 إلى i في حالة أخرى.\ni يبدأ من 1.\nعاملي الرقم i هو الضرب من الأرقام من 1 إلى i (1 * 2 * ... * i).\nمثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/48", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # بالنظر إلى عدد صحيح موجب n ، يرجع tuple الذي يحتوي على عدد palindrome الصحيحة الزوجية والفردية التي تقع ضمن النطاق (1، n) ، شاملاً.\n# \n# مثال 1:\n# \n#     الإدخال: 3\n#     النتيجة: (1، 2)\n#     الشرح:\n#     عدد palindrome الصحيحة هي 1 و 2 و 3. واحد منهم زوجي ، واثنان منهم فرديان.\n# \n# مثال 2:\n# \n#     الإدخال: 12\n#     النتيجة: (4، 6)\n#     الشرح:\n#     عدد palindrome الصحيحة هي 1 و 2 و 3 و 4 و 5 و 6 و 7 و 8 و 9 و 11. أربعة منهم زوجيون ، و 6 منهم فرديون.\n# \n# ملاحظة:\n#     1. 1 <= n <= 10^3\n#     2. tuple المرجع يحتوي على عدد palindrome الصحيحة الزوجية والفردية على التوالي.\n# \n#\ndef even_odd_palindrome(n)", "entry_point": "even_odd_palindrome", "test": "\n\narg00 = 123\nx0 = even_odd_palindrome(arg00)\nv0 = [8, 13]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 12\nx1 = even_odd_palindrome(arg10)\nv1 = [4, 6]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\nx2 = even_odd_palindrome(arg20)\nv2 = [1, 2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 63\nx3 = even_odd_palindrome(arg30)\nv3 = [6, 8]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 25\nx4 = even_odd_palindrome(arg40)\nv4 = [5, 6]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 19\nx5 = even_odd_palindrome(arg50)\nv5 = [4, 6]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 9\nx6 = even_odd_palindrome(arg60)\nv6 = [4, 5]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 1\nx7 = even_odd_palindrome(arg70)\nv7 = [0, 1]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "بالنظر إلى عدد صحيح موجب n ، يرجع tuple الذي يحتوي على عدد palindrome الصحيحة الزوجية والفردية التي تقع ضمن النطاق (1، n) ، شاملاً.\n\nمثال 1:\n\n    الإدخال: 3\n    النتيجة: (1، 2)\n    الشرح:\n    عدد palindrome الصحيحة هي 1 و 2 و 3. واحد منهم زوجي ، واثنان منهم فرديان.\n\nمثال 2:\n\n    الإدخال: 12\n    النتيجة: (4، 6)\n    الشرح:\n    عدد palindrome الصحيحة هي 1 و 2 و 3 و 4 و 5 و 6 و 7 و 8 و 9 و 11. أربعة منهم زوجيون ، و 6 منهم فرديون.\n\nملاحظة:\n    1. 1 <= n <= 10^3\n    2. tuple المرجع يحتوي على عدد palindrome الصحيحة الزوجية والفردية على التوالي.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/49", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# لدينا مصفوفة 'arr' من N أعداد صحيحة arr [1]، arr [2]، ...، arr [N]. سيتم ترتيب الأرقام في المصفوفة بشكل عشوائي. مهمتك هي تحديد ما إذا كان من الممكن الحصول على مصفوفة مرتبة بترتيب غير تنازلي عن طريق تنفيذ العملية التالية على المصفوفة المعطاة:\n#     يسمح لك بتنفيذ عملية التحويل اليميني أي عدد من المرات.\n# \n#     تعني عملية التحويل اليميني الواحد تحويل جميع عناصر المصفوفة بمقدار واحد في الاتجاه الصحيح. سيتم نقل العنصر الأخير في المصفوفة إلى الموضع البدء في المصفوفة أي الفهرس 0.\n# \n#     إذا كان من الممكن الحصول على المصفوفة المرتبة بتنفيذ العملية أعلاه ، فأرجع True وإلا فأرجع False. إذا كانت المصفوفة المعطاة فارغة ، فأرجع True.\n# \n#     ملاحظة: يتم ضمان وجود عناصر فريدة في القائمة المعطاة.\n# \n#     على سبيل المثال:\n# \n#     move_one_ball ([3، 4، 5، 1، 2]) ==> True\n#     تفسير: يمكن تحقيق الترتيب غير التنازلي للمصفوفة المعطاة بتنفيذ 2 عمليات تحويل يمينية.\n#     move_one_ball ([3، 5، 4، 1، 2]) ==> False\n#     تفسير: لا يمكن الحصول على ترتيب غير تنازلي للمصفوفة المعطاة بتنفيذ أي عدد من عمليات التحويل اليميني.\n# \n#             \n#\ndef move_one_ball(arr)", "entry_point": "move_one_ball", "test": "\n\narg00 = [3, 4, 5, 1, 2]\nx0 = move_one_ball(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [3, 5, 10, 1, 2]\nx1 = move_one_ball(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [4, 3, 1, 2]\nx2 = move_one_ball(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 5, 4, 1, 2]\nx3 = move_one_ball(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = []\nx4 = move_one_ball(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "لدينا مصفوفة 'arr' من N أعداد صحيحة arr [1]، arr [2]، ...، arr [N]. سيتم ترتيب الأرقام في المصفوفة بشكل عشوائي. مهمتك هي تحديد ما إذا كان من الممكن الحصول على مصفوفة مرتبة بترتيب غير تنازلي عن طريق تنفيذ العملية التالية على المصفوفة المعطاة:\n    يسمح لك بتنفيذ عملية التحويل اليميني أي عدد من المرات.\n\n    تعني عملية التحويل اليميني الواحد تحويل جميع عناصر المصفوفة بمقدار واحد في الاتجاه الصحيح. سيتم نقل العنصر الأخير في المصفوفة إلى الموضع البدء في المصفوفة أي الفهرس 0.\n\n    إذا كان من الممكن الحصول على المصفوفة المرتبة بتنفيذ العملية أعلاه ، فأرجع True وإلا فأرجع False. إذا كانت المصفوفة المعطاة فارغة ، فأرجع True.\n\n    ملاحظة: يتم ضمان وجود عناصر فريدة في القائمة المعطاة.\n\n    على سبيل المثال:\n\n    move_one_ball ([3، 4، 5، 1، 2]) ==> True\n    تفسير: يمكن تحقيق الترتيب غير التنازلي للمصفوفة المعطاة بتنفيذ 2 عمليات تحويل يمينية.\n    move_one_ball ([3، 5، 4، 1، 2]) ==> False\n    تفسير: لا يمكن الحصول على ترتيب غير تنازلي للمصفوفة المعطاة بتنفيذ أي عدد من عمليات التحويل اليميني.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/50", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# في هذه المشكلة، ستقوم بتنفيذ وظيفة تأخذ قائمتين من الأرقام، وتحدد ما إذا كان من الممكن القيام بتبادل العناصر بينهما لجعل lst1 قائمة من الأرقام الزوجية فقط. لا يوجد حد لعدد العناصر المتبادلة بين lst1 و lst2. إذا كان من الممكن تبادل العناصر بين lst1 و lst2 لجعل جميع عناصر lst1 زوجية، فأرجع \"نعم\". وإلا، أرجع \"لا\". على سبيل المثال: exchange([1، 2، 3، 4]، [1، 2، 3، 4]) => \"نعم\" exchange([1، 2، 3، 4]، [1، 5، 3، 4]) => \"لا\" يفترض أن تكون القوائم المدخلة غير فارغة.\n# \n#\ndef exchange(lst1, lst2)", "entry_point": "exchange", "test": "\n\narg00 = [1, 2, 3, 4]\narg01 = [1, 2, 3, 4]\nx0 = exchange(arg00, arg01)\nv0 = \"YES\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 3, 4]\narg11 = [1, 5, 3, 4]\nx1 = exchange(arg10, arg11)\nv1 = \"NO\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, 3, 4]\narg21 = [2, 1, 4, 3]\nx2 = exchange(arg20, arg21)\nv2 = \"YES\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [5, 7, 3]\narg31 = [2, 6, 4]\nx3 = exchange(arg30, arg31)\nv3 = \"YES\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [5, 7, 3]\narg41 = [2, 6, 3]\nx4 = exchange(arg40, arg41)\nv4 = \"NO\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [3, 2, 6, 1, 8, 9]\narg51 = [3, 5, 5, 1, 1, 1]\nx5 = exchange(arg50, arg51)\nv5 = \"NO\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [100, 200]\narg61 = [200, 200]\nx6 = exchange(arg60, arg61)\nv6 = \"YES\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "في هذه المشكلة، ستقوم بتنفيذ وظيفة تأخذ قائمتين من الأرقام، وتحدد ما إذا كان من الممكن القيام بتبادل العناصر بينهما لجعل lst1 قائمة من الأرقام الزوجية فقط. لا يوجد حد لعدد العناصر المتبادلة بين lst1 و lst2. إذا كان من الممكن تبادل العناصر بين lst1 و lst2 لجعل جميع عناصر lst1 زوجية، فأرجع \"نعم\". وإلا، أرجع \"لا\". على سبيل المثال: exchange([1، 2، 3، 4]، [1، 2، 3، 4]) => \"نعم\" exchange([1، 2، 3، 4]، [1، 5، 3، 4]) => \"لا\" يفترض أن تكون القوائم المدخلة غير فارغة.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/51", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# المهمة\n# نحن نحصل على سلسلتين s و c ، يجب عليك حذف جميع الأحرف في s التي تساوي أي حرف في c\n# ثم التحقق مما إذا كانت سلسلة النتيجة هي palindrome.\n# يسمى سلسلة palindrome إذا قرأت بالمعكوس نفسها.\n# يجب عليك إرجاع tuple يحتوي على سلسلة النتيجة و True / False للتحقق.\n# مثال\n# بالنسبة لـ s = \"abcde\" ، c = \"ae\" ، يجب أن يكون النتيجة ('bcd'،False)\n# بالنسبة لـ s = \"abcdef\" ، c = \"b\" يجب أن يكون النتيجة ('acdef'،False)\n# بالنسبة لـ s = \"abcdedcba\" ، c = \"ab\" يجب أن يكون النتيجة ('cdedc'،True)\n# \n#\ndef reverse_delete(s, c)", "entry_point": "reverse_delete", "test": "\n\narg00 = \"abcde\"\narg01 = \"ae\"\nx0 = reverse_delete(arg00, arg01)\nv0 = [\"bcd\", false]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdef\"\narg11 = \"b\"\nx1 = reverse_delete(arg10, arg11)\nv1 = [\"acdef\", false]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"abcdedcba\"\narg21 = \"ab\"\nx2 = reverse_delete(arg20, arg21)\nv2 = [\"cdedc\", true]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"dwik\"\narg31 = \"w\"\nx3 = reverse_delete(arg30, arg31)\nv3 = [\"dik\", false]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"a\"\narg41 = \"a\"\nx4 = reverse_delete(arg40, arg41)\nv4 = [\"\", true]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"abcdedcba\"\narg51 = \"\"\nx5 = reverse_delete(arg50, arg51)\nv5 = [\"abcdedcba\", true]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"abcdedcba\"\narg61 = \"v\"\nx6 = reverse_delete(arg60, arg61)\nv6 = [\"abcdedcba\", true]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"vabba\"\narg71 = \"v\"\nx7 = reverse_delete(arg70, arg71)\nv7 = [\"abba\", true]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"mamma\"\narg81 = \"mia\"\nx8 = reverse_delete(arg80, arg81)\nv8 = [\"\", true]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "المهمة\nنحن نحصل على سلسلتين s و c ، يجب عليك حذف جميع الأحرف في s التي تساوي أي حرف في c\nثم التحقق مما إذا كانت سلسلة النتيجة هي palindrome.\nيسمى سلسلة palindrome إذا قرأت بالمعكوس نفسها.\nيجب عليك إرجاع tuple يحتوي على سلسلة النتيجة و True / False للتحقق.\nمثال\nبالنسبة لـ s = \"abcde\" ، c = \"ae\" ، يجب أن يكون النتيجة ('bcd'،False)\nبالنسبة لـ s = \"abcdef\" ، c = \"b\" يجب أن يكون النتيجة ('acdef'،False)\nبالنسبة لـ s = \"abcdedcba\" ، c = \"ab\" يجب أن يكون النتيجة ('cdedc'،True)", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/52", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # يتم تزويدك بشبكة مستطيلة من الآبار. تمثل كل صف بئرًا ويمثل الرقم 1 في الصف وحدة واحدة من الماء. لكل بئر دلو مقابل يمكن استخدامه لاستخراج الماء منه، وجميع الدلاء لديها نفس السعة. مهمتك هي استخدام الدلاء لتفريغ الآبار. أخرج عدد المرات التي تحتاج فيها إلى خفض الدلاء.\n# \n# مثال 1:\n#     المدخلات:\n#         grid: [[0،0،1،0]، [0،1،0،0]، [1،1،1،1]]\n#         bucket_capacity: 1\n#     الناتج: 6\n# \n# مثال 2:\n#     المدخلات:\n#         grid: [[0،0،1،1]، [0،0،0،0]، [1،1،1،1]، [0،1،1،1]]\n#         bucket_capacity: 2\n#     الناتج: 5\n# \n# مثال 3:\n#     المدخلات:\n#         grid: [[0،0،0]، [0،0،0]]\n#         bucket_capacity: 5\n#     الناتج: 0\n# \n# القيود:\n#     * جميع الآبار لديها نفس الطول\n#     * 1 <= grid.length <= 10^2\n#     * 1 <= grid [:،1].length <= 10^2\n#     * grid [i] [j] -> 0 | 1\n#     * 1 <= capacity <= 10\n# \n#\ndef max_fill(grid, capacity)", "entry_point": "max_fill", "test": "\n\narg00 = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\narg01 = 1\nx0 = max_fill(arg00, arg01)\nv0 = 6\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\narg11 = 2\nx1 = max_fill(arg10, arg11)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [[0, 0, 0], [0, 0, 0]]\narg21 = 5\nx2 = max_fill(arg20, arg21)\nv2 = 0\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [[1, 1, 1, 1], [1, 1, 1, 1]]\narg31 = 2\nx3 = max_fill(arg30, arg31)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [[1, 1, 1, 1], [1, 1, 1, 1]]\narg41 = 9\nx4 = max_fill(arg40, arg41)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "يتم تزويدك بشبكة مستطيلة من الآبار. تمثل كل صف بئرًا ويمثل الرقم 1 في الصف وحدة واحدة من الماء. لكل بئر دلو مقابل يمكن استخدامه لاستخراج الماء منه، وجميع الدلاء لديها نفس السعة. مهمتك هي استخدام الدلاء لتفريغ الآبار. أخرج عدد المرات التي تحتاج فيها إلى خفض الدلاء.\n\nمثال 1:\n    المدخلات:\n        grid: [[0،0،1،0]، [0،1،0،0]، [1،1،1،1]]\n        bucket_capacity: 1\n    الناتج: 6\n\nمثال 2:\n    المدخلات:\n        grid: [[0،0،1،1]، [0،0،0،0]، [1،1،1،1]، [0،1،1،1]]\n        bucket_capacity: 2\n    الناتج: 5\n\nمثال 3:\n    المدخلات:\n        grid: [[0،0،0]، [0،0،0]]\n        bucket_capacity: 5\n    الناتج: 0\n\nالقيود:\n    * جميع الآبار لديها نفس الطول\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid [:،1].length <= 10^2\n    * grid [i] [j] -> 0 | 1\n    * 1 <= capacity <= 10", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/53", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# تم تكليفك بتنفيذ وظيفة تعيد قائمة بجميع الكلمات من السلسلة s التي تحتوي بالضبط على n حروف ساكنة، بالترتيب الذي تظهر به هذه الكلمات في السلسلة s. إذا كانت السلسلة s فارغة ، يجب أن تعيد الوظيفة قائمة فارغة. ملاحظة: يمكنك الافتراض بأن سلسلة الإدخال تحتوي فقط على الحروف والمسافات.\n#     أمثلة:\n# \n# select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n# select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n# select_words(\"simple white space\", 2) ==> []\n# select_words(\"Hello world\", 4) ==> [\"world\"]\n# select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n#\ndef select_words(s, n)", "entry_point": "select_words", "test": "\n\narg00 = \"Mary had a little lamb\"\narg01 = 4\nx0 = select_words(arg00, arg01)\nv0 = [\"little\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Mary had a little lamb\"\narg11 = 3\nx1 = select_words(arg10, arg11)\nv1 = [\"Mary\", \"lamb\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"simple white space\"\narg21 = 2\nx2 = select_words(arg20, arg21)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Hello world\"\narg31 = 4\nx3 = select_words(arg30, arg31)\nv3 = [\"world\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Uncle sam\"\narg41 = 3\nx4 = select_words(arg40, arg41)\nv4 = [\"Uncle\"]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"\"\narg51 = 4\nx5 = select_words(arg50, arg51)\nv5 = []\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"a b c d e f\"\narg61 = 1\nx6 = select_words(arg60, arg61)\nv6 = [\"b\", \"c\", \"d\", \"f\"]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "تم تكليفك بتنفيذ وظيفة تعيد قائمة بجميع الكلمات من السلسلة s التي تحتوي بالضبط على n حروف ساكنة، بالترتيب الذي تظهر به هذه الكلمات في السلسلة s. إذا كانت السلسلة s فارغة ، يجب أن تعيد الوظيفة قائمة فارغة. ملاحظة: يمكنك الافتراض بأن سلسلة الإدخال تحتوي فقط على الحروف والمسافات.\n    أمثلة:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/54", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # بالنظر إلى مصفوفة arr من الأعداد الصحيحة وعدد صحيح موجب k ، يتم إرجاع قائمة مرتبة بطول k مع أكبر k أرقام في arr.\n# \n#     مثال 1:\n# \n#         المدخلات: arr = [-3، -4، 5]، k = 3\n#         الناتج: [-4، -3، 5]\n# \n#     مثال 2:\n# \n#         المدخلات: arr = [4، -4، 4]، k = 2\n#         الناتج: [4، 4]\n# \n#     مثال 3:\n# \n#         المدخلات: arr = [-3، 2، 1، 2، -1، -2، 1]، k = 1\n#         الناتج: [2]\n# \n#     ملاحظة:\n#         1. سيكون طول المصفوفة في نطاق [1، 1000].\n#         2. ستكون العناصر في المصفوفة في نطاق [-1000، 1000].\n#         3. 0 <= k <= len (arr)\n# \n#\ndef maximum(arr, k)", "entry_point": "maximum", "test": "\n\narg00 = [-3, -4, 5]\narg01 = 3\nx0 = maximum(arg00, arg01)\nv0 = [-4, -3, 5]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [4, -4, 4]\narg11 = 2\nx1 = maximum(arg10, arg11)\nv1 = [4, 4]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-3, 2, 1, 2, -1, -2, 1]\narg21 = 1\nx2 = maximum(arg20, arg21)\nv2 = [2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [123, -123, 20, 0, 1, 2, -3]\narg31 = 3\nx3 = maximum(arg30, arg31)\nv3 = [2, 20, 123]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-123, 20, 0, 1, 2, -3]\narg41 = 4\nx4 = maximum(arg40, arg41)\nv4 = [0, 1, 2, 20]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [5, 15, 0, 3, -13, -8, 0]\narg51 = 7\nx5 = maximum(arg50, arg51)\nv5 = [-13, -8, 0, 0, 3, 5, 15]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-1, 0, 2, 5, 3, -10]\narg61 = 2\nx6 = maximum(arg60, arg61)\nv6 = [3, 5]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [1, 0, 5, -7]\narg71 = 1\nx7 = maximum(arg70, arg71)\nv7 = [5]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [4, -4]\narg81 = 2\nx8 = maximum(arg80, arg81)\nv8 = [-4, 4]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [-10, 10]\narg91 = 2\nx9 = maximum(arg90, arg91)\nv9 = [-10, 10]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [1, 2, 3, -23, 243, -400, 0]\narg101 = 0\nx10 = maximum(arg100, arg101)\nv10 = []\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "بالنظر إلى مصفوفة arr من الأعداد الصحيحة وعدد صحيح موجب k ، يتم إرجاع قائمة مرتبة بطول k مع أكبر k أرقام في arr.\n\n    مثال 1:\n\n        المدخلات: arr = [-3، -4، 5]، k = 3\n        الناتج: [-4، -3، 5]\n\n    مثال 2:\n\n        المدخلات: arr = [4، -4، 4]، k = 2\n        الناتج: [4، 4]\n\n    مثال 3:\n\n        المدخلات: arr = [-3، 2، 1، 2، -1، -2، 1]، k = 1\n        الناتج: [2]\n\n    ملاحظة:\n        1. سيكون طول المصفوفة في نطاق [1، 1000].\n        2. ستكون العناصر في المصفوفة في نطاق [-1000، 1000].\n        3. 0 <= k <= len (arr)", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/55", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # عندما يتم إعطاء مصفوفة غير فارغة من الأعداد الصحيحة arr وعدد صحيح k ، يتم إرجاع مجموع العناصر التي لديها رقمين على الأكثر من أول k عنصرًا في arr.\n# \n#     مثال:\n# \n#         المدخلات: arr = [111،21،3،4000،5،6،7،8،9] ، k = 4\n#         الإخراج: 24 # مجموع 21 + 3\n# \n#     القيود:\n#         1. 1 <= len(arr) <= 100\n#         2. 1 <= k <= len(arr)\n# \n#\ndef add_elements(arr, k)", "entry_point": "add_elements", "test": "\n\narg00 = [1, -2, -3, 41, 57, 76, 87, 88, 99]\narg01 = 3\nx0 = add_elements(arg00, arg01)\nv0 = -4\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [111, 121, 3, 4000, 5, 6]\narg11 = 2\nx1 = add_elements(arg10, arg11)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [11, 21, 3, 90, 5, 6, 7, 8, 9]\narg21 = 4\nx2 = add_elements(arg20, arg21)\nv2 = 125\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [111, 21, 3, 4000, 5, 6, 7, 8, 9]\narg31 = 4\nx3 = add_elements(arg30, arg31)\nv3 = 24\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\narg41 = 1\nx4 = add_elements(arg40, arg41)\nv4 = 1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "عندما يتم إعطاء مصفوفة غير فارغة من الأعداد الصحيحة arr وعدد صحيح k ، يتم إرجاع مجموع العناصر التي لديها رقمين على الأكثر من أول k عنصرًا في arr.\n\n    مثال:\n\n        المدخلات: arr = [111،21،3،4000،5،6،7،8،9] ، k = 4\n        الإخراج: 24 # مجموع 21 + 3\n\n    القيود:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/56", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# يتم تزويدك بنطاقين،\n# حيث يتكون كل نطاق من زوج من الأعداد الصحيحة. على سبيل المثال، النطاق = (البداية، النهاية) = (1، 2).\n# النطاقات المعطاة مغلقة مما يعني أن النطاق (البداية، النهاية)\n# يشمل كل من البداية والنهاية.\n# يفترض لكل نطاق معطى أن بدايته أقل أو يساوي نهايته.\n# مهمتك هي تحديد ما إذا كان طول تقاطع هذين النطاقين هو عدد أولي.\n# على سبيل المثال، تقاطع النطاقات (1، 3)، (2، 4) هو (2، 3)\n# الذي يبلغ طوله 1، وهو ليس عددًا أوليًا.\n# إذا كان طول التقاطع عددًا أوليًا، فأرجع \"نعم\"،\n# وإلا، أرجع \"لا\".\n# إذا لم يتقاطع النطاقان، فأرجع \"لا\".\n# \n# [المدخلات/المخرجات] الأمثلة:\n# \n# intersection((1, 2), (2, 3)) ==> \"NO\"\n# intersection((-1, 1), (0, 4)) ==> \"NO\"\n# intersection((-3, -1), (-5, 5)) ==> \"YES\"\n#\ndef intersection(interval1, interval2)", "entry_point": "intersection", "test": "\n\narg00 = [1, 2]\narg01 = [2, 3]\nx0 = intersection(arg00, arg01)\nv0 = \"NO\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [-1, 1]\narg11 = [0, 4]\nx1 = intersection(arg10, arg11)\nv1 = \"NO\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-3, -1]\narg21 = [-5, 5]\nx2 = intersection(arg20, arg21)\nv2 = \"YES\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [-2, 2]\narg31 = [-4, 0]\nx3 = intersection(arg30, arg31)\nv3 = \"YES\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-11, 2]\narg41 = [-1, -1]\nx4 = intersection(arg40, arg41)\nv4 = \"NO\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 2]\narg51 = [3, 5]\nx5 = intersection(arg50, arg51)\nv5 = \"NO\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [1, 2]\narg61 = [1, 2]\nx6 = intersection(arg60, arg61)\nv6 = \"NO\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-2, -2]\narg71 = [-3, -2]\nx7 = intersection(arg70, arg71)\nv7 = \"NO\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "يتم تزويدك بنطاقين،\nحيث يتكون كل نطاق من زوج من الأعداد الصحيحة. على سبيل المثال، النطاق = (البداية، النهاية) = (1، 2).\nالنطاقات المعطاة مغلقة مما يعني أن النطاق (البداية، النهاية)\nيشمل كل من البداية والنهاية.\nيفترض لكل نطاق معطى أن بدايته أقل أو يساوي نهايته.\nمهمتك هي تحديد ما إذا كان طول تقاطع هذين النطاقين هو عدد أولي.\nعلى سبيل المثال، تقاطع النطاقات (1، 3)، (2، 4) هو (2، 3)\nالذي يبلغ طوله 1، وهو ليس عددًا أوليًا.\nإذا كان طول التقاطع عددًا أوليًا، فأرجع \"نعم\"،\nوإلا، أرجع \"لا\".\nإذا لم يتقاطع النطاقان، فأرجع \"لا\".\n\n[المدخلات/المخرجات] الأمثلة:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/57", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# الجميع يعرف سلسلة فيبوناتشي، وقد درسها الرياضيون بعمق في القرون القليلة الماضية. ومع ذلك، ما لا يعرفه الناس هو سلسلة تريبوناتشي. تعرف سلسلة تريبوناتشي بالتكرار:\n# tri(1) = 3\n# tri(n) = 1 + n / 2، إذا كان n زوجيًا.\n# tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، إذا كان n فرديًا.\n# على سبيل المثال:\n# tri(2) = 1 + (2 / 2) = 2\n# tri(4) = 3\n# tri(3) = tri(2) + tri(1) + tri(4)\n# = 2 + 3 + 3 = 8\n# يتم إعطاؤك عدد صحيح غير سلبي n ، ويجب عليك إرجاع قائمة بأول n + 1 عددًا في سلسلة تريبوناتشي.\n# أمثلة:\n# tri(3) = [1، 3، 2، 8]\n# \n#\ndef tri(n)", "entry_point": "tri", "test": "\n\narg00 = 3\nx0 = tri(arg00)\nv0 = [1, 3, 2.0, 8.0]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 4\nx1 = tri(arg10)\nv1 = [1, 3, 2.0, 8.0, 3.0]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = tri(arg20)\nv2 = [1, 3, 2.0, 8.0, 3.0, 15.0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 6\nx3 = tri(arg30)\nv3 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\nx4 = tri(arg40)\nv4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 8\nx5 = tri(arg50)\nv5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 9\nx6 = tri(arg60)\nv6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 20\nx7 = tri(arg70)\nv7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 0\nx8 = tri(arg80)\nv8 = [1]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1\nx9 = tri(arg90)\nv9 = [1, 3]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "الجميع يعرف سلسلة فيبوناتشي، وقد درسها الرياضيون بعمق في القرون القليلة الماضية. ومع ذلك، ما لا يعرفه الناس هو سلسلة تريبوناتشي. تعرف سلسلة تريبوناتشي بالتكرار:\ntri(1) = 3\ntri(n) = 1 + n / 2، إذا كان n زوجيًا.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، إذا كان n فرديًا.\nعلى سبيل المثال:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nيتم إعطاؤك عدد صحيح غير سلبي n ، ويجب عليك إرجاع قائمة بأول n + 1 عددًا في سلسلة تريبوناتشي.\nأمثلة:\ntri(3) = [1، 3، 2، 8]", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/58", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# بالنظر إلى عدد صحيح موجب n، يتم إرجاع حاصل ضرب الأرقام الفردية.\n# إذا كانت جميع الأرقام زوجية، يتم إرجاع القيمة 0.\n# على سبيل المثال:\n# \n# digits(1)  == 1\n# digits(4)  == 0\n# digits(235) == 15\n#\ndef digits(n)", "entry_point": "digits", "test": "\n\narg00 = 5\nx0 = digits(arg00)\nv0 = 5\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 54\nx1 = digits(arg10)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 120\nx2 = digits(arg20)\nv2 = 1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5014\nx3 = digits(arg30)\nv3 = 5\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 98765\nx4 = digits(arg40)\nv4 = 315\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 5576543\nx5 = digits(arg50)\nv5 = 2625\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 2468\nx6 = digits(arg60)\nv6 = 0\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "بالنظر إلى عدد صحيح موجب n، يتم إرجاع حاصل ضرب الأرقام الفردية.\nإذا كانت جميع الأرقام زوجية، يتم إرجاع القيمة 0.\nعلى سبيل المثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/59", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # أنشئ دالة تأخذ سلسلة نصية كمدخلات تحتوي فقط على أقواس مربعة.\n# يجب أن تعيد الدالة True إذا وفقط إذا كان هناك متتالية صحيحة من الأقواس\n# حيث يتم تضمين على الأقل قوس واحد في المتتالية.\n# is_nested('[[]]') ➞ True\n# is_nested('[]]]]]]][[[[[]') ➞ False\n# is_nested('[][]') ➞ False\n# is_nested('[]') ➞ False\n# is_nested('[[][]]') ➞ True\n# is_nested('[[]][[') ➞ True\n#\ndef is_nested(string)", "entry_point": "is_nested", "test": "\n\narg00 = \"[[]]\"\nx0 = is_nested(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"[]]]]]]][[[[[]\"\nx1 = is_nested(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"[][]\"\nx2 = is_nested(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"[]\"\nx3 = is_nested(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"[[[[]]]]\"\nx4 = is_nested(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"[]]]]]]]]]]\"\nx5 = is_nested(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"[][][[]]\"\nx6 = is_nested(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"[[]\"\nx7 = is_nested(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"[]]\"\nx8 = is_nested(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"[[]][[\"\nx9 = is_nested(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"[[][]]\"\nx10 = is_nested(arg100)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"\"\nx11 = is_nested(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"[[[[[[[[\"\nx12 = is_nested(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = \"]]]]]]]]\"\nx13 = is_nested(arg130)\nv13 = false\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\n", "description": "أنشئ دالة تأخذ سلسلة نصية كمدخلات تحتوي فقط على أقواس مربعة.\nيجب أن تعيد الدالة True إذا وفقط إذا كان هناك متتالية صحيحة من الأقواس\nحيث يتم تضمين على الأقل قوس واحد في المتتالية.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/60", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# تمنحك قائمة من الأرقام.\n# تحتاج إلى إرجاع مجموع الأرقام المربعة في القائمة المعطاة،\n# قم بتقريب كل عنصر في القائمة إلى العدد الصحيح الأعلى (السقف) أولاً.\n# أمثلة:\n# للقائمة = [1،2،3] يجب أن يكون الإخراج 14\n# للقائمة = [1،4،9] يجب أن يكون الإخراج 98\n# للقائمة = [1،3،5،7] يجب أن يكون الإخراج 84\n# للقائمة = [1.4،4.2،0] يجب أن يكون الإخراج 29\n# للقائمة = [-2.4،1،1] يجب أن يكون الإخراج 6\n# \n# \n\n#\ndef sum_squares(lst)", "entry_point": "sum_squares", "test": "\n\narg00 = [1, 2, 3]\nx0 = sum_squares(arg00)\nv0 = 14\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1.0, 2, 3]\nx1 = sum_squares(arg10)\nv1 = 14\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 5, 7]\nx2 = sum_squares(arg20)\nv2 = 84\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1.4, 4.2, 0]\nx3 = sum_squares(arg30)\nv3 = 29\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-2.4, 1, 1]\nx4 = sum_squares(arg40)\nv4 = 6\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [100, 1, 15, 2]\nx5 = sum_squares(arg50)\nv5 = 10230\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [10000, 10000]\nx6 = sum_squares(arg60)\nv6 = 200000000\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-1.4, 4.6, 6.3]\nx7 = sum_squares(arg70)\nv7 = 75\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-1.4, 17.9, 18.9, 19.9]\nx8 = sum_squares(arg80)\nv8 = 1086\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [0]\nx9 = sum_squares(arg90)\nv9 = 0\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [-1]\nx10 = sum_squares(arg100)\nv10 = 1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = [-1, 1, 0]\nx11 = sum_squares(arg110)\nv11 = 2\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\n", "description": "تمنحك قائمة من الأرقام.\nتحتاج إلى إرجاع مجموع الأرقام المربعة في القائمة المعطاة،\nقم بتقريب كل عنصر في القائمة إلى العدد الصحيح الأعلى (السقف) أولاً.\nأمثلة:\nللقائمة = [1،2،3] يجب أن يكون الإخراج 14\nللقائمة = [1،4،9] يجب أن يكون الإخراج 98\nللقائمة = [1،3،5،7] يجب أن يكون الإخراج 84\nللقائمة = [1.4،4.2،0] يجب أن يكون الإخراج 29\nللقائمة = [-2.4،1،1] يجب أن يكون الإخراج 6", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/61", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # أنشئ دالة تعيد True إذا كان الحرف الأخير في السلسلة المعطاة حرفًا أبجديًا وليس جزءًا من كلمة، وتعيد False في الحالة الأخرى.\n# ملاحظة: \"الكلمة\" هي مجموعة من الأحرف مفصولة بمسافة.\n# \n# أمثلة:\n# \n# check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n# check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n# check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n# check_if_last_char_is_a_letter(\"\") ➞ False \n#\ndef check_if_last_char_is_a_letter(txt)", "entry_point": "check_if_last_char_is_a_letter", "test": "\n\narg00 = \"apple\"\nx0 = check_if_last_char_is_a_letter(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"apple pi e\"\nx1 = check_if_last_char_is_a_letter(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"eeeee\"\nx2 = check_if_last_char_is_a_letter(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"A\"\nx3 = check_if_last_char_is_a_letter(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Pumpkin pie \"\nx4 = check_if_last_char_is_a_letter(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"Pumpkin pie 1\"\nx5 = check_if_last_char_is_a_letter(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"\"\nx6 = check_if_last_char_is_a_letter(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"eeeee e \"\nx7 = check_if_last_char_is_a_letter(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"apple pie\"\nx8 = check_if_last_char_is_a_letter(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"apple pi e \"\nx9 = check_if_last_char_is_a_letter(arg90)\nv9 = false\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "أنشئ دالة تعيد True إذا كان الحرف الأخير في السلسلة المعطاة حرفًا أبجديًا وليس جزءًا من كلمة، وتعيد False في الحالة الأخرى.\nملاحظة: \"الكلمة\" هي مجموعة من الأحرف مفصولة بمسافة.\n\nأمثلة:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/62", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# أنشئ دالة تعيد أكبر فهرس لعنصر لا يزيد عن العنصر الذي يسبقه. إذا لم يوجد عنصر كهذا ، فأرجع -1. لن يحتوي المصفوفة المعطاة على قيم مكررة.\n# \n#     أمثلة:\n# \n# can_arrange([1,2,4,3,5]) = 3\n# can_arrange([1,2,3]) = -1\n#\ndef can_arrange(arr)", "entry_point": "can_arrange", "test": "\n\narg00 = [1, 2, 4, 3, 5]\nx0 = can_arrange(arg00)\nv0 = 3\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 4, 5]\nx1 = can_arrange(arg10)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 4, 2, 5, 6, 7, 8, 9, 10]\nx2 = can_arrange(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 8, 5, 7, 3]\nx3 = can_arrange(arg30)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = []\nx4 = can_arrange(arg40)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "أنشئ دالة تعيد أكبر فهرس لعنصر لا يزيد عن العنصر الذي يسبقه. إذا لم يوجد عنصر كهذا ، فأرجع -1. لن يحتوي المصفوفة المعطاة على قيم مكررة.\n\n    أمثلة:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/63", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # أنشئ دالة تعيد tuple (a، b) ، حيث يكون 'a' هو أكبر الأعداد الصحيحة السالبة ، و 'b' هو أصغر الأعداد الصحيحة الموجبة في القائمة. إذا لم يكن هناك أعداد صحيحة سالبة أو موجبة ، فأرجعها كـ None.\n# \n#     Examples:\n# \n# largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n# largest_smallest_integers([]) == (None, None)\n# largest_smallest_integers([0]) == (None, None)\n#\ndef largest_smallest_integers(lst)", "entry_point": "largest_smallest_integers", "test": "\n\narg00 = [2, 4, 1, 3, 5, 7]\nx0 = largest_smallest_integers(arg00)\nv0 = [nil, 1]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [2, 4, 1, 3, 5, 7, 0]\nx1 = largest_smallest_integers(arg10)\nv1 = [nil, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 2, 4, 5, 6, -2]\nx2 = largest_smallest_integers(arg20)\nv2 = [-2, 1]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 5, 3, 6, 2, 7, -7]\nx3 = largest_smallest_integers(arg30)\nv3 = [-7, 2]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [7, 3, 8, 4, 9, 2, 5, -9]\nx4 = largest_smallest_integers(arg40)\nv4 = [-9, 2]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = []\nx5 = largest_smallest_integers(arg50)\nv5 = [nil, nil]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [0]\nx6 = largest_smallest_integers(arg60)\nv6 = [nil, nil]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-1, -3, -5, -6]\nx7 = largest_smallest_integers(arg70)\nv7 = [-1, nil]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-1, -3, -5, -6, 0]\nx8 = largest_smallest_integers(arg80)\nv8 = [-1, nil]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [-6, -4, -4, -3, 1]\nx9 = largest_smallest_integers(arg90)\nv9 = [-3, 1]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [-6, -4, -4, -3, -100, 1]\nx10 = largest_smallest_integers(arg100)\nv10 = [-3, 1]\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "أنشئ دالة تعيد tuple (a، b) ، حيث يكون 'a' هو أكبر الأعداد الصحيحة السالبة ، و 'b' هو أصغر الأعداد الصحيحة الموجبة في القائمة. إذا لم يكن هناك أعداد صحيحة سالبة أو موجبة ، فأرجعها كـ None.\n\n    Examples:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/64", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# العامل البرازيلي يعرف على أنه:\n#     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n#     حيث n > 0\n# \n#     على سبيل المثال:\n# >>> special_factorial(4)\n# 288\n\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\n#\ndef special_factorial(n)", "entry_point": "special_factorial", "test": "\n\narg00 = 4\nx0 = special_factorial(arg00)\nv0 = 288\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 5\nx1 = special_factorial(arg10)\nv1 = 34560\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 7\nx2 = special_factorial(arg20)\nv2 = 125411328000\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 1\nx3 = special_factorial(arg30)\nv3 = 1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "العامل البرازيلي يعرف على أنه:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    حيث n > 0\n\n    على سبيل المثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/65", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # يتم تزويدك بسلسلة تمثل جملة،\n# الجملة تحتوي على بعض الكلمات المفصولة بمسافة،\n# ويجب عليك إرجاع سلسلة تحتوي على الكلمات من الجملة الأصلية،\n# التي تحتوي على أعداد أولية من الأحرف،\n# يجب أن يكون ترتيب الكلمات في السلسلة الجديدة هو نفس الترتيب الأصلي.\n# \n# مثال 1:\n#     المدخلات: الجملة = \"This is a test\"\n#     الناتج: \"is\"\n# \n# مثال 2:\n#     المدخلات: الجملة = \"lets go for swimming\"\n#     الناتج: \"go for\"\n# \n# القيود:\n#     * 1 <= len(sentence) <= 100\n#     * تحتوي الجملة على أحرف فقط\n# \n#\ndef words_in_sentence(sentence)", "entry_point": "words_in_sentence", "test": "\n\narg00 = \"This is a test\"\nx0 = words_in_sentence(arg00)\nv0 = \"is\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"lets go for swimming\"\nx1 = words_in_sentence(arg10)\nv1 = \"go for\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"there is no place available here\"\nx2 = words_in_sentence(arg20)\nv2 = \"there is no place\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Hi I am Hussein\"\nx3 = words_in_sentence(arg30)\nv3 = \"Hi am Hussein\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"go for it\"\nx4 = words_in_sentence(arg40)\nv4 = \"go for it\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"here\"\nx5 = words_in_sentence(arg50)\nv5 = \"\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"here is\"\nx6 = words_in_sentence(arg60)\nv6 = \"is\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "يتم تزويدك بسلسلة تمثل جملة،\nالجملة تحتوي على بعض الكلمات المفصولة بمسافة،\nويجب عليك إرجاع سلسلة تحتوي على الكلمات من الجملة الأصلية،\nالتي تحتوي على أعداد أولية من الأحرف،\nيجب أن يكون ترتيب الكلمات في السلسلة الجديدة هو نفس الترتيب الأصلي.\n\nمثال 1:\n    المدخلات: الجملة = \"This is a test\"\n    الناتج: \"is\"\n\nمثال 2:\n    المدخلات: الجملة = \"lets go for swimming\"\n    الناتج: \"go for\"\n\nالقيود:\n    * 1 <= len(sentence) <= 100\n    * تحتوي الجملة على أحرف فقط", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/66", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# مهمتك هي تنفيذ وظيفة ستبسط التعبير\n# x * n. تعيد الوظيفة True إذا كان x * n يقيم إلى عدد صحيح و False\n# إلا في ذلك. كل من x و n هما تمثيل سلسلة لكسر ، ولهما التنسيق التالي ،\n# <البسط>/<المقام> حيث كل من البسط والمقام هما أعداد صحيحة موجبة.\n# \n# يمكنك الافتراض أن x و n هما كسور صالحة ، ولا يحتويان على الصفر كمقام.\n# simplify(\"1/5\", \"5/1\") = True\n# simplify(\"1/6\", \"2/1\") = False\n# simplify(\"7/10\", \"10/2\") = False\n#\ndef simplify(x, n)", "entry_point": "simplify", "test": "\n\narg00 = \"1/5\"\narg01 = \"5/1\"\nx0 = simplify(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1/6\"\narg11 = \"2/1\"\nx1 = simplify(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"5/1\"\narg21 = \"3/1\"\nx2 = simplify(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"7/10\"\narg31 = \"10/2\"\nx3 = simplify(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"2/10\"\narg41 = \"50/10\"\nx4 = simplify(arg40, arg41)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"7/2\"\narg51 = \"4/2\"\nx5 = simplify(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"11/6\"\narg61 = \"6/1\"\nx6 = simplify(arg60, arg61)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"2/3\"\narg71 = \"5/2\"\nx7 = simplify(arg70, arg71)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"5/2\"\narg81 = \"3/5\"\nx8 = simplify(arg80, arg81)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"2/4\"\narg91 = \"8/4\"\nx9 = simplify(arg90, arg91)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"2/4\"\narg101 = \"4/2\"\nx10 = simplify(arg100, arg101)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"1/5\"\narg111 = \"5/1\"\nx11 = simplify(arg110, arg111)\nv11 = true\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"1/5\"\narg121 = \"1/5\"\nx12 = simplify(arg120, arg121)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\n", "description": "مهمتك هي تنفيذ وظيفة ستبسط التعبير\nx * n. تعيد الوظيفة True إذا كان x * n يقيم إلى عدد صحيح و False\nإلا في ذلك. كل من x و n هما تمثيل سلسلة لكسر ، ولهما التنسيق التالي ،\n<البسط>/<المقام> حيث كل من البسط والمقام هما أعداد صحيحة موجبة.\n\nيمكنك الافتراض أن x و n هما كسور صالحة ، ولا يحتويان على الصفر كمقام.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/67", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # اكتب دالة تقوم بفرز القائمة المعطاة من الأعداد الصحيحة بترتيب تصاعدي وفقًا لمجموع أرقامها. ملاحظة: إذا كان هناك عدة عناصر بمجموع أرقام مماثل ، فقم بترتيبها بناءً على مؤشرها في القائمة الأصلية.\n# \n# على سبيل المثال:\n# >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n# >>> order_by_points([]) == []\n#\ndef order_by_points(nums)", "entry_point": "order_by_points", "test": "\n\narg00 = [1, 11, -1, -11, -12]\nx0 = order_by_points(arg00)\nv0 = [-1, -11, 1, -12, 11]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\nx1 = order_by_points(arg10)\nv1 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = []\nx2 = order_by_points(arg20)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, -11, -32, 43, 54, -98, 2, -3]\nx3 = order_by_points(arg30)\nv3 = [-3, -32, -98, -11, 1, 2, 43, 54]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\nx4 = order_by_points(arg40)\nv4 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 6, 6, -76, -21, 23, 4]\nx5 = order_by_points(arg50)\nv5 = [-76, -21, 0, 4, 23, 6, 6]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "اكتب دالة تقوم بفرز القائمة المعطاة من الأعداد الصحيحة بترتيب تصاعدي وفقًا لمجموع أرقامها. ملاحظة: إذا كان هناك عدة عناصر بمجموع أرقام مماثل ، فقم بترتيبها بناءً على مؤشرها في القائمة الأصلية.\n\nعلى سبيل المثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/68", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# اكتب دالة تأخذ مصفوفة من الأرقام كمدخلات وتعيد عدد العناصر في المصفوفة التي تزيد عن 10 وكلاً من الأرقام الأولى والأخيرة للعدد فردية (1، 3، 5، 7، 9). على سبيل المثال:\n# \n# specialFilter([15, -73, 14, -15]) => 1 \n# specialFilter([33, -2, -3, 45, 21, 109]) => 2\n#\ndef specialfilter(nums)", "entry_point": "specialfilter", "test": "\n\narg00 = [5, -2, 1, -5]\nx0 = specialfilter(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [15, -73, 14, -15]\nx1 = specialfilter(arg10)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [33, -2, -3, 45, 21, 109]\nx2 = specialfilter(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [43, -12, 93, 125, 121, 109]\nx3 = specialfilter(arg30)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [71, -2, -33, 75, 21, 19]\nx4 = specialfilter(arg40)\nv4 = 3\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1]\nx5 = specialfilter(arg50)\nv5 = 0\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = []\nx6 = specialfilter(arg60)\nv6 = 0\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "اكتب دالة تأخذ مصفوفة من الأرقام كمدخلات وتعيد عدد العناصر في المصفوفة التي تزيد عن 10 وكلاً من الأرقام الأولى والأخيرة للعدد فردية (1، 3، 5، 7، 9). على سبيل المثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/69", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # تمنحك عدد صحيح موجب n. يجب عليك إنشاء مصفوفة صحيحة a طولها n.\n#         بالنسبة لكل i (1 ≤ i ≤ n) ، قيمة a [i] = i * i - i + 1.\n#         إرجاع عدد الثلاثيات (a [i]، a [j]، a [k]) من a حيث i <j <k ،\n#     و a [i] + a [j] + a [k] هو مضاعف للعدد 3.\n# \n#     مثال:\n#         المدخلات: n = 5\n#         الناتج: 1\n#         شرح:\n#         a = [1، 3، 7، 13، 21]\n#         الثلاثية الوحيدة الصالحة هي (1، 7، 13).\n# \n#\ndef get_max_triples(n)", "entry_point": "get_max_triples", "test": "\n\narg00 = 5\nx0 = get_max_triples(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 6\nx1 = get_max_triples(arg10)\nv1 = 4\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\nx2 = get_max_triples(arg20)\nv2 = 36\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 100\nx3 = get_max_triples(arg30)\nv3 = 53361\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "تمنحك عدد صحيح موجب n. يجب عليك إنشاء مصفوفة صحيحة a طولها n.\n        بالنسبة لكل i (1 ≤ i ≤ n) ، قيمة a [i] = i * i - i + 1.\n        إرجاع عدد الثلاثيات (a [i]، a [j]، a [k]) من a حيث i <j <k ،\n    و a [i] + a [j] + a [k] هو مضاعف للعدد 3.\n\n    مثال:\n        المدخلات: n = 5\n        الناتج: 1\n        شرح:\n        a = [1، 3، 7، 13، 21]\n        الثلاثية الوحيدة الصالحة هي (1، 7، 13).", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/70", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # هناك ثمانية كواكب في نظامنا الشمسي: الأقرب إلى الشمس هو عطارد، الكوكب التالي هو الزهرة، ثم الأرض، المريخ، المشتري، زحل، أورانوس، نبتون.\n# اكتب دالة تأخذ اسمي كوكب كسلسلة نصية planet1 و planet2. يجب أن تعيد الدالة tuple يحتوي على جميع الكواكب التي تقع مداراتها بين مدار كوكب1 ومدار كوكب2، مرتبة حسب القرب من الشمس. يجب أن تعيد الدالة tuple فارغًا إذا كان planet1 أو planet2 ليستا أسماء كواكب صحيحة.\n# أمثلة\n# \n# bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n# bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n# bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n#\ndef bf(planet1, planet2)", "entry_point": "bf", "test": "\n\narg00 = \"Jupiter\"\narg01 = \"Neptune\"\nx0 = bf(arg00, arg01)\nv0 = [\"Saturn\", \"Uranus\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Earth\"\narg11 = \"Mercury\"\nx1 = bf(arg10, arg11)\nv1 = [\"Venus\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"Mercury\"\narg21 = \"Uranus\"\nx2 = bf(arg20, arg21)\nv2 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Neptune\"\narg31 = \"Venus\"\nx3 = bf(arg30, arg31)\nv3 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Earth\"\narg41 = \"Earth\"\nx4 = bf(arg40, arg41)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"Mars\"\narg51 = \"Earth\"\nx5 = bf(arg50, arg51)\nv5 = []\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"Jupiter\"\narg61 = \"Makemake\"\nx6 = bf(arg60, arg61)\nv6 = []\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "هناك ثمانية كواكب في نظامنا الشمسي: الأقرب إلى الشمس هو عطارد، الكوكب التالي هو الزهرة، ثم الأرض، المريخ، المشتري، زحل، أورانوس، نبتون.\nاكتب دالة تأخذ اسمي كوكب كسلسلة نصية planet1 و planet2. يجب أن تعيد الدالة tuple يحتوي على جميع الكواكب التي تقع مداراتها بين مدار كوكب1 ومدار كوكب2، مرتبة حسب القرب من الشمس. يجب أن تعيد الدالة tuple فارغًا إذا كان planet1 أو planet2 ليستا أسماء كواكب صحيحة.\nأمثلة", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/71", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# برنامج بسيط يجب أن يعيد قيمة x إذا كان n عددًا أولًا ويجب أن يعيد قيمة y في حالة أخرى.\n# \n# أمثلة:\n# \n# for x_or_y(7, 34, 12) == 34\n# for x_or_y(15, 8, 5) == 5\n# \n#\ndef x_or_y(n, x, y)", "entry_point": "x_or_y", "test": "\n\narg00 = 7\narg01 = 34\narg02 = 12\nx0 = x_or_y(arg00, arg01, arg02)\nv0 = 34\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 15\narg11 = 8\narg12 = 5\nx1 = x_or_y(arg10, arg11, arg12)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\narg21 = 33\narg22 = 5212\nx2 = x_or_y(arg20, arg21, arg22)\nv2 = 33\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 1259\narg31 = 3\narg32 = 52\nx3 = x_or_y(arg30, arg31, arg32)\nv3 = 3\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7919\narg41 = -1\narg42 = 12\nx4 = x_or_y(arg40, arg41, arg42)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 3609\narg51 = 1245\narg52 = 583\nx5 = x_or_y(arg50, arg51, arg52)\nv5 = 583\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 91\narg61 = 56\narg62 = 129\nx6 = x_or_y(arg60, arg61, arg62)\nv6 = 129\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 6\narg71 = 34\narg72 = 1234\nx7 = x_or_y(arg70, arg71, arg72)\nv7 = 1234\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 1\narg81 = 2\narg82 = 0\nx8 = x_or_y(arg80, arg81, arg82)\nv8 = 0\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 2\narg91 = 2\narg92 = 0\nx9 = x_or_y(arg90, arg91, arg92)\nv9 = 2\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "برنامج بسيط يجب أن يعيد قيمة x إذا كان n عددًا أولًا ويجب أن يعيد قيمة y في حالة أخرى.\n\nأمثلة:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/72", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # عندما يتم إعطاء قائمة من الأرقام، يتم إرجاع مجموع مربعات الأرقام في القائمة التي هي فردية. يتم تجاهل الأرقام التي هي سلبية أو غير صحيحة.\n# \n# double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n# double_the_difference([-1, -2, 0]) == 0\n# double_the_difference([9, -2]) == 81\n# double_the_difference([0]) == 0\n# \n# إذا كانت القائمة المدخلة فارغة، يتم إرجاع 0.\n# \n#\ndef double_the_difference(lst)", "entry_point": "double_the_difference", "test": "\n\narg00 = []\nx0 = double_the_difference(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 4]\nx1 = double_the_difference(arg10)\nv1 = 25\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [0.1, 0.2, 0.3]\nx2 = double_the_difference(arg20)\nv2 = 0\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [-10, -20, -30]\nx3 = double_the_difference(arg30)\nv3 = 0\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-1, -2, 8]\nx4 = double_the_difference(arg40)\nv4 = 0\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0.2, 3, 5]\nx5 = double_the_difference(arg50)\nv5 = 34\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]\nx6 = double_the_difference(arg60)\nv6 = 166650\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "عندما يتم إعطاء قائمة من الأرقام، يتم إرجاع مجموع مربعات الأرقام في القائمة التي هي فردية. يتم تجاهل الأرقام التي هي سلبية أو غير صحيحة.\n\ndouble_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0\n\nإذا كانت القائمة المدخلة فارغة، يتم إرجاع 0.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/73", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# سيتم تزويدك بإسم الصف (سلسلة نصية) وقائمة من الامتدادات.\n# يجب استخدام الامتدادات لتحميل صفوف إضافية إلى الصف. قوة الامتداد هي كما يلي: دع CAP يكون عدد الأحرف الكبيرة في اسم الامتداد، ودع SM يكون عدد الأحرف الصغيرة في اسم الامتداد، يتم إعطاء القوة بواسطة الكسر CAP - SM. يجب عليك العثور على الامتداد الأقوى وإرجاع سلسلة بهذا الشكل: اسم الصف.اسم الامتداد الأقوى.\n# إذا كان هناك اثنين أو أكثر من الامتدادات بنفس القوة، يجب اختيار الذي يأتي أولاً في القائمة.\n# على سبيل المثال، إذا تم تزويدك بـ \"Slices\" كصف وقائمة من الامتدادات: ['SErviNGSliCes'، 'Cheese'، 'StuFfed']، فيجب عليك إرجاع 'Slices.SErviNGSliCes' لأن 'SErviNGSliCes' هو الامتداد الأقوى (قوته -1).\n# مثال:\n# \n# for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n#\ndef strongest_extension(class_name, extensions)", "entry_point": "strongest_extension", "test": "\n\narg00 = \"Watashi\"\narg01 = [\"tEN\", \"niNE\", \"eIGHt8OKe\"]\nx0 = strongest_extension(arg00, arg01)\nv0 = \"Watashi.eIGHt8OKe\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Boku123\"\narg11 = [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]\nx1 = strongest_extension(arg10, arg11)\nv1 = \"Boku123.YEs.WeCaNe\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"__YESIMHERE\"\narg21 = [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]\nx2 = strongest_extension(arg20, arg21)\nv2 = \"__YESIMHERE.NuLl__\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"K\"\narg31 = [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]\nx3 = strongest_extension(arg30, arg31)\nv3 = \"K.TAR\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"__HAHA\"\narg41 = [\"Tab\", \"123\", \"781345\", \"-_-\"]\nx4 = strongest_extension(arg40, arg41)\nv4 = \"__HAHA.123\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"YameRore\"\narg51 = [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]\nx5 = strongest_extension(arg50, arg51)\nv5 = \"YameRore.okIWILL123\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"finNNalLLly\"\narg61 = [\"Die\", \"NowW\", \"Wow\", \"WoW\"]\nx6 = strongest_extension(arg60, arg61)\nv6 = \"finNNalLLly.WoW\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"_\"\narg71 = [\"Bb\", \"91245\"]\nx7 = strongest_extension(arg70, arg71)\nv7 = \"_.Bb\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"Sp\"\narg81 = [\"671235\", \"Bb\"]\nx8 = strongest_extension(arg80, arg81)\nv8 = \"Sp.671235\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "سيتم تزويدك بإسم الصف (سلسلة نصية) وقائمة من الامتدادات.\nيجب استخدام الامتدادات لتحميل صفوف إضافية إلى الصف. قوة الامتداد هي كما يلي: دع CAP يكون عدد الأحرف الكبيرة في اسم الامتداد، ودع SM يكون عدد الأحرف الصغيرة في اسم الامتداد، يتم إعطاء القوة بواسطة الكسر CAP - SM. يجب عليك العثور على الامتداد الأقوى وإرجاع سلسلة بهذا الشكل: اسم الصف.اسم الامتداد الأقوى.\nإذا كان هناك اثنين أو أكثر من الامتدادات بنفس القوة، يجب اختيار الذي يأتي أولاً في القائمة.\nعلى سبيل المثال، إذا تم تزويدك بـ \"Slices\" كصف وقائمة من الامتدادات: ['SErviNGSliCes'، 'Cheese'، 'StuFfed']، فيجب عليك إرجاع 'Slices.SErviNGSliCes' لأن 'SErviNGSliCes' هو الامتداد الأقوى (قوته -1).\nمثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/74", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# يتم تزويدك بكلمتين. تحتاج إلى إرجاع True إذا كانت الكلمة الثانية أو أي من دوراناتها هي متعابدة في الكلمة الأولى.\n# cycpattern_check(\"abcd\",\"abd\") => False\n# cycpattern_check(\"hello\",\"ell\") => True\n# cycpattern_check(\"whassup\",\"psus\") => False\n# cycpattern_check(\"abab\",\"baa\") => True\n# cycpattern_check(\"efef\",\"eeff\") => False\n# cycpattern_check(\"himenss\",\"simen\") => True\n\n#\ndef cycpattern_check(a, b)", "entry_point": "cycpattern_check", "test": "\n\narg00 = \"xyzw\"\narg01 = \"xyw\"\nx0 = cycpattern_check(arg00, arg01)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"yello\"\narg11 = \"ell\"\nx1 = cycpattern_check(arg10, arg11)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"whattup\"\narg21 = \"ptut\"\nx2 = cycpattern_check(arg20, arg21)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"efef\"\narg31 = \"fee\"\nx3 = cycpattern_check(arg30, arg31)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"abab\"\narg41 = \"aabb\"\nx4 = cycpattern_check(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"winemtt\"\narg51 = \"tinem\"\nx5 = cycpattern_check(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "يتم تزويدك بكلمتين. تحتاج إلى إرجاع True إذا كانت الكلمة الثانية أو أي من دوراناتها هي متعابدة في الكلمة الأولى.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/75", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # بالنظر إلى عدد صحيح موجب، احصل على ما يعادله من الأرقام الرومانية كسلسلة نصية، وارجعها بأحرف صغيرة.\n# القيود: 1 <= num <= 1000\n# \n# أمثلة:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\n#\ndef int_to_mini_roman(number)", "entry_point": "int_to_mini_roman", "test": "\n\narg00 = 19\nx0 = int_to_mini_roman(arg00)\nv0 = \"xix\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 152\nx1 = int_to_mini_roman(arg10)\nv1 = \"clii\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 251\nx2 = int_to_mini_roman(arg20)\nv2 = \"ccli\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 426\nx3 = int_to_mini_roman(arg30)\nv3 = \"cdxxvi\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 500\nx4 = int_to_mini_roman(arg40)\nv4 = \"d\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 1\nx5 = int_to_mini_roman(arg50)\nv5 = \"i\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 4\nx6 = int_to_mini_roman(arg60)\nv6 = \"iv\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 43\nx7 = int_to_mini_roman(arg70)\nv7 = \"xliii\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 90\nx8 = int_to_mini_roman(arg80)\nv8 = \"xc\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 94\nx9 = int_to_mini_roman(arg90)\nv9 = \"xciv\"\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 532\nx10 = int_to_mini_roman(arg100)\nv10 = \"dxxxii\"\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 900\nx11 = int_to_mini_roman(arg110)\nv11 = \"cm\"\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 994\nx12 = int_to_mini_roman(arg120)\nv12 = \"cmxciv\"\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = 1000\nx13 = int_to_mini_roman(arg130)\nv13 = \"m\"\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\n", "description": "بالنظر إلى عدد صحيح موجب، احصل على ما يعادله من الأرقام الرومانية كسلسلة نصية، وارجعها بأحرف صغيرة.\nالقيود: 1 <= num <= 1000\n\nأمثلة:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/76", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # بالنظر إلى أطوال الأضلاع الثلاثة لمثلث. إرجاع قيمة صحيحة (True) إذا كانت الأضلاع الثلاثة تشكل مثلثاً قائم الزاوية، وإرجاع قيمة خاطئة (False) في الحالات الأخرى. يعتبر المثلث القائم الزاوية هو مثلث يحتوي على زاوية قائمة أو بزاوية 90 درجة. مثال:\n# \n# right_angle_triangle(3, 4, 5) == True\n# right_angle_triangle(1, 2, 3) == False\n#\ndef right_angle_triangle(a, b, c)", "entry_point": "right_angle_triangle", "test": "\n\narg00 = 3\narg01 = 4\narg02 = 5\nx0 = right_angle_triangle(arg00, arg01, arg02)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 2\narg12 = 3\nx1 = right_angle_triangle(arg10, arg11, arg12)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\narg21 = 6\narg22 = 8\nx2 = right_angle_triangle(arg20, arg21, arg22)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 2\narg31 = 2\narg32 = 2\nx3 = right_angle_triangle(arg30, arg31, arg32)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\narg41 = 24\narg42 = 25\nx4 = right_angle_triangle(arg40, arg41, arg42)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 10\narg51 = 5\narg52 = 7\nx5 = right_angle_triangle(arg50, arg51, arg52)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 5\narg61 = 12\narg62 = 13\nx6 = right_angle_triangle(arg60, arg61, arg62)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 15\narg71 = 8\narg72 = 17\nx7 = right_angle_triangle(arg70, arg71, arg72)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 48\narg81 = 55\narg82 = 73\nx8 = right_angle_triangle(arg80, arg81, arg82)\nv8 = true\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1\narg91 = 1\narg92 = 1\nx9 = right_angle_triangle(arg90, arg91, arg92)\nv9 = false\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 2\narg101 = 2\narg102 = 10\nx10 = right_angle_triangle(arg100, arg101, arg102)\nv10 = false\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "بالنظر إلى أطوال الأضلاع الثلاثة لمثلث. إرجاع قيمة صحيحة (True) إذا كانت الأضلاع الثلاثة تشكل مثلثاً قائم الزاوية، وإرجاع قيمة خاطئة (False) في الحالات الأخرى. يعتبر المثلث القائم الزاوية هو مثلث يحتوي على زاوية قائمة أو بزاوية 90 درجة. مثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/77", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# تمنحك سلسلة s.\n#     إذا كان s[i] حرفًا، فعكس حالته من الحروف الصغيرة إلى الحروف الكبيرة أو العكس،\n#     وإلا فاحتفظ به كما هو.\n#     إذا لم تحتوي السلسلة على أحرف، فعكس السلسلة.\n#     يجب أن تعيد الدالة السلسلة الناتجة.\n#     أمثلة\n# \n# solve(\"1234\") = \"4321\"\n# solve(\"ab\") = \"AB\"\n# solve(\"#a@C\") = \"#A@c\"\n#\ndef solve(s)", "entry_point": "solve", "test": "\n\narg00 = \"AsDf\"\nx0 = solve(arg00)\nv0 = \"aSdF\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1234\"\nx1 = solve(arg10)\nv1 = \"4321\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"ab\"\nx2 = solve(arg20)\nv2 = \"AB\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"#a@C\"\nx3 = solve(arg30)\nv3 = \"#A@c\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"#AsdfW^45\"\nx4 = solve(arg40)\nv4 = \"#aSDFw^45\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"#6@2\"\nx5 = solve(arg50)\nv5 = \"2@6#\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"#\\$a^D\"\nx6 = solve(arg60)\nv6 = \"#\\$A^d\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"#ccc\"\nx7 = solve(arg70)\nv7 = \"#CCC\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "تمنحك سلسلة s.\n    إذا كان s[i] حرفًا، فعكس حالته من الحروف الصغيرة إلى الحروف الكبيرة أو العكس،\n    وإلا فاحتفظ به كما هو.\n    إذا لم تحتوي السلسلة على أحرف، فعكس السلسلة.\n    يجب أن تعيد الدالة السلسلة الناتجة.\n    أمثلة", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/78", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # بالنظر إلى سلسلة 'text'، أرجع سلسلة مكافئة لها بتشفير md5.\n# إذا كانت 'text' فارغة، أرجع قيمة فارغة.\n# >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n#\ndef string_to_md5(text)", "entry_point": "string_to_md5", "test": "\n\narg00 = \"Hello world\"\nx0 = string_to_md5(arg00)\nv0 = \"3e25960a79dbc69b674cd4ec67a72c62\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"\"\nx1 = string_to_md5(arg10)\nv1 = nil\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"A B C\"\nx2 = string_to_md5(arg20)\nv2 = \"0ef78513b0cb8cef12743f5aeb35f888\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"password\"\nx3 = string_to_md5(arg30)\nv3 = \"5f4dcc3b5aa765d61d8327deb882cf99\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "بالنظر إلى سلسلة 'text'، أرجع سلسلة مكافئة لها بتشفير md5.\nإذا كانت 'text' فارغة، أرجع قيمة فارغة.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
{"task_id": "ruby/79", "prompt": "\n##\n# أنت مبرمج Ruby خبير، وهذه مهمتك.\n# # بالنظر إلى عددين صحيحين موجبين a و b، يتم إرجاع الأرقام الزوجية بين a و b بترتيب تصاعدي.\n# \n# على سبيل المثال:\n# \n# generate_integers(2, 8) => [2, 4, 6, 8]\n# generate_integers(8, 2) => [2, 4, 6, 8]\n# generate_integers(10, 14) => []\n#\ndef generate_integers(a, b)", "entry_point": "generate_integers", "test": "\n\narg00 = 2\narg01 = 10\nx0 = generate_integers(arg00, arg01)\nv0 = [2, 4, 6, 8]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 10\narg11 = 2\nx1 = generate_integers(arg10, arg11)\nv1 = [2, 4, 6, 8]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 132\narg21 = 2\nx2 = generate_integers(arg20, arg21)\nv2 = [2, 4, 6, 8]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 17\narg31 = 89\nx3 = generate_integers(arg30, arg31)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "بالنظر إلى عددين صحيحين موجبين a و b، يتم إرجاع الأرقام الزوجية بين a و b بترتيب تصاعدي.\n\nعلى سبيل المثال:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Arabic"}
