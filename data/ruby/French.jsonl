{"task_id": "ruby/0", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Vous disposez d'une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde de zéro. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit renvoyer True. Sinon, elle doit renvoyer False.\n# >>> below_zero([1, 2, 3])\n# False\n# >>> below_zero([1, 2, -4, 5])\n# True\n#\ndef below_zero(operations)", "entry_point": "below_zero", "test": "\n\narg00 = []\nx0 = below_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, -3, 1, 2, -3]\nx1 = below_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, -4, 5, 6]\nx2 = below_zero(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, -1, 2, -2, 5, -5, 4, -4]\nx3 = below_zero(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, -1, 2, -2, 5, -5, 4, -5]\nx4 = below_zero(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, -2, 2, -2, 5, -5, 4, -4]\nx5 = below_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Vous disposez d'une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde de zéro. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit renvoyer True. Sinon, elle doit renvoyer False.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/1", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Pour une liste donnée d'entiers, retourner un tuple composé d'une somme et d'un produit de tous les entiers de la liste. La somme vide doit être égale à 0 et le produit vide doit être égal à 1.\n# >>> sum_product([])\n# (0, 1)\n# >>> sum_product([1, 2, 3, 4])\n# (10, 24)\n#\ndef sum_product(numbers)", "entry_point": "sum_product", "test": "\n\narg00 = []\nx0 = sum_product(arg00)\nv0 = [0, 1]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 1, 1]\nx1 = sum_product(arg10)\nv1 = [3, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [100, 0]\nx2 = sum_product(arg20)\nv2 = [100, 0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 5, 7]\nx3 = sum_product(arg30)\nv3 = [15, 105]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [10]\nx4 = sum_product(arg40)\nv4 = [10, 10]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Pour une liste donnée d'entiers, retourner un tuple composé d'une somme et d'un produit de tous les entiers de la liste. La somme vide doit être égale à 0 et le produit vide doit être égal à 1.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/2", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Les entrées sont deux chaînes de caractères a et b composées uniquement de 1 et de 0.\n# Effectuez une opération XOR binaire sur ces entrées et renvoyez le résultat également sous forme de chaîne de caractères.\n# >>> string_xor('010', '110')\n# '100'\n#\ndef string_xor(a, b)", "entry_point": "string_xor", "test": "\n\narg00 = \"111000\"\narg01 = \"101010\"\nx0 = string_xor(arg00, arg01)\nv0 = \"010010\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1\"\narg11 = \"1\"\nx1 = string_xor(arg10, arg11)\nv1 = \"0\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"0101\"\narg21 = \"0000\"\nx2 = string_xor(arg20, arg21)\nv2 = \"0101\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "Les entrées sont deux chaînes de caractères a et b composées uniquement de 1 et de 0.\nEffectuez une opération XOR binaire sur ces entrées et renvoyez le résultat également sous forme de chaîne de caractères.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/3", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# À partir d'une liste de chaînes de caractères, renvoyer la plus longue. Renvoyer la première en cas de plusieurs chaînes de même longueur. Renvoyer null si la liste d'entrée est vide.\n# >>> longest([])\n\n# >>> longest(['a', 'b', 'c'])\n# 'a'\n# >>> longest(['a', 'bb', 'ccc'])\n# 'ccc'\n#\ndef longest(strings)", "entry_point": "longest", "test": "\n\narg00 = []\nx0 = longest(arg00)\nv0 = nil\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [\"x\", \"y\", \"z\"]\nx1 = longest(arg10)\nv1 = \"x\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]\nx2 = longest(arg20)\nv2 = \"zzzz\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "À partir d'une liste de chaînes de caractères, renvoyer la plus longue. Renvoyer la première en cas de plusieurs chaînes de même longueur. Renvoyer null si la liste d'entrée est vide.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/4", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Retourne le plus grand commun diviseur de deux entiers a et b.\n# >>> greatest_common_divisor(3, 5)\n# 1\n# >>> greatest_common_divisor(25, 15)\n# 5\n#\ndef greatest_common_divisor(a, b)", "entry_point": "greatest_common_divisor", "test": "\n\narg00 = 3\narg01 = 7\nx0 = greatest_common_divisor(arg00, arg01)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 10\narg11 = 15\nx1 = greatest_common_divisor(arg10, arg11)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 49\narg21 = 14\nx2 = greatest_common_divisor(arg20, arg21)\nv2 = 7\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 144\narg31 = 60\nx3 = greatest_common_divisor(arg30, arg31)\nv3 = 12\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Retourne le plus grand commun diviseur de deux entiers a et b.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/5", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# L'entrée est une chaîne de caractères séparée par des espaces contenant des chiffres de 'zéro' à 'neuf'.\n#     Les choix valides sont 'zéro', 'un', 'deux', 'trois', 'quatre', 'cinq', 'six', 'sept', 'huit' et 'neuf'.\n#     Renvoyer la chaîne avec les chiffres triés par ordre croissant.\n# >>> sort_numbers('three one five')\n# 'one three five'\n#\ndef sort_numbers(numbers)", "entry_point": "sort_numbers", "test": "\n\narg00 = \"\"\nx0 = sort_numbers(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"three\"\nx1 = sort_numbers(arg10)\nv1 = \"three\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"three five nine\"\nx2 = sort_numbers(arg20)\nv2 = \"three five nine\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"five zero four seven nine eight\"\nx3 = sort_numbers(arg30)\nv3 = \"zero four five seven eight nine\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"six five four three two one zero\"\nx4 = sort_numbers(arg40)\nv4 = \"zero one two three four five six\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "L'entrée est une chaîne de caractères séparée par des espaces contenant des chiffres de 'zéro' à 'neuf'.\n    Les choix valides sont 'zéro', 'un', 'deux', 'trois', 'quatre', 'cinq', 'six', 'sept', 'huit' et 'neuf'.\n    Renvoyer la chaîne avec les chiffres triés par ordre croissant.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/6", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Étant donné une liste de nombres (d'au moins deux éléments), appliquez une transformation linéaire à cette liste, de sorte que le plus petit nombre devienne 0 et le plus grand devienne 1.\n# >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\n#\ndef rescale_to_unit(numbers)", "entry_point": "rescale_to_unit", "test": "\n\narg00 = [2.0, 49.9]\nx0 = rescale_to_unit(arg00)\nv0 = [0.0, 1.0]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [100.0, 49.9]\nx1 = rescale_to_unit(arg10)\nv1 = [1.0, 0.0]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1.0, 2.0, 3.0, 4.0, 5.0]\nx2 = rescale_to_unit(arg20)\nv2 = [0.0, 0.25, 0.5, 0.75, 1.0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [2.0, 1.0, 5.0, 3.0, 4.0]\nx3 = rescale_to_unit(arg30)\nv3 = [0.25, 0.0, 1.0, 0.5, 0.75]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [12.0, 11.0, 15.0, 13.0, 14.0]\nx4 = rescale_to_unit(arg40)\nv4 = [0.25, 0.0, 1.0, 0.5, 0.75]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Étant donné une liste de nombres (d'au moins deux éléments), appliquez une transformation linéaire à cette liste, de sorte que le plus petit nombre devienne 0 et le plus grand devienne 1.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/7", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Pour une chaîne de caractères donnée, inverser les caractères en minuscules en majuscules et les caractères en majuscules en minuscules.\n# >>> flip_case('Hello')\n# 'hELLO'\n#\ndef flip_case(string)", "entry_point": "flip_case", "test": "\n\narg00 = \"\"\nx0 = flip_case(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Hello!\"\nx1 = flip_case(arg10)\nv1 = \"hELLO!\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"These violent delights have violent ends\"\nx2 = flip_case(arg20)\nv2 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "Pour une chaîne de caractères donnée, inverser les caractères en minuscules en majuscules et les caractères en majuscules en minuscules.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/8", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Retourner seulement les nombres positifs dans la liste.\n# >>> get_positive([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\n#\ndef get_positive(l)", "entry_point": "get_positive", "test": "\n\narg00 = [-1, -2, 4, 5, 6]\nx0 = get_positive(arg00)\nv0 = [4, 5, 6]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]\nx1 = get_positive(arg10)\nv1 = [5, 3, 2, 3, 3, 9, 123, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-1, -2]\nx2 = get_positive(arg20)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = []\nx3 = get_positive(arg30)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Retourner seulement les nombres positifs dans la liste.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/9", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Retourne vrai si un nombre donné est premier, et faux sinon.\n# >>> is_prime(6)\n# False\n# >>> is_prime(101)\n# True\n# >>> is_prime(11)\n# True\n# >>> is_prime(13441)\n# True\n# >>> is_prime(61)\n# True\n# >>> is_prime(4)\n# False\n# >>> is_prime(1)\n# False\n#\ndef is_prime(n)", "entry_point": "is_prime", "test": "\n\narg00 = 6\nx0 = is_prime(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 101\nx1 = is_prime(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 11\nx2 = is_prime(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 13441\nx3 = is_prime(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 61\nx4 = is_prime(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 4\nx5 = is_prime(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 1\nx6 = is_prime(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 5\nx7 = is_prime(arg70)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 11\nx8 = is_prime(arg80)\nv8 = true\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 17\nx9 = is_prime(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 85\nx10 = is_prime(arg100)\nv10 = false\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 77\nx11 = is_prime(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 255379\nx12 = is_prime(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\n", "description": "Retourne vrai si un nombre donné est premier, et faux sinon.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/10", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Retourner les éléments uniques triés dans une liste.\n# >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\n#\ndef unique(l)", "entry_point": "unique", "test": "\n\narg00 = [5, 3, 5, 2, 3, 3, 9, 0, 123]\nx0 = unique(arg00)\nv0 = [0, 2, 3, 5, 9, 123]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\n", "description": "Retourner les éléments uniques triés dans une liste.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/11", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # prime_fib renvoie le n-ième nombre qui est à la fois un nombre de Fibonacci et un nombre premier.\n# >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n# 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n# 89\n#\ndef prime_fib(n)", "entry_point": "prime_fib", "test": "\n\narg00 = 1\nx0 = prime_fib(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 2\nx1 = prime_fib(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\nx2 = prime_fib(arg20)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 4\nx3 = prime_fib(arg30)\nv3 = 13\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 5\nx4 = prime_fib(arg40)\nv4 = 89\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 6\nx5 = prime_fib(arg50)\nv5 = 233\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 7\nx6 = prime_fib(arg60)\nv6 = 1597\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 8\nx7 = prime_fib(arg70)\nv7 = 28657\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 9\nx8 = prime_fib(arg80)\nv8 = 514229\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 10\nx9 = prime_fib(arg90)\nv9 = 433494437\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "prime_fib renvoie le n-ième nombre qui est à la fois un nombre de Fibonacci et un nombre premier.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/12", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # triples_sum_to_zero prend une liste d'entiers en entrée.\n#     Elle renvoie True s'il y a trois éléments distincts dans la liste qui\n#     s'additionnent à zéro, et False sinon.\n# >>> triples_sum_to_zero([1, 3, 5, 0])\n# False\n# >>> triples_sum_to_zero([1, 3, -2, 1])\n# True\n# >>> triples_sum_to_zero([1, 2, 3, 7])\n# False\n# >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n# True\n# >>> triples_sum_to_zero([1])\n# False\n#\ndef triples_sum_to_zero(l)", "entry_point": "triples_sum_to_zero", "test": "\n\narg00 = [1, 3, 5, 0]\nx0 = triples_sum_to_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 3, 5, -1]\nx1 = triples_sum_to_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, -2, 1]\nx2 = triples_sum_to_zero(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 2, 3, 7]\nx3 = triples_sum_to_zero(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 5, 7]\nx4 = triples_sum_to_zero(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [2, 4, -5, 3, 9, 7]\nx5 = triples_sum_to_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [1]\nx6 = triples_sum_to_zero(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [1, 3, 5, -100]\nx7 = triples_sum_to_zero(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [100, 3, 5, -100]\nx8 = triples_sum_to_zero(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "triples_sum_to_zero prend une liste d'entiers en entrée.\n    Elle renvoie True s'il y a trois éléments distincts dans la liste qui\n    s'additionnent à zéro, et False sinon.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/13", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # pairs_sum_to_zero prend une liste d'entiers en entrée.\n#     Elle renvoie True s'il y a deux éléments distincts dans la liste qui\n#     s'additionnent à zéro, et False sinon.\n# >>> pairs_sum_to_zero([1, 3, 5, 0])\n# False\n# >>> pairs_sum_to_zero([1, 3, -2, 1])\n# False\n# >>> pairs_sum_to_zero([1, 2, 3, 7])\n# False\n# >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n# True\n# >>> pairs_sum_to_zero([1])\n# False\n#\ndef pairs_sum_to_zero(l)", "entry_point": "pairs_sum_to_zero", "test": "\n\narg00 = [1, 3, 5, 0]\nx0 = pairs_sum_to_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 3, -2, 1]\nx1 = pairs_sum_to_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, 3, 7]\nx2 = pairs_sum_to_zero(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [2, 4, -5, 3, 5, 7]\nx3 = pairs_sum_to_zero(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\nx4 = pairs_sum_to_zero(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [-3, 9, -1, 3, 2, 30]\nx5 = pairs_sum_to_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-3, 9, -1, 3, 2, 31]\nx6 = pairs_sum_to_zero(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-3, 9, -1, 4, 2, 30]\nx7 = pairs_sum_to_zero(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-3, 9, -1, 4, 2, 31]\nx8 = pairs_sum_to_zero(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "pairs_sum_to_zero prend une liste d'entiers en entrée.\n    Elle renvoie True s'il y a deux éléments distincts dans la liste qui\n    s'additionnent à zéro, et False sinon.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/14", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# La séquence de nombres Fib4 est une séquence similaire à la séquence de Fibonacci définie comme suit:\n#     fib4(0) -> 0\n#     fib4(1) -> 0\n#     fib4(2) -> 2\n#     fib4(3) -> 0\n#     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n#     Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres Fib4. N'utilisez pas la récursivité.\n# >>> fib4(5)\n# 4\n# >>> fib4(6)\n# 8\n# >>> fib4(7)\n# 14\n#\ndef fib4(n)", "entry_point": "fib4", "test": "\n\narg00 = 5\nx0 = fib4(arg00)\nv0 = 4\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 8\nx1 = fib4(arg10)\nv1 = 28\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\nx2 = fib4(arg20)\nv2 = 104\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 12\nx3 = fib4(arg30)\nv3 = 386\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "La séquence de nombres Fib4 est une séquence similaire à la séquence de Fibonacci définie comme suit:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres Fib4. N'utilisez pas la récursivité.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/15", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Retourne la médiane des éléments de la liste l.\n# >>> median([3, 1, 2, 4, 5])\n# 3\n# >>> median([-10, 4, 6, 1000, 10, 20])\n# 15.0\n#\ndef median(l)", "entry_point": "median", "test": "\n\narg00 = [3, 1, 2, 4, 5]\nx0 = median(arg00)\nv0 = 3\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [-10, 4, 6, 1000, 10, 20]\nx1 = median(arg10)\nv1 = 8.0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [5]\nx2 = median(arg20)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [6, 5]\nx3 = median(arg30)\nv3 = 5.5\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [8, 1, 3, 9, 9, 2, 7]\nx4 = median(arg40)\nv4 = 7\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Retourne la médiane des éléments de la liste l.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/16", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Vérifie si la chaîne de caractères donnée est un palindrome.\n# >>> is_palindrome('')\n# True\n# >>> is_palindrome('aba')\n# True\n# >>> is_palindrome('aaaaa')\n# True\n# >>> is_palindrome('zbcd')\n# False\n#\ndef is_palindrome(text)", "entry_point": "is_palindrome", "test": "\n\narg00 = \"\"\nx0 = is_palindrome(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"aba\"\nx1 = is_palindrome(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"aaaaa\"\nx2 = is_palindrome(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"zbcd\"\nx3 = is_palindrome(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"xywyx\"\nx4 = is_palindrome(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"xywyz\"\nx5 = is_palindrome(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"xywzx\"\nx6 = is_palindrome(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Vérifie si la chaîne de caractères donnée est un palindrome.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/17", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # remove_vowels est une fonction qui prend une chaîne de caractères et renvoie une chaîne de caractères sans voyelles.\n# >>> remove_vowels('')\n# ''\n# >>> remove_vowels(\"abcdef\\nghijklm\")\n# 'bcdf\\nghjklm'\n# >>> remove_vowels('abcdef')\n# 'bcdf'\n# >>> remove_vowels('aaaaa')\n# ''\n# >>> remove_vowels('aaBAA')\n# 'B'\n# >>> remove_vowels('zbcd')\n# 'zbcd'\n#\ndef remove_vowels(text)", "entry_point": "remove_vowels", "test": "\n\narg00 = \"\"\nx0 = remove_vowels(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdef\\nghijklm\"\nx1 = remove_vowels(arg10)\nv1 = \"bcdf\\nghjklm\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"fedcba\"\nx2 = remove_vowels(arg20)\nv2 = \"fdcb\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"eeeee\"\nx3 = remove_vowels(arg30)\nv3 = \"\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"acBAA\"\nx4 = remove_vowels(arg40)\nv4 = \"cB\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"EcBOO\"\nx5 = remove_vowels(arg50)\nv5 = \"cB\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"ybcd\"\nx6 = remove_vowels(arg60)\nv6 = \"ybcd\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "remove_vowels est une fonction qui prend une chaîne de caractères et renvoie une chaîne de caractères sans voyelles.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/18", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Retourne True si tous les nombres de la liste l sont en dessous du seuil t.\n# >>> below_threshold([1, 2, 4, 10], 100)\n# True\n# >>> below_threshold([1, 20, 4, 10], 5)\n# False\n#\ndef below_threshold(l, t)", "entry_point": "below_threshold", "test": "\n\narg00 = [1, 2, 4, 10]\narg01 = 100\nx0 = below_threshold(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 20, 4, 10]\narg11 = 5\nx1 = below_threshold(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 20, 4, 10]\narg21 = 21\nx2 = below_threshold(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 20, 4, 10]\narg31 = 22\nx3 = below_threshold(arg30, arg31)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 8, 4, 10]\narg41 = 11\nx4 = below_threshold(arg40, arg41)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 8, 4, 10]\narg51 = 10\nx5 = below_threshold(arg50, arg51)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Retourne True si tous les nombres de la liste l sont en dessous du seuil t.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/19", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Ajouter deux nombres x et y\n# >>> add(2, 3)\n# 5\n# >>> add(5, 7)\n# 12\n#\ndef add(x, y)", "entry_point": "add", "test": "\n\narg00 = 0\narg01 = 1\nx0 = add(arg00, arg01)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 0\nx1 = add(arg10, arg11)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 2\narg21 = 3\nx2 = add(arg20, arg21)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5\narg31 = 7\nx3 = add(arg30, arg31)\nv3 = 12\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\narg41 = 5\nx4 = add(arg40, arg41)\nv4 = 12\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 572\narg51 = 725\nx5 = add(arg50, arg51)\nv5 = 1297\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 51\narg61 = 804\nx6 = add(arg60, arg61)\nv6 = 855\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 645\narg71 = 96\nx7 = add(arg70, arg71)\nv7 = 741\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 712\narg81 = 853\nx8 = add(arg80, arg81)\nv8 = 1565\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 223\narg91 = 101\nx9 = add(arg90, arg91)\nv9 = 324\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 76\narg101 = 29\nx10 = add(arg100, arg101)\nv10 = 105\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 416\narg111 = 149\nx11 = add(arg110, arg111)\nv11 = 565\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 145\narg121 = 409\nx12 = add(arg120, arg121)\nv12 = 554\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = 535\narg131 = 430\nx13 = add(arg130, arg131)\nv13 = 965\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = 118\narg141 = 303\nx14 = add(arg140, arg141)\nv14 = 421\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = 287\narg151 = 94\nx15 = add(arg150, arg151)\nv15 = 381\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\narg160 = 768\narg161 = 257\nx16 = add(arg160, arg161)\nv16 = 1025\nif x16 != v16\n    raise StandardError, \"Error at test case 17\"\nend\n\narg170 = 421\narg171 = 677\nx17 = add(arg170, arg171)\nv17 = 1098\nif x17 != v17\n    raise StandardError, \"Error at test case 18\"\nend\n\narg180 = 802\narg181 = 814\nx18 = add(arg180, arg181)\nv18 = 1616\nif x18 != v18\n    raise StandardError, \"Error at test case 19\"\nend\n\narg190 = 510\narg191 = 922\nx19 = add(arg190, arg191)\nv19 = 1432\nif x19 != v19\n    raise StandardError, \"Error at test case 20\"\nend\n\narg200 = 345\narg201 = 819\nx20 = add(arg200, arg201)\nv20 = 1164\nif x20 != v20\n    raise StandardError, \"Error at test case 21\"\nend\n\narg210 = 895\narg211 = 436\nx21 = add(arg210, arg211)\nv21 = 1331\nif x21 != v21\n    raise StandardError, \"Error at test case 22\"\nend\n\narg220 = 123\narg221 = 424\nx22 = add(arg220, arg221)\nv22 = 547\nif x22 != v22\n    raise StandardError, \"Error at test case 23\"\nend\n\narg230 = 923\narg231 = 245\nx23 = add(arg230, arg231)\nv23 = 1168\nif x23 != v23\n    raise StandardError, \"Error at test case 24\"\nend\n\narg240 = 23\narg241 = 438\nx24 = add(arg240, arg241)\nv24 = 461\nif x24 != v24\n    raise StandardError, \"Error at test case 25\"\nend\n\narg250 = 565\narg251 = 133\nx25 = add(arg250, arg251)\nv25 = 698\nif x25 != v25\n    raise StandardError, \"Error at test case 26\"\nend\n\narg260 = 945\narg261 = 925\nx26 = add(arg260, arg261)\nv26 = 1870\nif x26 != v26\n    raise StandardError, \"Error at test case 27\"\nend\n\narg270 = 261\narg271 = 983\nx27 = add(arg270, arg271)\nv27 = 1244\nif x27 != v27\n    raise StandardError, \"Error at test case 28\"\nend\n\narg280 = 139\narg281 = 577\nx28 = add(arg280, arg281)\nv28 = 716\nif x28 != v28\n    raise StandardError, \"Error at test case 29\"\nend\n\narg290 = 763\narg291 = 178\nx29 = add(arg290, arg291)\nv29 = 941\nif x29 != v29\n    raise StandardError, \"Error at test case 30\"\nend\n\narg300 = 147\narg301 = 892\nx30 = add(arg300, arg301)\nv30 = 1039\nif x30 != v30\n    raise StandardError, \"Error at test case 31\"\nend\n\narg310 = 436\narg311 = 402\nx31 = add(arg310, arg311)\nv31 = 838\nif x31 != v31\n    raise StandardError, \"Error at test case 32\"\nend\n\narg320 = 610\narg321 = 581\nx32 = add(arg320, arg321)\nv32 = 1191\nif x32 != v32\n    raise StandardError, \"Error at test case 33\"\nend\n\narg330 = 103\narg331 = 416\nx33 = add(arg330, arg331)\nv33 = 519\nif x33 != v33\n    raise StandardError, \"Error at test case 34\"\nend\n\narg340 = 339\narg341 = 990\nx34 = add(arg340, arg341)\nv34 = 1329\nif x34 != v34\n    raise StandardError, \"Error at test case 35\"\nend\n\narg350 = 130\narg351 = 504\nx35 = add(arg350, arg351)\nv35 = 634\nif x35 != v35\n    raise StandardError, \"Error at test case 36\"\nend\n\narg360 = 242\narg361 = 717\nx36 = add(arg360, arg361)\nv36 = 959\nif x36 != v36\n    raise StandardError, \"Error at test case 37\"\nend\n\narg370 = 562\narg371 = 110\nx37 = add(arg370, arg371)\nv37 = 672\nif x37 != v37\n    raise StandardError, \"Error at test case 38\"\nend\n\narg380 = 396\narg381 = 909\nx38 = add(arg380, arg381)\nv38 = 1305\nif x38 != v38\n    raise StandardError, \"Error at test case 39\"\nend\n\narg390 = 887\narg391 = 703\nx39 = add(arg390, arg391)\nv39 = 1590\nif x39 != v39\n    raise StandardError, \"Error at test case 40\"\nend\n\narg400 = 870\narg401 = 551\nx40 = add(arg400, arg401)\nv40 = 1421\nif x40 != v40\n    raise StandardError, \"Error at test case 41\"\nend\n\narg410 = 422\narg411 = 391\nx41 = add(arg410, arg411)\nv41 = 813\nif x41 != v41\n    raise StandardError, \"Error at test case 42\"\nend\n\narg420 = 299\narg421 = 505\nx42 = add(arg420, arg421)\nv42 = 804\nif x42 != v42\n    raise StandardError, \"Error at test case 43\"\nend\n\narg430 = 346\narg431 = 56\nx43 = add(arg430, arg431)\nv43 = 402\nif x43 != v43\n    raise StandardError, \"Error at test case 44\"\nend\n\narg440 = 36\narg441 = 706\nx44 = add(arg440, arg441)\nv44 = 742\nif x44 != v44\n    raise StandardError, \"Error at test case 45\"\nend\n\narg450 = 738\narg451 = 411\nx45 = add(arg450, arg451)\nv45 = 1149\nif x45 != v45\n    raise StandardError, \"Error at test case 46\"\nend\n\narg460 = 679\narg461 = 87\nx46 = add(arg460, arg461)\nv46 = 766\nif x46 != v46\n    raise StandardError, \"Error at test case 47\"\nend\n\narg470 = 25\narg471 = 303\nx47 = add(arg470, arg471)\nv47 = 328\nif x47 != v47\n    raise StandardError, \"Error at test case 48\"\nend\n\narg480 = 161\narg481 = 612\nx48 = add(arg480, arg481)\nv48 = 773\nif x48 != v48\n    raise StandardError, \"Error at test case 49\"\nend\n\narg490 = 306\narg491 = 841\nx49 = add(arg490, arg491)\nv49 = 1147\nif x49 != v49\n    raise StandardError, \"Error at test case 50\"\nend\n\narg500 = 973\narg501 = 411\nx50 = add(arg500, arg501)\nv50 = 1384\nif x50 != v50\n    raise StandardError, \"Error at test case 51\"\nend\n\narg510 = 711\narg511 = 157\nx51 = add(arg510, arg511)\nv51 = 868\nif x51 != v51\n    raise StandardError, \"Error at test case 52\"\nend\n\narg520 = 471\narg521 = 27\nx52 = add(arg520, arg521)\nv52 = 498\nif x52 != v52\n    raise StandardError, \"Error at test case 53\"\nend\n\narg530 = 714\narg531 = 792\nx53 = add(arg530, arg531)\nv53 = 1506\nif x53 != v53\n    raise StandardError, \"Error at test case 54\"\nend\n\narg540 = 38\narg541 = 206\nx54 = add(arg540, arg541)\nv54 = 244\nif x54 != v54\n    raise StandardError, \"Error at test case 55\"\nend\n\narg550 = 907\narg551 = 343\nx55 = add(arg550, arg551)\nv55 = 1250\nif x55 != v55\n    raise StandardError, \"Error at test case 56\"\nend\n\narg560 = 23\narg561 = 760\nx56 = add(arg560, arg561)\nv56 = 783\nif x56 != v56\n    raise StandardError, \"Error at test case 57\"\nend\n\narg570 = 524\narg571 = 859\nx57 = add(arg570, arg571)\nv57 = 1383\nif x57 != v57\n    raise StandardError, \"Error at test case 58\"\nend\n\narg580 = 30\narg581 = 529\nx58 = add(arg580, arg581)\nv58 = 559\nif x58 != v58\n    raise StandardError, \"Error at test case 59\"\nend\n\narg590 = 341\narg591 = 691\nx59 = add(arg590, arg591)\nv59 = 1032\nif x59 != v59\n    raise StandardError, \"Error at test case 60\"\nend\n\narg600 = 167\narg601 = 729\nx60 = add(arg600, arg601)\nv60 = 896\nif x60 != v60\n    raise StandardError, \"Error at test case 61\"\nend\n\narg610 = 636\narg611 = 289\nx61 = add(arg610, arg611)\nv61 = 925\nif x61 != v61\n    raise StandardError, \"Error at test case 62\"\nend\n\narg620 = 503\narg621 = 144\nx62 = add(arg620, arg621)\nv62 = 647\nif x62 != v62\n    raise StandardError, \"Error at test case 63\"\nend\n\narg630 = 51\narg631 = 985\nx63 = add(arg630, arg631)\nv63 = 1036\nif x63 != v63\n    raise StandardError, \"Error at test case 64\"\nend\n\narg640 = 287\narg641 = 149\nx64 = add(arg640, arg641)\nv64 = 436\nif x64 != v64\n    raise StandardError, \"Error at test case 65\"\nend\n\narg650 = 659\narg651 = 75\nx65 = add(arg650, arg651)\nv65 = 734\nif x65 != v65\n    raise StandardError, \"Error at test case 66\"\nend\n\narg660 = 462\narg661 = 797\nx66 = add(arg660, arg661)\nv66 = 1259\nif x66 != v66\n    raise StandardError, \"Error at test case 67\"\nend\n\narg670 = 406\narg671 = 141\nx67 = add(arg670, arg671)\nv67 = 547\nif x67 != v67\n    raise StandardError, \"Error at test case 68\"\nend\n\narg680 = 106\narg681 = 44\nx68 = add(arg680, arg681)\nv68 = 150\nif x68 != v68\n    raise StandardError, \"Error at test case 69\"\nend\n\narg690 = 300\narg691 = 934\nx69 = add(arg690, arg691)\nv69 = 1234\nif x69 != v69\n    raise StandardError, \"Error at test case 70\"\nend\n\narg700 = 471\narg701 = 524\nx70 = add(arg700, arg701)\nv70 = 995\nif x70 != v70\n    raise StandardError, \"Error at test case 71\"\nend\n\narg710 = 122\narg711 = 429\nx71 = add(arg710, arg711)\nv71 = 551\nif x71 != v71\n    raise StandardError, \"Error at test case 72\"\nend\n\narg720 = 735\narg721 = 195\nx72 = add(arg720, arg721)\nv72 = 930\nif x72 != v72\n    raise StandardError, \"Error at test case 73\"\nend\n\narg730 = 335\narg731 = 484\nx73 = add(arg730, arg731)\nv73 = 819\nif x73 != v73\n    raise StandardError, \"Error at test case 74\"\nend\n\narg740 = 28\narg741 = 809\nx74 = add(arg740, arg741)\nv74 = 837\nif x74 != v74\n    raise StandardError, \"Error at test case 75\"\nend\n\narg750 = 430\narg751 = 20\nx75 = add(arg750, arg751)\nv75 = 450\nif x75 != v75\n    raise StandardError, \"Error at test case 76\"\nend\n\narg760 = 916\narg761 = 635\nx76 = add(arg760, arg761)\nv76 = 1551\nif x76 != v76\n    raise StandardError, \"Error at test case 77\"\nend\n\narg770 = 301\narg771 = 999\nx77 = add(arg770, arg771)\nv77 = 1300\nif x77 != v77\n    raise StandardError, \"Error at test case 78\"\nend\n\narg780 = 454\narg781 = 466\nx78 = add(arg780, arg781)\nv78 = 920\nif x78 != v78\n    raise StandardError, \"Error at test case 79\"\nend\n\narg790 = 905\narg791 = 259\nx79 = add(arg790, arg791)\nv79 = 1164\nif x79 != v79\n    raise StandardError, \"Error at test case 80\"\nend\n\narg800 = 168\narg801 = 205\nx80 = add(arg800, arg801)\nv80 = 373\nif x80 != v80\n    raise StandardError, \"Error at test case 81\"\nend\n\narg810 = 570\narg811 = 434\nx81 = add(arg810, arg811)\nv81 = 1004\nif x81 != v81\n    raise StandardError, \"Error at test case 82\"\nend\n\narg820 = 64\narg821 = 959\nx82 = add(arg820, arg821)\nv82 = 1023\nif x82 != v82\n    raise StandardError, \"Error at test case 83\"\nend\n\narg830 = 957\narg831 = 510\nx83 = add(arg830, arg831)\nv83 = 1467\nif x83 != v83\n    raise StandardError, \"Error at test case 84\"\nend\n\narg840 = 722\narg841 = 598\nx84 = add(arg840, arg841)\nv84 = 1320\nif x84 != v84\n    raise StandardError, \"Error at test case 85\"\nend\n\narg850 = 770\narg851 = 226\nx85 = add(arg850, arg851)\nv85 = 996\nif x85 != v85\n    raise StandardError, \"Error at test case 86\"\nend\n\narg860 = 579\narg861 = 66\nx86 = add(arg860, arg861)\nv86 = 645\nif x86 != v86\n    raise StandardError, \"Error at test case 87\"\nend\n\narg870 = 117\narg871 = 674\nx87 = add(arg870, arg871)\nv87 = 791\nif x87 != v87\n    raise StandardError, \"Error at test case 88\"\nend\n\narg880 = 530\narg881 = 30\nx88 = add(arg880, arg881)\nv88 = 560\nif x88 != v88\n    raise StandardError, \"Error at test case 89\"\nend\n\narg890 = 776\narg891 = 345\nx89 = add(arg890, arg891)\nv89 = 1121\nif x89 != v89\n    raise StandardError, \"Error at test case 90\"\nend\n\narg900 = 327\narg901 = 389\nx90 = add(arg900, arg901)\nv90 = 716\nif x90 != v90\n    raise StandardError, \"Error at test case 91\"\nend\n\narg910 = 596\narg911 = 12\nx91 = add(arg910, arg911)\nv91 = 608\nif x91 != v91\n    raise StandardError, \"Error at test case 92\"\nend\n\narg920 = 599\narg921 = 511\nx92 = add(arg920, arg921)\nv92 = 1110\nif x92 != v92\n    raise StandardError, \"Error at test case 93\"\nend\n\narg930 = 936\narg931 = 476\nx93 = add(arg930, arg931)\nv93 = 1412\nif x93 != v93\n    raise StandardError, \"Error at test case 94\"\nend\n\narg940 = 461\narg941 = 14\nx94 = add(arg940, arg941)\nv94 = 475\nif x94 != v94\n    raise StandardError, \"Error at test case 95\"\nend\n\narg950 = 966\narg951 = 157\nx95 = add(arg950, arg951)\nv95 = 1123\nif x95 != v95\n    raise StandardError, \"Error at test case 96\"\nend\n\narg960 = 326\narg961 = 91\nx96 = add(arg960, arg961)\nv96 = 417\nif x96 != v96\n    raise StandardError, \"Error at test case 97\"\nend\n\narg970 = 392\narg971 = 455\nx97 = add(arg970, arg971)\nv97 = 847\nif x97 != v97\n    raise StandardError, \"Error at test case 98\"\nend\n\narg980 = 446\narg981 = 477\nx98 = add(arg980, arg981)\nv98 = 923\nif x98 != v98\n    raise StandardError, \"Error at test case 99\"\nend\n\narg990 = 324\narg991 = 860\nx99 = add(arg990, arg991)\nv99 = 1184\nif x99 != v99\n    raise StandardError, \"Error at test case 100\"\nend\n\narg1000 = 945\narg1001 = 85\nx100 = add(arg1000, arg1001)\nv100 = 1030\nif x100 != v100\n    raise StandardError, \"Error at test case 101\"\nend\n\narg1010 = 886\narg1011 = 582\nx101 = add(arg1010, arg1011)\nv101 = 1468\nif x101 != v101\n    raise StandardError, \"Error at test case 102\"\nend\n\narg1020 = 886\narg1021 = 712\nx102 = add(arg1020, arg1021)\nv102 = 1598\nif x102 != v102\n    raise StandardError, \"Error at test case 103\"\nend\n\narg1030 = 842\narg1031 = 953\nx103 = add(arg1030, arg1031)\nv103 = 1795\nif x103 != v103\n    raise StandardError, \"Error at test case 104\"\nend\n\n", "description": "Ajouter deux nombres x et y", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/20", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Vérifiez si deux mots ont les mêmes caractères.\n# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n# True\n# >>> same_chars('abcd', 'dddddddabc')\n# True\n# >>> same_chars('dddddddabc', 'abcd')\n# True\n# >>> same_chars('eabcd', 'dddddddabc')\n# False\n# >>> same_chars('abcd', 'dddddddabce')\n# False\n# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n# False\n#\ndef same_chars(s0, s1)", "entry_point": "same_chars", "test": "\n\narg00 = \"eabcdzzzz\"\narg01 = \"dddzzzzzzzddeddabc\"\nx0 = same_chars(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcd\"\narg11 = \"dddddddabc\"\nx1 = same_chars(arg10, arg11)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"dddddddabc\"\narg21 = \"abcd\"\nx2 = same_chars(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"eabcd\"\narg31 = \"dddddddabc\"\nx3 = same_chars(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"abcd\"\narg41 = \"dddddddabcf\"\nx4 = same_chars(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"eabcdzzzz\"\narg51 = \"dddzzzzzzzddddabc\"\nx5 = same_chars(arg50, arg51)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"aabb\"\narg61 = \"aaccc\"\nx6 = same_chars(arg60, arg61)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Vérifiez si deux mots ont les mêmes caractères.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/21", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Retourne le n-ième nombre de Fibonacci.\n# >>> fib(10)\n# 55\n# >>> fib(1)\n# 1\n# >>> fib(8)\n# 21\n#\ndef fib(n)", "entry_point": "fib", "test": "\n\narg00 = 10\nx0 = fib(arg00)\nv0 = 55\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\nx1 = fib(arg10)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 8\nx2 = fib(arg20)\nv2 = 21\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 11\nx3 = fib(arg30)\nv3 = 89\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 12\nx4 = fib(arg40)\nv4 = 144\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Retourne le n-ième nombre de Fibonacci.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/22", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Retourne les éléments communs uniques triés pour deux listes.\n# >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5, 3, 2, 8], [3, 2])\n# [2, 3]\n\n#\ndef common(l1, l2)", "entry_point": "common", "test": "\n\narg00 = [1, 4, 3, 34, 653, 2, 5]\narg01 = [5, 7, 1, 5, 9, 653, 121]\nx0 = common(arg00, arg01)\nv0 = [1, 5, 653]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 3, 2, 8]\narg11 = [3, 2]\nx1 = common(arg10, arg11)\nv1 = [2, 3]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [4, 3, 2, 8]\narg21 = [3, 2, 4]\nx2 = common(arg20, arg21)\nv2 = [2, 3, 4]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 3, 2, 8]\narg31 = []\nx3 = common(arg30, arg31)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Retourne les éléments communs uniques triés pour deux listes.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/23", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Retourne le plus grand facteur premier de n. Supposons que n > 1 et n'est pas un nombre premier.\n# >>> largest_prime_factor(13195)\n# 29\n# >>> largest_prime_factor(2048)\n# 2\n#\ndef largest_prime_factor(n)", "entry_point": "largest_prime_factor", "test": "\n\narg00 = 15\nx0 = largest_prime_factor(arg00)\nv0 = 5\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 27\nx1 = largest_prime_factor(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 63\nx2 = largest_prime_factor(arg20)\nv2 = 7\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 330\nx3 = largest_prime_factor(arg30)\nv3 = 11\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 13195\nx4 = largest_prime_factor(arg40)\nv4 = 29\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Retourne le plus grand facteur premier de n. Supposons que n > 1 et n'est pas un nombre premier.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/24", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# sum_to_n est une fonction qui additionne les nombres de 1 à n.\n# >>> sum_to_n(30)\n# 465\n# >>> sum_to_n(100)\n# 5050\n# >>> sum_to_n(5)\n# 15\n# >>> sum_to_n(10)\n# 55\n# >>> sum_to_n(1)\n# 1\n#\ndef sum_to_n(n)", "entry_point": "sum_to_n", "test": "\n\narg00 = 1\nx0 = sum_to_n(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 6\nx1 = sum_to_n(arg10)\nv1 = 21\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 11\nx2 = sum_to_n(arg20)\nv2 = 66\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 30\nx3 = sum_to_n(arg30)\nv3 = 465\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 100\nx4 = sum_to_n(arg40)\nv4 = 5050\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "sum_to_n est une fonction qui additionne les nombres de 1 à n.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/25", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# xs représente les coefficients d'un polynôme.\n#     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n#      Renvoyer la dérivée de ce polynôme sous la même forme.\n# >>> derivative([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative([1, 2, 3])\n# [2, 6]\n#\ndef derivative(xs)", "entry_point": "derivative", "test": "\n\narg00 = [3, 1, 2, 4, 5]\nx0 = derivative(arg00)\nv0 = [1, 4, 12, 20]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 3]\nx1 = derivative(arg10)\nv1 = [2, 6]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3, 2, 1]\nx2 = derivative(arg20)\nv2 = [2, 2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 2, 1, 0, 4]\nx3 = derivative(arg30)\nv3 = [2, 2, 0, 16]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\nx4 = derivative(arg40)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "xs représente les coefficients d'un polynôme.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Renvoyer la dérivée de ce polynôme sous la même forme.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/26", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# La séquence de nombres FibFib est une séquence similaire à la séquence de Fibonacci définie comme suit :\n#     fibfib(0) == 0\n#     fibfib(1) == 0\n#     fibfib(2) == 1\n#     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n#     Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres FibFib.\n# >>> fibfib(1)\n# 0\n# >>> fibfib(5)\n# 4\n# >>> fibfib(8)\n# 24\n#\ndef fibfib(n)", "entry_point": "fibfib", "test": "\n\narg00 = 2\nx0 = fibfib(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\nx1 = fibfib(arg10)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = fibfib(arg20)\nv2 = 4\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 8\nx3 = fibfib(arg30)\nv3 = 24\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 10\nx4 = fibfib(arg40)\nv4 = 81\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 12\nx5 = fibfib(arg50)\nv5 = 274\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 14\nx6 = fibfib(arg60)\nv6 = 927\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "La séquence de nombres FibFib est une séquence similaire à la séquence de Fibonacci définie comme suit :\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres FibFib.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/27", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Écrivez une fonction vowels_count qui prend une chaîne de caractères représentant un mot en entrée et renvoie le nombre de voyelles dans la chaîne. Les voyelles dans ce cas sont 'a', 'e', 'i', 'o', 'u'. Ici, 'y' est également une voyelle, mais seulement lorsqu'elle est à la fin du mot donné.\n# \n# Exemple :\n# >>> vowels_count(\"abcde\")\n# 2\n# >>> vowels_count(\"ACEDY\")\n# 3\n#\ndef vowels_count(s)", "entry_point": "vowels_count", "test": "\n\narg00 = \"abcde\"\nx0 = vowels_count(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Alone\"\nx1 = vowels_count(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"key\"\nx2 = vowels_count(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"bye\"\nx3 = vowels_count(arg30)\nv3 = 1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"keY\"\nx4 = vowels_count(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"bYe\"\nx5 = vowels_count(arg50)\nv5 = 1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"ACEDY\"\nx6 = vowels_count(arg60)\nv6 = 3\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Écrivez une fonction vowels_count qui prend une chaîne de caractères représentant un mot en entrée et renvoie le nombre de voyelles dans la chaîne. Les voyelles dans ce cas sont 'a', 'e', 'i', 'o', 'u'. Ici, 'y' est également une voyelle, mais seulement lorsqu'elle est à la fin du mot donné.\n\nExemple :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/28", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Vous disposez d'une liste non vide d'entiers positifs. Renvoyez l'entier le plus grand qui est supérieur à zéro et dont la fréquence est supérieure ou égale à la valeur de l'entier lui-même. La fréquence d'un entier est le nombre de fois où il apparaît dans la liste. Si aucune valeur de ce type n'existe, renvoyez -1. Exemples :\n# \n#     search([4, 1, 2, 2, 3, 1]) == 2\n#     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n#     search([5, 5, 4, 4, 4]) == -1\n#\ndef search(lst)", "entry_point": "search", "test": "\n\narg00 = [5, 5, 5, 5, 1]\nx0 = search(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [4, 1, 4, 1, 4, 4]\nx1 = search(arg10)\nv1 = 4\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3, 3]\nx2 = search(arg20)\nv2 = -1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [8, 8, 8, 8, 8, 8, 8, 8]\nx3 = search(arg30)\nv3 = 8\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [2, 3, 3, 2, 2]\nx4 = search(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]\nx5 = search(arg50)\nv5 = 1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [3, 2, 8, 2]\nx6 = search(arg60)\nv6 = 2\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]\nx7 = search(arg70)\nv7 = 1\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [8, 8, 3, 6, 5, 6, 4]\nx8 = search(arg80)\nv8 = -1\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]\nx9 = search(arg90)\nv9 = 1\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [1, 9, 10, 1, 3]\nx10 = search(arg100)\nv10 = 1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]\nx11 = search(arg110)\nv11 = 5\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = [1]\nx12 = search(arg120)\nv12 = 1\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]\nx13 = search(arg130)\nv13 = 4\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]\nx14 = search(arg140)\nv14 = 2\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]\nx15 = search(arg150)\nv15 = 1\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\narg160 = [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]\nx16 = search(arg160)\nv16 = 4\nif x16 != v16\n    raise StandardError, \"Error at test case 17\"\nend\n\narg170 = [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]\nx17 = search(arg170)\nv17 = 4\nif x17 != v17\n    raise StandardError, \"Error at test case 18\"\nend\n\narg180 = [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]\nx18 = search(arg180)\nv18 = 2\nif x18 != v18\n    raise StandardError, \"Error at test case 19\"\nend\n\narg190 = [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]\nx19 = search(arg190)\nv19 = -1\nif x19 != v19\n    raise StandardError, \"Error at test case 20\"\nend\n\narg200 = [10]\nx20 = search(arg200)\nv20 = -1\nif x20 != v20\n    raise StandardError, \"Error at test case 21\"\nend\n\narg210 = [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]\nx21 = search(arg210)\nv21 = 2\nif x21 != v21\n    raise StandardError, \"Error at test case 22\"\nend\n\narg220 = [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]\nx22 = search(arg220)\nv22 = 1\nif x22 != v22\n    raise StandardError, \"Error at test case 23\"\nend\n\narg230 = [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]\nx23 = search(arg230)\nv23 = 1\nif x23 != v23\n    raise StandardError, \"Error at test case 24\"\nend\n\narg240 = [3, 10, 10, 9, 2]\nx24 = search(arg240)\nv24 = -1\nif x24 != v24\n    raise StandardError, \"Error at test case 25\"\nend\n\n", "description": "Vous disposez d'une liste non vide d'entiers positifs. Renvoyez l'entier le plus grand qui est supérieur à zéro et dont la fréquence est supérieure ou égale à la valeur de l'entier lui-même. La fréquence d'un entier est le nombre de fois où il apparaît dans la liste. Si aucune valeur de ce type n'existe, renvoyez -1. Exemples :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/29", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Étant donné les longueurs des trois côtés d'un triangle. Renvoyer l'aire du triangle arrondie à 2 décimales si les trois côtés forment un triangle valide. Sinon, retourner -1. Trois côtés forment un triangle valide lorsque la somme de deux côtés est supérieure au troisième côté. Exemple :\n# \n# triangle_area(3, 4, 5) == 6.00\n# triangle_area(1, 2, 10) == -1\n#\ndef triangle_area(a, b, c)", "entry_point": "triangle_area", "test": "\n\narg00 = 3\narg01 = 4\narg02 = 5\nx0 = triangle_area(arg00, arg01, arg02)\nv0 = 6.0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 2\narg12 = 10\nx1 = triangle_area(arg10, arg11, arg12)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 4\narg21 = 8\narg22 = 5\nx2 = triangle_area(arg20, arg21, arg22)\nv2 = 8.18\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 2\narg31 = 2\narg32 = 2\nx3 = triangle_area(arg30, arg31, arg32)\nv3 = 1.73\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 1\narg41 = 2\narg42 = 3\nx4 = triangle_area(arg40, arg41, arg42)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 10\narg51 = 5\narg52 = 7\nx5 = triangle_area(arg50, arg51, arg52)\nv5 = 16.25\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 2\narg61 = 6\narg62 = 3\nx6 = triangle_area(arg60, arg61, arg62)\nv6 = -1\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 1\narg71 = 1\narg72 = 1\nx7 = triangle_area(arg70, arg71, arg72)\nv7 = 0.43\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 2\narg81 = 2\narg82 = 10\nx8 = triangle_area(arg80, arg81, arg82)\nv8 = -1\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "Étant donné les longueurs des trois côtés d'un triangle. Renvoyer l'aire du triangle arrondie à 2 décimales si les trois côtés forment un triangle valide. Sinon, retourner -1. Trois côtés forment un triangle valide lorsque la somme de deux côtés est supérieure au troisième côté. Exemple :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/30", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Écrivez une fonction qui renvoie True si l'objet q va voler, et False sinon.\n#     L'objet q volera s'il est équilibré (c'est une liste palindromique) et que la somme de ses éléments est inférieure ou égale au poids maximum possible w.\n# \n#     Exemple:\n#     will_it_fly([1, 2], 5) ➞ False \n#     # 1+2 est inférieur au poids maximum possible, mais c'est déséquilibré.\n# \n#     will_it_fly([3, 2, 3], 1) ➞ False\n#     # c'est équilibré, mais 3+2+3 est plus que le poids maximum possible.\n# \n#     will_it_fly([3, 2, 3], 9) ➞ True\n#     # 3+2+3 est inférieur au poids maximum possible, et c'est équilibré.\n# \n#     will_it_fly([3], 5) ➞ True\n#     # 3 est inférieur au poids maximum possible, et c'est équilibré.\n# \n#\ndef will_it_fly(q, w)", "entry_point": "will_it_fly", "test": "\n\narg00 = [3, 2, 3]\narg01 = 9\nx0 = will_it_fly(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2]\narg11 = 5\nx1 = will_it_fly(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3]\narg21 = 5\nx2 = will_it_fly(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 2, 3]\narg31 = 1\nx3 = will_it_fly(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 3]\narg41 = 6\nx4 = will_it_fly(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [5]\narg51 = 5\nx5 = will_it_fly(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Écrivez une fonction qui renvoie True si l'objet q va voler, et False sinon.\n    L'objet q volera s'il est équilibré (c'est une liste palindromique) et que la somme de ses éléments est inférieure ou égale au poids maximum possible w.\n\n    Exemple:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 est inférieur au poids maximum possible, mais c'est déséquilibré.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # c'est équilibré, mais 3+2+3 est plus que le poids maximum possible.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 est inférieur au poids maximum possible, et c'est équilibré.\n\n    will_it_fly([3], 5) ➞ True\n    # 3 est inférieur au poids maximum possible, et c'est équilibré.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/31", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Écrivez une fonction qui renvoie vrai si le nombre donné est le produit de 3 nombres premiers\n#     et faux sinon.\n#     Sachant que (a) est inférieur à 100.\n#     Exemple:\n# \n# is_multiply_prime(30) == True\n# 30 = 2 * 3 * 5\n#\ndef is_multiply_prime(a)", "entry_point": "is_multiply_prime", "test": "\n\narg00 = 5\nx0 = is_multiply_prime(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 30\nx1 = is_multiply_prime(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 8\nx2 = is_multiply_prime(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 10\nx3 = is_multiply_prime(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 125\nx4 = is_multiply_prime(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 105\nx5 = is_multiply_prime(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 126\nx6 = is_multiply_prime(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 729\nx7 = is_multiply_prime(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 891\nx8 = is_multiply_prime(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1001\nx9 = is_multiply_prime(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "Écrivez une fonction qui renvoie vrai si le nombre donné est le produit de 3 nombres premiers\n    et faux sinon.\n    Sachant que (a) est inférieur à 100.\n    Exemple:", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/32", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Vous recevrez un nombre en forme décimale et votre tâche consiste à le convertir en format binaire. La fonction doit renvoyer une chaîne de caractères, chaque caractère représentant un nombre binaire. Chaque caractère dans la chaîne sera '0' ou '1'.\n# \n# Il y aura quelques caractères supplémentaires 'db' au début et à la fin de la chaîne. Les caractères supplémentaires sont là pour aider avec le format.\n# \n# Exemples :\n# \n# decimal_to_binary(15)   # returns \"db1111db\"\n# decimal_to_binary(32)   # returns \"db100000db\"\n#\ndef decimal_to_binary(decimal)", "entry_point": "decimal_to_binary", "test": "\n\narg00 = 0\nx0 = decimal_to_binary(arg00)\nv0 = \"db0db\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 32\nx1 = decimal_to_binary(arg10)\nv1 = \"db100000db\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 103\nx2 = decimal_to_binary(arg20)\nv2 = \"db1100111db\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 15\nx3 = decimal_to_binary(arg30)\nv3 = \"db1111db\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Vous recevrez un nombre en forme décimale et votre tâche consiste à le convertir en format binaire. La fonction doit renvoyer une chaîne de caractères, chaque caractère représentant un nombre binaire. Chaque caractère dans la chaîne sera '0' ou '1'.\n\nIl y aura quelques caractères supplémentaires 'db' au début et à la fin de la chaîne. Les caractères supplémentaires sont là pour aider avec le format.\n\nExemples :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/33", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# On vous donne une chaîne de caractères s.\n#     Votre tâche est de vérifier si la chaîne est heureuse ou non.\n#     Une chaîne est heureuse si sa longueur est d'au moins 3 et que chaque groupe de 3 lettres consécutives est distinct.\n#     Par exemple :\n# \n# is_happy(a) => False\n# is_happy(aa) => False\n# is_happy(abcd) => True\n# is_happy(aabb) => False\n# is_happy(adb) => True\n# is_happy(xyy) => False\n#\ndef is_happy(s)", "entry_point": "is_happy", "test": "\n\narg00 = \"a\"\nx0 = is_happy(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"aa\"\nx1 = is_happy(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"abcd\"\nx2 = is_happy(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"aabb\"\nx3 = is_happy(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"adb\"\nx4 = is_happy(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"xyy\"\nx5 = is_happy(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"iopaxpoi\"\nx6 = is_happy(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"iopaxioi\"\nx7 = is_happy(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "On vous donne une chaîne de caractères s.\n    Votre tâche est de vérifier si la chaîne est heureuse ou non.\n    Une chaîne est heureuse si sa longueur est d'au moins 3 et que chaque groupe de 3 lettres consécutives est distinct.\n    Par exemple :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/34", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# C'est la dernière semaine du semestre et le professeur doit donner les notes aux étudiants. Le professeur a créé son propre algorithme pour noter. Le seul problème est qu'elle a perdu le code qu'elle utilisait pour noter. Elle vous a donné une liste de GPA pour certains étudiants et vous devez écrire une fonction qui peut produire une liste de notes en utilisant le tableau suivant :\n#              GPA       |    Note\n#               4.0                A+\n#             > 3.7                A \n#             > 3.3                A- \n#             > 3.0                B+\n#             > 2.7                B \n#             > 2.3                B-\n#             > 2.0                C+\n#             > 1.7                C\n#             > 1.3                C-\n#             > 1.0                D+ \n#             > 0.7                D \n#             > 0.0                D-\n#               0.0                E\n#     \n# \n#     Exemple :\n# \n# grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n#\ndef numerical_letter_grade(grades)", "entry_point": "numerical_letter_grade", "test": "\n\narg00 = [4.0, 3, 1.7, 2, 3.5]\nx0 = numerical_letter_grade(arg00)\nv0 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1.2]\nx1 = numerical_letter_grade(arg10)\nv1 = [\"D+\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [0.5]\nx2 = numerical_letter_grade(arg20)\nv2 = [\"D-\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [0.0]\nx3 = numerical_letter_grade(arg30)\nv3 = [\"E\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 0.3, 1.5, 2.8, 3.3]\nx4 = numerical_letter_grade(arg40)\nv4 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 0.7]\nx5 = numerical_letter_grade(arg50)\nv5 = [\"E\", \"D-\"]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "C'est la dernière semaine du semestre et le professeur doit donner les notes aux étudiants. Le professeur a créé son propre algorithme pour noter. Le seul problème est qu'elle a perdu le code qu'elle utilisait pour noter. Elle vous a donné une liste de GPA pour certains étudiants et vous devez écrire une fonction qui peut produire une liste de notes en utilisant le tableau suivant :\n             GPA       |    Note\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Exemple :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/35", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Écrivez une fonction qui prend une chaîne de caractères et renvoie True si la longueur de la chaîne est un nombre premier ou False sinon.\n# Exemples\n# \n# prime_length('Hello') == True\n# prime_length('abcdcba') == True\n# prime_length('kittens') == True\n# prime_length('orange') == False\n#\ndef prime_length(string)", "entry_point": "prime_length", "test": "\n\narg00 = \"Hello\"\nx0 = prime_length(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdcba\"\nx1 = prime_length(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"kittens\"\nx2 = prime_length(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"orange\"\nx3 = prime_length(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"wow\"\nx4 = prime_length(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"world\"\nx5 = prime_length(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"MadaM\"\nx6 = prime_length(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"Wow\"\nx7 = prime_length(arg70)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"\"\nx8 = prime_length(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"HI\"\nx9 = prime_length(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"go\"\nx10 = prime_length(arg100)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"gogo\"\nx11 = prime_length(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"aaaaaaaaaaaaaaa\"\nx12 = prime_length(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = \"Madam\"\nx13 = prime_length(arg130)\nv13 = true\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = \"M\"\nx14 = prime_length(arg140)\nv14 = false\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = \"0\"\nx15 = prime_length(arg150)\nv15 = false\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\n", "description": "Écrivez une fonction qui prend une chaîne de caractères et renvoie True si la longueur de la chaîne est un nombre premier ou False sinon.\nExemples", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/36", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Étant donné un entier positif N, retournez la somme totale de ses chiffres en binaire.\n# \n#     Exemple\n#         Pour N = 1000, la somme des chiffres sera 1, la sortie devrait être \"1\".\n#         Pour N = 150, la somme des chiffres sera 6, la sortie devrait être \"110\".\n#         Pour N = 147, la somme des chiffres sera 12, la sortie devrait être \"1100\".\n#     \n#     Variables:\n#         @N entier\n#              Contraintes : 0 ≤ N ≤ 10000.\n#     Sortie :\n#          une chaîne de nombre binaire\n# \n#\ndef solve(n)", "entry_point": "solve", "test": "\n\narg00 = 1000\nx0 = solve(arg00)\nv0 = \"1\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 150\nx1 = solve(arg10)\nv1 = \"110\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 147\nx2 = solve(arg20)\nv2 = \"1100\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 333\nx3 = solve(arg30)\nv3 = \"1001\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 963\nx4 = solve(arg40)\nv4 = \"10010\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Étant donné un entier positif N, retournez la somme totale de ses chiffres en binaire.\n\n    Exemple\n        Pour N = 1000, la somme des chiffres sera 1, la sortie devrait être \"1\".\n        Pour N = 150, la somme des chiffres sera 6, la sortie devrait être \"110\".\n        Pour N = 147, la somme des chiffres sera 12, la sortie devrait être \"1100\".\n    \n    Variables:\n        @N entier\n             Contraintes : 0 ≤ N ≤ 10000.\n    Sortie :\n         une chaîne de nombre binaire", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/37", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # On vous donne des données en deux dimensions, sous forme de listes imbriquées,\n# qui ressemblent à une matrice, mais contrairement aux matrices,\n# chaque ligne peut contenir un nombre différent de colonnes.\n# Étant donné lst et un entier x, trouvez les entiers x dans la liste,\n# et renvoyez une liste de tuples, [(x1, y1), (x2, y2) ...] tels que\n# chaque tuple est une coordonnée - (ligne, colonnes), en commençant par 0.\n# Triez les coordonnées initialement par lignes par ordre croissant.\n# De plus, triez les coordonnées de la ligne par colonnes par ordre décroissant.\n# \n# Exemples :\n# \n# get_row([\n#   [1,2,3,4,5,6],\n#   [1,2,3,4,1,6],\n#   [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([], 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n#\ndef get_row(lst, x)", "entry_point": "get_row", "test": "\n\narg00 = []\narg01 = 1\nx0 = get_row(arg00, arg01)\nv0 = []\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [[1]]\narg11 = 2\nx1 = get_row(arg10, arg11)\nv1 = []\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [[], [1], [1, 2, 3]]\narg21 = 3\nx2 = get_row(arg20, arg21)\nv2 = [[2, 2]]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "On vous donne des données en deux dimensions, sous forme de listes imbriquées,\nqui ressemblent à une matrice, mais contrairement aux matrices,\nchaque ligne peut contenir un nombre différent de colonnes.\nÉtant donné lst et un entier x, trouvez les entiers x dans la liste,\net renvoyez une liste de tuples, [(x1, y1), (x2, y2) ...] tels que\nchaque tuple est une coordonnée - (ligne, colonnes), en commençant par 0.\nTriez les coordonnées initialement par lignes par ordre croissant.\nDe plus, triez les coordonnées de la ligne par colonnes par ordre décroissant.\n\nExemples :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/38", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Vous disposez d'une liste d'entiers.\n#     Écrivez une fonction next_smallest() qui renvoie le deuxième élément le plus petit de la liste.\n#     Renvoyez null s'il n'y a pas un tel élément.\n# next_smallest([1, 2, 3, 4, 5]) == 2\n# next_smallest([5, 1, 4, 3, 2]) == 2\n# next_smallest([]) == None\n# next_smallest([1, 1]) == None\n#\ndef next_smallest(lst)", "entry_point": "next_smallest", "test": "\n\narg00 = [1, 2, 3, 4, 5]\nx0 = next_smallest(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 1, 4, 3, 2]\nx1 = next_smallest(arg10)\nv1 = 2\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = []\nx2 = next_smallest(arg20)\nv2 = nil\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 1]\nx3 = next_smallest(arg30)\nv3 = nil\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 1, 1, 1, 0]\nx4 = next_smallest(arg40)\nv4 = 1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 1]\nx5 = next_smallest(arg50)\nv5 = nil\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-35, 34, 12, -45]\nx6 = next_smallest(arg60)\nv6 = -35\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Vous disposez d'une liste d'entiers.\n    Écrivez une fonction next_smallest() qui renvoie le deuxième élément le plus petit de la liste.\n    Renvoyez null s'il n'y a pas un tel élément.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/39", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Vous recevrez une chaîne de mots et votre tâche consiste à compter le nombre d'ennuis. Un ennui est une phrase qui commence par le mot \"Je\". Les phrases sont délimitées par '.', '?' ou '!'.\n# \n# Par exemple:\n# >>> is_bored(\"Hello world\")\n# 0\n# >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\n#\ndef is_bored(s)", "entry_point": "is_bored", "test": "\n\narg00 = \"Hello world\"\nx0 = is_bored(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Is the sky blue?\"\nx1 = is_bored(arg10)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"I love It !\"\nx2 = is_bored(arg20)\nv2 = 1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"bIt\"\nx3 = is_bored(arg30)\nv3 = 0\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"I feel good today. I will be productive. will kill It\"\nx4 = is_bored(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"You and I are going for a walk\"\nx5 = is_bored(arg50)\nv5 = 0\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Vous recevrez une chaîne de mots et votre tâche consiste à compter le nombre d'ennuis. Un ennui est une phrase qui commence par le mot \"Je\". Les phrases sont délimitées par '.', '?' ou '!'.\n\nPar exemple:", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/40", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Vous avez une liste d'entiers.\n#     Vous devez trouver la plus grande valeur première et retourner la somme de ses chiffres.\n# \n#     Exemples:\n# \n# For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n# For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n# For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n# For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n# For lst = [0,81,12,3,1,21] the output should be 3\n# For lst = [0,8,1,2,1,7] the output should be 7\n#\ndef skjkasdkd(lst)", "entry_point": "skjkasdkd", "test": "\n\narg00 = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]\nx0 = skjkasdkd(arg00)\nv0 = 10\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]\nx1 = skjkasdkd(arg10)\nv1 = 25\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]\nx2 = skjkasdkd(arg20)\nv2 = 13\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]\nx3 = skjkasdkd(arg30)\nv3 = 11\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [0, 81, 12, 3, 1, 21]\nx4 = skjkasdkd(arg40)\nv4 = 3\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 8, 1, 2, 1, 7]\nx5 = skjkasdkd(arg50)\nv5 = 7\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [8191]\nx6 = skjkasdkd(arg60)\nv6 = 19\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [8191, 123456, 127, 7]\nx7 = skjkasdkd(arg70)\nv7 = 19\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [127, 97, 8192]\nx8 = skjkasdkd(arg80)\nv8 = 10\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "Vous avez une liste d'entiers.\n    Vous devez trouver la plus grande valeur première et retourner la somme de ses chiffres.\n\n    Exemples:", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/41", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Étant donné un dictionnaire, renvoyer True si toutes les clés sont des chaînes de caractères en minuscules ou toutes les clés sont des chaînes de caractères en majuscules, sinon renvoyer False. La fonction doit renvoyer False si le dictionnaire donné est vide. Exemples :\n# \n# check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n# check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n# check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n# check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n# check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n#\ndef check_dict_case(dict)", "entry_point": "check_dict_case", "test": "\n\narg00 = {\"p\"=>\"pineapple\", \"b\"=>\"banana\"}\nx0 = check_dict_case(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = {\"p\"=>\"pineapple\", \"A\"=>\"banana\", \"B\"=>\"banana\"}\nx1 = check_dict_case(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = {\"p\"=>\"pineapple\", 5=>\"banana\", \"a\"=>\"apple\"}\nx2 = check_dict_case(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = {\"Name\"=>\"John\", \"Age\"=>\"36\", \"City\"=>\"Houston\"}\nx3 = check_dict_case(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = {\"STATE\"=>\"NC\", \"ZIP\"=>\"12345\"}\nx4 = check_dict_case(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = {\"fruit\"=>\"Orange\", \"taste\"=>\"Sweet\"}\nx5 = check_dict_case(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = {}\nx6 = check_dict_case(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Étant donné un dictionnaire, renvoyer True si toutes les clés sont des chaînes de caractères en minuscules ou toutes les clés sont des chaînes de caractères en majuscules, sinon renvoyer False. La fonction doit renvoyer False si le dictionnaire donné est vide. Exemples :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/42", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Créez une fonction qui prend une valeur (chaîne de caractères) représentant un nombre et renvoie l'entier le plus proche. Si le nombre est à égale distance de deux entiers, arrondissez-le à l'entier le plus éloigné de zéro.\n# \n# Exemples\n# >>> closest_integer(\"10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\n#\ndef closest_integer(value)", "entry_point": "closest_integer", "test": "\n\narg00 = \"10\"\nx0 = closest_integer(arg00)\nv0 = 10\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"14.5\"\nx1 = closest_integer(arg10)\nv1 = 15\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"-15.5\"\nx2 = closest_integer(arg20)\nv2 = -16\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"15.3\"\nx3 = closest_integer(arg30)\nv3 = 15\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"0\"\nx4 = closest_integer(arg40)\nv4 = 0\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Créez une fonction qui prend une valeur (chaîne de caractères) représentant un nombre et renvoie l'entier le plus proche. Si le nombre est à égale distance de deux entiers, arrondissez-le à l'entier le plus éloigné de zéro.\n\nExemples", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/43", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Étant donné un entier positif n, vous devez faire une pile de n niveaux de pierres.\n#     Le premier niveau a n pierres.\n#     Le nombre de pierres dans le niveau suivant est:\n#         - le prochain nombre impair si n est impair.\n#         - le prochain nombre pair si n est pair.\n#     Retournez le nombre de pierres dans chaque niveau dans une liste, où l'élément à l'indice\n#     i représente le nombre de pierres dans le niveau (i+1).\n# \n#     Exemples:\n# >>> make_a_pile(3)\n# [3, 5, 7]\n#\ndef make_a_pile(n)", "entry_point": "make_a_pile", "test": "\n\narg00 = 3\nx0 = make_a_pile(arg00)\nv0 = [3, 5, 7]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 4\nx1 = make_a_pile(arg10)\nv1 = [4, 6, 8, 10]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = make_a_pile(arg20)\nv2 = [5, 7, 9, 11, 13]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 6\nx3 = make_a_pile(arg30)\nv3 = [6, 8, 10, 12, 14, 16]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 8\nx4 = make_a_pile(arg40)\nv4 = [8, 10, 12, 14, 16, 18, 20, 22]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Étant donné un entier positif n, vous devez faire une pile de n niveaux de pierres.\n    Le premier niveau a n pierres.\n    Le nombre de pierres dans le niveau suivant est:\n        - le prochain nombre impair si n est impair.\n        - le prochain nombre pair si n est pair.\n    Retournez le nombre de pierres dans chaque niveau dans une liste, où l'élément à l'indice\n    i représente le nombre de pierres dans le niveau (i+1).\n\n    Exemples:", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/44", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Vous recevrez une chaîne de mots séparés par des virgules ou des espaces. Votre tâche est de diviser la chaîne en mots et de renvoyer un tableau des mots.\n# \n# Par exemple:\n# \n# words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n#\ndef words_string(s)", "entry_point": "words_string", "test": "\n\narg00 = \"Hi, my name is John\"\nx0 = words_string(arg00)\nv0 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"One, two, three, four, five, six\"\nx1 = words_string(arg10)\nv1 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"Hi, my name\"\nx2 = words_string(arg20)\nv2 = [\"Hi\", \"my\", \"name\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"One,, two, three, four, five, six,\"\nx3 = words_string(arg30)\nv3 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"\"\nx4 = words_string(arg40)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"ahmed     , gamal\"\nx5 = words_string(arg50)\nv5 = [\"ahmed\", \"gamal\"]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Vous recevrez une chaîne de mots séparés par des virgules ou des espaces. Votre tâche est de diviser la chaîne en mots et de renvoyer un tableau des mots.\n\nPar exemple:", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/45", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Cette fonction prend deux nombres positifs x et y et renvoie le plus grand nombre entier pair qui se trouve dans l'intervalle [x, y] inclus. Si aucun nombre ne répond à cette condition, la fonction doit renvoyer -1.\n# \n# Par exemple :\n# \n# choose_num(12, 15) = 14\n# choose_num(13, 12) = -1\n#\ndef choose_num(x, y)", "entry_point": "choose_num", "test": "\n\narg00 = 12\narg01 = 15\nx0 = choose_num(arg00, arg01)\nv0 = 14\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 13\narg11 = 12\nx1 = choose_num(arg10, arg11)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 33\narg21 = 12354\nx2 = choose_num(arg20, arg21)\nv2 = 12354\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5234\narg31 = 5233\nx3 = choose_num(arg30, arg31)\nv3 = -1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 6\narg41 = 29\nx4 = choose_num(arg40, arg41)\nv4 = 28\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 27\narg51 = 10\nx5 = choose_num(arg50, arg51)\nv5 = -1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 7\narg61 = 7\nx6 = choose_num(arg60, arg61)\nv6 = -1\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 546\narg71 = 546\nx7 = choose_num(arg70, arg71)\nv7 = 546\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "Cette fonction prend deux nombres positifs x et y et renvoie le plus grand nombre entier pair qui se trouve dans l'intervalle [x, y] inclus. Si aucun nombre ne répond à cette condition, la fonction doit renvoyer -1.\n\nPar exemple :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/46", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# On vous donne deux entiers positifs n et m, et votre tâche est de calculer la moyenne des entiers de n à m (y compris n et m). Arrondissez la réponse à l'entier le plus proche et convertissez-le en binaire. Si n est supérieur à m, retournez -1. Exemple:\n# \n# rounded_avg(1, 5) => \"0b11\"\n# rounded_avg(7, 5) => -1\n# rounded_avg(10, 20) => \"0b1111\"\n# rounded_avg(20, 33) => \"0b11010\"\n#\ndef rounded_avg(n, m)", "entry_point": "rounded_avg", "test": "\n\narg00 = 1\narg01 = 5\nx0 = rounded_avg(arg00, arg01)\nv0 = \"0b11\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 7\narg11 = 13\nx1 = rounded_avg(arg10, arg11)\nv1 = \"0b1010\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 964\narg21 = 977\nx2 = rounded_avg(arg20, arg21)\nv2 = \"0b1111001010\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 996\narg31 = 997\nx3 = rounded_avg(arg30, arg31)\nv3 = \"0b1111100100\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 560\narg41 = 851\nx4 = rounded_avg(arg40, arg41)\nv4 = \"0b1011000010\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 185\narg51 = 546\nx5 = rounded_avg(arg50, arg51)\nv5 = \"0b101101110\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 362\narg61 = 496\nx6 = rounded_avg(arg60, arg61)\nv6 = \"0b110101101\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 350\narg71 = 902\nx7 = rounded_avg(arg70, arg71)\nv7 = \"0b1001110010\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 197\narg81 = 233\nx8 = rounded_avg(arg80, arg81)\nv8 = \"0b11010111\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 7\narg91 = 5\nx9 = rounded_avg(arg90, arg91)\nv9 = -1\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 5\narg101 = 1\nx10 = rounded_avg(arg100, arg101)\nv10 = -1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 5\narg111 = 5\nx11 = rounded_avg(arg110, arg111)\nv11 = \"0b101\"\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\n", "description": "On vous donne deux entiers positifs n et m, et votre tâche est de calculer la moyenne des entiers de n à m (y compris n et m). Arrondissez la réponse à l'entier le plus proche et convertissez-le en binaire. Si n est supérieur à m, retournez -1. Exemple:", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/47", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Implémentez la fonction f qui prend n en paramètre et renvoie une liste de taille n, telle que la valeur de l'élément à l'index i soit le factoriel de i si i est pair ou la somme des nombres de 1 à i sinon. i commence à 1. Le factoriel de i est la multiplication des nombres de 1 à i (1 * 2 * ... * i). Exemple :\n# \n# f(5) == [1, 2, 6, 24, 15]\n#\ndef f(n)", "entry_point": "f", "test": "\n\narg00 = 5\nx0 = f(arg00)\nv0 = [1, 2, 6, 24, 15]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 7\nx1 = f(arg10)\nv1 = [1, 2, 6, 24, 15, 720, 28]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 1\nx2 = f(arg20)\nv2 = [1]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 3\nx3 = f(arg30)\nv3 = [1, 2, 6]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Implémentez la fonction f qui prend n en paramètre et renvoie une liste de taille n, telle que la valeur de l'élément à l'index i soit le factoriel de i si i est pair ou la somme des nombres de 1 à i sinon. i commence à 1. Le factoriel de i est la multiplication des nombres de 1 à i (1 * 2 * ... * i). Exemple :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/48", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Étant donné un entier positif n, renvoyer un tuple qui contient le nombre de nombres palindromes pairs et impairs qui se trouvent dans la plage (1, n), inclus.\n# \n#     Exemple 1:\n# \n#         Entrée: 3\n#         Sortie: (1, 2)\n#         Explication:\n#         Les nombres palindromes sont 1, 2, 3. Un d'entre eux est pair et deux sont impairs.\n# \n#     Exemple 2:\n# \n#         Entrée: 12\n#         Sortie: (4, 6)\n#         Explication:\n#         Les nombres palindromes sont 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Quatre d'entre eux sont pairs et six sont impairs.\n# \n#     Remarque:\n#         1. 1 <= n <= 10^3\n#         2. Le tuple renvoyé contient respectivement le nombre de nombres palindromes pairs et impairs.\n# \n#\ndef even_odd_palindrome(n)", "entry_point": "even_odd_palindrome", "test": "\n\narg00 = 123\nx0 = even_odd_palindrome(arg00)\nv0 = [8, 13]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 12\nx1 = even_odd_palindrome(arg10)\nv1 = [4, 6]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\nx2 = even_odd_palindrome(arg20)\nv2 = [1, 2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 63\nx3 = even_odd_palindrome(arg30)\nv3 = [6, 8]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 25\nx4 = even_odd_palindrome(arg40)\nv4 = [5, 6]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 19\nx5 = even_odd_palindrome(arg50)\nv5 = [4, 6]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 9\nx6 = even_odd_palindrome(arg60)\nv6 = [4, 5]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 1\nx7 = even_odd_palindrome(arg70)\nv7 = [0, 1]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "Étant donné un entier positif n, renvoyer un tuple qui contient le nombre de nombres palindromes pairs et impairs qui se trouvent dans la plage (1, n), inclus.\n\n    Exemple 1:\n\n        Entrée: 3\n        Sortie: (1, 2)\n        Explication:\n        Les nombres palindromes sont 1, 2, 3. Un d'entre eux est pair et deux sont impairs.\n\n    Exemple 2:\n\n        Entrée: 12\n        Sortie: (4, 6)\n        Explication:\n        Les nombres palindromes sont 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Quatre d'entre eux sont pairs et six sont impairs.\n\n    Remarque:\n        1. 1 <= n <= 10^3\n        2. Le tuple renvoyé contient respectivement le nombre de nombres palindromes pairs et impairs.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/49", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Nous avons un tableau 'arr' de N entiers arr[1], arr[2], ..., arr[N]. Les nombres dans le tableau seront dans un ordre aléatoire. Votre tâche est de déterminer s'il est possible d'obtenir un tableau trié dans l'ordre non décroissant en effectuant l'opération suivante sur le tableau donné :\n#         Vous êtes autorisé à effectuer une opération de décalage vers la droite un nombre quelconque de fois.\n#     \n#     Une opération de décalage vers la droite signifie décaler tous les éléments du tableau d'une position vers la droite. Le dernier élément du tableau sera déplacé à la position de départ dans le tableau, c'est-à-dire l'indice 0.\n# \n#     Si il est possible d'obtenir le tableau trié en effectuant l'opération ci-dessus, retournez True sinon retournez False.\n#     Si le tableau donné est vide, retournez True.\n# \n#     Remarque : La liste donnée est garantie d'avoir des éléments uniques.\n# \n#     Par exemple :\n#     \n#     move_one_ball([3, 4, 5, 1, 2])==>True\n#     Explication : En effectuant 2 opérations de décalage vers la droite, l'ordre non décroissant peut être obtenu pour le tableau donné.\n#     move_one_ball([3, 5, 4, 1, 2])==>False\n#     Explication : Il n'est pas possible d'obtenir un ordre non décroissant pour le tableau donné en effectuant un nombre quelconque d'opérations de décalage vers la droite.\n# \n#             \n#\ndef move_one_ball(arr)", "entry_point": "move_one_ball", "test": "\n\narg00 = [3, 4, 5, 1, 2]\nx0 = move_one_ball(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [3, 5, 10, 1, 2]\nx1 = move_one_ball(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [4, 3, 1, 2]\nx2 = move_one_ball(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 5, 4, 1, 2]\nx3 = move_one_ball(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = []\nx4 = move_one_ball(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Nous avons un tableau 'arr' de N entiers arr[1], arr[2], ..., arr[N]. Les nombres dans le tableau seront dans un ordre aléatoire. Votre tâche est de déterminer s'il est possible d'obtenir un tableau trié dans l'ordre non décroissant en effectuant l'opération suivante sur le tableau donné :\n        Vous êtes autorisé à effectuer une opération de décalage vers la droite un nombre quelconque de fois.\n    \n    Une opération de décalage vers la droite signifie décaler tous les éléments du tableau d'une position vers la droite. Le dernier élément du tableau sera déplacé à la position de départ dans le tableau, c'est-à-dire l'indice 0.\n\n    Si il est possible d'obtenir le tableau trié en effectuant l'opération ci-dessus, retournez True sinon retournez False.\n    Si le tableau donné est vide, retournez True.\n\n    Remarque : La liste donnée est garantie d'avoir des éléments uniques.\n\n    Par exemple :\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explication : En effectuant 2 opérations de décalage vers la droite, l'ordre non décroissant peut être obtenu pour le tableau donné.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explication : Il n'est pas possible d'obtenir un ordre non décroissant pour le tableau donné en effectuant un nombre quelconque d'opérations de décalage vers la droite.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/50", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Dans ce problème, vous implémenterez une fonction qui prend deux listes de nombres et détermine s'il est possible d'échanger des éléments entre elles pour faire de lst1 une liste de nombres pairs uniquement. Il n'y a pas de limite sur le nombre d'éléments échangés entre lst1 et lst2. Si il est possible d'échanger des éléments entre lst1 et lst2 pour que tous les éléments de lst1 soient pairs, retournez \"YES\". Sinon, retournez \"NO\". Par exemple: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". On suppose que les listes d'entrée ne seront pas vides.\n# \n#\ndef exchange(lst1, lst2)", "entry_point": "exchange", "test": "\n\narg00 = [1, 2, 3, 4]\narg01 = [1, 2, 3, 4]\nx0 = exchange(arg00, arg01)\nv0 = \"YES\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 3, 4]\narg11 = [1, 5, 3, 4]\nx1 = exchange(arg10, arg11)\nv1 = \"NO\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, 3, 4]\narg21 = [2, 1, 4, 3]\nx2 = exchange(arg20, arg21)\nv2 = \"YES\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [5, 7, 3]\narg31 = [2, 6, 4]\nx3 = exchange(arg30, arg31)\nv3 = \"YES\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [5, 7, 3]\narg41 = [2, 6, 3]\nx4 = exchange(arg40, arg41)\nv4 = \"NO\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [3, 2, 6, 1, 8, 9]\narg51 = [3, 5, 5, 1, 1, 1]\nx5 = exchange(arg50, arg51)\nv5 = \"NO\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [100, 200]\narg61 = [200, 200]\nx6 = exchange(arg60, arg61)\nv6 = \"YES\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Dans ce problème, vous implémenterez une fonction qui prend deux listes de nombres et détermine s'il est possible d'échanger des éléments entre elles pour faire de lst1 une liste de nombres pairs uniquement. Il n'y a pas de limite sur le nombre d'éléments échangés entre lst1 et lst2. Si il est possible d'échanger des éléments entre lst1 et lst2 pour que tous les éléments de lst1 soient pairs, retournez \"YES\". Sinon, retournez \"NO\". Par exemple: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". On suppose que les listes d'entrée ne seront pas vides.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/51", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Tâche\n#     Nous avons deux chaînes de caractères s et c, vous devez supprimer tous les caractères de s qui sont égaux à n'importe quel caractère de c\n#     puis vérifier si la chaîne résultante est un palindrome.\n#     Une chaîne est appelée palindrome si elle se lit de la même manière de gauche à droite et de droite à gauche.\n#     Vous devez retourner un tuple contenant la chaîne résultante et True/False pour la vérification.\n#     Exemple\n#     Pour s = \"abcde\", c = \"ae\", le résultat devrait être ('bcd',False)\n#     Pour s = \"abcdef\", c = \"b\"  le résultat devrait être ('acdef',False)\n#     Pour s = \"abcdedcba\", c = \"ab\", le résultat devrait être ('cdedc',True)\n# \n#\ndef reverse_delete(s, c)", "entry_point": "reverse_delete", "test": "\n\narg00 = \"abcde\"\narg01 = \"ae\"\nx0 = reverse_delete(arg00, arg01)\nv0 = [\"bcd\", false]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdef\"\narg11 = \"b\"\nx1 = reverse_delete(arg10, arg11)\nv1 = [\"acdef\", false]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"abcdedcba\"\narg21 = \"ab\"\nx2 = reverse_delete(arg20, arg21)\nv2 = [\"cdedc\", true]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"dwik\"\narg31 = \"w\"\nx3 = reverse_delete(arg30, arg31)\nv3 = [\"dik\", false]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"a\"\narg41 = \"a\"\nx4 = reverse_delete(arg40, arg41)\nv4 = [\"\", true]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"abcdedcba\"\narg51 = \"\"\nx5 = reverse_delete(arg50, arg51)\nv5 = [\"abcdedcba\", true]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"abcdedcba\"\narg61 = \"v\"\nx6 = reverse_delete(arg60, arg61)\nv6 = [\"abcdedcba\", true]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"vabba\"\narg71 = \"v\"\nx7 = reverse_delete(arg70, arg71)\nv7 = [\"abba\", true]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"mamma\"\narg81 = \"mia\"\nx8 = reverse_delete(arg80, arg81)\nv8 = [\"\", true]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "Tâche\n    Nous avons deux chaînes de caractères s et c, vous devez supprimer tous les caractères de s qui sont égaux à n'importe quel caractère de c\n    puis vérifier si la chaîne résultante est un palindrome.\n    Une chaîne est appelée palindrome si elle se lit de la même manière de gauche à droite et de droite à gauche.\n    Vous devez retourner un tuple contenant la chaîne résultante et True/False pour la vérification.\n    Exemple\n    Pour s = \"abcde\", c = \"ae\", le résultat devrait être ('bcd',False)\n    Pour s = \"abcdef\", c = \"b\"  le résultat devrait être ('acdef',False)\n    Pour s = \"abcdedcba\", c = \"ab\", le résultat devrait être ('cdedc',True)", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/52", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # On vous donne une grille rectangulaire de puits. Chaque ligne représente un seul puits, et chaque 1 dans une ligne représente une unité d'eau. Chaque puits a un seau correspondant qui peut être utilisé pour extraire de l'eau, et tous les seaux ont la même capacité. Votre tâche est d'utiliser les seaux pour vider les puits. Sortez le nombre de fois que vous devez abaisser les seaux.\n# \n# Exemple 1:\n#     Entrée:\n#         grille : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n#         capacité_du_seau : 1\n#     Sortie: 6\n# \n# Exemple 2:\n#     Entrée:\n#         grille : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n#         capacité_du_seau : 2\n#     Sortie: 5\n# \n# Exemple 3:\n#     Entrée:\n#         grille : [[0,0,0], [0,0,0]]\n#         capacité_du_seau : 5\n#     Sortie: 0\n# \n# Contraintes:\n#     * tous les puits ont la même longueur\n#     * 1 <= grille.longueur <= 10^2\n#     * 1 <= grille[:,1].longueur <= 10^2\n#     * grille[i][j] -> 0 | 1\n#     * 1 <= capacité <= 10\n# \n#\ndef max_fill(grid, capacity)", "entry_point": "max_fill", "test": "\n\narg00 = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\narg01 = 1\nx0 = max_fill(arg00, arg01)\nv0 = 6\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\narg11 = 2\nx1 = max_fill(arg10, arg11)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [[0, 0, 0], [0, 0, 0]]\narg21 = 5\nx2 = max_fill(arg20, arg21)\nv2 = 0\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [[1, 1, 1, 1], [1, 1, 1, 1]]\narg31 = 2\nx3 = max_fill(arg30, arg31)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [[1, 1, 1, 1], [1, 1, 1, 1]]\narg41 = 9\nx4 = max_fill(arg40, arg41)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "On vous donne une grille rectangulaire de puits. Chaque ligne représente un seul puits, et chaque 1 dans une ligne représente une unité d'eau. Chaque puits a un seau correspondant qui peut être utilisé pour extraire de l'eau, et tous les seaux ont la même capacité. Votre tâche est d'utiliser les seaux pour vider les puits. Sortez le nombre de fois que vous devez abaisser les seaux.\n\nExemple 1:\n    Entrée:\n        grille : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        capacité_du_seau : 1\n    Sortie: 6\n\nExemple 2:\n    Entrée:\n        grille : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        capacité_du_seau : 2\n    Sortie: 5\n\nExemple 3:\n    Entrée:\n        grille : [[0,0,0], [0,0,0]]\n        capacité_du_seau : 5\n    Sortie: 0\n\nContraintes:\n    * tous les puits ont la même longueur\n    * 1 <= grille.longueur <= 10^2\n    * 1 <= grille[:,1].longueur <= 10^2\n    * grille[i][j] -> 0 | 1\n    * 1 <= capacité <= 10", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/53", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Étant donné une chaîne de caractères s et un nombre naturel n, vous avez été chargé d'implémenter une fonction qui renvoie une liste de tous les mots de la chaîne s qui contiennent exactement n consonnes, dans l'ordre où ces mots apparaissent dans la chaîne s. Si la chaîne s est vide, la fonction doit renvoyer une liste vide. Remarque : vous pouvez supposer que la chaîne d'entrée ne contient que des lettres et des espaces. Exemples :\n# \n# select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n# select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n# select_words(\"simple white space\", 2) ==> []\n# select_words(\"Hello world\", 4) ==> [\"world\"]\n# select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n#\ndef select_words(s, n)", "entry_point": "select_words", "test": "\n\narg00 = \"Mary had a little lamb\"\narg01 = 4\nx0 = select_words(arg00, arg01)\nv0 = [\"little\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Mary had a little lamb\"\narg11 = 3\nx1 = select_words(arg10, arg11)\nv1 = [\"Mary\", \"lamb\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"simple white space\"\narg21 = 2\nx2 = select_words(arg20, arg21)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Hello world\"\narg31 = 4\nx3 = select_words(arg30, arg31)\nv3 = [\"world\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Uncle sam\"\narg41 = 3\nx4 = select_words(arg40, arg41)\nv4 = [\"Uncle\"]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"\"\narg51 = 4\nx5 = select_words(arg50, arg51)\nv5 = []\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"a b c d e f\"\narg61 = 1\nx6 = select_words(arg60, arg61)\nv6 = [\"b\", \"c\", \"d\", \"f\"]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Étant donné une chaîne de caractères s et un nombre naturel n, vous avez été chargé d'implémenter une fonction qui renvoie une liste de tous les mots de la chaîne s qui contiennent exactement n consonnes, dans l'ordre où ces mots apparaissent dans la chaîne s. Si la chaîne s est vide, la fonction doit renvoyer une liste vide. Remarque : vous pouvez supposer que la chaîne d'entrée ne contient que des lettres et des espaces. Exemples :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/54", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Étant donné un tableau arr d'entiers et un entier positif k, renvoyer une liste triée de longueur k avec les k nombres maximum dans arr.\n# \n#     Exemple 1:\n# \n#         Input: arr = [-3, -4, 5], k = 3\n#         Output: [-4, -3, 5]\n# \n#     Exemple 2:\n# \n#         Input: arr = [4, -4, 4], k = 2\n#         Output: [4, 4]\n# \n#     Exemple 3:\n# \n#         Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n#         Output: [2]\n# \n#     Note:\n#         1. La longueur du tableau sera dans la plage de [1, 1000].\n#         2. Les éléments du tableau seront dans la plage de [-1000, 1000].\n#         3. 0 <= k <= len(arr)\n# \n#\ndef maximum(arr, k)", "entry_point": "maximum", "test": "\n\narg00 = [-3, -4, 5]\narg01 = 3\nx0 = maximum(arg00, arg01)\nv0 = [-4, -3, 5]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [4, -4, 4]\narg11 = 2\nx1 = maximum(arg10, arg11)\nv1 = [4, 4]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-3, 2, 1, 2, -1, -2, 1]\narg21 = 1\nx2 = maximum(arg20, arg21)\nv2 = [2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [123, -123, 20, 0, 1, 2, -3]\narg31 = 3\nx3 = maximum(arg30, arg31)\nv3 = [2, 20, 123]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-123, 20, 0, 1, 2, -3]\narg41 = 4\nx4 = maximum(arg40, arg41)\nv4 = [0, 1, 2, 20]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [5, 15, 0, 3, -13, -8, 0]\narg51 = 7\nx5 = maximum(arg50, arg51)\nv5 = [-13, -8, 0, 0, 3, 5, 15]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-1, 0, 2, 5, 3, -10]\narg61 = 2\nx6 = maximum(arg60, arg61)\nv6 = [3, 5]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [1, 0, 5, -7]\narg71 = 1\nx7 = maximum(arg70, arg71)\nv7 = [5]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [4, -4]\narg81 = 2\nx8 = maximum(arg80, arg81)\nv8 = [-4, 4]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [-10, 10]\narg91 = 2\nx9 = maximum(arg90, arg91)\nv9 = [-10, 10]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [1, 2, 3, -23, 243, -400, 0]\narg101 = 0\nx10 = maximum(arg100, arg101)\nv10 = []\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "Étant donné un tableau arr d'entiers et un entier positif k, renvoyer une liste triée de longueur k avec les k nombres maximum dans arr.\n\n    Exemple 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Exemple 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Exemple 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. La longueur du tableau sera dans la plage de [1, 1000].\n        2. Les éléments du tableau seront dans la plage de [-1000, 1000].\n        3. 0 <= k <= len(arr)", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/55", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Étant donné un tableau non vide d'entiers arr et un entier k, retournez la somme des éléments ayant au plus deux chiffres parmi les k premiers éléments de arr.\n# \n# Exemple :\n# \n#     Entrée : arr = [111,21,3,4000,5,6,7,8,9], k = 4\n#     Sortie : 24 # somme de 21 + 3\n# \n# Contraintes :\n#     1. 1 <= len(arr) <= 100\n#     2. 1 <= k <= len(arr)\n# \n#\ndef add_elements(arr, k)", "entry_point": "add_elements", "test": "\n\narg00 = [1, -2, -3, 41, 57, 76, 87, 88, 99]\narg01 = 3\nx0 = add_elements(arg00, arg01)\nv0 = -4\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [111, 121, 3, 4000, 5, 6]\narg11 = 2\nx1 = add_elements(arg10, arg11)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [11, 21, 3, 90, 5, 6, 7, 8, 9]\narg21 = 4\nx2 = add_elements(arg20, arg21)\nv2 = 125\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [111, 21, 3, 4000, 5, 6, 7, 8, 9]\narg31 = 4\nx3 = add_elements(arg30, arg31)\nv3 = 24\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\narg41 = 1\nx4 = add_elements(arg40, arg41)\nv4 = 1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Étant donné un tableau non vide d'entiers arr et un entier k, retournez la somme des éléments ayant au plus deux chiffres parmi les k premiers éléments de arr.\n\nExemple :\n\n    Entrée : arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Sortie : 24 # somme de 21 + 3\n\nContraintes :\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/56", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# On vous donne deux intervalles,\n#     où chaque intervalle est une paire d'entiers. Par exemple, intervalle = (début, fin) = (1, 2).\n#     Les intervalles donnés sont fermés, ce qui signifie que l'intervalle (début, fin)\n#     inclut à la fois le début et la fin.\n#     Pour chaque intervalle donné, on suppose que son début est inférieur ou égal à sa fin.\n#     Votre tâche est de déterminer si la longueur de l'intersection de ces deux\n#     intervalles est un nombre premier.\n#     Par exemple, l'intersection des intervalles (1, 3), (2, 4) est (2, 3)\n#     dont la longueur est 1, qui n'est pas un nombre premier.\n#     Si la longueur de l'intersection est un nombre premier, renvoyez \"YES\",\n#     sinon, renvoyez \"NO\".\n#     Si les deux intervalles ne se croisent pas, renvoyez \"NO\".\n# \n# \n#     [entrée/sortie] exemples:\n# \n# intersection((1, 2), (2, 3)) ==> \"NO\"\n# intersection((-1, 1), (0, 4)) ==> \"NO\"\n# intersection((-3, -1), (-5, 5)) ==> \"YES\"\n#\ndef intersection(interval1, interval2)", "entry_point": "intersection", "test": "\n\narg00 = [1, 2]\narg01 = [2, 3]\nx0 = intersection(arg00, arg01)\nv0 = \"NO\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [-1, 1]\narg11 = [0, 4]\nx1 = intersection(arg10, arg11)\nv1 = \"NO\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-3, -1]\narg21 = [-5, 5]\nx2 = intersection(arg20, arg21)\nv2 = \"YES\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [-2, 2]\narg31 = [-4, 0]\nx3 = intersection(arg30, arg31)\nv3 = \"YES\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-11, 2]\narg41 = [-1, -1]\nx4 = intersection(arg40, arg41)\nv4 = \"NO\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 2]\narg51 = [3, 5]\nx5 = intersection(arg50, arg51)\nv5 = \"NO\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [1, 2]\narg61 = [1, 2]\nx6 = intersection(arg60, arg61)\nv6 = \"NO\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-2, -2]\narg71 = [-3, -2]\nx7 = intersection(arg70, arg71)\nv7 = \"NO\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "On vous donne deux intervalles,\n    où chaque intervalle est une paire d'entiers. Par exemple, intervalle = (début, fin) = (1, 2).\n    Les intervalles donnés sont fermés, ce qui signifie que l'intervalle (début, fin)\n    inclut à la fois le début et la fin.\n    Pour chaque intervalle donné, on suppose que son début est inférieur ou égal à sa fin.\n    Votre tâche est de déterminer si la longueur de l'intersection de ces deux\n    intervalles est un nombre premier.\n    Par exemple, l'intersection des intervalles (1, 3), (2, 4) est (2, 3)\n    dont la longueur est 1, qui n'est pas un nombre premier.\n    Si la longueur de l'intersection est un nombre premier, renvoyez \"YES\",\n    sinon, renvoyez \"NO\".\n    Si les deux intervalles ne se croisent pas, renvoyez \"NO\".\n\n\n    [entrée/sortie] exemples:", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/57", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Tout le monde connaît la suite de Fibonacci, qui a été étudiée en profondeur par les mathématiciens au cours des derniers siècles. Cependant, ce que les gens ne savent pas, c'est la suite de Tribonacci. La suite de Tribonacci est définie par la récurrence :\n# tri(1) = 3\n# tri(n) = 1 + n / 2, si n est pair.\n# tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n est impair.\n# Par exemple :\n# tri(2) = 1 + (2 / 2) = 2\n# tri(4) = 3\n# tri(3) = tri(2) + tri(1) + tri(4)\n# = 2 + 3 + 3 = 8\n# Vous avez un nombre entier non négatif n, vous devez retourner une liste des n + 1 premiers nombres de la suite de Tribonacci.\n# Exemples :\n# tri(3) = [1, 3, 2, 8]\n# \n#\ndef tri(n)", "entry_point": "tri", "test": "\n\narg00 = 3\nx0 = tri(arg00)\nv0 = [1, 3, 2.0, 8.0]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 4\nx1 = tri(arg10)\nv1 = [1, 3, 2.0, 8.0, 3.0]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = tri(arg20)\nv2 = [1, 3, 2.0, 8.0, 3.0, 15.0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 6\nx3 = tri(arg30)\nv3 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\nx4 = tri(arg40)\nv4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 8\nx5 = tri(arg50)\nv5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 9\nx6 = tri(arg60)\nv6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 20\nx7 = tri(arg70)\nv7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 0\nx8 = tri(arg80)\nv8 = [1]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1\nx9 = tri(arg90)\nv9 = [1, 3]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "Tout le monde connaît la suite de Fibonacci, qui a été étudiée en profondeur par les mathématiciens au cours des derniers siècles. Cependant, ce que les gens ne savent pas, c'est la suite de Tribonacci. La suite de Tribonacci est définie par la récurrence :\ntri(1) = 3\ntri(n) = 1 + n / 2, si n est pair.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n est impair.\nPar exemple :\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nVous avez un nombre entier non négatif n, vous devez retourner une liste des n + 1 premiers nombres de la suite de Tribonacci.\nExemples :\ntri(3) = [1, 3, 2, 8]", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/58", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Étant donné un entier positif n, renvoyer le produit des chiffres impairs.\n#     Renvoyer 0 si tous les chiffres sont pairs.\n#     Par exemple:\n# \n# digits(1)  == 1\n# digits(4)  == 0\n# digits(235) == 15\n#\ndef digits(n)", "entry_point": "digits", "test": "\n\narg00 = 5\nx0 = digits(arg00)\nv0 = 5\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 54\nx1 = digits(arg10)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 120\nx2 = digits(arg20)\nv2 = 1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5014\nx3 = digits(arg30)\nv3 = 5\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 98765\nx4 = digits(arg40)\nv4 = 315\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 5576543\nx5 = digits(arg50)\nv5 = 2625\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 2468\nx6 = digits(arg60)\nv6 = 0\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Étant donné un entier positif n, renvoyer le produit des chiffres impairs.\n    Renvoyer 0 si tous les chiffres sont pairs.\n    Par exemple:", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/59", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Créez une fonction qui prend une chaîne de caractères en entrée contenant uniquement des crochets carrés.\n# La fonction doit renvoyer True si et seulement s'il existe une sous-séquence valide de crochets où au moins un crochet dans la sous-séquence est imbriqué.\n# is_nested('[[]]') ➞ True\n# is_nested('[]]]]]]][[[[[]') ➞ False\n# is_nested('[][]') ➞ False\n# is_nested('[]') ➞ False\n# is_nested('[[][]]') ➞ True\n# is_nested('[[]][[') ➞ True\n#\ndef is_nested(string)", "entry_point": "is_nested", "test": "\n\narg00 = \"[[]]\"\nx0 = is_nested(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"[]]]]]]][[[[[]\"\nx1 = is_nested(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"[][]\"\nx2 = is_nested(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"[]\"\nx3 = is_nested(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"[[[[]]]]\"\nx4 = is_nested(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"[]]]]]]]]]]\"\nx5 = is_nested(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"[][][[]]\"\nx6 = is_nested(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"[[]\"\nx7 = is_nested(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"[]]\"\nx8 = is_nested(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"[[]][[\"\nx9 = is_nested(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"[[][]]\"\nx10 = is_nested(arg100)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"\"\nx11 = is_nested(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"[[[[[[[[\"\nx12 = is_nested(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = \"]]]]]]]]\"\nx13 = is_nested(arg130)\nv13 = false\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\n", "description": "Créez une fonction qui prend une chaîne de caractères en entrée contenant uniquement des crochets carrés.\nLa fonction doit renvoyer True si et seulement s'il existe une sous-séquence valide de crochets où au moins un crochet dans la sous-séquence est imbriqué.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/60", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Vous avez une liste de nombres.\n# Vous devez retourner la somme des carrés des nombres dans la liste donnée,\n# arrondir chaque élément de la liste à l'entier supérieur (plafond) d'abord.\n# Exemples:\n# Pour lst = [1,2,3], la sortie devrait être 14\n# Pour lst = [1,4,9], la sortie devrait être 98\n# Pour lst = [1,3,5,7], la sortie devrait être 84\n# Pour lst = [1.4,4.2,0], la sortie devrait être 29\n# Pour lst = [-2.4,1,1], la sortie devrait être 6\n# \n# \n\n#\ndef sum_squares(lst)", "entry_point": "sum_squares", "test": "\n\narg00 = [1, 2, 3]\nx0 = sum_squares(arg00)\nv0 = 14\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1.0, 2, 3]\nx1 = sum_squares(arg10)\nv1 = 14\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 5, 7]\nx2 = sum_squares(arg20)\nv2 = 84\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1.4, 4.2, 0]\nx3 = sum_squares(arg30)\nv3 = 29\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-2.4, 1, 1]\nx4 = sum_squares(arg40)\nv4 = 6\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [100, 1, 15, 2]\nx5 = sum_squares(arg50)\nv5 = 10230\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [10000, 10000]\nx6 = sum_squares(arg60)\nv6 = 200000000\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-1.4, 4.6, 6.3]\nx7 = sum_squares(arg70)\nv7 = 75\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-1.4, 17.9, 18.9, 19.9]\nx8 = sum_squares(arg80)\nv8 = 1086\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [0]\nx9 = sum_squares(arg90)\nv9 = 0\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [-1]\nx10 = sum_squares(arg100)\nv10 = 1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = [-1, 1, 0]\nx11 = sum_squares(arg110)\nv11 = 2\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\n", "description": "Vous avez une liste de nombres.\nVous devez retourner la somme des carrés des nombres dans la liste donnée,\narrondir chaque élément de la liste à l'entier supérieur (plafond) d'abord.\nExemples:\nPour lst = [1,2,3], la sortie devrait être 14\nPour lst = [1,4,9], la sortie devrait être 98\nPour lst = [1,3,5,7], la sortie devrait être 84\nPour lst = [1.4,4.2,0], la sortie devrait être 29\nPour lst = [-2.4,1,1], la sortie devrait être 6", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/61", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Créez une fonction qui renvoie True si le dernier caractère d'une chaîne donnée est un caractère alphabétique et ne fait pas partie d'un mot, et False sinon.\n#     Remarque: un \"mot\" est un groupe de caractères séparés par un espace.\n# \n#     Exemples:\n# \n# check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n# check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n# check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n# check_if_last_char_is_a_letter(\"\") ➞ False \n#\ndef check_if_last_char_is_a_letter(txt)", "entry_point": "check_if_last_char_is_a_letter", "test": "\n\narg00 = \"apple\"\nx0 = check_if_last_char_is_a_letter(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"apple pi e\"\nx1 = check_if_last_char_is_a_letter(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"eeeee\"\nx2 = check_if_last_char_is_a_letter(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"A\"\nx3 = check_if_last_char_is_a_letter(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Pumpkin pie \"\nx4 = check_if_last_char_is_a_letter(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"Pumpkin pie 1\"\nx5 = check_if_last_char_is_a_letter(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"\"\nx6 = check_if_last_char_is_a_letter(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"eeeee e \"\nx7 = check_if_last_char_is_a_letter(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"apple pie\"\nx8 = check_if_last_char_is_a_letter(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"apple pi e \"\nx9 = check_if_last_char_is_a_letter(arg90)\nv9 = false\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "Créez une fonction qui renvoie True si le dernier caractère d'une chaîne donnée est un caractère alphabétique et ne fait pas partie d'un mot, et False sinon.\n    Remarque: un \"mot\" est un groupe de caractères séparés par un espace.\n\n    Exemples:", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/62", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Créez une fonction qui renvoie l'indice le plus grand d'un élément qui n'est pas supérieur ou égal à l'élément immédiatement précédent. Si aucun tel élément n'existe, retournez -1. Le tableau donné ne contiendra pas de valeurs en double.\n# \n# Exemples :\n# \n# can_arrange([1,2,4,3,5]) = 3\n# can_arrange([1,2,3]) = -1\n#\ndef can_arrange(arr)", "entry_point": "can_arrange", "test": "\n\narg00 = [1, 2, 4, 3, 5]\nx0 = can_arrange(arg00)\nv0 = 3\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 4, 5]\nx1 = can_arrange(arg10)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 4, 2, 5, 6, 7, 8, 9, 10]\nx2 = can_arrange(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 8, 5, 7, 3]\nx3 = can_arrange(arg30)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = []\nx4 = can_arrange(arg40)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Créez une fonction qui renvoie l'indice le plus grand d'un élément qui n'est pas supérieur ou égal à l'élément immédiatement précédent. Si aucun tel élément n'existe, retournez -1. Le tableau donné ne contiendra pas de valeurs en double.\n\nExemples :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/63", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Créez une fonction qui renvoie un tuple (a, b), où 'a' est le plus grand des entiers négatifs et 'b' est le plus petit des entiers positifs dans une liste. Si aucun entier négatif ou positif n'est présent, renvoyez-les comme None.\n# \n# Exemples :\n# \n# largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n# largest_smallest_integers([]) == (None, None)\n# largest_smallest_integers([0]) == (None, None)\n#\ndef largest_smallest_integers(lst)", "entry_point": "largest_smallest_integers", "test": "\n\narg00 = [2, 4, 1, 3, 5, 7]\nx0 = largest_smallest_integers(arg00)\nv0 = [nil, 1]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [2, 4, 1, 3, 5, 7, 0]\nx1 = largest_smallest_integers(arg10)\nv1 = [nil, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 2, 4, 5, 6, -2]\nx2 = largest_smallest_integers(arg20)\nv2 = [-2, 1]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 5, 3, 6, 2, 7, -7]\nx3 = largest_smallest_integers(arg30)\nv3 = [-7, 2]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [7, 3, 8, 4, 9, 2, 5, -9]\nx4 = largest_smallest_integers(arg40)\nv4 = [-9, 2]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = []\nx5 = largest_smallest_integers(arg50)\nv5 = [nil, nil]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [0]\nx6 = largest_smallest_integers(arg60)\nv6 = [nil, nil]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-1, -3, -5, -6]\nx7 = largest_smallest_integers(arg70)\nv7 = [-1, nil]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-1, -3, -5, -6, 0]\nx8 = largest_smallest_integers(arg80)\nv8 = [-1, nil]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [-6, -4, -4, -3, 1]\nx9 = largest_smallest_integers(arg90)\nv9 = [-3, 1]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [-6, -4, -4, -3, -100, 1]\nx10 = largest_smallest_integers(arg100)\nv10 = [-3, 1]\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "Créez une fonction qui renvoie un tuple (a, b), où 'a' est le plus grand des entiers négatifs et 'b' est le plus petit des entiers positifs dans une liste. Si aucun entier négatif ou positif n'est présent, renvoyez-les comme None.\n\nExemples :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/64", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Le factoriel brésilien est défini comme suit :\n#     factoriel_bresilien(n) = n! * (n-1)! * (n-2)! * ... * 1!\n#     où n > 0\n# \n#     Par exemple :\n# >>> special_factorial(4)\n# 288\n\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\n#\ndef special_factorial(n)", "entry_point": "special_factorial", "test": "\n\narg00 = 4\nx0 = special_factorial(arg00)\nv0 = 288\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 5\nx1 = special_factorial(arg10)\nv1 = 34560\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 7\nx2 = special_factorial(arg20)\nv2 = 125411328000\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 1\nx3 = special_factorial(arg30)\nv3 = 1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Le factoriel brésilien est défini comme suit :\n    factoriel_bresilien(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    où n > 0\n\n    Par exemple :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/65", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # On vous donne une chaîne de caractères représentant une phrase,\n#     la phrase contient des mots séparés par un espace,\n#     et vous devez retourner une chaîne de caractères qui contient les mots de la phrase originale,\n#     dont les longueurs sont des nombres premiers,\n#     l'ordre des mots dans la nouvelle chaîne doit être le même que celui de la phrase originale.\n# \n#     Exemple 1:\n#         Entrée: sentence = \"This is a test\"\n#         Sortie: \"is\"\n# \n#     Exemple 2:\n#         Entrée: sentence = \"lets go for swimming\"\n#         Sortie: \"go for\"\n# \n#     Contraintes:\n#         * 1 <= len(sentence) <= 100\n#         * sentence ne contient que des lettres\n# \n#\ndef words_in_sentence(sentence)", "entry_point": "words_in_sentence", "test": "\n\narg00 = \"This is a test\"\nx0 = words_in_sentence(arg00)\nv0 = \"is\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"lets go for swimming\"\nx1 = words_in_sentence(arg10)\nv1 = \"go for\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"there is no place available here\"\nx2 = words_in_sentence(arg20)\nv2 = \"there is no place\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Hi I am Hussein\"\nx3 = words_in_sentence(arg30)\nv3 = \"Hi am Hussein\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"go for it\"\nx4 = words_in_sentence(arg40)\nv4 = \"go for it\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"here\"\nx5 = words_in_sentence(arg50)\nv5 = \"\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"here is\"\nx6 = words_in_sentence(arg60)\nv6 = \"is\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "On vous donne une chaîne de caractères représentant une phrase,\n    la phrase contient des mots séparés par un espace,\n    et vous devez retourner une chaîne de caractères qui contient les mots de la phrase originale,\n    dont les longueurs sont des nombres premiers,\n    l'ordre des mots dans la nouvelle chaîne doit être le même que celui de la phrase originale.\n\n    Exemple 1:\n        Entrée: sentence = \"This is a test\"\n        Sortie: \"is\"\n\n    Exemple 2:\n        Entrée: sentence = \"lets go for swimming\"\n        Sortie: \"go for\"\n\n    Contraintes:\n        * 1 <= len(sentence) <= 100\n        * sentence ne contient que des lettres", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/66", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Votre tâche consiste à implémenter une fonction qui simplifiera l'expression x * n. La fonction renvoie True si x * n évalue à un nombre entier et False sinon. Les deux x et n sont des représentations de chaîne d'une fraction et ont le format suivant, <numérateur>/<dénominateur> où le numérateur et le dénominateur sont des nombres entiers positifs.\n# \n# Vous pouvez supposer que x et n sont des fractions valides et n'ont pas zéro comme dénominateur.\n# simplify(\"1/5\", \"5/1\") = True\n# simplify(\"1/6\", \"2/1\") = False\n# simplify(\"7/10\", \"10/2\") = False\n#\ndef simplify(x, n)", "entry_point": "simplify", "test": "\n\narg00 = \"1/5\"\narg01 = \"5/1\"\nx0 = simplify(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1/6\"\narg11 = \"2/1\"\nx1 = simplify(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"5/1\"\narg21 = \"3/1\"\nx2 = simplify(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"7/10\"\narg31 = \"10/2\"\nx3 = simplify(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"2/10\"\narg41 = \"50/10\"\nx4 = simplify(arg40, arg41)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"7/2\"\narg51 = \"4/2\"\nx5 = simplify(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"11/6\"\narg61 = \"6/1\"\nx6 = simplify(arg60, arg61)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"2/3\"\narg71 = \"5/2\"\nx7 = simplify(arg70, arg71)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"5/2\"\narg81 = \"3/5\"\nx8 = simplify(arg80, arg81)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"2/4\"\narg91 = \"8/4\"\nx9 = simplify(arg90, arg91)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"2/4\"\narg101 = \"4/2\"\nx10 = simplify(arg100, arg101)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"1/5\"\narg111 = \"5/1\"\nx11 = simplify(arg110, arg111)\nv11 = true\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"1/5\"\narg121 = \"1/5\"\nx12 = simplify(arg120, arg121)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\n", "description": "Votre tâche consiste à implémenter une fonction qui simplifiera l'expression x * n. La fonction renvoie True si x * n évalue à un nombre entier et False sinon. Les deux x et n sont des représentations de chaîne d'une fraction et ont le format suivant, <numérateur>/<dénominateur> où le numérateur et le dénominateur sont des nombres entiers positifs.\n\nVous pouvez supposer que x et n sont des fractions valides et n'ont pas zéro comme dénominateur.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/67", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Écrivez une fonction qui trie la liste donnée d'entiers\n#     dans l'ordre croissant en fonction de la somme de leurs chiffres.\n#     Remarque : s'il y a plusieurs éléments avec une somme de chiffres similaire,\n#     les trier en fonction de leur index dans la liste d'origine.\n# \n#     Par exemple:\n# >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n# >>> order_by_points([]) == []\n#\ndef order_by_points(nums)", "entry_point": "order_by_points", "test": "\n\narg00 = [1, 11, -1, -11, -12]\nx0 = order_by_points(arg00)\nv0 = [-1, -11, 1, -12, 11]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\nx1 = order_by_points(arg10)\nv1 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = []\nx2 = order_by_points(arg20)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, -11, -32, 43, 54, -98, 2, -3]\nx3 = order_by_points(arg30)\nv3 = [-3, -32, -98, -11, 1, 2, 43, 54]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\nx4 = order_by_points(arg40)\nv4 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 6, 6, -76, -21, 23, 4]\nx5 = order_by_points(arg50)\nv5 = [-76, -21, 0, 4, 23, 6, 6]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Écrivez une fonction qui trie la liste donnée d'entiers\n    dans l'ordre croissant en fonction de la somme de leurs chiffres.\n    Remarque : s'il y a plusieurs éléments avec une somme de chiffres similaire,\n    les trier en fonction de leur index dans la liste d'origine.\n\n    Par exemple:", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/68", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Écrivez une fonction qui prend en entrée un tableau de nombres et renvoie le nombre d'éléments du tableau qui sont supérieurs à 10 et dont les premiers et derniers chiffres d'un nombre sont impairs (1, 3, 5, 7, 9). Par exemple :\n# \n# specialFilter([15, -73, 14, -15]) => 1 \n# specialFilter([33, -2, -3, 45, 21, 109]) => 2\n#\ndef specialfilter(nums)", "entry_point": "specialfilter", "test": "\n\narg00 = [5, -2, 1, -5]\nx0 = specialfilter(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [15, -73, 14, -15]\nx1 = specialfilter(arg10)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [33, -2, -3, 45, 21, 109]\nx2 = specialfilter(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [43, -12, 93, 125, 121, 109]\nx3 = specialfilter(arg30)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [71, -2, -33, 75, 21, 19]\nx4 = specialfilter(arg40)\nv4 = 3\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1]\nx5 = specialfilter(arg50)\nv5 = 0\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = []\nx6 = specialfilter(arg60)\nv6 = 0\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Écrivez une fonction qui prend en entrée un tableau de nombres et renvoie le nombre d'éléments du tableau qui sont supérieurs à 10 et dont les premiers et derniers chiffres d'un nombre sont impairs (1, 3, 5, 7, 9). Par exemple :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/69", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # On vous donne un entier positif n. Vous devez créer un tableau d'entiers a de longueur n.\n#         Pour chaque i (1 ≤ i ≤ n), la valeur de a[i] = i * i - i + 1.\n#         Renvoyez le nombre de triplets (a[i], a[j], a[k]) de a où i < j < k, \n#     et a[i] + a[j] + a[k] est un multiple de 3.\n# \n#     Exemple :\n#         Entrée : n = 5\n#         Sortie : 1\n#         Explication : \n#         a = [1, 3, 7, 13, 21]\n#         Le seul triplet valide est (1, 7, 13).\n# \n#\ndef get_max_triples(n)", "entry_point": "get_max_triples", "test": "\n\narg00 = 5\nx0 = get_max_triples(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 6\nx1 = get_max_triples(arg10)\nv1 = 4\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\nx2 = get_max_triples(arg20)\nv2 = 36\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 100\nx3 = get_max_triples(arg30)\nv3 = 53361\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "On vous donne un entier positif n. Vous devez créer un tableau d'entiers a de longueur n.\n        Pour chaque i (1 ≤ i ≤ n), la valeur de a[i] = i * i - i + 1.\n        Renvoyez le nombre de triplets (a[i], a[j], a[k]) de a où i < j < k, \n    et a[i] + a[j] + a[k] est un multiple de 3.\n\n    Exemple :\n        Entrée : n = 5\n        Sortie : 1\n        Explication : \n        a = [1, 3, 7, 13, 21]\n        Le seul triplet valide est (1, 7, 13).", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/70", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Il y a huit planètes dans notre système solaire : la plus proche du Soleil est Mercure, la suivante est Vénus, puis la Terre, Mars, Jupiter, Saturne, Uranus, Neptune. Écrivez une fonction qui prend deux noms de planètes en tant que chaînes de caractères planet1 et planet2. La fonction devrait renvoyer un tuple contenant toutes les planètes dont les orbites sont situées entre l'orbite de planet1 et l'orbite de planet2, triées par proximité avec le soleil. La fonction devrait renvoyer un tuple vide si planet1 ou planet2 ne sont pas des noms de planètes corrects. Exemples.\n# \n# bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n# bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n# bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n#\ndef bf(planet1, planet2)", "entry_point": "bf", "test": "\n\narg00 = \"Jupiter\"\narg01 = \"Neptune\"\nx0 = bf(arg00, arg01)\nv0 = [\"Saturn\", \"Uranus\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Earth\"\narg11 = \"Mercury\"\nx1 = bf(arg10, arg11)\nv1 = [\"Venus\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"Mercury\"\narg21 = \"Uranus\"\nx2 = bf(arg20, arg21)\nv2 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Neptune\"\narg31 = \"Venus\"\nx3 = bf(arg30, arg31)\nv3 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Earth\"\narg41 = \"Earth\"\nx4 = bf(arg40, arg41)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"Mars\"\narg51 = \"Earth\"\nx5 = bf(arg50, arg51)\nv5 = []\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"Jupiter\"\narg61 = \"Makemake\"\nx6 = bf(arg60, arg61)\nv6 = []\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Il y a huit planètes dans notre système solaire : la plus proche du Soleil est Mercure, la suivante est Vénus, puis la Terre, Mars, Jupiter, Saturne, Uranus, Neptune. Écrivez une fonction qui prend deux noms de planètes en tant que chaînes de caractères planet1 et planet2. La fonction devrait renvoyer un tuple contenant toutes les planètes dont les orbites sont situées entre l'orbite de planet1 et l'orbite de planet2, triées par proximité avec le soleil. La fonction devrait renvoyer un tuple vide si planet1 ou planet2 ne sont pas des noms de planètes corrects. Exemples.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/71", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Un programme simple qui devrait renvoyer la valeur de x si n est un nombre premier et devrait renvoyer la valeur de y sinon.\n# \n# Exemples :\n# \n# for x_or_y(7, 34, 12) == 34\n# for x_or_y(15, 8, 5) == 5\n# \n#\ndef x_or_y(n, x, y)", "entry_point": "x_or_y", "test": "\n\narg00 = 7\narg01 = 34\narg02 = 12\nx0 = x_or_y(arg00, arg01, arg02)\nv0 = 34\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 15\narg11 = 8\narg12 = 5\nx1 = x_or_y(arg10, arg11, arg12)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\narg21 = 33\narg22 = 5212\nx2 = x_or_y(arg20, arg21, arg22)\nv2 = 33\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 1259\narg31 = 3\narg32 = 52\nx3 = x_or_y(arg30, arg31, arg32)\nv3 = 3\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7919\narg41 = -1\narg42 = 12\nx4 = x_or_y(arg40, arg41, arg42)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 3609\narg51 = 1245\narg52 = 583\nx5 = x_or_y(arg50, arg51, arg52)\nv5 = 583\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 91\narg61 = 56\narg62 = 129\nx6 = x_or_y(arg60, arg61, arg62)\nv6 = 129\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 6\narg71 = 34\narg72 = 1234\nx7 = x_or_y(arg70, arg71, arg72)\nv7 = 1234\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 1\narg81 = 2\narg82 = 0\nx8 = x_or_y(arg80, arg81, arg82)\nv8 = 0\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 2\narg91 = 2\narg92 = 0\nx9 = x_or_y(arg90, arg91, arg92)\nv9 = 2\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "Un programme simple qui devrait renvoyer la valeur de x si n est un nombre premier et devrait renvoyer la valeur de y sinon.\n\nExemples :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/72", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Étant donné une liste de nombres, retournez la somme des carrés des nombres de la liste qui sont impairs. Ignorez les nombres négatifs ou non entiers.\n# \n#     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n#     double_the_difference([-1, -2, 0]) == 0\n#     double_the_difference([9, -2]) == 81\n#     double_the_difference([0]) == 0\n#     \n#     Si la liste d'entrée est vide, retournez 0.\n# \n#\ndef double_the_difference(lst)", "entry_point": "double_the_difference", "test": "\n\narg00 = []\nx0 = double_the_difference(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 4]\nx1 = double_the_difference(arg10)\nv1 = 25\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [0.1, 0.2, 0.3]\nx2 = double_the_difference(arg20)\nv2 = 0\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [-10, -20, -30]\nx3 = double_the_difference(arg30)\nv3 = 0\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-1, -2, 8]\nx4 = double_the_difference(arg40)\nv4 = 0\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0.2, 3, 5]\nx5 = double_the_difference(arg50)\nv5 = 34\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]\nx6 = double_the_difference(arg60)\nv6 = 166650\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Étant donné une liste de nombres, retournez la somme des carrés des nombres de la liste qui sont impairs. Ignorez les nombres négatifs ou non entiers.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n    \n    Si la liste d'entrée est vide, retournez 0.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/73", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Vous recevrez le nom d'une classe (une chaîne de caractères) et une liste d'extensions. Les extensions doivent être utilisées pour charger des classes supplémentaires dans la classe. La force de l'extension est déterminée comme suit : soit CAP le nombre de lettres majuscules dans le nom de l'extension, et SM le nombre de lettres minuscules dans le nom de l'extension, la force est donnée par la fraction CAP - SM. Vous devez trouver l'extension la plus forte et renvoyer une chaîne de caractères dans ce format : NomDeLaClasse.NomDeLExtensionLaPlusForte. S'il y a deux ou plusieurs extensions avec la même force, vous devez choisir celle qui vient en premier dans la liste. Par exemple, si vous recevez \"Slices\" comme classe et une liste d'extensions : ['SErviNGSliCes', 'Cheese', 'StuFfed'], vous devez renvoyer 'Slices.SErviNGSliCes' car 'SErviNGSliCes' est l'extension la plus forte (sa force est -1). Exemple :\n# \n# for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n#\ndef strongest_extension(class_name, extensions)", "entry_point": "strongest_extension", "test": "\n\narg00 = \"Watashi\"\narg01 = [\"tEN\", \"niNE\", \"eIGHt8OKe\"]\nx0 = strongest_extension(arg00, arg01)\nv0 = \"Watashi.eIGHt8OKe\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Boku123\"\narg11 = [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]\nx1 = strongest_extension(arg10, arg11)\nv1 = \"Boku123.YEs.WeCaNe\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"__YESIMHERE\"\narg21 = [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]\nx2 = strongest_extension(arg20, arg21)\nv2 = \"__YESIMHERE.NuLl__\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"K\"\narg31 = [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]\nx3 = strongest_extension(arg30, arg31)\nv3 = \"K.TAR\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"__HAHA\"\narg41 = [\"Tab\", \"123\", \"781345\", \"-_-\"]\nx4 = strongest_extension(arg40, arg41)\nv4 = \"__HAHA.123\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"YameRore\"\narg51 = [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]\nx5 = strongest_extension(arg50, arg51)\nv5 = \"YameRore.okIWILL123\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"finNNalLLly\"\narg61 = [\"Die\", \"NowW\", \"Wow\", \"WoW\"]\nx6 = strongest_extension(arg60, arg61)\nv6 = \"finNNalLLly.WoW\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"_\"\narg71 = [\"Bb\", \"91245\"]\nx7 = strongest_extension(arg70, arg71)\nv7 = \"_.Bb\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"Sp\"\narg81 = [\"671235\", \"Bb\"]\nx8 = strongest_extension(arg80, arg81)\nv8 = \"Sp.671235\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "Vous recevrez le nom d'une classe (une chaîne de caractères) et une liste d'extensions. Les extensions doivent être utilisées pour charger des classes supplémentaires dans la classe. La force de l'extension est déterminée comme suit : soit CAP le nombre de lettres majuscules dans le nom de l'extension, et SM le nombre de lettres minuscules dans le nom de l'extension, la force est donnée par la fraction CAP - SM. Vous devez trouver l'extension la plus forte et renvoyer une chaîne de caractères dans ce format : NomDeLaClasse.NomDeLExtensionLaPlusForte. S'il y a deux ou plusieurs extensions avec la même force, vous devez choisir celle qui vient en premier dans la liste. Par exemple, si vous recevez \"Slices\" comme classe et une liste d'extensions : ['SErviNGSliCes', 'Cheese', 'StuFfed'], vous devez renvoyer 'Slices.SErviNGSliCes' car 'SErviNGSliCes' est l'extension la plus forte (sa force est -1). Exemple :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/74", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# Vous avez deux mots. Vous devez renvoyer True si le deuxième mot ou l'une de ses rotations est une sous-chaîne dans le premier mot.\n# cycpattern_check(\"abcd\",\"abd\") => False\n# cycpattern_check(\"hello\",\"ell\") => True\n# cycpattern_check(\"whassup\",\"psus\") => False\n# cycpattern_check(\"abab\",\"baa\") => True\n# cycpattern_check(\"efef\",\"eeff\") => False\n# cycpattern_check(\"himenss\",\"simen\") => True\n\n#\ndef cycpattern_check(a, b)", "entry_point": "cycpattern_check", "test": "\n\narg00 = \"xyzw\"\narg01 = \"xyw\"\nx0 = cycpattern_check(arg00, arg01)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"yello\"\narg11 = \"ell\"\nx1 = cycpattern_check(arg10, arg11)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"whattup\"\narg21 = \"ptut\"\nx2 = cycpattern_check(arg20, arg21)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"efef\"\narg31 = \"fee\"\nx3 = cycpattern_check(arg30, arg31)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"abab\"\narg41 = \"aabb\"\nx4 = cycpattern_check(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"winemtt\"\narg51 = \"tinem\"\nx5 = cycpattern_check(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Vous avez deux mots. Vous devez renvoyer True si le deuxième mot ou l'une de ses rotations est une sous-chaîne dans le premier mot.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/75", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Étant donné un entier positif, obtenez son équivalent en chiffres romains sous forme de chaîne de caractères et retournez-le en minuscules.\n# Restrictions : 1 <= num <= 1000\n# \n# Exemples :\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\n#\ndef int_to_mini_roman(number)", "entry_point": "int_to_mini_roman", "test": "\n\narg00 = 19\nx0 = int_to_mini_roman(arg00)\nv0 = \"xix\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 152\nx1 = int_to_mini_roman(arg10)\nv1 = \"clii\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 251\nx2 = int_to_mini_roman(arg20)\nv2 = \"ccli\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 426\nx3 = int_to_mini_roman(arg30)\nv3 = \"cdxxvi\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 500\nx4 = int_to_mini_roman(arg40)\nv4 = \"d\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 1\nx5 = int_to_mini_roman(arg50)\nv5 = \"i\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 4\nx6 = int_to_mini_roman(arg60)\nv6 = \"iv\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 43\nx7 = int_to_mini_roman(arg70)\nv7 = \"xliii\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 90\nx8 = int_to_mini_roman(arg80)\nv8 = \"xc\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 94\nx9 = int_to_mini_roman(arg90)\nv9 = \"xciv\"\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 532\nx10 = int_to_mini_roman(arg100)\nv10 = \"dxxxii\"\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 900\nx11 = int_to_mini_roman(arg110)\nv11 = \"cm\"\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 994\nx12 = int_to_mini_roman(arg120)\nv12 = \"cmxciv\"\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = 1000\nx13 = int_to_mini_roman(arg130)\nv13 = \"m\"\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\n", "description": "Étant donné un entier positif, obtenez son équivalent en chiffres romains sous forme de chaîne de caractères et retournez-le en minuscules.\nRestrictions : 1 <= num <= 1000\n\nExemples :", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/76", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Étant donné les longueurs des trois côtés d'un triangle. Renvoyer True si les trois côtés forment un triangle rectangle, False sinon. Un triangle rectangle est un triangle dans lequel un angle est un angle droit ou de 90 degrés. Exemple:\n# \n# right_angle_triangle(3, 4, 5) == True\n# right_angle_triangle(1, 2, 3) == False\n#\ndef right_angle_triangle(a, b, c)", "entry_point": "right_angle_triangle", "test": "\n\narg00 = 3\narg01 = 4\narg02 = 5\nx0 = right_angle_triangle(arg00, arg01, arg02)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 2\narg12 = 3\nx1 = right_angle_triangle(arg10, arg11, arg12)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\narg21 = 6\narg22 = 8\nx2 = right_angle_triangle(arg20, arg21, arg22)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 2\narg31 = 2\narg32 = 2\nx3 = right_angle_triangle(arg30, arg31, arg32)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\narg41 = 24\narg42 = 25\nx4 = right_angle_triangle(arg40, arg41, arg42)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 10\narg51 = 5\narg52 = 7\nx5 = right_angle_triangle(arg50, arg51, arg52)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 5\narg61 = 12\narg62 = 13\nx6 = right_angle_triangle(arg60, arg61, arg62)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 15\narg71 = 8\narg72 = 17\nx7 = right_angle_triangle(arg70, arg71, arg72)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 48\narg81 = 55\narg82 = 73\nx8 = right_angle_triangle(arg80, arg81, arg82)\nv8 = true\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1\narg91 = 1\narg92 = 1\nx9 = right_angle_triangle(arg90, arg91, arg92)\nv9 = false\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 2\narg101 = 2\narg102 = 10\nx10 = right_angle_triangle(arg100, arg101, arg102)\nv10 = false\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "Étant donné les longueurs des trois côtés d'un triangle. Renvoyer True si les trois côtés forment un triangle rectangle, False sinon. Un triangle rectangle est un triangle dans lequel un angle est un angle droit ou de 90 degrés. Exemple:", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/77", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# On vous donne une chaîne de caractères s.\n#     Si s[i] est une lettre, inversez sa casse de minuscule à majuscule ou vice versa,\n#     sinon gardez-le tel quel.\n#     Si la chaîne ne contient pas de lettres, inversez la chaîne.\n#     La fonction doit renvoyer la chaîne résultante.\n#     Exemples\n# \n# solve(\"1234\") = \"4321\"\n# solve(\"ab\") = \"AB\"\n# solve(\"#a@C\") = \"#A@c\"\n#\ndef solve(s)", "entry_point": "solve", "test": "\n\narg00 = \"AsDf\"\nx0 = solve(arg00)\nv0 = \"aSdF\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1234\"\nx1 = solve(arg10)\nv1 = \"4321\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"ab\"\nx2 = solve(arg20)\nv2 = \"AB\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"#a@C\"\nx3 = solve(arg30)\nv3 = \"#A@c\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"#AsdfW^45\"\nx4 = solve(arg40)\nv4 = \"#aSDFw^45\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"#6@2\"\nx5 = solve(arg50)\nv5 = \"2@6#\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"#\\$a^D\"\nx6 = solve(arg60)\nv6 = \"#\\$A^d\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"#ccc\"\nx7 = solve(arg70)\nv7 = \"#CCC\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "On vous donne une chaîne de caractères s.\n    Si s[i] est une lettre, inversez sa casse de minuscule à majuscule ou vice versa,\n    sinon gardez-le tel quel.\n    Si la chaîne ne contient pas de lettres, inversez la chaîne.\n    La fonction doit renvoyer la chaîne résultante.\n    Exemples", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/78", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Étant donné une chaîne de caractères 'text', retournez sa chaîne équivalente de hachage md5. Si 'text' est une chaîne vide, retournez null.\n# >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n#\ndef string_to_md5(text)", "entry_point": "string_to_md5", "test": "\n\narg00 = \"Hello world\"\nx0 = string_to_md5(arg00)\nv0 = \"3e25960a79dbc69b674cd4ec67a72c62\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"\"\nx1 = string_to_md5(arg10)\nv1 = nil\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"A B C\"\nx2 = string_to_md5(arg20)\nv2 = \"0ef78513b0cb8cef12743f5aeb35f888\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"password\"\nx3 = string_to_md5(arg30)\nv3 = \"5f4dcc3b5aa765d61d8327deb882cf99\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Étant donné une chaîne de caractères 'text', retournez sa chaîne équivalente de hachage md5. Si 'text' est une chaîne vide, retournez null.", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "ruby/79", "prompt": "\n##\n# Vous êtes un programmeur Ruby expert, et voici votre tâche.\n# # Étant donné deux entiers positifs a et b, renvoyer les chiffres pairs entre a et b, dans l'ordre croissant.\n# \n# Par exemple:\n# \n# generate_integers(2, 8) => [2, 4, 6, 8]\n# generate_integers(8, 2) => [2, 4, 6, 8]\n# generate_integers(10, 14) => []\n#\ndef generate_integers(a, b)", "entry_point": "generate_integers", "test": "\n\narg00 = 2\narg01 = 10\nx0 = generate_integers(arg00, arg01)\nv0 = [2, 4, 6, 8]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 10\narg11 = 2\nx1 = generate_integers(arg10, arg11)\nv1 = [2, 4, 6, 8]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 132\narg21 = 2\nx2 = generate_integers(arg20, arg21)\nv2 = [2, 4, 6, 8]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 17\narg31 = 89\nx3 = generate_integers(arg30, arg31)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Étant donné deux entiers positifs a et b, renvoyer les chiffres pairs entre a et b, dans l'ordre croissant.\n\nPar exemple:", "language": "ruby", "canonical_solution": NaN, "natural_language": "French"}
