{"task_id": "ruby/0", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Jy kry 'n lys van deposito en onttrekking operasies op 'n bankrekening wat begin met 'n nul balans. Jou taak is om te bepaal of die balans van die rekening op enige punt onder nul val, en op daardie punt moet die funksie True teruggee. Anders moet dit False teruggee.\n# >>> below_zero([1, 2, 3])\n# False\n# >>> below_zero([1, 2, -4, 5])\n# True\n#\ndef below_zero(operations)", "entry_point": "below_zero", "test": "\n\narg00 = []\nx0 = below_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, -3, 1, 2, -3]\nx1 = below_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, -4, 5, 6]\nx2 = below_zero(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, -1, 2, -2, 5, -5, 4, -4]\nx3 = below_zero(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, -1, 2, -2, 5, -5, 4, -5]\nx4 = below_zero(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, -2, 2, -2, 5, -5, 4, -4]\nx5 = below_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Jy kry 'n lys van deposito en onttrekking operasies op 'n bankrekening wat begin met 'n nul balans. Jou taak is om te bepaal of die balans van die rekening op enige punt onder nul val, en op daardie punt moet die funksie True teruggee. Anders moet dit False teruggee.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/1", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Vir 'n gegewe lys van heelgetalle, gee 'n tuple terug wat bestaan uit 'n som en 'n produk van al die heelgetalle in die lys.\n#     Leë som moet gelyk wees aan 0 en leë produk moet gelyk wees aan 1.\n# >>> sum_product([])\n# (0, 1)\n# >>> sum_product([1, 2, 3, 4])\n# (10, 24)\n#\ndef sum_product(numbers)", "entry_point": "sum_product", "test": "\n\narg00 = []\nx0 = sum_product(arg00)\nv0 = [0, 1]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 1, 1]\nx1 = sum_product(arg10)\nv1 = [3, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [100, 0]\nx2 = sum_product(arg20)\nv2 = [100, 0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 5, 7]\nx3 = sum_product(arg30)\nv3 = [15, 105]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [10]\nx4 = sum_product(arg40)\nv4 = [10, 10]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Vir 'n gegewe lys van heelgetalle, gee 'n tuple terug wat bestaan uit 'n som en 'n produk van al die heelgetalle in die lys.\n    Leë som moet gelyk wees aan 0 en leë produk moet gelyk wees aan 1.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/2", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Die insette is twee reekse a en b wat slegs uit 1's en 0's bestaan.\n# Voer binêre XOR op hierdie insette uit en gee die resultaat ook terug as 'n string.\n# >>> string_xor('010', '110')\n# '100'\n#\ndef string_xor(a, b)", "entry_point": "string_xor", "test": "\n\narg00 = \"111000\"\narg01 = \"101010\"\nx0 = string_xor(arg00, arg01)\nv0 = \"010010\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1\"\narg11 = \"1\"\nx1 = string_xor(arg10, arg11)\nv1 = \"0\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"0101\"\narg21 = \"0000\"\nx2 = string_xor(arg20, arg21)\nv2 = \"0101\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "Die insette is twee reekse a en b wat slegs uit 1's en 0's bestaan.\nVoer binêre XOR op hierdie insette uit en gee die resultaat ook terug as 'n string.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/3", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Uit 'n lys van strings, gee die langste een terug. Gee die eerste een terug in die geval van meerdere strings van dieselfde lengte. Gee null terug in die geval dat die invoerlys leeg is.\n# >>> longest([])\n\n# >>> longest(['a', 'b', 'c'])\n# 'a'\n# >>> longest(['a', 'bb', 'ccc'])\n# 'ccc'\n#\ndef longest(strings)", "entry_point": "longest", "test": "\n\narg00 = []\nx0 = longest(arg00)\nv0 = nil\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [\"x\", \"y\", \"z\"]\nx1 = longest(arg10)\nv1 = \"x\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]\nx2 = longest(arg20)\nv2 = \"zzzz\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "Uit 'n lys van strings, gee die langste een terug. Gee die eerste een terug in die geval van meerdere strings van dieselfde lengte. Gee null terug in die geval dat die invoerlys leeg is.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/4", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gee die grootste gemeenskaplike deler van twee heelgetalle a en b terug.\n# >>> greatest_common_divisor(3, 5)\n# 1\n# >>> greatest_common_divisor(25, 15)\n# 5\n#\ndef greatest_common_divisor(a, b)", "entry_point": "greatest_common_divisor", "test": "\n\narg00 = 3\narg01 = 7\nx0 = greatest_common_divisor(arg00, arg01)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 10\narg11 = 15\nx1 = greatest_common_divisor(arg10, arg11)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 49\narg21 = 14\nx2 = greatest_common_divisor(arg20, arg21)\nv2 = 7\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 144\narg31 = 60\nx3 = greatest_common_divisor(arg30, arg31)\nv3 = 12\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Gee die grootste gemeenskaplike deler van twee heelgetalle a en b terug.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/5", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Die inset is 'n spasie-gedeelde string van getalle van 'nul' tot 'nege'.\n#     Geldige keuses is 'nul', 'een', 'twee', 'drie', 'vier', 'vyf', 'ses', 'sewe', 'agt' en 'nege'.\n#     Gee die string terug met die getalle gesorteer van die kleinste tot die grootste.\n# >>> sort_numbers('three one five')\n# 'one three five'\n#\ndef sort_numbers(numbers)", "entry_point": "sort_numbers", "test": "\n\narg00 = \"\"\nx0 = sort_numbers(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"three\"\nx1 = sort_numbers(arg10)\nv1 = \"three\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"three five nine\"\nx2 = sort_numbers(arg20)\nv2 = \"three five nine\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"five zero four seven nine eight\"\nx3 = sort_numbers(arg30)\nv3 = \"zero four five seven eight nine\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"six five four three two one zero\"\nx4 = sort_numbers(arg40)\nv4 = \"zero one two three four five six\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Die inset is 'n spasie-gedeelde string van getalle van 'nul' tot 'nege'.\n    Geldige keuses is 'nul', 'een', 'twee', 'drie', 'vier', 'vyf', 'ses', 'sewe', 'agt' en 'nege'.\n    Gee die string terug met die getalle gesorteer van die kleinste tot die grootste.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/6", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gegee 'n lys van getalle (van ten minste twee elemente), pas 'n lineêre transformasie toe op daardie lys,\n# sodat die kleinste getal 0 sal word en die grootste 1 sal word.\n# >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\n#\ndef rescale_to_unit(numbers)", "entry_point": "rescale_to_unit", "test": "\n\narg00 = [2.0, 49.9]\nx0 = rescale_to_unit(arg00)\nv0 = [0.0, 1.0]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [100.0, 49.9]\nx1 = rescale_to_unit(arg10)\nv1 = [1.0, 0.0]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1.0, 2.0, 3.0, 4.0, 5.0]\nx2 = rescale_to_unit(arg20)\nv2 = [0.0, 0.25, 0.5, 0.75, 1.0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [2.0, 1.0, 5.0, 3.0, 4.0]\nx3 = rescale_to_unit(arg30)\nv3 = [0.25, 0.0, 1.0, 0.5, 0.75]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [12.0, 11.0, 15.0, 13.0, 14.0]\nx4 = rescale_to_unit(arg40)\nv4 = [0.25, 0.0, 1.0, 0.5, 0.75]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Gegee 'n lys van getalle (van ten minste twee elemente), pas 'n lineêre transformasie toe op daardie lys,\nsodat die kleinste getal 0 sal word en die grootste 1 sal word.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/7", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Vir 'n gegewe string, draai kleinletters na hoofletters en hoofletters na kleinletters.\n# >>> flip_case('Hello')\n# 'hELLO'\n#\ndef flip_case(string)", "entry_point": "flip_case", "test": "\n\narg00 = \"\"\nx0 = flip_case(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Hello!\"\nx1 = flip_case(arg10)\nv1 = \"hELLO!\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"These violent delights have violent ends\"\nx2 = flip_case(arg20)\nv2 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "Vir 'n gegewe string, draai kleinletters na hoofletters en hoofletters na kleinletters.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/8", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gee slegs positiewe getalle terug in die lys.\n# >>> get_positive([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\n#\ndef get_positive(l)", "entry_point": "get_positive", "test": "\n\narg00 = [-1, -2, 4, 5, 6]\nx0 = get_positive(arg00)\nv0 = [4, 5, 6]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]\nx1 = get_positive(arg10)\nv1 = [5, 3, 2, 3, 3, 9, 123, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-1, -2]\nx2 = get_positive(arg20)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = []\nx3 = get_positive(arg30)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Gee slegs positiewe getalle terug in die lys.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/9", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gee waar terug as 'n gegewe nommer 'n priemgetal is, en vals andersins.\n# >>> is_prime(6)\n# False\n# >>> is_prime(101)\n# True\n# >>> is_prime(11)\n# True\n# >>> is_prime(13441)\n# True\n# >>> is_prime(61)\n# True\n# >>> is_prime(4)\n# False\n# >>> is_prime(1)\n# False\n#\ndef is_prime(n)", "entry_point": "is_prime", "test": "\n\narg00 = 6\nx0 = is_prime(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 101\nx1 = is_prime(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 11\nx2 = is_prime(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 13441\nx3 = is_prime(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 61\nx4 = is_prime(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 4\nx5 = is_prime(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 1\nx6 = is_prime(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 5\nx7 = is_prime(arg70)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 11\nx8 = is_prime(arg80)\nv8 = true\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 17\nx9 = is_prime(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 85\nx10 = is_prime(arg100)\nv10 = false\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 77\nx11 = is_prime(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 255379\nx12 = is_prime(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\n", "description": "Gee waar terug as 'n gegewe nommer 'n priemgetal is, en vals andersins.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/10", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gee gesorteerde unieke elemente terug in 'n lys.\n# >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\n#\ndef unique(l)", "entry_point": "unique", "test": "\n\narg00 = [5, 3, 5, 2, 3, 3, 9, 0, 123]\nx0 = unique(arg00)\nv0 = [0, 2, 3, 5, 9, 123]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\n", "description": "Gee gesorteerde unieke elemente terug in 'n lys.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/11", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # prime_fib gee terug die n-de nommer wat 'n Fibonacci-nommer is en ook 'n priemgetal is.\n# >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n# 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n# 89\n#\ndef prime_fib(n)", "entry_point": "prime_fib", "test": "\n\narg00 = 1\nx0 = prime_fib(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 2\nx1 = prime_fib(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\nx2 = prime_fib(arg20)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 4\nx3 = prime_fib(arg30)\nv3 = 13\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 5\nx4 = prime_fib(arg40)\nv4 = 89\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 6\nx5 = prime_fib(arg50)\nv5 = 233\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 7\nx6 = prime_fib(arg60)\nv6 = 1597\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 8\nx7 = prime_fib(arg70)\nv7 = 28657\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 9\nx8 = prime_fib(arg80)\nv8 = 514229\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 10\nx9 = prime_fib(arg90)\nv9 = 433494437\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "prime_fib gee terug die n-de nommer wat 'n Fibonacci-nommer is en ook 'n priemgetal is.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/12", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # triples_sum_to_zero neem 'n lys van heelgetalle as 'n inset en gee 'n waarde van Waar terug as daar drie onderskeie elemente in die lys is wat saam tot nul optel, en vals andersins.\n# >>> triples_sum_to_zero([1, 3, 5, 0])\n# False\n# >>> triples_sum_to_zero([1, 3, -2, 1])\n# True\n# >>> triples_sum_to_zero([1, 2, 3, 7])\n# False\n# >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n# True\n# >>> triples_sum_to_zero([1])\n# False\n#\ndef triples_sum_to_zero(l)", "entry_point": "triples_sum_to_zero", "test": "\n\narg00 = [1, 3, 5, 0]\nx0 = triples_sum_to_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 3, 5, -1]\nx1 = triples_sum_to_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, -2, 1]\nx2 = triples_sum_to_zero(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 2, 3, 7]\nx3 = triples_sum_to_zero(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 5, 7]\nx4 = triples_sum_to_zero(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [2, 4, -5, 3, 9, 7]\nx5 = triples_sum_to_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [1]\nx6 = triples_sum_to_zero(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [1, 3, 5, -100]\nx7 = triples_sum_to_zero(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [100, 3, 5, -100]\nx8 = triples_sum_to_zero(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "triples_sum_to_zero neem 'n lys van heelgetalle as 'n inset en gee 'n waarde van Waar terug as daar drie onderskeie elemente in die lys is wat saam tot nul optel, en vals andersins.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/13", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # pairs_sum_to_zero neem 'n lys van heelgetalle as 'n inset en gee True terug as daar twee onderskeie elemente in die lys is wat tot nul optel, en False andersins.\n# >>> pairs_sum_to_zero([1, 3, 5, 0])\n# False\n# >>> pairs_sum_to_zero([1, 3, -2, 1])\n# False\n# >>> pairs_sum_to_zero([1, 2, 3, 7])\n# False\n# >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n# True\n# >>> pairs_sum_to_zero([1])\n# False\n#\ndef pairs_sum_to_zero(l)", "entry_point": "pairs_sum_to_zero", "test": "\n\narg00 = [1, 3, 5, 0]\nx0 = pairs_sum_to_zero(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 3, -2, 1]\nx1 = pairs_sum_to_zero(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, 3, 7]\nx2 = pairs_sum_to_zero(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [2, 4, -5, 3, 5, 7]\nx3 = pairs_sum_to_zero(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\nx4 = pairs_sum_to_zero(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [-3, 9, -1, 3, 2, 30]\nx5 = pairs_sum_to_zero(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-3, 9, -1, 3, 2, 31]\nx6 = pairs_sum_to_zero(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-3, 9, -1, 4, 2, 30]\nx7 = pairs_sum_to_zero(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-3, 9, -1, 4, 2, 31]\nx8 = pairs_sum_to_zero(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "pairs_sum_to_zero neem 'n lys van heelgetalle as 'n inset en gee True terug as daar twee onderskeie elemente in die lys is wat tot nul optel, en False andersins.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/14", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Die Fib4-getalreeks is 'n reeks soortgelyk aan die Fibbonacci-reeks wat as volg gedefinieer word:\n#     fib4(0) -> 0\n#     fib4(1) -> 0\n#     fib4(2) -> 2\n#     fib4(3) -> 0\n#     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n#     Skryf asseblief 'n funksie om die n-de element van die fib4-getalreeks doeltreffend te bereken. Moenie herhaling gebruik nie.\n# >>> fib4(5)\n# 4\n# >>> fib4(6)\n# 8\n# >>> fib4(7)\n# 14\n#\ndef fib4(n)", "entry_point": "fib4", "test": "\n\narg00 = 5\nx0 = fib4(arg00)\nv0 = 4\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 8\nx1 = fib4(arg10)\nv1 = 28\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\nx2 = fib4(arg20)\nv2 = 104\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 12\nx3 = fib4(arg30)\nv3 = 386\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Die Fib4-getalreeks is 'n reeks soortgelyk aan die Fibbonacci-reeks wat as volg gedefinieer word:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Skryf asseblief 'n funksie om die n-de element van die fib4-getalreeks doeltreffend te bereken. Moenie herhaling gebruik nie.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/15", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gee die mediaan van elemente in die lys l terug.\n# >>> median([3, 1, 2, 4, 5])\n# 3\n# >>> median([-10, 4, 6, 1000, 10, 20])\n# 15.0\n#\ndef median(l)", "entry_point": "median", "test": "\n\narg00 = [3, 1, 2, 4, 5]\nx0 = median(arg00)\nv0 = 3\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [-10, 4, 6, 1000, 10, 20]\nx1 = median(arg10)\nv1 = 8.0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [5]\nx2 = median(arg20)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [6, 5]\nx3 = median(arg30)\nv3 = 5.5\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [8, 1, 3, 9, 9, 2, 7]\nx4 = median(arg40)\nv4 = 7\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Gee die mediaan van elemente in die lys l terug.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/16", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Kyk of die gegewe string 'n palindroom is.\n# >>> is_palindrome('')\n# True\n# >>> is_palindrome('aba')\n# True\n# >>> is_palindrome('aaaaa')\n# True\n# >>> is_palindrome('zbcd')\n# False\n#\ndef is_palindrome(text)", "entry_point": "is_palindrome", "test": "\n\narg00 = \"\"\nx0 = is_palindrome(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"aba\"\nx1 = is_palindrome(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"aaaaa\"\nx2 = is_palindrome(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"zbcd\"\nx3 = is_palindrome(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"xywyx\"\nx4 = is_palindrome(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"xywyz\"\nx5 = is_palindrome(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"xywzx\"\nx6 = is_palindrome(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Kyk of die gegewe string 'n palindroom is.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/17", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # \"remove_vowels\" is 'n funksie wat 'n string neem en 'n string sonder klinkers teruggee.\n# >>> remove_vowels('')\n# ''\n# >>> remove_vowels(\"abcdef\\nghijklm\")\n# 'bcdf\\nghjklm'\n# >>> remove_vowels('abcdef')\n# 'bcdf'\n# >>> remove_vowels('aaaaa')\n# ''\n# >>> remove_vowels('aaBAA')\n# 'B'\n# >>> remove_vowels('zbcd')\n# 'zbcd'\n#\ndef remove_vowels(text)", "entry_point": "remove_vowels", "test": "\n\narg00 = \"\"\nx0 = remove_vowels(arg00)\nv0 = \"\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdef\\nghijklm\"\nx1 = remove_vowels(arg10)\nv1 = \"bcdf\\nghjklm\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"fedcba\"\nx2 = remove_vowels(arg20)\nv2 = \"fdcb\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"eeeee\"\nx3 = remove_vowels(arg30)\nv3 = \"\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"acBAA\"\nx4 = remove_vowels(arg40)\nv4 = \"cB\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"EcBOO\"\nx5 = remove_vowels(arg50)\nv5 = \"cB\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"ybcd\"\nx6 = remove_vowels(arg60)\nv6 = \"ybcd\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "\"remove_vowels\" is 'n funksie wat 'n string neem en 'n string sonder klinkers teruggee.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/18", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gee Waar terug as alle getalle in die lys l onder die drempelwaarde t is.\n# >>> below_threshold([1, 2, 4, 10], 100)\n# True\n# >>> below_threshold([1, 20, 4, 10], 5)\n# False\n#\ndef below_threshold(l, t)", "entry_point": "below_threshold", "test": "\n\narg00 = [1, 2, 4, 10]\narg01 = 100\nx0 = below_threshold(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 20, 4, 10]\narg11 = 5\nx1 = below_threshold(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 20, 4, 10]\narg21 = 21\nx2 = below_threshold(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 20, 4, 10]\narg31 = 22\nx3 = below_threshold(arg30, arg31)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 8, 4, 10]\narg41 = 11\nx4 = below_threshold(arg40, arg41)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 8, 4, 10]\narg51 = 10\nx5 = below_threshold(arg50, arg51)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Gee Waar terug as alle getalle in die lys l onder die drempelwaarde t is.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/19", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Voeg twee getalle x en y by.\n# >>> add(2, 3)\n# 5\n# >>> add(5, 7)\n# 12\n#\ndef add(x, y)", "entry_point": "add", "test": "\n\narg00 = 0\narg01 = 1\nx0 = add(arg00, arg01)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 0\nx1 = add(arg10, arg11)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 2\narg21 = 3\nx2 = add(arg20, arg21)\nv2 = 5\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5\narg31 = 7\nx3 = add(arg30, arg31)\nv3 = 12\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\narg41 = 5\nx4 = add(arg40, arg41)\nv4 = 12\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 572\narg51 = 725\nx5 = add(arg50, arg51)\nv5 = 1297\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 51\narg61 = 804\nx6 = add(arg60, arg61)\nv6 = 855\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 645\narg71 = 96\nx7 = add(arg70, arg71)\nv7 = 741\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 712\narg81 = 853\nx8 = add(arg80, arg81)\nv8 = 1565\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 223\narg91 = 101\nx9 = add(arg90, arg91)\nv9 = 324\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 76\narg101 = 29\nx10 = add(arg100, arg101)\nv10 = 105\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 416\narg111 = 149\nx11 = add(arg110, arg111)\nv11 = 565\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 145\narg121 = 409\nx12 = add(arg120, arg121)\nv12 = 554\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = 535\narg131 = 430\nx13 = add(arg130, arg131)\nv13 = 965\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = 118\narg141 = 303\nx14 = add(arg140, arg141)\nv14 = 421\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = 287\narg151 = 94\nx15 = add(arg150, arg151)\nv15 = 381\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\narg160 = 768\narg161 = 257\nx16 = add(arg160, arg161)\nv16 = 1025\nif x16 != v16\n    raise StandardError, \"Error at test case 17\"\nend\n\narg170 = 421\narg171 = 677\nx17 = add(arg170, arg171)\nv17 = 1098\nif x17 != v17\n    raise StandardError, \"Error at test case 18\"\nend\n\narg180 = 802\narg181 = 814\nx18 = add(arg180, arg181)\nv18 = 1616\nif x18 != v18\n    raise StandardError, \"Error at test case 19\"\nend\n\narg190 = 510\narg191 = 922\nx19 = add(arg190, arg191)\nv19 = 1432\nif x19 != v19\n    raise StandardError, \"Error at test case 20\"\nend\n\narg200 = 345\narg201 = 819\nx20 = add(arg200, arg201)\nv20 = 1164\nif x20 != v20\n    raise StandardError, \"Error at test case 21\"\nend\n\narg210 = 895\narg211 = 436\nx21 = add(arg210, arg211)\nv21 = 1331\nif x21 != v21\n    raise StandardError, \"Error at test case 22\"\nend\n\narg220 = 123\narg221 = 424\nx22 = add(arg220, arg221)\nv22 = 547\nif x22 != v22\n    raise StandardError, \"Error at test case 23\"\nend\n\narg230 = 923\narg231 = 245\nx23 = add(arg230, arg231)\nv23 = 1168\nif x23 != v23\n    raise StandardError, \"Error at test case 24\"\nend\n\narg240 = 23\narg241 = 438\nx24 = add(arg240, arg241)\nv24 = 461\nif x24 != v24\n    raise StandardError, \"Error at test case 25\"\nend\n\narg250 = 565\narg251 = 133\nx25 = add(arg250, arg251)\nv25 = 698\nif x25 != v25\n    raise StandardError, \"Error at test case 26\"\nend\n\narg260 = 945\narg261 = 925\nx26 = add(arg260, arg261)\nv26 = 1870\nif x26 != v26\n    raise StandardError, \"Error at test case 27\"\nend\n\narg270 = 261\narg271 = 983\nx27 = add(arg270, arg271)\nv27 = 1244\nif x27 != v27\n    raise StandardError, \"Error at test case 28\"\nend\n\narg280 = 139\narg281 = 577\nx28 = add(arg280, arg281)\nv28 = 716\nif x28 != v28\n    raise StandardError, \"Error at test case 29\"\nend\n\narg290 = 763\narg291 = 178\nx29 = add(arg290, arg291)\nv29 = 941\nif x29 != v29\n    raise StandardError, \"Error at test case 30\"\nend\n\narg300 = 147\narg301 = 892\nx30 = add(arg300, arg301)\nv30 = 1039\nif x30 != v30\n    raise StandardError, \"Error at test case 31\"\nend\n\narg310 = 436\narg311 = 402\nx31 = add(arg310, arg311)\nv31 = 838\nif x31 != v31\n    raise StandardError, \"Error at test case 32\"\nend\n\narg320 = 610\narg321 = 581\nx32 = add(arg320, arg321)\nv32 = 1191\nif x32 != v32\n    raise StandardError, \"Error at test case 33\"\nend\n\narg330 = 103\narg331 = 416\nx33 = add(arg330, arg331)\nv33 = 519\nif x33 != v33\n    raise StandardError, \"Error at test case 34\"\nend\n\narg340 = 339\narg341 = 990\nx34 = add(arg340, arg341)\nv34 = 1329\nif x34 != v34\n    raise StandardError, \"Error at test case 35\"\nend\n\narg350 = 130\narg351 = 504\nx35 = add(arg350, arg351)\nv35 = 634\nif x35 != v35\n    raise StandardError, \"Error at test case 36\"\nend\n\narg360 = 242\narg361 = 717\nx36 = add(arg360, arg361)\nv36 = 959\nif x36 != v36\n    raise StandardError, \"Error at test case 37\"\nend\n\narg370 = 562\narg371 = 110\nx37 = add(arg370, arg371)\nv37 = 672\nif x37 != v37\n    raise StandardError, \"Error at test case 38\"\nend\n\narg380 = 396\narg381 = 909\nx38 = add(arg380, arg381)\nv38 = 1305\nif x38 != v38\n    raise StandardError, \"Error at test case 39\"\nend\n\narg390 = 887\narg391 = 703\nx39 = add(arg390, arg391)\nv39 = 1590\nif x39 != v39\n    raise StandardError, \"Error at test case 40\"\nend\n\narg400 = 870\narg401 = 551\nx40 = add(arg400, arg401)\nv40 = 1421\nif x40 != v40\n    raise StandardError, \"Error at test case 41\"\nend\n\narg410 = 422\narg411 = 391\nx41 = add(arg410, arg411)\nv41 = 813\nif x41 != v41\n    raise StandardError, \"Error at test case 42\"\nend\n\narg420 = 299\narg421 = 505\nx42 = add(arg420, arg421)\nv42 = 804\nif x42 != v42\n    raise StandardError, \"Error at test case 43\"\nend\n\narg430 = 346\narg431 = 56\nx43 = add(arg430, arg431)\nv43 = 402\nif x43 != v43\n    raise StandardError, \"Error at test case 44\"\nend\n\narg440 = 36\narg441 = 706\nx44 = add(arg440, arg441)\nv44 = 742\nif x44 != v44\n    raise StandardError, \"Error at test case 45\"\nend\n\narg450 = 738\narg451 = 411\nx45 = add(arg450, arg451)\nv45 = 1149\nif x45 != v45\n    raise StandardError, \"Error at test case 46\"\nend\n\narg460 = 679\narg461 = 87\nx46 = add(arg460, arg461)\nv46 = 766\nif x46 != v46\n    raise StandardError, \"Error at test case 47\"\nend\n\narg470 = 25\narg471 = 303\nx47 = add(arg470, arg471)\nv47 = 328\nif x47 != v47\n    raise StandardError, \"Error at test case 48\"\nend\n\narg480 = 161\narg481 = 612\nx48 = add(arg480, arg481)\nv48 = 773\nif x48 != v48\n    raise StandardError, \"Error at test case 49\"\nend\n\narg490 = 306\narg491 = 841\nx49 = add(arg490, arg491)\nv49 = 1147\nif x49 != v49\n    raise StandardError, \"Error at test case 50\"\nend\n\narg500 = 973\narg501 = 411\nx50 = add(arg500, arg501)\nv50 = 1384\nif x50 != v50\n    raise StandardError, \"Error at test case 51\"\nend\n\narg510 = 711\narg511 = 157\nx51 = add(arg510, arg511)\nv51 = 868\nif x51 != v51\n    raise StandardError, \"Error at test case 52\"\nend\n\narg520 = 471\narg521 = 27\nx52 = add(arg520, arg521)\nv52 = 498\nif x52 != v52\n    raise StandardError, \"Error at test case 53\"\nend\n\narg530 = 714\narg531 = 792\nx53 = add(arg530, arg531)\nv53 = 1506\nif x53 != v53\n    raise StandardError, \"Error at test case 54\"\nend\n\narg540 = 38\narg541 = 206\nx54 = add(arg540, arg541)\nv54 = 244\nif x54 != v54\n    raise StandardError, \"Error at test case 55\"\nend\n\narg550 = 907\narg551 = 343\nx55 = add(arg550, arg551)\nv55 = 1250\nif x55 != v55\n    raise StandardError, \"Error at test case 56\"\nend\n\narg560 = 23\narg561 = 760\nx56 = add(arg560, arg561)\nv56 = 783\nif x56 != v56\n    raise StandardError, \"Error at test case 57\"\nend\n\narg570 = 524\narg571 = 859\nx57 = add(arg570, arg571)\nv57 = 1383\nif x57 != v57\n    raise StandardError, \"Error at test case 58\"\nend\n\narg580 = 30\narg581 = 529\nx58 = add(arg580, arg581)\nv58 = 559\nif x58 != v58\n    raise StandardError, \"Error at test case 59\"\nend\n\narg590 = 341\narg591 = 691\nx59 = add(arg590, arg591)\nv59 = 1032\nif x59 != v59\n    raise StandardError, \"Error at test case 60\"\nend\n\narg600 = 167\narg601 = 729\nx60 = add(arg600, arg601)\nv60 = 896\nif x60 != v60\n    raise StandardError, \"Error at test case 61\"\nend\n\narg610 = 636\narg611 = 289\nx61 = add(arg610, arg611)\nv61 = 925\nif x61 != v61\n    raise StandardError, \"Error at test case 62\"\nend\n\narg620 = 503\narg621 = 144\nx62 = add(arg620, arg621)\nv62 = 647\nif x62 != v62\n    raise StandardError, \"Error at test case 63\"\nend\n\narg630 = 51\narg631 = 985\nx63 = add(arg630, arg631)\nv63 = 1036\nif x63 != v63\n    raise StandardError, \"Error at test case 64\"\nend\n\narg640 = 287\narg641 = 149\nx64 = add(arg640, arg641)\nv64 = 436\nif x64 != v64\n    raise StandardError, \"Error at test case 65\"\nend\n\narg650 = 659\narg651 = 75\nx65 = add(arg650, arg651)\nv65 = 734\nif x65 != v65\n    raise StandardError, \"Error at test case 66\"\nend\n\narg660 = 462\narg661 = 797\nx66 = add(arg660, arg661)\nv66 = 1259\nif x66 != v66\n    raise StandardError, \"Error at test case 67\"\nend\n\narg670 = 406\narg671 = 141\nx67 = add(arg670, arg671)\nv67 = 547\nif x67 != v67\n    raise StandardError, \"Error at test case 68\"\nend\n\narg680 = 106\narg681 = 44\nx68 = add(arg680, arg681)\nv68 = 150\nif x68 != v68\n    raise StandardError, \"Error at test case 69\"\nend\n\narg690 = 300\narg691 = 934\nx69 = add(arg690, arg691)\nv69 = 1234\nif x69 != v69\n    raise StandardError, \"Error at test case 70\"\nend\n\narg700 = 471\narg701 = 524\nx70 = add(arg700, arg701)\nv70 = 995\nif x70 != v70\n    raise StandardError, \"Error at test case 71\"\nend\n\narg710 = 122\narg711 = 429\nx71 = add(arg710, arg711)\nv71 = 551\nif x71 != v71\n    raise StandardError, \"Error at test case 72\"\nend\n\narg720 = 735\narg721 = 195\nx72 = add(arg720, arg721)\nv72 = 930\nif x72 != v72\n    raise StandardError, \"Error at test case 73\"\nend\n\narg730 = 335\narg731 = 484\nx73 = add(arg730, arg731)\nv73 = 819\nif x73 != v73\n    raise StandardError, \"Error at test case 74\"\nend\n\narg740 = 28\narg741 = 809\nx74 = add(arg740, arg741)\nv74 = 837\nif x74 != v74\n    raise StandardError, \"Error at test case 75\"\nend\n\narg750 = 430\narg751 = 20\nx75 = add(arg750, arg751)\nv75 = 450\nif x75 != v75\n    raise StandardError, \"Error at test case 76\"\nend\n\narg760 = 916\narg761 = 635\nx76 = add(arg760, arg761)\nv76 = 1551\nif x76 != v76\n    raise StandardError, \"Error at test case 77\"\nend\n\narg770 = 301\narg771 = 999\nx77 = add(arg770, arg771)\nv77 = 1300\nif x77 != v77\n    raise StandardError, \"Error at test case 78\"\nend\n\narg780 = 454\narg781 = 466\nx78 = add(arg780, arg781)\nv78 = 920\nif x78 != v78\n    raise StandardError, \"Error at test case 79\"\nend\n\narg790 = 905\narg791 = 259\nx79 = add(arg790, arg791)\nv79 = 1164\nif x79 != v79\n    raise StandardError, \"Error at test case 80\"\nend\n\narg800 = 168\narg801 = 205\nx80 = add(arg800, arg801)\nv80 = 373\nif x80 != v80\n    raise StandardError, \"Error at test case 81\"\nend\n\narg810 = 570\narg811 = 434\nx81 = add(arg810, arg811)\nv81 = 1004\nif x81 != v81\n    raise StandardError, \"Error at test case 82\"\nend\n\narg820 = 64\narg821 = 959\nx82 = add(arg820, arg821)\nv82 = 1023\nif x82 != v82\n    raise StandardError, \"Error at test case 83\"\nend\n\narg830 = 957\narg831 = 510\nx83 = add(arg830, arg831)\nv83 = 1467\nif x83 != v83\n    raise StandardError, \"Error at test case 84\"\nend\n\narg840 = 722\narg841 = 598\nx84 = add(arg840, arg841)\nv84 = 1320\nif x84 != v84\n    raise StandardError, \"Error at test case 85\"\nend\n\narg850 = 770\narg851 = 226\nx85 = add(arg850, arg851)\nv85 = 996\nif x85 != v85\n    raise StandardError, \"Error at test case 86\"\nend\n\narg860 = 579\narg861 = 66\nx86 = add(arg860, arg861)\nv86 = 645\nif x86 != v86\n    raise StandardError, \"Error at test case 87\"\nend\n\narg870 = 117\narg871 = 674\nx87 = add(arg870, arg871)\nv87 = 791\nif x87 != v87\n    raise StandardError, \"Error at test case 88\"\nend\n\narg880 = 530\narg881 = 30\nx88 = add(arg880, arg881)\nv88 = 560\nif x88 != v88\n    raise StandardError, \"Error at test case 89\"\nend\n\narg890 = 776\narg891 = 345\nx89 = add(arg890, arg891)\nv89 = 1121\nif x89 != v89\n    raise StandardError, \"Error at test case 90\"\nend\n\narg900 = 327\narg901 = 389\nx90 = add(arg900, arg901)\nv90 = 716\nif x90 != v90\n    raise StandardError, \"Error at test case 91\"\nend\n\narg910 = 596\narg911 = 12\nx91 = add(arg910, arg911)\nv91 = 608\nif x91 != v91\n    raise StandardError, \"Error at test case 92\"\nend\n\narg920 = 599\narg921 = 511\nx92 = add(arg920, arg921)\nv92 = 1110\nif x92 != v92\n    raise StandardError, \"Error at test case 93\"\nend\n\narg930 = 936\narg931 = 476\nx93 = add(arg930, arg931)\nv93 = 1412\nif x93 != v93\n    raise StandardError, \"Error at test case 94\"\nend\n\narg940 = 461\narg941 = 14\nx94 = add(arg940, arg941)\nv94 = 475\nif x94 != v94\n    raise StandardError, \"Error at test case 95\"\nend\n\narg950 = 966\narg951 = 157\nx95 = add(arg950, arg951)\nv95 = 1123\nif x95 != v95\n    raise StandardError, \"Error at test case 96\"\nend\n\narg960 = 326\narg961 = 91\nx96 = add(arg960, arg961)\nv96 = 417\nif x96 != v96\n    raise StandardError, \"Error at test case 97\"\nend\n\narg970 = 392\narg971 = 455\nx97 = add(arg970, arg971)\nv97 = 847\nif x97 != v97\n    raise StandardError, \"Error at test case 98\"\nend\n\narg980 = 446\narg981 = 477\nx98 = add(arg980, arg981)\nv98 = 923\nif x98 != v98\n    raise StandardError, \"Error at test case 99\"\nend\n\narg990 = 324\narg991 = 860\nx99 = add(arg990, arg991)\nv99 = 1184\nif x99 != v99\n    raise StandardError, \"Error at test case 100\"\nend\n\narg1000 = 945\narg1001 = 85\nx100 = add(arg1000, arg1001)\nv100 = 1030\nif x100 != v100\n    raise StandardError, \"Error at test case 101\"\nend\n\narg1010 = 886\narg1011 = 582\nx101 = add(arg1010, arg1011)\nv101 = 1468\nif x101 != v101\n    raise StandardError, \"Error at test case 102\"\nend\n\narg1020 = 886\narg1021 = 712\nx102 = add(arg1020, arg1021)\nv102 = 1598\nif x102 != v102\n    raise StandardError, \"Error at test case 103\"\nend\n\narg1030 = 842\narg1031 = 953\nx103 = add(arg1030, arg1031)\nv103 = 1795\nif x103 != v103\n    raise StandardError, \"Error at test case 104\"\nend\n\n", "description": "Voeg twee getalle x en y by.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/20", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Kyk of twee woorde dieselfde karakters het.\n# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n# True\n# >>> same_chars('abcd', 'dddddddabc')\n# True\n# >>> same_chars('dddddddabc', 'abcd')\n# True\n# >>> same_chars('eabcd', 'dddddddabc')\n# False\n# >>> same_chars('abcd', 'dddddddabce')\n# False\n# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n# False\n#\ndef same_chars(s0, s1)", "entry_point": "same_chars", "test": "\n\narg00 = \"eabcdzzzz\"\narg01 = \"dddzzzzzzzddeddabc\"\nx0 = same_chars(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcd\"\narg11 = \"dddddddabc\"\nx1 = same_chars(arg10, arg11)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"dddddddabc\"\narg21 = \"abcd\"\nx2 = same_chars(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"eabcd\"\narg31 = \"dddddddabc\"\nx3 = same_chars(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"abcd\"\narg41 = \"dddddddabcf\"\nx4 = same_chars(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"eabcdzzzz\"\narg51 = \"dddzzzzzzzddddabc\"\nx5 = same_chars(arg50, arg51)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"aabb\"\narg61 = \"aaccc\"\nx6 = same_chars(arg60, arg61)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Kyk of twee woorde dieselfde karakters het.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/21", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gee die n-de Fibonacci-getal terug.\n# >>> fib(10)\n# 55\n# >>> fib(1)\n# 1\n# >>> fib(8)\n# 21\n#\ndef fib(n)", "entry_point": "fib", "test": "\n\narg00 = 10\nx0 = fib(arg00)\nv0 = 55\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\nx1 = fib(arg10)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 8\nx2 = fib(arg20)\nv2 = 21\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 11\nx3 = fib(arg30)\nv3 = 89\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 12\nx4 = fib(arg40)\nv4 = 144\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Gee die n-de Fibonacci-getal terug.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/22", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gee gesorteerde unieke gemeenskaplike elemente vir twee lys.\n# >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5, 3, 2, 8], [3, 2])\n# [2, 3]\n\n#\ndef common(l1, l2)", "entry_point": "common", "test": "\n\narg00 = [1, 4, 3, 34, 653, 2, 5]\narg01 = [5, 7, 1, 5, 9, 653, 121]\nx0 = common(arg00, arg01)\nv0 = [1, 5, 653]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 3, 2, 8]\narg11 = [3, 2]\nx1 = common(arg10, arg11)\nv1 = [2, 3]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [4, 3, 2, 8]\narg21 = [3, 2, 4]\nx2 = common(arg20, arg21)\nv2 = [2, 3, 4]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 3, 2, 8]\narg31 = []\nx3 = common(arg30, arg31)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Gee gesorteerde unieke gemeenskaplike elemente vir twee lys.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/23", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gee die grootste priemfaktor van n terug. Aanvaar dat n > 1 en nie 'n priemgetal is nie.\n# >>> largest_prime_factor(13195)\n# 29\n# >>> largest_prime_factor(2048)\n# 2\n#\ndef largest_prime_factor(n)", "entry_point": "largest_prime_factor", "test": "\n\narg00 = 15\nx0 = largest_prime_factor(arg00)\nv0 = 5\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 27\nx1 = largest_prime_factor(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 63\nx2 = largest_prime_factor(arg20)\nv2 = 7\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 330\nx3 = largest_prime_factor(arg30)\nv3 = 11\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 13195\nx4 = largest_prime_factor(arg40)\nv4 = 29\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Gee die grootste priemfaktor van n terug. Aanvaar dat n > 1 en nie 'n priemgetal is nie.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/24", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# sum_to_n is 'n funksie wat getalle van 1 tot n optel.\n# >>> sum_to_n(30)\n# 465\n# >>> sum_to_n(100)\n# 5050\n# >>> sum_to_n(5)\n# 15\n# >>> sum_to_n(10)\n# 55\n# >>> sum_to_n(1)\n# 1\n#\ndef sum_to_n(n)", "entry_point": "sum_to_n", "test": "\n\narg00 = 1\nx0 = sum_to_n(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 6\nx1 = sum_to_n(arg10)\nv1 = 21\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 11\nx2 = sum_to_n(arg20)\nv2 = 66\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 30\nx3 = sum_to_n(arg30)\nv3 = 465\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 100\nx4 = sum_to_n(arg40)\nv4 = 5050\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "sum_to_n is 'n funksie wat getalle van 1 tot n optel.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/25", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# xs verteenwoordig koëffisiënte van 'n polinoom.\n#     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n#     Gee die afgeleide van hierdie polinoom terug in dieselfde vorm.\n# >>> derivative([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative([1, 2, 3])\n# [2, 6]\n#\ndef derivative(xs)", "entry_point": "derivative", "test": "\n\narg00 = [3, 1, 2, 4, 5]\nx0 = derivative(arg00)\nv0 = [1, 4, 12, 20]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 3]\nx1 = derivative(arg10)\nv1 = [2, 6]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3, 2, 1]\nx2 = derivative(arg20)\nv2 = [2, 2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 2, 1, 0, 4]\nx3 = derivative(arg30)\nv3 = [2, 2, 0, 16]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\nx4 = derivative(arg40)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "xs verteenwoordig koëffisiënte van 'n polinoom.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Gee die afgeleide van hierdie polinoom terug in dieselfde vorm.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/26", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Die FibFib getalreeks is 'n reeks soortgelyk aan die Fibbonacci-reeks wat as volg gedefinieer word:\n#     fibfib(0) == 0\n#     fibfib(1) == 0\n#     fibfib(2) == 1\n#     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n#     Skryf asseblief 'n funksie om die n-de element van die fibfib getalreeks effektief te bereken.\n# >>> fibfib(1)\n# 0\n# >>> fibfib(5)\n# 4\n# >>> fibfib(8)\n# 24\n#\ndef fibfib(n)", "entry_point": "fibfib", "test": "\n\narg00 = 2\nx0 = fibfib(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\nx1 = fibfib(arg10)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = fibfib(arg20)\nv2 = 4\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 8\nx3 = fibfib(arg30)\nv3 = 24\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 10\nx4 = fibfib(arg40)\nv4 = 81\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 12\nx5 = fibfib(arg50)\nv5 = 274\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 14\nx6 = fibfib(arg60)\nv6 = 927\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Die FibFib getalreeks is 'n reeks soortgelyk aan die Fibbonacci-reeks wat as volg gedefinieer word:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Skryf asseblief 'n funksie om die n-de element van die fibfib getalreeks effektief te bereken.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/27", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Skryf 'n funksie vowels_count wat 'n string wat 'n woord voorstel as inset neem en die aantal klinkers in die string teruggee. Klinkers in hierdie geval is 'a', 'e', 'i', 'o', 'u'. Hier is 'y' ook 'n klinker, maar slegs as dit aan die einde van die gegewe woord is.\n# \n# Voorbeeld:\n# >>> vowels_count(\"abcde\")\n# 2\n# >>> vowels_count(\"ACEDY\")\n# 3\n#\ndef vowels_count(s)", "entry_point": "vowels_count", "test": "\n\narg00 = \"abcde\"\nx0 = vowels_count(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Alone\"\nx1 = vowels_count(arg10)\nv1 = 3\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"key\"\nx2 = vowels_count(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"bye\"\nx3 = vowels_count(arg30)\nv3 = 1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"keY\"\nx4 = vowels_count(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"bYe\"\nx5 = vowels_count(arg50)\nv5 = 1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"ACEDY\"\nx6 = vowels_count(arg60)\nv6 = 3\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Skryf 'n funksie vowels_count wat 'n string wat 'n woord voorstel as inset neem en die aantal klinkers in die string teruggee. Klinkers in hierdie geval is 'a', 'e', 'i', 'o', 'u'. Hier is 'y' ook 'n klinker, maar slegs as dit aan die einde van die gegewe woord is.\n\nVoorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/28", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Jy kry 'n nie-leë lys van positiewe heelgetalle. Gee die grootste heelgetal terug wat groter is as nul en 'n frekwensie het wat groter is as of gelyk is aan die waarde van die heelgetal self. Die frekwensie van 'n heelgetal is die aantal kere wat dit in die lys voorkom. As daar geen sulke waarde bestaan nie, gee -1 terug. Voorbeelde:\n# \n#     search([4, 1, 2, 2, 3, 1]) == 2\n#     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n#     search([5, 5, 4, 4, 4]) == -1\n#\ndef search(lst)", "entry_point": "search", "test": "\n\narg00 = [5, 5, 5, 5, 1]\nx0 = search(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [4, 1, 4, 1, 4, 4]\nx1 = search(arg10)\nv1 = 4\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3, 3]\nx2 = search(arg20)\nv2 = -1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [8, 8, 8, 8, 8, 8, 8, 8]\nx3 = search(arg30)\nv3 = 8\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [2, 3, 3, 2, 2]\nx4 = search(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]\nx5 = search(arg50)\nv5 = 1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [3, 2, 8, 2]\nx6 = search(arg60)\nv6 = 2\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]\nx7 = search(arg70)\nv7 = 1\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [8, 8, 3, 6, 5, 6, 4]\nx8 = search(arg80)\nv8 = -1\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]\nx9 = search(arg90)\nv9 = 1\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [1, 9, 10, 1, 3]\nx10 = search(arg100)\nv10 = 1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]\nx11 = search(arg110)\nv11 = 5\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = [1]\nx12 = search(arg120)\nv12 = 1\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]\nx13 = search(arg130)\nv13 = 4\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]\nx14 = search(arg140)\nv14 = 2\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]\nx15 = search(arg150)\nv15 = 1\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\narg160 = [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]\nx16 = search(arg160)\nv16 = 4\nif x16 != v16\n    raise StandardError, \"Error at test case 17\"\nend\n\narg170 = [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]\nx17 = search(arg170)\nv17 = 4\nif x17 != v17\n    raise StandardError, \"Error at test case 18\"\nend\n\narg180 = [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]\nx18 = search(arg180)\nv18 = 2\nif x18 != v18\n    raise StandardError, \"Error at test case 19\"\nend\n\narg190 = [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]\nx19 = search(arg190)\nv19 = -1\nif x19 != v19\n    raise StandardError, \"Error at test case 20\"\nend\n\narg200 = [10]\nx20 = search(arg200)\nv20 = -1\nif x20 != v20\n    raise StandardError, \"Error at test case 21\"\nend\n\narg210 = [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]\nx21 = search(arg210)\nv21 = 2\nif x21 != v21\n    raise StandardError, \"Error at test case 22\"\nend\n\narg220 = [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]\nx22 = search(arg220)\nv22 = 1\nif x22 != v22\n    raise StandardError, \"Error at test case 23\"\nend\n\narg230 = [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]\nx23 = search(arg230)\nv23 = 1\nif x23 != v23\n    raise StandardError, \"Error at test case 24\"\nend\n\narg240 = [3, 10, 10, 9, 2]\nx24 = search(arg240)\nv24 = -1\nif x24 != v24\n    raise StandardError, \"Error at test case 25\"\nend\n\n", "description": "Jy kry 'n nie-leë lys van positiewe heelgetalle. Gee die grootste heelgetal terug wat groter is as nul en 'n frekwensie het wat groter is as of gelyk is aan die waarde van die heelgetal self. Die frekwensie van 'n heelgetal is die aantal kere wat dit in die lys voorkom. As daar geen sulke waarde bestaan nie, gee -1 terug. Voorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/29", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Gegee die lengtes van die drie sye van 'n driehoek. Gee die oppervlakte van die driehoek terug afgerond tot 2 desimale punte as die drie sye 'n geldige driehoek vorm. Anders gee -1 terug. Drie sye maak 'n geldige driehoek wanneer die som van enige twee sye groter is as die derde sy. Voorbeeld:\n# \n# triangle_area(3, 4, 5) == 6.00\n# triangle_area(1, 2, 10) == -1\n#\ndef triangle_area(a, b, c)", "entry_point": "triangle_area", "test": "\n\narg00 = 3\narg01 = 4\narg02 = 5\nx0 = triangle_area(arg00, arg01, arg02)\nv0 = 6.0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 2\narg12 = 10\nx1 = triangle_area(arg10, arg11, arg12)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 4\narg21 = 8\narg22 = 5\nx2 = triangle_area(arg20, arg21, arg22)\nv2 = 8.18\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 2\narg31 = 2\narg32 = 2\nx3 = triangle_area(arg30, arg31, arg32)\nv3 = 1.73\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 1\narg41 = 2\narg42 = 3\nx4 = triangle_area(arg40, arg41, arg42)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 10\narg51 = 5\narg52 = 7\nx5 = triangle_area(arg50, arg51, arg52)\nv5 = 16.25\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 2\narg61 = 6\narg62 = 3\nx6 = triangle_area(arg60, arg61, arg62)\nv6 = -1\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 1\narg71 = 1\narg72 = 1\nx7 = triangle_area(arg70, arg71, arg72)\nv7 = 0.43\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 2\narg81 = 2\narg82 = 10\nx8 = triangle_area(arg80, arg81, arg82)\nv8 = -1\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "Gegee die lengtes van die drie sye van 'n driehoek. Gee die oppervlakte van die driehoek terug afgerond tot 2 desimale punte as die drie sye 'n geldige driehoek vorm. Anders gee -1 terug. Drie sye maak 'n geldige driehoek wanneer die som van enige twee sye groter is as die derde sy. Voorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/30", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Skryf 'n funksie wat True teruggee as die voorwerp q sal vlieg, en andersins False.\n# Die voorwerp q sal vlieg as dit gebalanseerd is (dit is 'n palindromiese lys) en die som van sy elemente minder as of gelyk aan die maksimum moontlike gewig w is.\n# \n# Voorbeeld:\n# will_it_fly([1, 2], 5) ➞ False\n# # 1+2 is minder as die maksimum moontlike gewig, maar dit is ongebalanseerd.\n# \n# will_it_fly([3, 2, 3], 1) ➞ False\n# # dit is gebalanseerd, maar 3+2+3 is meer as die maksimum moontlike gewig.\n# \n# will_it_fly([3, 2, 3], 9) ➞ True\n# # 3+2+3 is minder as die maksimum moontlike gewig, en dit is gebalanseerd.\n# \n# will_it_fly([3], 5) ➞ True\n# # 3 is minder as die maksimum moontlike gewig, en dit is gebalanseerd.\n# \n#\ndef will_it_fly(q, w)", "entry_point": "will_it_fly", "test": "\n\narg00 = [3, 2, 3]\narg01 = 9\nx0 = will_it_fly(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2]\narg11 = 5\nx1 = will_it_fly(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [3]\narg21 = 5\nx2 = will_it_fly(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 2, 3]\narg31 = 1\nx3 = will_it_fly(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 3]\narg41 = 6\nx4 = will_it_fly(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [5]\narg51 = 5\nx5 = will_it_fly(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Skryf 'n funksie wat True teruggee as die voorwerp q sal vlieg, en andersins False.\nDie voorwerp q sal vlieg as dit gebalanseerd is (dit is 'n palindromiese lys) en die som van sy elemente minder as of gelyk aan die maksimum moontlike gewig w is.\n\nVoorbeeld:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 is minder as die maksimum moontlike gewig, maar dit is ongebalanseerd.\n\nwill_it_fly([3, 2, 3], 1) ➞ False\n# dit is gebalanseerd, maar 3+2+3 is meer as die maksimum moontlike gewig.\n\nwill_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 is minder as die maksimum moontlike gewig, en dit is gebalanseerd.\n\nwill_it_fly([3], 5) ➞ True\n# 3 is minder as die maksimum moontlike gewig, en dit is gebalanseerd.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/31", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Skryf 'n funksie wat waar teruggee as die gegewe getal die vermenigvuldiging van 3 priemgetalle is en vals andersins. Wetende dat (a) minder as 100 is. Voorbeeld:\n# \n# is_multiply_prime(30) == True\n# 30 = 2 * 3 * 5\n#\ndef is_multiply_prime(a)", "entry_point": "is_multiply_prime", "test": "\n\narg00 = 5\nx0 = is_multiply_prime(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 30\nx1 = is_multiply_prime(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 8\nx2 = is_multiply_prime(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 10\nx3 = is_multiply_prime(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 125\nx4 = is_multiply_prime(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 105\nx5 = is_multiply_prime(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 126\nx6 = is_multiply_prime(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 729\nx7 = is_multiply_prime(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 891\nx8 = is_multiply_prime(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1001\nx9 = is_multiply_prime(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "Skryf 'n funksie wat waar teruggee as die gegewe getal die vermenigvuldiging van 3 priemgetalle is en vals andersins. Wetende dat (a) minder as 100 is. Voorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/32", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Jy sal 'n nommer in desimale vorm ontvang en jou taak is om dit na binêre formaat te omskep. Die funksie moet 'n string teruggee, met elke karakter wat 'n binêre nommer voorstel. Elke karakter in die string sal 'n '0' of '1' wees.\n# \n# Daar sal 'n paar ekstra karakters 'db' aan die begin en einde van die string wees. Die ekstra karakters is daar om met die formaat te help.\n# \n# Voorbeelde:\n# \n# decimal_to_binary(15)   # returns \"db1111db\"\n# decimal_to_binary(32)   # returns \"db100000db\"\n#\ndef decimal_to_binary(decimal)", "entry_point": "decimal_to_binary", "test": "\n\narg00 = 0\nx0 = decimal_to_binary(arg00)\nv0 = \"db0db\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 32\nx1 = decimal_to_binary(arg10)\nv1 = \"db100000db\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 103\nx2 = decimal_to_binary(arg20)\nv2 = \"db1100111db\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 15\nx3 = decimal_to_binary(arg30)\nv3 = \"db1111db\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Jy sal 'n nommer in desimale vorm ontvang en jou taak is om dit na binêre formaat te omskep. Die funksie moet 'n string teruggee, met elke karakter wat 'n binêre nommer voorstel. Elke karakter in die string sal 'n '0' of '1' wees.\n\nDaar sal 'n paar ekstra karakters 'db' aan die begin en einde van die string wees. Die ekstra karakters is daar om met die formaat te help.\n\nVoorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/33", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Jy kry 'n string s.\n#     Jou taak is om te kyk of die string gelukkig is of nie.\n#     'n String is gelukkig as sy lengte ten minste 3 is en elke 3 opeenvolgende letters verskillend is.\n#     Byvoorbeeld:\n# \n# is_happy(a) => False\n# is_happy(aa) => False\n# is_happy(abcd) => True\n# is_happy(aabb) => False\n# is_happy(adb) => True\n# is_happy(xyy) => False\n#\ndef is_happy(s)", "entry_point": "is_happy", "test": "\n\narg00 = \"a\"\nx0 = is_happy(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"aa\"\nx1 = is_happy(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"abcd\"\nx2 = is_happy(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"aabb\"\nx3 = is_happy(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"adb\"\nx4 = is_happy(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"xyy\"\nx5 = is_happy(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"iopaxpoi\"\nx6 = is_happy(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"iopaxioi\"\nx7 = is_happy(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "Jy kry 'n string s.\n    Jou taak is om te kyk of die string gelukkig is of nie.\n    'n String is gelukkig as sy lengte ten minste 3 is en elke 3 opeenvolgende letters verskillend is.\n    Byvoorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/34", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Dit is die laaste week van die semester en die onderwyser moet die punte aan die studente gee. Die onderwyser het haar eie algoritme vir gradering gemaak. Die enigste probleem is dat sy die kode wat sy vir gradering gebruik het, verloor het. Sy het 'n lys van GPAs vir sommige studente gegee en jy moet 'n funksie skryf wat 'n lys van lettergrade kan uitvoer deur die volgende tabel te gebruik: \n#              GPA       |    Letter grade\n#               4.0                A+\n#             > 3.7                A \n#             > 3.3                A- \n#             > 3.0                B+\n#             > 2.7                B \n#             > 2.3                B-\n#             > 2.0                C+\n#             > 1.7                C\n#             > 1.3                C-\n#             > 1.0                D+ \n#             > 0.7                D \n#             > 0.0                D-\n#               0.0                E\n#     \n#     Voorbeeld:\n# \n# grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n#\ndef numerical_letter_grade(grades)", "entry_point": "numerical_letter_grade", "test": "\n\narg00 = [4.0, 3, 1.7, 2, 3.5]\nx0 = numerical_letter_grade(arg00)\nv0 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1.2]\nx1 = numerical_letter_grade(arg10)\nv1 = [\"D+\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [0.5]\nx2 = numerical_letter_grade(arg20)\nv2 = [\"D-\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [0.0]\nx3 = numerical_letter_grade(arg30)\nv3 = [\"E\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 0.3, 1.5, 2.8, 3.3]\nx4 = numerical_letter_grade(arg40)\nv4 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 0.7]\nx5 = numerical_letter_grade(arg50)\nv5 = [\"E\", \"D-\"]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Dit is die laaste week van die semester en die onderwyser moet die punte aan die studente gee. Die onderwyser het haar eie algoritme vir gradering gemaak. Die enigste probleem is dat sy die kode wat sy vir gradering gebruik het, verloor het. Sy het 'n lys van GPAs vir sommige studente gegee en jy moet 'n funksie skryf wat 'n lys van lettergrade kan uitvoer deur die volgende tabel te gebruik: \n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n    Voorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/35", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Skryf 'n funksie wat 'n string neem en True teruggee as die stringlengte 'n priemgetal is of andersins vals teruggee\n#     Voorbeelde\n# \n# prime_length('Hello') == True\n# prime_length('abcdcba') == True\n# prime_length('kittens') == True\n# prime_length('orange') == False\n#\ndef prime_length(string)", "entry_point": "prime_length", "test": "\n\narg00 = \"Hello\"\nx0 = prime_length(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdcba\"\nx1 = prime_length(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"kittens\"\nx2 = prime_length(arg20)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"orange\"\nx3 = prime_length(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"wow\"\nx4 = prime_length(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"world\"\nx5 = prime_length(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"MadaM\"\nx6 = prime_length(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"Wow\"\nx7 = prime_length(arg70)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"\"\nx8 = prime_length(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"HI\"\nx9 = prime_length(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"go\"\nx10 = prime_length(arg100)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"gogo\"\nx11 = prime_length(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"aaaaaaaaaaaaaaa\"\nx12 = prime_length(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = \"Madam\"\nx13 = prime_length(arg130)\nv13 = true\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\narg140 = \"M\"\nx14 = prime_length(arg140)\nv14 = false\nif x14 != v14\n    raise StandardError, \"Error at test case 15\"\nend\n\narg150 = \"0\"\nx15 = prime_length(arg150)\nv15 = false\nif x15 != v15\n    raise StandardError, \"Error at test case 16\"\nend\n\n", "description": "Skryf 'n funksie wat 'n string neem en True teruggee as die stringlengte 'n priemgetal is of andersins vals teruggee\n    Voorbeelde", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/36", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gegee 'n positiewe heelgetal N, gee die totale som van sy syfers in binêre vorm terug.\n# \n#     Voorbeeld\n#         Vir N = 1000, sal die som van syfers 1 wees en die uitset moet \"1\" wees.\n#         Vir N = 150, sal die som van syfers 6 wees en die uitset moet \"110\" wees.\n#         Vir N = 147, sal die som van syfers 12 wees en die uitset moet \"1100\" wees.\n#     \n#     Veranderlikes:\n#         @N heelgetal\n#              Beperkings: 0 ≤ N ≤ 10000.\n#     Uitset:\n#          'n string van binêre nommer.\n# \n#\ndef solve(n)", "entry_point": "solve", "test": "\n\narg00 = 1000\nx0 = solve(arg00)\nv0 = \"1\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 150\nx1 = solve(arg10)\nv1 = \"110\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 147\nx2 = solve(arg20)\nv2 = \"1100\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 333\nx3 = solve(arg30)\nv3 = \"1001\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 963\nx4 = solve(arg40)\nv4 = \"10010\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Gegee 'n positiewe heelgetal N, gee die totale som van sy syfers in binêre vorm terug.\n\n    Voorbeeld\n        Vir N = 1000, sal die som van syfers 1 wees en die uitset moet \"1\" wees.\n        Vir N = 150, sal die som van syfers 6 wees en die uitset moet \"110\" wees.\n        Vir N = 147, sal die som van syfers 12 wees en die uitset moet \"1100\" wees.\n    \n    Veranderlikes:\n        @N heelgetal\n             Beperkings: 0 ≤ N ≤ 10000.\n    Uitset:\n         'n string van binêre nommer.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/37", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Jy kry 'n 2-dimensionele data, as 'n geneste lys,\n# wat soortgelyk is aan 'n matriks, maar anders as matrikse,\n# kan elke ry 'n ander aantal kolomme bevat.\n# Gegee lst en 'n heelgetal x, vind heelgetalle x in die lys,\n# en gee 'n lys van tuples terug, [(x1, y1), (x2, y2) ...] sodat\n# elke tuple 'n koördinaat is - (ry, kolomme), beginnende met 0.\n# Sorteer koördinate aanvanklik volgens rye in oplopende volgorde.\n# Sorteer ook koördinate van die ry volgens kolomme in aflopende volgorde.\n# \n# Voorbeelde:\n# \n# get_row([\n#   [1,2,3,4,5,6],\n#   [1,2,3,4,1,6],\n#   [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([], 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n#\ndef get_row(lst, x)", "entry_point": "get_row", "test": "\n\narg00 = []\narg01 = 1\nx0 = get_row(arg00, arg01)\nv0 = []\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [[1]]\narg11 = 2\nx1 = get_row(arg10, arg11)\nv1 = []\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [[], [1], [1, 2, 3]]\narg21 = 3\nx2 = get_row(arg20, arg21)\nv2 = [[2, 2]]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\n", "description": "Jy kry 'n 2-dimensionele data, as 'n geneste lys,\nwat soortgelyk is aan 'n matriks, maar anders as matrikse,\nkan elke ry 'n ander aantal kolomme bevat.\nGegee lst en 'n heelgetal x, vind heelgetalle x in die lys,\nen gee 'n lys van tuples terug, [(x1, y1), (x2, y2) ...] sodat\nelke tuple 'n koördinaat is - (ry, kolomme), beginnende met 0.\nSorteer koördinate aanvanklik volgens rye in oplopende volgorde.\nSorteer ook koördinate van die ry volgens kolomme in aflopende volgorde.\n\nVoorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/38", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Jy kry 'n lys van heelgetalle.\n#     Skryf 'n funksie next_smallest() wat die tweede kleinste element van die lys teruggee.\n#     Gee null terug as daar geen sulke element is nie.\n# next_smallest([1, 2, 3, 4, 5]) == 2\n# next_smallest([5, 1, 4, 3, 2]) == 2\n# next_smallest([]) == None\n# next_smallest([1, 1]) == None\n#\ndef next_smallest(lst)", "entry_point": "next_smallest", "test": "\n\narg00 = [1, 2, 3, 4, 5]\nx0 = next_smallest(arg00)\nv0 = 2\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 1, 4, 3, 2]\nx1 = next_smallest(arg10)\nv1 = 2\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = []\nx2 = next_smallest(arg20)\nv2 = nil\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, 1]\nx3 = next_smallest(arg30)\nv3 = nil\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 1, 1, 1, 0]\nx4 = next_smallest(arg40)\nv4 = 1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 1]\nx5 = next_smallest(arg50)\nv5 = nil\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-35, 34, 12, -45]\nx6 = next_smallest(arg60)\nv6 = -35\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Jy kry 'n lys van heelgetalle.\n    Skryf 'n funksie next_smallest() wat die tweede kleinste element van die lys teruggee.\n    Gee null terug as daar geen sulke element is nie.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/39", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Jy sal 'n string van woorde gegee word, en jou taak is om die aantal vervelings te tel. 'n Verveling is 'n sin wat met die woord \"Ek\" begin. Sinne word afgebaken deur '.', '?' of '!'. \n# \n# Byvoorbeeld:\n# >>> is_bored(\"Hello world\")\n# 0\n# >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\n#\ndef is_bored(s)", "entry_point": "is_bored", "test": "\n\narg00 = \"Hello world\"\nx0 = is_bored(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Is the sky blue?\"\nx1 = is_bored(arg10)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"I love It !\"\nx2 = is_bored(arg20)\nv2 = 1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"bIt\"\nx3 = is_bored(arg30)\nv3 = 0\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"I feel good today. I will be productive. will kill It\"\nx4 = is_bored(arg40)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"You and I are going for a walk\"\nx5 = is_bored(arg50)\nv5 = 0\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Jy sal 'n string van woorde gegee word, en jou taak is om die aantal vervelings te tel. 'n Verveling is 'n sin wat met die woord \"Ek\" begin. Sinne word afgebaken deur '.', '?' of '!'. \n\nByvoorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/40", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Jy kry 'n lys van heelgetalle.\n#     Jy moet die grootste priemgetal vind en die som van sy syfers teruggee.\n# \n#     Voorbeelde:\n# \n# For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n# For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n# For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n# For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n# For lst = [0,81,12,3,1,21] the output should be 3\n# For lst = [0,8,1,2,1,7] the output should be 7\n#\ndef skjkasdkd(lst)", "entry_point": "skjkasdkd", "test": "\n\narg00 = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]\nx0 = skjkasdkd(arg00)\nv0 = 10\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]\nx1 = skjkasdkd(arg10)\nv1 = 25\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]\nx2 = skjkasdkd(arg20)\nv2 = 13\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]\nx3 = skjkasdkd(arg30)\nv3 = 11\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [0, 81, 12, 3, 1, 21]\nx4 = skjkasdkd(arg40)\nv4 = 3\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 8, 1, 2, 1, 7]\nx5 = skjkasdkd(arg50)\nv5 = 7\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [8191]\nx6 = skjkasdkd(arg60)\nv6 = 19\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [8191, 123456, 127, 7]\nx7 = skjkasdkd(arg70)\nv7 = 19\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [127, 97, 8192]\nx8 = skjkasdkd(arg80)\nv8 = 10\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "Jy kry 'n lys van heelgetalle.\n    Jy moet die grootste priemgetal vind en die som van sy syfers teruggee.\n\n    Voorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/41", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Gegee 'n woordeboek, gee waar as alle sleutels strings in kleinletters is of alle sleutels strings in hoofletters is, anders gee vals terug. Die funksie moet vals teruggee as die gegee woordeboek leeg is. Voorbeelde:\n# \n# check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n# check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n# check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n# check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n# check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n#\ndef check_dict_case(dict)", "entry_point": "check_dict_case", "test": "\n\narg00 = {\"p\"=>\"pineapple\", \"b\"=>\"banana\"}\nx0 = check_dict_case(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = {\"p\"=>\"pineapple\", \"A\"=>\"banana\", \"B\"=>\"banana\"}\nx1 = check_dict_case(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = {\"p\"=>\"pineapple\", 5=>\"banana\", \"a\"=>\"apple\"}\nx2 = check_dict_case(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = {\"Name\"=>\"John\", \"Age\"=>\"36\", \"City\"=>\"Houston\"}\nx3 = check_dict_case(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = {\"STATE\"=>\"NC\", \"ZIP\"=>\"12345\"}\nx4 = check_dict_case(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = {\"fruit\"=>\"Orange\", \"taste\"=>\"Sweet\"}\nx5 = check_dict_case(arg50)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = {}\nx6 = check_dict_case(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Gegee 'n woordeboek, gee waar as alle sleutels strings in kleinletters is of alle sleutels strings in hoofletters is, anders gee vals terug. Die funksie moet vals teruggee as die gegee woordeboek leeg is. Voorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/42", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Skep 'n funksie wat 'n waarde (string) wat 'n nommer voorstel, aanvaar en die naaste heelgetal daaraan teruggee. As die nommer ewe ver van twee heelgetalle af is, rond dit weg van nul af.\n# \n# Voorbeelde\n# >>> closest_integer(\"10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\n#\ndef closest_integer(value)", "entry_point": "closest_integer", "test": "\n\narg00 = \"10\"\nx0 = closest_integer(arg00)\nv0 = 10\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"14.5\"\nx1 = closest_integer(arg10)\nv1 = 15\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"-15.5\"\nx2 = closest_integer(arg20)\nv2 = -16\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"15.3\"\nx3 = closest_integer(arg30)\nv3 = 15\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"0\"\nx4 = closest_integer(arg40)\nv4 = 0\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Skep 'n funksie wat 'n waarde (string) wat 'n nommer voorstel, aanvaar en die naaste heelgetal daaraan teruggee. As die nommer ewe ver van twee heelgetalle af is, rond dit weg van nul af.\n\nVoorbeelde", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/43", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Gegee 'n positiewe heelgetal n, moet jy 'n hoop van n vlakke klippe maak.\n#     Die eerste vlak het n klippe.\n#     Die aantal klippe in die volgende vlak is:\n#         - die volgende onewe getal as n onewe is.\n#         - die volgende ewe getal as n ewe is.\n#     Gee die aantal klippe in elke vlak terug in 'n lys, waar die element by indeks\n#     i die aantal klippe in vlak (i+1) verteenwoordig.\n# \n#     Voorbeelde:\n# >>> make_a_pile(3)\n# [3, 5, 7]\n#\ndef make_a_pile(n)", "entry_point": "make_a_pile", "test": "\n\narg00 = 3\nx0 = make_a_pile(arg00)\nv0 = [3, 5, 7]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 4\nx1 = make_a_pile(arg10)\nv1 = [4, 6, 8, 10]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = make_a_pile(arg20)\nv2 = [5, 7, 9, 11, 13]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 6\nx3 = make_a_pile(arg30)\nv3 = [6, 8, 10, 12, 14, 16]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 8\nx4 = make_a_pile(arg40)\nv4 = [8, 10, 12, 14, 16, 18, 20, 22]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Gegee 'n positiewe heelgetal n, moet jy 'n hoop van n vlakke klippe maak.\n    Die eerste vlak het n klippe.\n    Die aantal klippe in die volgende vlak is:\n        - die volgende onewe getal as n onewe is.\n        - die volgende ewe getal as n ewe is.\n    Gee die aantal klippe in elke vlak terug in 'n lys, waar die element by indeks\n    i die aantal klippe in vlak (i+1) verteenwoordig.\n\n    Voorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/44", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Jy sal 'n string van woorde gekommaseer of geskei deur spasies ontvang. Jou taak is om die string in woorde te verdeel en 'n array van die woorde terug te gee.\n# \n# Byvoorbeeld:\n# \n# words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n#\ndef words_string(s)", "entry_point": "words_string", "test": "\n\narg00 = \"Hi, my name is John\"\nx0 = words_string(arg00)\nv0 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"One, two, three, four, five, six\"\nx1 = words_string(arg10)\nv1 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"Hi, my name\"\nx2 = words_string(arg20)\nv2 = [\"Hi\", \"my\", \"name\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"One,, two, three, four, five, six,\"\nx3 = words_string(arg30)\nv3 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"\"\nx4 = words_string(arg40)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"ahmed     , gamal\"\nx5 = words_string(arg50)\nv5 = [\"ahmed\", \"gamal\"]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Jy sal 'n string van woorde gekommaseer of geskei deur spasies ontvang. Jou taak is om die string in woorde te verdeel en 'n array van die woorde terug te gee.\n\nByvoorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/45", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Hierdie funksie neem twee positiewe getalle, x en y, en gee die grootste ewe heelgetal terug wat in die interval [x, y] insluitend is. As daar geen sulke getal is nie, moet die funksie -1 teruggee.\n# \n# Byvoorbeeld:\n# \n# choose_num(12, 15) = 14\n# choose_num(13, 12) = -1\n#\ndef choose_num(x, y)", "entry_point": "choose_num", "test": "\n\narg00 = 12\narg01 = 15\nx0 = choose_num(arg00, arg01)\nv0 = 14\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 13\narg11 = 12\nx1 = choose_num(arg10, arg11)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 33\narg21 = 12354\nx2 = choose_num(arg20, arg21)\nv2 = 12354\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5234\narg31 = 5233\nx3 = choose_num(arg30, arg31)\nv3 = -1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 6\narg41 = 29\nx4 = choose_num(arg40, arg41)\nv4 = 28\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 27\narg51 = 10\nx5 = choose_num(arg50, arg51)\nv5 = -1\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 7\narg61 = 7\nx6 = choose_num(arg60, arg61)\nv6 = -1\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 546\narg71 = 546\nx7 = choose_num(arg70, arg71)\nv7 = 546\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "Hierdie funksie neem twee positiewe getalle, x en y, en gee die grootste ewe heelgetal terug wat in die interval [x, y] insluitend is. As daar geen sulke getal is nie, moet die funksie -1 teruggee.\n\nByvoorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/46", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Jy kry twee positiewe heelgetalle n en m, en jou taak is om die gemiddelde van die heelgetalle vanaf n tot m (insluitend n en m) te bereken. Rond die antwoord af na die naaste heelgetal en omskep dit na binêre. As n groter is as m, gee -1 terug. Voorbeeld:\n# \n# rounded_avg(1, 5) => \"0b11\"\n# rounded_avg(7, 5) => -1\n# rounded_avg(10, 20) => \"0b1111\"\n# rounded_avg(20, 33) => \"0b11010\"\n#\ndef rounded_avg(n, m)", "entry_point": "rounded_avg", "test": "\n\narg00 = 1\narg01 = 5\nx0 = rounded_avg(arg00, arg01)\nv0 = \"0b11\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 7\narg11 = 13\nx1 = rounded_avg(arg10, arg11)\nv1 = \"0b1010\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 964\narg21 = 977\nx2 = rounded_avg(arg20, arg21)\nv2 = \"0b1111001010\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 996\narg31 = 997\nx3 = rounded_avg(arg30, arg31)\nv3 = \"0b1111100100\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 560\narg41 = 851\nx4 = rounded_avg(arg40, arg41)\nv4 = \"0b1011000010\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 185\narg51 = 546\nx5 = rounded_avg(arg50, arg51)\nv5 = \"0b101101110\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 362\narg61 = 496\nx6 = rounded_avg(arg60, arg61)\nv6 = \"0b110101101\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 350\narg71 = 902\nx7 = rounded_avg(arg70, arg71)\nv7 = \"0b1001110010\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 197\narg81 = 233\nx8 = rounded_avg(arg80, arg81)\nv8 = \"0b11010111\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 7\narg91 = 5\nx9 = rounded_avg(arg90, arg91)\nv9 = -1\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 5\narg101 = 1\nx10 = rounded_avg(arg100, arg101)\nv10 = -1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 5\narg111 = 5\nx11 = rounded_avg(arg110, arg111)\nv11 = \"0b101\"\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\n", "description": "Jy kry twee positiewe heelgetalle n en m, en jou taak is om die gemiddelde van die heelgetalle vanaf n tot m (insluitend n en m) te bereken. Rond die antwoord af na die naaste heelgetal en omskep dit na binêre. As n groter is as m, gee -1 terug. Voorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/47", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Implementeer die funksie f wat n as 'n parameter neem,\n# en 'n lys van grootte n teruggee, sodat die waarde van die element by indeks i die faktoriaal van i is as i ewe is,\n# of die som van getalle van 1 tot i andersins.\n# i begin by 1.\n# Die faktoriaal van i is die vermenigvuldiging van die getalle van 1 tot i (1 * 2 * ... * i).\n# Voorbeeld:\n# \n# f(5) == [1, 2, 6, 24, 15]\n#\ndef f(n)", "entry_point": "f", "test": "\n\narg00 = 5\nx0 = f(arg00)\nv0 = [1, 2, 6, 24, 15]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 7\nx1 = f(arg10)\nv1 = [1, 2, 6, 24, 15, 720, 28]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 1\nx2 = f(arg20)\nv2 = [1]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 3\nx3 = f(arg30)\nv3 = [1, 2, 6]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Implementeer die funksie f wat n as 'n parameter neem,\nen 'n lys van grootte n teruggee, sodat die waarde van die element by indeks i die faktoriaal van i is as i ewe is,\nof die som van getalle van 1 tot i andersins.\ni begin by 1.\nDie faktoriaal van i is die vermenigvuldiging van die getalle van 1 tot i (1 * 2 * ... * i).\nVoorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/48", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Gegee 'n positiewe heelgetal n, gee 'n tuple terug wat die aantal ewe en onewe heelgetal palindromes bevat wat binne die reeks (1, n) val, insluitend.\n# \n# Voorbeeld 1:\n# \n#     Inset: 3\n#     Uitset: (1, 2)\n#     Verduideliking:\n#     Heelgetal palindroom is 1, 2, 3. Een van hulle is ewe, en twee van hulle is onewe.\n# \n# Voorbeeld 2:\n# \n#     Inset: 12\n#     Uitset: (4, 6)\n#     Verduideliking:\n#     Heelgetal palindroom is 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier van hulle is ewe, en 6 van hulle is onewe.\n# \n# Nota:\n#     1. 1 <= n <= 10^3\n#     2. Die teruggekeerde tuple het onderskeidelik die aantal ewe en onewe heelgetal palindromes.\n# \n#\ndef even_odd_palindrome(n)", "entry_point": "even_odd_palindrome", "test": "\n\narg00 = 123\nx0 = even_odd_palindrome(arg00)\nv0 = [8, 13]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 12\nx1 = even_odd_palindrome(arg10)\nv1 = [4, 6]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\nx2 = even_odd_palindrome(arg20)\nv2 = [1, 2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 63\nx3 = even_odd_palindrome(arg30)\nv3 = [6, 8]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 25\nx4 = even_odd_palindrome(arg40)\nv4 = [5, 6]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 19\nx5 = even_odd_palindrome(arg50)\nv5 = [4, 6]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 9\nx6 = even_odd_palindrome(arg60)\nv6 = [4, 5]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 1\nx7 = even_odd_palindrome(arg70)\nv7 = [0, 1]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "Gegee 'n positiewe heelgetal n, gee 'n tuple terug wat die aantal ewe en onewe heelgetal palindromes bevat wat binne die reeks (1, n) val, insluitend.\n\nVoorbeeld 1:\n\n    Inset: 3\n    Uitset: (1, 2)\n    Verduideliking:\n    Heelgetal palindroom is 1, 2, 3. Een van hulle is ewe, en twee van hulle is onewe.\n\nVoorbeeld 2:\n\n    Inset: 12\n    Uitset: (4, 6)\n    Verduideliking:\n    Heelgetal palindroom is 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier van hulle is ewe, en 6 van hulle is onewe.\n\nNota:\n    1. 1 <= n <= 10^3\n    2. Die teruggekeerde tuple het onderskeidelik die aantal ewe en onewe heelgetal palindromes.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/49", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Ons het 'n reeks 'arr' van N heelgetalle arr[1], arr[2], ..., arr[N]. Die getalle in die reeks sal willekeurig wees. Jou taak is om te bepaal of dit moontlik is om 'n reeks gesorteer in nie-afnemende volgorde te kry deur die volgende operasie op die gegewe reeks uit te voer:\n#         Jy mag enige aantal regsverskuiwingsoperasies uitvoer.\n#     \n#     Een regsverskuiwingsoperasie beteken dat alle elemente van die reeks een posisie regs verskuif word. Die laaste element van die reeks sal na die beginposisie in die reeks geskuif word, d.w.s. na die 0-indeks.\n# \n#     As dit moontlik is om die gesorteerde reeks te verkry deur die bogenoemde operasie uit te voer, gee dan True terug, anders gee False terug. As die gegewe reeks leeg is, gee dan True terug.\n# \n#     Let wel: Daar word gewaarborg dat die gegewe lys unieke elemente bevat.\n# \n#     Byvoorbeeld:\n# \n#     move_one_ball([3, 4, 5, 1, 2])==>True\n#     Verduideliking: Deur 2 regsverskuiwingsoperasies uit te voer, kan nie-afnemende volgorde vir die gegewe reeks bereik word.\n#     move_one_ball([3, 5, 4, 1, 2])==>False\n#     Verduideliking: Dit is nie moontlik om nie-afnemende volgorde vir die gegewe reeks te kry deur enige aantal regsverskuiwingsoperasies uit te voer nie.\n# \n#             \n#\ndef move_one_ball(arr)", "entry_point": "move_one_ball", "test": "\n\narg00 = [3, 4, 5, 1, 2]\nx0 = move_one_ball(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [3, 5, 10, 1, 2]\nx1 = move_one_ball(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [4, 3, 1, 2]\nx2 = move_one_ball(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [3, 5, 4, 1, 2]\nx3 = move_one_ball(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = []\nx4 = move_one_ball(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Ons het 'n reeks 'arr' van N heelgetalle arr[1], arr[2], ..., arr[N]. Die getalle in die reeks sal willekeurig wees. Jou taak is om te bepaal of dit moontlik is om 'n reeks gesorteer in nie-afnemende volgorde te kry deur die volgende operasie op die gegewe reeks uit te voer:\n        Jy mag enige aantal regsverskuiwingsoperasies uitvoer.\n    \n    Een regsverskuiwingsoperasie beteken dat alle elemente van die reeks een posisie regs verskuif word. Die laaste element van die reeks sal na die beginposisie in die reeks geskuif word, d.w.s. na die 0-indeks.\n\n    As dit moontlik is om die gesorteerde reeks te verkry deur die bogenoemde operasie uit te voer, gee dan True terug, anders gee False terug. As die gegewe reeks leeg is, gee dan True terug.\n\n    Let wel: Daar word gewaarborg dat die gegewe lys unieke elemente bevat.\n\n    Byvoorbeeld:\n\n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Verduideliking: Deur 2 regsverskuiwingsoperasies uit te voer, kan nie-afnemende volgorde vir die gegewe reeks bereik word.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Verduideliking: Dit is nie moontlik om nie-afnemende volgorde vir die gegewe reeks te kry deur enige aantal regsverskuiwingsoperasies uit te voer nie.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/50", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# In hierdie probleem, sal jy 'n funksie implementeer wat twee lyste van getalle neem,\n# en bepaal of dit moontlik is om 'n uitruiling van elemente tussen hulle te doen om lst1 'n lys van net ewe getalle te maak.\n# Daar is geen limiet op die aantal uitgeruilde elemente tussen lst1 en lst2 nie.\n# As dit moontlik is om elemente tussen lst1 en lst2 uit te ruil om\n# alle elemente van lst1 ewe te maak, gee \"JA\" terug.\n# Andersins, gee \"NEE\" terug.\n# Byvoorbeeld:\n# uitruil([1, 2, 3, 4], [1, 2, 3, 4]) => \"JA\"\n# uitruil([1, 2, 3, 4], [1, 5, 3, 4]) => \"NEE\"\n# Daar word aanvaar dat die insetlyste nie leeg sal wees nie.\n# \n#\ndef exchange(lst1, lst2)", "entry_point": "exchange", "test": "\n\narg00 = [1, 2, 3, 4]\narg01 = [1, 2, 3, 4]\nx0 = exchange(arg00, arg01)\nv0 = \"YES\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 3, 4]\narg11 = [1, 5, 3, 4]\nx1 = exchange(arg10, arg11)\nv1 = \"NO\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 2, 3, 4]\narg21 = [2, 1, 4, 3]\nx2 = exchange(arg20, arg21)\nv2 = \"YES\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [5, 7, 3]\narg31 = [2, 6, 4]\nx3 = exchange(arg30, arg31)\nv3 = \"YES\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [5, 7, 3]\narg41 = [2, 6, 3]\nx4 = exchange(arg40, arg41)\nv4 = \"NO\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [3, 2, 6, 1, 8, 9]\narg51 = [3, 5, 5, 1, 1, 1]\nx5 = exchange(arg50, arg51)\nv5 = \"NO\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [100, 200]\narg61 = [200, 200]\nx6 = exchange(arg60, arg61)\nv6 = \"YES\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "In hierdie probleem, sal jy 'n funksie implementeer wat twee lyste van getalle neem,\nen bepaal of dit moontlik is om 'n uitruiling van elemente tussen hulle te doen om lst1 'n lys van net ewe getalle te maak.\nDaar is geen limiet op die aantal uitgeruilde elemente tussen lst1 en lst2 nie.\nAs dit moontlik is om elemente tussen lst1 en lst2 uit te ruil om\nalle elemente van lst1 ewe te maak, gee \"JA\" terug.\nAndersins, gee \"NEE\" terug.\nByvoorbeeld:\nuitruil([1, 2, 3, 4], [1, 2, 3, 4]) => \"JA\"\nuitruil([1, 2, 3, 4], [1, 5, 3, 4]) => \"NEE\"\nDaar word aanvaar dat die insetlyste nie leeg sal wees nie.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/51", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Taak\n#     Ons het twee strings s en c gekry, jy moet alle karakters in s wat gelyk is aan enige karakter in c verwyder\n#     en dan moet jy kyk of die resultaat string 'n palindroom is.\n#     'n String word 'n palindroom genoem as dit dieselfde agteruit as vorentoe lees.\n#     Jy moet 'n tuple teruggee wat die resultaat string en True/False vir die toets bevat.\n#     Voorbeeld\n#     Vir s = \"abcde\", c = \"ae\", moet die resultaat wees ('bcd',False)\n#     Vir s = \"abcdef\", c = \"b\" moet die resultaat wees ('acdef',False)\n#     Vir s = \"abcdedcba\", c = \"ab\", moet die resultaat wees ('cdedc',True)\n# \n#\ndef reverse_delete(s, c)", "entry_point": "reverse_delete", "test": "\n\narg00 = \"abcde\"\narg01 = \"ae\"\nx0 = reverse_delete(arg00, arg01)\nv0 = [\"bcd\", false]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"abcdef\"\narg11 = \"b\"\nx1 = reverse_delete(arg10, arg11)\nv1 = [\"acdef\", false]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"abcdedcba\"\narg21 = \"ab\"\nx2 = reverse_delete(arg20, arg21)\nv2 = [\"cdedc\", true]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"dwik\"\narg31 = \"w\"\nx3 = reverse_delete(arg30, arg31)\nv3 = [\"dik\", false]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"a\"\narg41 = \"a\"\nx4 = reverse_delete(arg40, arg41)\nv4 = [\"\", true]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"abcdedcba\"\narg51 = \"\"\nx5 = reverse_delete(arg50, arg51)\nv5 = [\"abcdedcba\", true]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"abcdedcba\"\narg61 = \"v\"\nx6 = reverse_delete(arg60, arg61)\nv6 = [\"abcdedcba\", true]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"vabba\"\narg71 = \"v\"\nx7 = reverse_delete(arg70, arg71)\nv7 = [\"abba\", true]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"mamma\"\narg81 = \"mia\"\nx8 = reverse_delete(arg80, arg81)\nv8 = [\"\", true]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "Taak\n    Ons het twee strings s en c gekry, jy moet alle karakters in s wat gelyk is aan enige karakter in c verwyder\n    en dan moet jy kyk of die resultaat string 'n palindroom is.\n    'n String word 'n palindroom genoem as dit dieselfde agteruit as vorentoe lees.\n    Jy moet 'n tuple teruggee wat die resultaat string en True/False vir die toets bevat.\n    Voorbeeld\n    Vir s = \"abcde\", c = \"ae\", moet die resultaat wees ('bcd',False)\n    Vir s = \"abcdef\", c = \"b\" moet die resultaat wees ('acdef',False)\n    Vir s = \"abcdedcba\", c = \"ab\", moet die resultaat wees ('cdedc',True)", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/52", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Jy kry 'n reghoekige rooster van putte. Elke ry verteenwoordig 'n enkele put, en elke 1 in 'n ry verteenwoordig 'n enkele eenheid water. Elke put het 'n ooreenstemmende emmer wat gebruik kan word om water daaruit te onttrek, en alle emmers het dieselfde kapasiteit. Jou taak is om die emmers te gebruik om die putte leeg te maak. Gee as uitset die aantal kere wat jy die emmers moet laat sak. \n# \n# Voorbeeld 1:\n#     Insette:\n#         rooster: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n#         emmer_kapasiteit: 1\n#     Uitset: 6\n# \n# Voorbeeld 2:\n#     Insette:\n#         rooster: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n#         emmer_kapasiteit: 2\n#     Uitset: 5\n# \n# Voorbeeld 3:\n#     Insette:\n#         rooster: [[0,0,0], [0,0,0]]\n#         emmer_kapasiteit: 5\n#     Uitset: 0\n# \n# Beperkings:\n#     * alle putte het dieselfde lengte\n#     * 1 <= rooster.lengte <= 10^2\n#     * 1 <= rooster[:,1].lengte <= 10^2\n#     * rooster[i][j] -> 0 | 1\n#     * 1 <= kapasiteit <= 10\n# \n#\ndef max_fill(grid, capacity)", "entry_point": "max_fill", "test": "\n\narg00 = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\narg01 = 1\nx0 = max_fill(arg00, arg01)\nv0 = 6\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\narg11 = 2\nx1 = max_fill(arg10, arg11)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [[0, 0, 0], [0, 0, 0]]\narg21 = 5\nx2 = max_fill(arg20, arg21)\nv2 = 0\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [[1, 1, 1, 1], [1, 1, 1, 1]]\narg31 = 2\nx3 = max_fill(arg30, arg31)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [[1, 1, 1, 1], [1, 1, 1, 1]]\narg41 = 9\nx4 = max_fill(arg40, arg41)\nv4 = 2\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Jy kry 'n reghoekige rooster van putte. Elke ry verteenwoordig 'n enkele put, en elke 1 in 'n ry verteenwoordig 'n enkele eenheid water. Elke put het 'n ooreenstemmende emmer wat gebruik kan word om water daaruit te onttrek, en alle emmers het dieselfde kapasiteit. Jou taak is om die emmers te gebruik om die putte leeg te maak. Gee as uitset die aantal kere wat jy die emmers moet laat sak. \n\nVoorbeeld 1:\n    Insette:\n        rooster: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        emmer_kapasiteit: 1\n    Uitset: 6\n\nVoorbeeld 2:\n    Insette:\n        rooster: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        emmer_kapasiteit: 2\n    Uitset: 5\n\nVoorbeeld 3:\n    Insette:\n        rooster: [[0,0,0], [0,0,0]]\n        emmer_kapasiteit: 5\n    Uitset: 0\n\nBeperkings:\n    * alle putte het dieselfde lengte\n    * 1 <= rooster.lengte <= 10^2\n    * 1 <= rooster[:,1].lengte <= 10^2\n    * rooster[i][j] -> 0 | 1\n    * 1 <= kapasiteit <= 10", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/53", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gegee 'n string s en 'n natuurlike getal n, is jy opdrag gegee om 'n funksie te implementeer wat 'n lys van alle woorde uit string s teruggee wat presies n medeklinkers bevat, in die volgorde waarin hierdie woorde in string s voorkom. As die string s leeg is, moet die funksie 'n leë lys teruggee. Let daarop: jy mag aanvaar dat die invoerstring slegs letters en spasies bevat. Voorbeelde:\n# \n# select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n# select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n# select_words(\"simple white space\", 2) ==> []\n# select_words(\"Hello world\", 4) ==> [\"world\"]\n# select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n#\ndef select_words(s, n)", "entry_point": "select_words", "test": "\n\narg00 = \"Mary had a little lamb\"\narg01 = 4\nx0 = select_words(arg00, arg01)\nv0 = [\"little\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Mary had a little lamb\"\narg11 = 3\nx1 = select_words(arg10, arg11)\nv1 = [\"Mary\", \"lamb\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"simple white space\"\narg21 = 2\nx2 = select_words(arg20, arg21)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Hello world\"\narg31 = 4\nx3 = select_words(arg30, arg31)\nv3 = [\"world\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Uncle sam\"\narg41 = 3\nx4 = select_words(arg40, arg41)\nv4 = [\"Uncle\"]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"\"\narg51 = 4\nx5 = select_words(arg50, arg51)\nv5 = []\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"a b c d e f\"\narg61 = 1\nx6 = select_words(arg60, arg61)\nv6 = [\"b\", \"c\", \"d\", \"f\"]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Gegee 'n string s en 'n natuurlike getal n, is jy opdrag gegee om 'n funksie te implementeer wat 'n lys van alle woorde uit string s teruggee wat presies n medeklinkers bevat, in die volgorde waarin hierdie woorde in string s voorkom. As die string s leeg is, moet die funksie 'n leë lys teruggee. Let daarop: jy mag aanvaar dat die invoerstring slegs letters en spasies bevat. Voorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/54", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Gegee 'n reeks arr van heelgetalle en 'n positiewe heelgetal k, gee 'n gesorteerde lys terug van lengte k met die maksimum k getalle in arr.\n# \n# Voorbeeld 1:\n# \n#     Inset: arr = [-3, -4, 5], k = 3\n#     Uitset: [-4, -3, 5]\n# \n# Voorbeeld 2:\n# \n#     Inset: arr = [4, -4, 4], k = 2\n#     Uitset: [4, 4]\n# \n# Voorbeeld 3:\n# \n#     Inset: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n#     Uitset: [2]\n# \n# Nota:\n#     1. Die lengte van die reeks sal in die omvang van [1, 1000] wees.\n#     2. Die elemente in die reeks sal in die omvang van [-1000, 1000] wees.\n#     3. 0 <= k <= len(arr)\n# \n#\ndef maximum(arr, k)", "entry_point": "maximum", "test": "\n\narg00 = [-3, -4, 5]\narg01 = 3\nx0 = maximum(arg00, arg01)\nv0 = [-4, -3, 5]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [4, -4, 4]\narg11 = 2\nx1 = maximum(arg10, arg11)\nv1 = [4, 4]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-3, 2, 1, 2, -1, -2, 1]\narg21 = 1\nx2 = maximum(arg20, arg21)\nv2 = [2]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [123, -123, 20, 0, 1, 2, -3]\narg31 = 3\nx3 = maximum(arg30, arg31)\nv3 = [2, 20, 123]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-123, 20, 0, 1, 2, -3]\narg41 = 4\nx4 = maximum(arg40, arg41)\nv4 = [0, 1, 2, 20]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [5, 15, 0, 3, -13, -8, 0]\narg51 = 7\nx5 = maximum(arg50, arg51)\nv5 = [-13, -8, 0, 0, 3, 5, 15]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-1, 0, 2, 5, 3, -10]\narg61 = 2\nx6 = maximum(arg60, arg61)\nv6 = [3, 5]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [1, 0, 5, -7]\narg71 = 1\nx7 = maximum(arg70, arg71)\nv7 = [5]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [4, -4]\narg81 = 2\nx8 = maximum(arg80, arg81)\nv8 = [-4, 4]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [-10, 10]\narg91 = 2\nx9 = maximum(arg90, arg91)\nv9 = [-10, 10]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [1, 2, 3, -23, 243, -400, 0]\narg101 = 0\nx10 = maximum(arg100, arg101)\nv10 = []\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "Gegee 'n reeks arr van heelgetalle en 'n positiewe heelgetal k, gee 'n gesorteerde lys terug van lengte k met die maksimum k getalle in arr.\n\nVoorbeeld 1:\n\n    Inset: arr = [-3, -4, 5], k = 3\n    Uitset: [-4, -3, 5]\n\nVoorbeeld 2:\n\n    Inset: arr = [4, -4, 4], k = 2\n    Uitset: [4, 4]\n\nVoorbeeld 3:\n\n    Inset: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Uitset: [2]\n\nNota:\n    1. Die lengte van die reeks sal in die omvang van [1, 1000] wees.\n    2. Die elemente in die reeks sal in die omvang van [-1000, 1000] wees.\n    3. 0 <= k <= len(arr)", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/55", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Gegee 'n nie-leë reeks van heelgetalle arr en 'n heelgetal k, gee terug die som van die elemente met hoogstens twee syfers van die eerste k elemente van arr.\n# \n# Voorbeeld:\n# \n#     Inset: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n#     Uitset: 24 # som van 21 + 3\n# \n# Beperkings:\n#     1. 1 <= len(arr) <= 100\n#     2. 1 <= k <= len(arr)\n# \n#\ndef add_elements(arr, k)", "entry_point": "add_elements", "test": "\n\narg00 = [1, -2, -3, 41, 57, 76, 87, 88, 99]\narg01 = 3\nx0 = add_elements(arg00, arg01)\nv0 = -4\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [111, 121, 3, 4000, 5, 6]\narg11 = 2\nx1 = add_elements(arg10, arg11)\nv1 = 0\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [11, 21, 3, 90, 5, 6, 7, 8, 9]\narg21 = 4\nx2 = add_elements(arg20, arg21)\nv2 = 125\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [111, 21, 3, 4000, 5, 6, 7, 8, 9]\narg31 = 4\nx3 = add_elements(arg30, arg31)\nv3 = 24\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1]\narg41 = 1\nx4 = add_elements(arg40, arg41)\nv4 = 1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Gegee 'n nie-leë reeks van heelgetalle arr en 'n heelgetal k, gee terug die som van die elemente met hoogstens twee syfers van die eerste k elemente van arr.\n\nVoorbeeld:\n\n    Inset: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Uitset: 24 # som van 21 + 3\n\nBeperkings:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/56", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Jy kry twee intervalle,\n#     waar elke interval 'n paar van heelgetalle is. Byvoorbeeld, interval = (begin, einde) = (1, 2).\n#     Die gegee intervalle is geslote wat beteken dat die interval (begin, einde)\n#     beide begin en einde insluit.\n#     Vir elke gegee interval word aanvaar dat sy begin minder of gelyk aan sy einde is.\n#     Jou taak is om te bepaal of die lengte van die kruising van hierdie twee\n#     intervalle 'n priemgetal is.\n#     Byvoorbeeld, die kruising van die intervalle (1, 3), (2, 4) is (2, 3)\n#     wat 'n lengte van 1 het, wat nie 'n priemgetal is nie.\n#     As die lengte van die kruising 'n priemgetal is, gee \"JA\" terug,\n#     anders, gee \"NEE\" terug.\n#     As die twee intervalle nie kruis nie, gee \"NEE\" terug.\n# \n# \n#     [invoer/uitvoer] voorbeelde:\n# \n# intersection((1, 2), (2, 3)) ==> \"NO\"\n# intersection((-1, 1), (0, 4)) ==> \"NO\"\n# intersection((-3, -1), (-5, 5)) ==> \"YES\"\n#\ndef intersection(interval1, interval2)", "entry_point": "intersection", "test": "\n\narg00 = [1, 2]\narg01 = [2, 3]\nx0 = intersection(arg00, arg01)\nv0 = \"NO\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [-1, 1]\narg11 = [0, 4]\nx1 = intersection(arg10, arg11)\nv1 = \"NO\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [-3, -1]\narg21 = [-5, 5]\nx2 = intersection(arg20, arg21)\nv2 = \"YES\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [-2, 2]\narg31 = [-4, 0]\nx3 = intersection(arg30, arg31)\nv3 = \"YES\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-11, 2]\narg41 = [-1, -1]\nx4 = intersection(arg40, arg41)\nv4 = \"NO\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1, 2]\narg51 = [3, 5]\nx5 = intersection(arg50, arg51)\nv5 = \"NO\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [1, 2]\narg61 = [1, 2]\nx6 = intersection(arg60, arg61)\nv6 = \"NO\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-2, -2]\narg71 = [-3, -2]\nx7 = intersection(arg70, arg71)\nv7 = \"NO\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "Jy kry twee intervalle,\n    waar elke interval 'n paar van heelgetalle is. Byvoorbeeld, interval = (begin, einde) = (1, 2).\n    Die gegee intervalle is geslote wat beteken dat die interval (begin, einde)\n    beide begin en einde insluit.\n    Vir elke gegee interval word aanvaar dat sy begin minder of gelyk aan sy einde is.\n    Jou taak is om te bepaal of die lengte van die kruising van hierdie twee\n    intervalle 'n priemgetal is.\n    Byvoorbeeld, die kruising van die intervalle (1, 3), (2, 4) is (2, 3)\n    wat 'n lengte van 1 het, wat nie 'n priemgetal is nie.\n    As die lengte van die kruising 'n priemgetal is, gee \"JA\" terug,\n    anders, gee \"NEE\" terug.\n    As die twee intervalle nie kruis nie, gee \"NEE\" terug.\n\n\n    [invoer/uitvoer] voorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/57", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Almal weet van die Fibonacci-reeks, dit is diep bestudeer deur wiskundiges in die laaste paar eeue. Wat mense egter nie weet nie, is die Tribonacci-reeks. Die Tribonacci-reeks word gedefinieer deur die herhaling:\n#     tri(1) = 3\n#     tri(n) = 1 + n / 2, as n ewe is.\n#     tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), as n onewe is.\n#     Byvoorbeeld:\n#     tri(2) = 1 + (2 / 2) = 2\n#     tri(4) = 3\n#     tri(3) = tri(2) + tri(1) + tri(4)\n#            = 2 + 3 + 3 = 8 \n#     Jy kry 'n nie-negatiewe heelgetal n, jy moet 'n lys van die eerste n + 1 getalle van die Tribonacci-reeks teruggee.\n#     Voorbeelde:\n#     tri(3) = [1, 3, 2, 8]\n# \n#\ndef tri(n)", "entry_point": "tri", "test": "\n\narg00 = 3\nx0 = tri(arg00)\nv0 = [1, 3, 2.0, 8.0]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 4\nx1 = tri(arg10)\nv1 = [1, 3, 2.0, 8.0, 3.0]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 5\nx2 = tri(arg20)\nv2 = [1, 3, 2.0, 8.0, 3.0, 15.0]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 6\nx3 = tri(arg30)\nv3 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\nx4 = tri(arg40)\nv4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 8\nx5 = tri(arg50)\nv5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 9\nx6 = tri(arg60)\nv6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 20\nx7 = tri(arg70)\nv7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 0\nx8 = tri(arg80)\nv8 = [1]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1\nx9 = tri(arg90)\nv9 = [1, 3]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "Almal weet van die Fibonacci-reeks, dit is diep bestudeer deur wiskundiges in die laaste paar eeue. Wat mense egter nie weet nie, is die Tribonacci-reeks. Die Tribonacci-reeks word gedefinieer deur die herhaling:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, as n ewe is.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), as n onewe is.\n    Byvoorbeeld:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    Jy kry 'n nie-negatiewe heelgetal n, jy moet 'n lys van die eerste n + 1 getalle van die Tribonacci-reeks teruggee.\n    Voorbeelde:\n    tri(3) = [1, 3, 2, 8]", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/58", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Gegee 'n positiewe heelgetal n, gee die produk van die onewe syfers terug.\n# Gee 0 terug as al die syfers ewe is.\n# Byvoorbeeld:\n# \n# digits(1)  == 1\n# digits(4)  == 0\n# digits(235) == 15\n#\ndef digits(n)", "entry_point": "digits", "test": "\n\narg00 = 5\nx0 = digits(arg00)\nv0 = 5\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 54\nx1 = digits(arg10)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 120\nx2 = digits(arg20)\nv2 = 1\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 5014\nx3 = digits(arg30)\nv3 = 5\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 98765\nx4 = digits(arg40)\nv4 = 315\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 5576543\nx5 = digits(arg50)\nv5 = 2625\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 2468\nx6 = digits(arg60)\nv6 = 0\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Gegee 'n positiewe heelgetal n, gee die produk van die onewe syfers terug.\nGee 0 terug as al die syfers ewe is.\nByvoorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/59", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Skep 'n funksie wat 'n string as inset neem wat slegs vierkantige hakies bevat.\n# Die funksie moet waar wees as en slegs as daar 'n geldige subsekvens van hakies is waar ten minste een hakie in die subsekvens genestel is.\n# is_nested('[[]]') ➞ True\n# is_nested('[]]]]]]][[[[[]') ➞ False\n# is_nested('[][]') ➞ False\n# is_nested('[]') ➞ False\n# is_nested('[[][]]') ➞ True\n# is_nested('[[]][[') ➞ True\n#\ndef is_nested(string)", "entry_point": "is_nested", "test": "\n\narg00 = \"[[]]\"\nx0 = is_nested(arg00)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"[]]]]]]][[[[[]\"\nx1 = is_nested(arg10)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"[][]\"\nx2 = is_nested(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"[]\"\nx3 = is_nested(arg30)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"[[[[]]]]\"\nx4 = is_nested(arg40)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"[]]]]]]]]]]\"\nx5 = is_nested(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"[][][[]]\"\nx6 = is_nested(arg60)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"[[]\"\nx7 = is_nested(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"[]]\"\nx8 = is_nested(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"[[]][[\"\nx9 = is_nested(arg90)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"[[][]]\"\nx10 = is_nested(arg100)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"\"\nx11 = is_nested(arg110)\nv11 = false\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"[[[[[[[[\"\nx12 = is_nested(arg120)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = \"]]]]]]]]\"\nx13 = is_nested(arg130)\nv13 = false\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\n", "description": "Skep 'n funksie wat 'n string as inset neem wat slegs vierkantige hakies bevat.\nDie funksie moet waar wees as en slegs as daar 'n geldige subsekvens van hakies is waar ten minste een hakie in die subsekvens genestel is.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/60", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Jy kry 'n lys van getalle.\n#     Jy moet die som van die gekwadreerde getalle in die lys gee,\n#     rond elke element in die lys af na die naaste heelgetal (Ceiling).\n#     Voorbeelde:\n#     Vir lst = [1,2,3] moet die uitvoer 14 wees\n#     Vir lst = [1,4,9] moet die uitvoer 98 wees\n#     Vir lst = [1,3,5,7] moet die uitvoer 84 wees\n#     Vir lst = [1.4,4.2,0] moet die uitvoer 29 wees\n#     Vir lst = [-2.4,1,1] moet die uitvoer 6 wees\n# \n# \n\n#\ndef sum_squares(lst)", "entry_point": "sum_squares", "test": "\n\narg00 = [1, 2, 3]\nx0 = sum_squares(arg00)\nv0 = 14\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1.0, 2, 3]\nx1 = sum_squares(arg10)\nv1 = 14\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 5, 7]\nx2 = sum_squares(arg20)\nv2 = 84\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1.4, 4.2, 0]\nx3 = sum_squares(arg30)\nv3 = 29\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-2.4, 1, 1]\nx4 = sum_squares(arg40)\nv4 = 6\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [100, 1, 15, 2]\nx5 = sum_squares(arg50)\nv5 = 10230\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [10000, 10000]\nx6 = sum_squares(arg60)\nv6 = 200000000\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-1.4, 4.6, 6.3]\nx7 = sum_squares(arg70)\nv7 = 75\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-1.4, 17.9, 18.9, 19.9]\nx8 = sum_squares(arg80)\nv8 = 1086\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [0]\nx9 = sum_squares(arg90)\nv9 = 0\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [-1]\nx10 = sum_squares(arg100)\nv10 = 1\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = [-1, 1, 0]\nx11 = sum_squares(arg110)\nv11 = 2\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\n", "description": "Jy kry 'n lys van getalle.\n    Jy moet die som van die gekwadreerde getalle in die lys gee,\n    rond elke element in die lys af na die naaste heelgetal (Ceiling).\n    Voorbeelde:\n    Vir lst = [1,2,3] moet die uitvoer 14 wees\n    Vir lst = [1,4,9] moet die uitvoer 98 wees\n    Vir lst = [1,3,5,7] moet die uitvoer 84 wees\n    Vir lst = [1.4,4.2,0] moet die uitvoer 29 wees\n    Vir lst = [-2.4,1,1] moet die uitvoer 6 wees", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/61", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Skep 'n funksie wat True teruggee as die laaste karakter van 'n gegewe string 'n alfabetiese karakter is en nie deel is van 'n woord nie, en andersins vals is. Let wel: \"woord\" is 'n groep karakters wat deur spasies geskei word.\n# \n# Voorbeelde:\n# \n# check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n# check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n# check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n# check_if_last_char_is_a_letter(\"\") ➞ False \n#\ndef check_if_last_char_is_a_letter(txt)", "entry_point": "check_if_last_char_is_a_letter", "test": "\n\narg00 = \"apple\"\nx0 = check_if_last_char_is_a_letter(arg00)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"apple pi e\"\nx1 = check_if_last_char_is_a_letter(arg10)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"eeeee\"\nx2 = check_if_last_char_is_a_letter(arg20)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"A\"\nx3 = check_if_last_char_is_a_letter(arg30)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Pumpkin pie \"\nx4 = check_if_last_char_is_a_letter(arg40)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"Pumpkin pie 1\"\nx5 = check_if_last_char_is_a_letter(arg50)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"\"\nx6 = check_if_last_char_is_a_letter(arg60)\nv6 = false\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"eeeee e \"\nx7 = check_if_last_char_is_a_letter(arg70)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"apple pie\"\nx8 = check_if_last_char_is_a_letter(arg80)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"apple pi e \"\nx9 = check_if_last_char_is_a_letter(arg90)\nv9 = false\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "Skep 'n funksie wat True teruggee as die laaste karakter van 'n gegewe string 'n alfabetiese karakter is en nie deel is van 'n woord nie, en andersins vals is. Let wel: \"woord\" is 'n groep karakters wat deur spasies geskei word.\n\nVoorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/62", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Skep 'n funksie wat die grootste indeks van 'n element teruggee wat nie groter as of gelyk aan die element onmiddellik voor dit is nie. As daar geen sodanige element bestaan nie, gee dan -1 terug. Die gegewe reeks sal nie duplikaat waardes bevat nie.\n# \n# Voorbeelde:\n# \n# can_arrange([1,2,4,3,5]) = 3\n# can_arrange([1,2,3]) = -1\n#\ndef can_arrange(arr)", "entry_point": "can_arrange", "test": "\n\narg00 = [1, 2, 4, 3, 5]\nx0 = can_arrange(arg00)\nv0 = 3\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1, 2, 4, 5]\nx1 = can_arrange(arg10)\nv1 = -1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 4, 2, 5, 6, 7, 8, 9, 10]\nx2 = can_arrange(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 8, 5, 7, 3]\nx3 = can_arrange(arg30)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = []\nx4 = can_arrange(arg40)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\n", "description": "Skep 'n funksie wat die grootste indeks van 'n element teruggee wat nie groter as of gelyk aan die element onmiddellik voor dit is nie. As daar geen sodanige element bestaan nie, gee dan -1 terug. Die gegewe reeks sal nie duplikaat waardes bevat nie.\n\nVoorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/63", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Skep 'n funksie wat 'n tuple (a, b) teruggee, waar 'a' die grootste van negatiewe heelgetalle is, en 'b' die kleinste van positiewe heelgetalle in 'n lys is. As daar geen negatiewe of positiewe heelgetalle is nie, gee hulle as None terug.\n# \n# Voorbeelde:\n# \n# largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n# largest_smallest_integers([]) == (None, None)\n# largest_smallest_integers([0]) == (None, None)\n#\ndef largest_smallest_integers(lst)", "entry_point": "largest_smallest_integers", "test": "\n\narg00 = [2, 4, 1, 3, 5, 7]\nx0 = largest_smallest_integers(arg00)\nv0 = [nil, 1]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [2, 4, 1, 3, 5, 7, 0]\nx1 = largest_smallest_integers(arg10)\nv1 = [nil, 1]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [1, 3, 2, 4, 5, 6, -2]\nx2 = largest_smallest_integers(arg20)\nv2 = [-2, 1]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [4, 5, 3, 6, 2, 7, -7]\nx3 = largest_smallest_integers(arg30)\nv3 = [-7, 2]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [7, 3, 8, 4, 9, 2, 5, -9]\nx4 = largest_smallest_integers(arg40)\nv4 = [-9, 2]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = []\nx5 = largest_smallest_integers(arg50)\nv5 = [nil, nil]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [0]\nx6 = largest_smallest_integers(arg60)\nv6 = [nil, nil]\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = [-1, -3, -5, -6]\nx7 = largest_smallest_integers(arg70)\nv7 = [-1, nil]\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = [-1, -3, -5, -6, 0]\nx8 = largest_smallest_integers(arg80)\nv8 = [-1, nil]\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = [-6, -4, -4, -3, 1]\nx9 = largest_smallest_integers(arg90)\nv9 = [-3, 1]\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = [-6, -4, -4, -3, -100, 1]\nx10 = largest_smallest_integers(arg100)\nv10 = [-3, 1]\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "Skep 'n funksie wat 'n tuple (a, b) teruggee, waar 'a' die grootste van negatiewe heelgetalle is, en 'b' die kleinste van positiewe heelgetalle in 'n lys is. As daar geen negatiewe of positiewe heelgetalle is nie, gee hulle as None terug.\n\nVoorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/64", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Die Brasiliaanse faktoriaal word gedefinieer as:\n#     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n#     waar n > 0\n# \n#     Byvoorbeeld:\n# >>> special_factorial(4)\n# 288\n\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\n#\ndef special_factorial(n)", "entry_point": "special_factorial", "test": "\n\narg00 = 4\nx0 = special_factorial(arg00)\nv0 = 288\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 5\nx1 = special_factorial(arg10)\nv1 = 34560\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 7\nx2 = special_factorial(arg20)\nv2 = 125411328000\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 1\nx3 = special_factorial(arg30)\nv3 = 1\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Die Brasiliaanse faktoriaal word gedefinieer as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    waar n > 0\n\n    Byvoorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/65", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Jy kry 'n string wat 'n sin verteenwoordig,\n#     die sin bevat sommige woorde geskei deur 'n spasie,\n#     en jy moet 'n string teruggee wat die woorde van die oorspronklike sin bevat,\n#     waarvan die lengtes primgetalle is,\n#     die volgorde van die woorde in die nuwe string moet dieselfde wees as die oorspronklike een.\n# \n#     Voorbeeld 1:\n#         Inset: sin = \"This is a test\"\n#         Uitset: \"is\"\n# \n#     Voorbeeld 2:\n#         Inset: sin = \"lets go for swimming\"\n#         Uitset: \"go for\"\n# \n#     Beperkings:\n#         * 1 <= len(sin) <= 100\n#         * sin bevat slegs letters\n# \n#\ndef words_in_sentence(sentence)", "entry_point": "words_in_sentence", "test": "\n\narg00 = \"This is a test\"\nx0 = words_in_sentence(arg00)\nv0 = \"is\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"lets go for swimming\"\nx1 = words_in_sentence(arg10)\nv1 = \"go for\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"there is no place available here\"\nx2 = words_in_sentence(arg20)\nv2 = \"there is no place\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Hi I am Hussein\"\nx3 = words_in_sentence(arg30)\nv3 = \"Hi am Hussein\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"go for it\"\nx4 = words_in_sentence(arg40)\nv4 = \"go for it\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"here\"\nx5 = words_in_sentence(arg50)\nv5 = \"\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"here is\"\nx6 = words_in_sentence(arg60)\nv6 = \"is\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Jy kry 'n string wat 'n sin verteenwoordig,\n    die sin bevat sommige woorde geskei deur 'n spasie,\n    en jy moet 'n string teruggee wat die woorde van die oorspronklike sin bevat,\n    waarvan die lengtes primgetalle is,\n    die volgorde van die woorde in die nuwe string moet dieselfde wees as die oorspronklike een.\n\n    Voorbeeld 1:\n        Inset: sin = \"This is a test\"\n        Uitset: \"is\"\n\n    Voorbeeld 2:\n        Inset: sin = \"lets go for swimming\"\n        Uitset: \"go for\"\n\n    Beperkings:\n        * 1 <= len(sin) <= 100\n        * sin bevat slegs letters", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/66", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Jou taak is om 'n funksie te implementeer wat die uitdrukking vereenvoudig x * n. Die funksie gee True terug as x * n evalueer tot 'n heelgetal en False andersins. Beide x en n is 'n string verteenwoordiging van 'n breuk, en het die volgende formaat, <teller>/<noemer> waar beide teller en noemer positiewe heelgetalle is.\n# \n# Jy kan aanvaar dat x en n geldige breuke is en nie nul as noemer het nie.\n# simplify(\"1/5\", \"5/1\") = True\n# simplify(\"1/6\", \"2/1\") = False\n# simplify(\"7/10\", \"10/2\") = False\n#\ndef simplify(x, n)", "entry_point": "simplify", "test": "\n\narg00 = \"1/5\"\narg01 = \"5/1\"\nx0 = simplify(arg00, arg01)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1/6\"\narg11 = \"2/1\"\nx1 = simplify(arg10, arg11)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"5/1\"\narg21 = \"3/1\"\nx2 = simplify(arg20, arg21)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"7/10\"\narg31 = \"10/2\"\nx3 = simplify(arg30, arg31)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"2/10\"\narg41 = \"50/10\"\nx4 = simplify(arg40, arg41)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"7/2\"\narg51 = \"4/2\"\nx5 = simplify(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"11/6\"\narg61 = \"6/1\"\nx6 = simplify(arg60, arg61)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"2/3\"\narg71 = \"5/2\"\nx7 = simplify(arg70, arg71)\nv7 = false\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"5/2\"\narg81 = \"3/5\"\nx8 = simplify(arg80, arg81)\nv8 = false\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = \"2/4\"\narg91 = \"8/4\"\nx9 = simplify(arg90, arg91)\nv9 = true\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = \"2/4\"\narg101 = \"4/2\"\nx10 = simplify(arg100, arg101)\nv10 = true\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = \"1/5\"\narg111 = \"5/1\"\nx11 = simplify(arg110, arg111)\nv11 = true\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = \"1/5\"\narg121 = \"1/5\"\nx12 = simplify(arg120, arg121)\nv12 = false\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\n", "description": "Jou taak is om 'n funksie te implementeer wat die uitdrukking vereenvoudig x * n. Die funksie gee True terug as x * n evalueer tot 'n heelgetal en False andersins. Beide x en n is 'n string verteenwoordiging van 'n breuk, en het die volgende formaat, <teller>/<noemer> waar beide teller en noemer positiewe heelgetalle is.\n\nJy kan aanvaar dat x en n geldige breuke is en nie nul as noemer het nie.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/67", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Skryf 'n funksie wat die gegewe lys van heelgetalle in opklimmende volgorde sorteert volgens die som van hul syfers. Let daarop: as daar verskeie items met soortgelyke som van hul syfers is, sorteer hulle volgens hul indeks in die oorspronklike lys.\n# \n# Byvoorbeeld:\n# >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n# >>> order_by_points([]) == []\n#\ndef order_by_points(nums)", "entry_point": "order_by_points", "test": "\n\narg00 = [1, 11, -1, -11, -12]\nx0 = order_by_points(arg00)\nv0 = [-1, -11, 1, -12, 11]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\nx1 = order_by_points(arg10)\nv1 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = []\nx2 = order_by_points(arg20)\nv2 = []\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [1, -11, -32, 43, 54, -98, 2, -3]\nx3 = order_by_points(arg30)\nv3 = [-3, -32, -98, -11, 1, 2, 43, 54]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\nx4 = order_by_points(arg40)\nv4 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0, 6, 6, -76, -21, 23, 4]\nx5 = order_by_points(arg50)\nv5 = [-76, -21, 0, 4, 23, 6, 6]\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Skryf 'n funksie wat die gegewe lys van heelgetalle in opklimmende volgorde sorteert volgens die som van hul syfers. Let daarop: as daar verskeie items met soortgelyke som van hul syfers is, sorteer hulle volgens hul indeks in die oorspronklike lys.\n\nByvoorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/68", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Skryf 'n funksie wat 'n reeks van getalle as inset neem en die aantal elemente in die reeks teruggee wat groter as 10 is en waarvan die eerste en laaste syfers van 'n getal beide onewe is (1, 3, 5, 7, 9). Byvoorbeeld:\n# \n# specialFilter([15, -73, 14, -15]) => 1 \n# specialFilter([33, -2, -3, 45, 21, 109]) => 2\n#\ndef specialfilter(nums)", "entry_point": "specialfilter", "test": "\n\narg00 = [5, -2, 1, -5]\nx0 = specialfilter(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [15, -73, 14, -15]\nx1 = specialfilter(arg10)\nv1 = 1\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [33, -2, -3, 45, 21, 109]\nx2 = specialfilter(arg20)\nv2 = 2\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [43, -12, 93, 125, 121, 109]\nx3 = specialfilter(arg30)\nv3 = 4\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [71, -2, -33, 75, 21, 19]\nx4 = specialfilter(arg40)\nv4 = 3\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [1]\nx5 = specialfilter(arg50)\nv5 = 0\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = []\nx6 = specialfilter(arg60)\nv6 = 0\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Skryf 'n funksie wat 'n reeks van getalle as inset neem en die aantal elemente in die reeks teruggee wat groter as 10 is en waarvan die eerste en laaste syfers van 'n getal beide onewe is (1, 3, 5, 7, 9). Byvoorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/69", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Jy kry 'n positiewe heelgetal n. Jy moet 'n heelgetal array a van lengte n skep. Vir elke i (1 ≤ i ≤ n), is die waarde van a[i] = i * i - i + 1. Gee die aantal drietalle (a[i], a[j], a[k]) van a terug waar i < j < k, en a[i] + a[j] + a[k] 'n veelvoud van 3 is.\n# \n# Voorbeeld:\n#     Inset: n = 5\n#     Uitset: 1\n#     Verduideliking:\n#     a = [1, 3, 7, 13, 21]\n#     Die enigste geldige drietal is (1, 7, 13).\n# \n#\ndef get_max_triples(n)", "entry_point": "get_max_triples", "test": "\n\narg00 = 5\nx0 = get_max_triples(arg00)\nv0 = 1\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 6\nx1 = get_max_triples(arg10)\nv1 = 4\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\nx2 = get_max_triples(arg20)\nv2 = 36\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 100\nx3 = get_max_triples(arg30)\nv3 = 53361\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Jy kry 'n positiewe heelgetal n. Jy moet 'n heelgetal array a van lengte n skep. Vir elke i (1 ≤ i ≤ n), is die waarde van a[i] = i * i - i + 1. Gee die aantal drietalle (a[i], a[j], a[k]) van a terug waar i < j < k, en a[i] + a[j] + a[k] 'n veelvoud van 3 is.\n\nVoorbeeld:\n    Inset: n = 5\n    Uitset: 1\n    Verduideliking:\n    a = [1, 3, 7, 13, 21]\n    Die enigste geldige drietal is (1, 7, 13).", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/70", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Daar is agt planete in ons sonnestelsel: die naaste aan die Son is Mercurius, die volgende een is Venus, dan Aarde, Mars, Jupiter, Saturnus, Uranus, Neptunus. Skryf 'n funksie wat twee planeetname as strings, planet1 en planet2, neem. Die funksie moet 'n tuple teruggee wat al die planete bevat waarvan die omwentelinge tussen die omwenteling van planet1 en die omwenteling van planet2 geleë is, gesorteer volgens die nabyheid aan die son. Die funksie moet 'n leë tuple teruggee as planet1 of planet2 nie korrekte planeetname is nie. Voorbeelde.\n# \n# bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n# bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n# bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n#\ndef bf(planet1, planet2)", "entry_point": "bf", "test": "\n\narg00 = \"Jupiter\"\narg01 = \"Neptune\"\nx0 = bf(arg00, arg01)\nv0 = [\"Saturn\", \"Uranus\"]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Earth\"\narg11 = \"Mercury\"\nx1 = bf(arg10, arg11)\nv1 = [\"Venus\"]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"Mercury\"\narg21 = \"Uranus\"\nx2 = bf(arg20, arg21)\nv2 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"Neptune\"\narg31 = \"Venus\"\nx3 = bf(arg30, arg31)\nv3 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"]\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"Earth\"\narg41 = \"Earth\"\nx4 = bf(arg40, arg41)\nv4 = []\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"Mars\"\narg51 = \"Earth\"\nx5 = bf(arg50, arg51)\nv5 = []\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"Jupiter\"\narg61 = \"Makemake\"\nx6 = bf(arg60, arg61)\nv6 = []\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Daar is agt planete in ons sonnestelsel: die naaste aan die Son is Mercurius, die volgende een is Venus, dan Aarde, Mars, Jupiter, Saturnus, Uranus, Neptunus. Skryf 'n funksie wat twee planeetname as strings, planet1 en planet2, neem. Die funksie moet 'n tuple teruggee wat al die planete bevat waarvan die omwentelinge tussen die omwenteling van planet1 en die omwenteling van planet2 geleë is, gesorteer volgens die nabyheid aan die son. Die funksie moet 'n leë tuple teruggee as planet1 of planet2 nie korrekte planeetname is nie. Voorbeelde.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/71", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# 'n Eenvoudige program wat die waarde van x moet teruggee as n 'n priemgetal is en die waarde van y moet teruggee as dit nie die geval is nie.\n# \n# Voorbeelde:\n# \n# for x_or_y(7, 34, 12) == 34\n# for x_or_y(15, 8, 5) == 5\n# \n#\ndef x_or_y(n, x, y)", "entry_point": "x_or_y", "test": "\n\narg00 = 7\narg01 = 34\narg02 = 12\nx0 = x_or_y(arg00, arg01, arg02)\nv0 = 34\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 15\narg11 = 8\narg12 = 5\nx1 = x_or_y(arg10, arg11, arg12)\nv1 = 5\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 3\narg21 = 33\narg22 = 5212\nx2 = x_or_y(arg20, arg21, arg22)\nv2 = 33\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 1259\narg31 = 3\narg32 = 52\nx3 = x_or_y(arg30, arg31, arg32)\nv3 = 3\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7919\narg41 = -1\narg42 = 12\nx4 = x_or_y(arg40, arg41, arg42)\nv4 = -1\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 3609\narg51 = 1245\narg52 = 583\nx5 = x_or_y(arg50, arg51, arg52)\nv5 = 583\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 91\narg61 = 56\narg62 = 129\nx6 = x_or_y(arg60, arg61, arg62)\nv6 = 129\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 6\narg71 = 34\narg72 = 1234\nx7 = x_or_y(arg70, arg71, arg72)\nv7 = 1234\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 1\narg81 = 2\narg82 = 0\nx8 = x_or_y(arg80, arg81, arg82)\nv8 = 0\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 2\narg91 = 2\narg92 = 0\nx9 = x_or_y(arg90, arg91, arg92)\nv9 = 2\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\n", "description": "'n Eenvoudige program wat die waarde van x moet teruggee as n 'n priemgetal is en die waarde van y moet teruggee as dit nie die geval is nie.\n\nVoorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/72", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Gegee 'n lys van getalle, gee terug die som van die kwadrate van die getalle in die lys wat oneweredig is. Ignoreer getalle wat negatief is of nie heelgetalle is nie.\n# \n#     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n#     double_the_difference([-1, -2, 0]) == 0\n#     double_the_difference([9, -2]) == 81\n#     double_the_difference([0]) == 0\n# \n#     As die insetlys leeg is, gee 0 terug.\n# \n#\ndef double_the_difference(lst)", "entry_point": "double_the_difference", "test": "\n\narg00 = []\nx0 = double_the_difference(arg00)\nv0 = 0\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = [5, 4]\nx1 = double_the_difference(arg10)\nv1 = 25\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = [0.1, 0.2, 0.3]\nx2 = double_the_difference(arg20)\nv2 = 0\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = [-10, -20, -30]\nx3 = double_the_difference(arg30)\nv3 = 0\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = [-1, -2, 8]\nx4 = double_the_difference(arg40)\nv4 = 0\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = [0.2, 3, 5]\nx5 = double_the_difference(arg50)\nv5 = 34\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = [-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]\nx6 = double_the_difference(arg60)\nv6 = 166650\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\n", "description": "Gegee 'n lys van getalle, gee terug die som van die kwadrate van die getalle in die lys wat oneweredig is. Ignoreer getalle wat negatief is of nie heelgetalle is nie.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    As die insetlys leeg is, gee 0 terug.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/73", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Jy sal die naam van 'n klas ( 'n string) en 'n lys van uitbreidings gegee word. Die uitbreidings moet gebruik word om addisionele klasse na die klas te laai. Die sterkte van die uitbreiding is as volg: Laat CAP die nommer van die hoofletters in die uitbreiding se naam wees, en laat SM die nommer van die kleinletters in die uitbreiding se naam wees, die sterkte word gegee deur die breuk CAP - SM. Jy moet die sterkste uitbreiding vind en 'n string in hierdie formaat teruggee: ClassName.StrongestExtensionName. As daar twee of meer uitbreidings met dieselfde sterkte is, moet jy die een kies wat eerste in die lys voorkom. Byvoorbeeld, as jy \"Slices\" as die klas en 'n lys van die uitbreidings: ['SErviNGSliCes', 'Cheese', 'StuFfed'] gegee word, moet jy 'Slices.SErviNGSliCes' teruggee omdat 'SErviNGSliCes' die sterkste uitbreiding is (sy sterkte is -1). Voorbeeld:\n# \n# for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n#\ndef strongest_extension(class_name, extensions)", "entry_point": "strongest_extension", "test": "\n\narg00 = \"Watashi\"\narg01 = [\"tEN\", \"niNE\", \"eIGHt8OKe\"]\nx0 = strongest_extension(arg00, arg01)\nv0 = \"Watashi.eIGHt8OKe\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"Boku123\"\narg11 = [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]\nx1 = strongest_extension(arg10, arg11)\nv1 = \"Boku123.YEs.WeCaNe\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"__YESIMHERE\"\narg21 = [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]\nx2 = strongest_extension(arg20, arg21)\nv2 = \"__YESIMHERE.NuLl__\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"K\"\narg31 = [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]\nx3 = strongest_extension(arg30, arg31)\nv3 = \"K.TAR\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"__HAHA\"\narg41 = [\"Tab\", \"123\", \"781345\", \"-_-\"]\nx4 = strongest_extension(arg40, arg41)\nv4 = \"__HAHA.123\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"YameRore\"\narg51 = [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]\nx5 = strongest_extension(arg50, arg51)\nv5 = \"YameRore.okIWILL123\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"finNNalLLly\"\narg61 = [\"Die\", \"NowW\", \"Wow\", \"WoW\"]\nx6 = strongest_extension(arg60, arg61)\nv6 = \"finNNalLLly.WoW\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"_\"\narg71 = [\"Bb\", \"91245\"]\nx7 = strongest_extension(arg70, arg71)\nv7 = \"_.Bb\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = \"Sp\"\narg81 = [\"671235\", \"Bb\"]\nx8 = strongest_extension(arg80, arg81)\nv8 = \"Sp.671235\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\n", "description": "Jy sal die naam van 'n klas ( 'n string) en 'n lys van uitbreidings gegee word. Die uitbreidings moet gebruik word om addisionele klasse na die klas te laai. Die sterkte van die uitbreiding is as volg: Laat CAP die nommer van die hoofletters in die uitbreiding se naam wees, en laat SM die nommer van die kleinletters in die uitbreiding se naam wees, die sterkte word gegee deur die breuk CAP - SM. Jy moet die sterkste uitbreiding vind en 'n string in hierdie formaat teruggee: ClassName.StrongestExtensionName. As daar twee of meer uitbreidings met dieselfde sterkte is, moet jy die een kies wat eerste in die lys voorkom. Byvoorbeeld, as jy \"Slices\" as die klas en 'n lys van die uitbreidings: ['SErviNGSliCes', 'Cheese', 'StuFfed'] gegee word, moet jy 'Slices.SErviNGSliCes' teruggee omdat 'SErviNGSliCes' die sterkste uitbreiding is (sy sterkte is -1). Voorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/74", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Jy kry 2 woorde. Jy moet True teruggee as die tweede woord of enige van sy rotasies 'n substring is in die eerste woord.\n# cycpattern_check(\"abcd\",\"abd\") => False\n# cycpattern_check(\"hello\",\"ell\") => True\n# cycpattern_check(\"whassup\",\"psus\") => False\n# cycpattern_check(\"abab\",\"baa\") => True\n# cycpattern_check(\"efef\",\"eeff\") => False\n# cycpattern_check(\"himenss\",\"simen\") => True\n\n#\ndef cycpattern_check(a, b)", "entry_point": "cycpattern_check", "test": "\n\narg00 = \"xyzw\"\narg01 = \"xyw\"\nx0 = cycpattern_check(arg00, arg01)\nv0 = false\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"yello\"\narg11 = \"ell\"\nx1 = cycpattern_check(arg10, arg11)\nv1 = true\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"whattup\"\narg21 = \"ptut\"\nx2 = cycpattern_check(arg20, arg21)\nv2 = false\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"efef\"\narg31 = \"fee\"\nx3 = cycpattern_check(arg30, arg31)\nv3 = true\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"abab\"\narg41 = \"aabb\"\nx4 = cycpattern_check(arg40, arg41)\nv4 = false\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"winemtt\"\narg51 = \"tinem\"\nx5 = cycpattern_check(arg50, arg51)\nv5 = true\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\n", "description": "Jy kry 2 woorde. Jy moet True teruggee as die tweede woord of enige van sy rotasies 'n substring is in die eerste woord.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/75", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Gegee 'n positiewe heelgetal, verkry sy Romeinse numeriese ekwivalent as 'n string,\n# en gee dit terug in kleinletters.\n# Beperkings: 1 <= num <= 1000\n# \n# Voorbeelde:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\n#\ndef int_to_mini_roman(number)", "entry_point": "int_to_mini_roman", "test": "\n\narg00 = 19\nx0 = int_to_mini_roman(arg00)\nv0 = \"xix\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 152\nx1 = int_to_mini_roman(arg10)\nv1 = \"clii\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 251\nx2 = int_to_mini_roman(arg20)\nv2 = \"ccli\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 426\nx3 = int_to_mini_roman(arg30)\nv3 = \"cdxxvi\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 500\nx4 = int_to_mini_roman(arg40)\nv4 = \"d\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 1\nx5 = int_to_mini_roman(arg50)\nv5 = \"i\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 4\nx6 = int_to_mini_roman(arg60)\nv6 = \"iv\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 43\nx7 = int_to_mini_roman(arg70)\nv7 = \"xliii\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 90\nx8 = int_to_mini_roman(arg80)\nv8 = \"xc\"\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 94\nx9 = int_to_mini_roman(arg90)\nv9 = \"xciv\"\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 532\nx10 = int_to_mini_roman(arg100)\nv10 = \"dxxxii\"\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\narg110 = 900\nx11 = int_to_mini_roman(arg110)\nv11 = \"cm\"\nif x11 != v11\n    raise StandardError, \"Error at test case 12\"\nend\n\narg120 = 994\nx12 = int_to_mini_roman(arg120)\nv12 = \"cmxciv\"\nif x12 != v12\n    raise StandardError, \"Error at test case 13\"\nend\n\narg130 = 1000\nx13 = int_to_mini_roman(arg130)\nv13 = \"m\"\nif x13 != v13\n    raise StandardError, \"Error at test case 14\"\nend\n\n", "description": "Gegee 'n positiewe heelgetal, verkry sy Romeinse numeriese ekwivalent as 'n string,\nen gee dit terug in kleinletters.\nBeperkings: 1 <= num <= 1000\n\nVoorbeelde:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/76", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Gegee die lengtes van die drie sye van 'n driehoek. Gee Waar terug as die drie sye 'n reguit driehoek vorm, vals andersins. 'n Reguit driehoek is 'n driehoek waarin een hoek 'n regte hoek of 90 grade is. Voorbeeld:\n# \n# right_angle_triangle(3, 4, 5) == True\n# right_angle_triangle(1, 2, 3) == False\n#\ndef right_angle_triangle(a, b, c)", "entry_point": "right_angle_triangle", "test": "\n\narg00 = 3\narg01 = 4\narg02 = 5\nx0 = right_angle_triangle(arg00, arg01, arg02)\nv0 = true\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 1\narg11 = 2\narg12 = 3\nx1 = right_angle_triangle(arg10, arg11, arg12)\nv1 = false\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 10\narg21 = 6\narg22 = 8\nx2 = right_angle_triangle(arg20, arg21, arg22)\nv2 = true\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 2\narg31 = 2\narg32 = 2\nx3 = right_angle_triangle(arg30, arg31, arg32)\nv3 = false\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = 7\narg41 = 24\narg42 = 25\nx4 = right_angle_triangle(arg40, arg41, arg42)\nv4 = true\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = 10\narg51 = 5\narg52 = 7\nx5 = right_angle_triangle(arg50, arg51, arg52)\nv5 = false\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = 5\narg61 = 12\narg62 = 13\nx6 = right_angle_triangle(arg60, arg61, arg62)\nv6 = true\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = 15\narg71 = 8\narg72 = 17\nx7 = right_angle_triangle(arg70, arg71, arg72)\nv7 = true\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\narg80 = 48\narg81 = 55\narg82 = 73\nx8 = right_angle_triangle(arg80, arg81, arg82)\nv8 = true\nif x8 != v8\n    raise StandardError, \"Error at test case 9\"\nend\n\narg90 = 1\narg91 = 1\narg92 = 1\nx9 = right_angle_triangle(arg90, arg91, arg92)\nv9 = false\nif x9 != v9\n    raise StandardError, \"Error at test case 10\"\nend\n\narg100 = 2\narg101 = 2\narg102 = 10\nx10 = right_angle_triangle(arg100, arg101, arg102)\nv10 = false\nif x10 != v10\n    raise StandardError, \"Error at test case 11\"\nend\n\n", "description": "Gegee die lengtes van die drie sye van 'n driehoek. Gee Waar terug as die drie sye 'n reguit driehoek vorm, vals andersins. 'n Reguit driehoek is 'n driehoek waarin een hoek 'n regte hoek of 90 grade is. Voorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/77", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# Jy kry 'n string s.\n#     as s[i] 'n letter is, keer sy geval om van klein na groot of andersom,\n#     anders hou dit soos dit is.\n#     As die string geen letters bevat nie, keer die string om.\n#     Die funksie moet die verkryde string teruggee.\n#     Voorbeelde\n# \n# solve(\"1234\") = \"4321\"\n# solve(\"ab\") = \"AB\"\n# solve(\"#a@C\") = \"#A@c\"\n#\ndef solve(s)", "entry_point": "solve", "test": "\n\narg00 = \"AsDf\"\nx0 = solve(arg00)\nv0 = \"aSdF\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"1234\"\nx1 = solve(arg10)\nv1 = \"4321\"\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"ab\"\nx2 = solve(arg20)\nv2 = \"AB\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"#a@C\"\nx3 = solve(arg30)\nv3 = \"#A@c\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\narg40 = \"#AsdfW^45\"\nx4 = solve(arg40)\nv4 = \"#aSDFw^45\"\nif x4 != v4\n    raise StandardError, \"Error at test case 5\"\nend\n\narg50 = \"#6@2\"\nx5 = solve(arg50)\nv5 = \"2@6#\"\nif x5 != v5\n    raise StandardError, \"Error at test case 6\"\nend\n\narg60 = \"#\\$a^D\"\nx6 = solve(arg60)\nv6 = \"#\\$A^d\"\nif x6 != v6\n    raise StandardError, \"Error at test case 7\"\nend\n\narg70 = \"#ccc\"\nx7 = solve(arg70)\nv7 = \"#CCC\"\nif x7 != v7\n    raise StandardError, \"Error at test case 8\"\nend\n\n", "description": "Jy kry 'n string s.\n    as s[i] 'n letter is, keer sy geval om van klein na groot of andersom,\n    anders hou dit soos dit is.\n    As die string geen letters bevat nie, keer die string om.\n    Die funksie moet die verkryde string teruggee.\n    Voorbeelde", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/78", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Gegee 'n string 'text', gee sy md5 hash ekwivalent string terug.\n# As 'text' 'n leë string is, gee null terug.\n# >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n#\ndef string_to_md5(text)", "entry_point": "string_to_md5", "test": "\n\narg00 = \"Hello world\"\nx0 = string_to_md5(arg00)\nv0 = \"3e25960a79dbc69b674cd4ec67a72c62\"\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = \"\"\nx1 = string_to_md5(arg10)\nv1 = nil\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = \"A B C\"\nx2 = string_to_md5(arg20)\nv2 = \"0ef78513b0cb8cef12743f5aeb35f888\"\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = \"password\"\nx3 = string_to_md5(arg30)\nv3 = \"5f4dcc3b5aa765d61d8327deb882cf99\"\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Gegee 'n string 'text', gee sy md5 hash ekwivalent string terug.\nAs 'text' 'n leë string is, gee null terug.", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
{"task_id": "ruby/79", "prompt": "\n##\n# Jy is 'n deskundige Ruby-programmeerder, en hier is jou taak.\n# # Gegee twee positiewe heelgetalle a en b, gee die ewe syfers tussen a en b terug, in opklimmende volgorde.\n# \n# Byvoorbeeld:\n# \n# generate_integers(2, 8) => [2, 4, 6, 8]\n# generate_integers(8, 2) => [2, 4, 6, 8]\n# generate_integers(10, 14) => []\n#\ndef generate_integers(a, b)", "entry_point": "generate_integers", "test": "\n\narg00 = 2\narg01 = 10\nx0 = generate_integers(arg00, arg01)\nv0 = [2, 4, 6, 8]\nif x0 != v0\n    raise StandardError, \"Error at test case 1\"\nend\n\narg10 = 10\narg11 = 2\nx1 = generate_integers(arg10, arg11)\nv1 = [2, 4, 6, 8]\nif x1 != v1\n    raise StandardError, \"Error at test case 2\"\nend\n\narg20 = 132\narg21 = 2\nx2 = generate_integers(arg20, arg21)\nv2 = [2, 4, 6, 8]\nif x2 != v2\n    raise StandardError, \"Error at test case 3\"\nend\n\narg30 = 17\narg31 = 89\nx3 = generate_integers(arg30, arg31)\nv3 = []\nif x3 != v3\n    raise StandardError, \"Error at test case 4\"\nend\n\n", "description": "Gegee twee positiewe heelgetalle a en b, gee die ewe syfers tussen a en b terug, in opklimmende volgorde.\n\nByvoorbeeld:", "language": "ruby", "canonical_solution": NaN, "natural_language": "Afrikaans"}
