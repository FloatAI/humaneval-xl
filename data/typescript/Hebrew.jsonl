{"task_id": "typescript/0", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * קיבלת רשימה של פעולות הפקדה ומשיכה בחשבון בנק שמתחיל עם מאזן שווה לאפס. המטרה שלך היא לזהות אם בכל נקודה המאזן של החשבון יורד מתחת לאפס, ובאותה נקודה הפונקציה צריכה להחזיר True. אחרת זה צריך להחזיר False.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n * \n */\nconst below_zero = function (operations: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = below_zero([]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = below_zero([1, 2, -3, 1, 2, -3]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = below_zero([1, 2, -4, 5, 6]);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = below_zero([1, -1, 2, -2, 5, -5, 4, -4]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = below_zero([1, -1, 2, -2, 5, -5, 4, -5]);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = below_zero([1, -2, 2, -2, 5, -5, 4, -4]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "קיבלת רשימה של פעולות הפקדה ומשיכה בחשבון בנק שמתחיל עם מאזן שווה לאפס. המטרה שלך היא לזהות אם בכל נקודה המאזן של החשבון יורד מתחת לאפס, ובאותה נקודה הפונקציה צריכה להחזיר True. אחרת זה צריך להחזיר False.", "entry_point": "below_zero", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/1", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * עבור רשימת מספרים נתונה, החזר צמד של סכום וכפל כל המספרים ברשימה.\n * סכום ריק צריך להיות שווה ל-0 וכפל ריק צריך להיות שווה ל-1.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n * \n */\nconst sum_product = function (numbers: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_product([]);\nlet expected_1 = [0, 1];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_product([1, 1, 1]);\nlet expected_2 = [3, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_product([100, 0]);\nlet expected_3 = [100, 0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_product([3, 5, 7]);\nlet expected_4 = [15, 105];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_product([10]);\nlet expected_5 = [10, 10];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "עבור רשימת מספרים נתונה, החזר צמד של סכום וכפל כל המספרים ברשימה.\nסכום ריק צריך להיות שווה ל-0 וכפל ריק צריך להיות שווה ל-1.", "entry_point": "sum_product", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/2", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * הקלט הוא שני מחרוזות a ו-b המורכבות רק מ-1 ו-0.\n * בצע XOR בינארי על הקלטים הללו והחזר את התוצאה גם כמחרוזת.\n * >>> string_xor('010', '110')\n * '100'\n * \n */\nconst string_xor = function (a: string, b: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = string_xor(\"111000\",\"101010\");\nlet expected_1 = \"010010\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = string_xor(\"1\",\"1\");\nlet expected_2 = \"0\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = string_xor(\"0101\",\"0000\");\nlet expected_3 = \"0101\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "הקלט הוא שני מחרוזות a ו-b המורכבות רק מ-1 ו-0.\nבצע XOR בינארי על הקלטים הללו והחזר את התוצאה גם כמחרוזת.", "entry_point": "string_xor", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/3", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * מתוך רשימת מחרוזות, החזר את הארוכה ביותר. החזר את הראשונה במקרה של מספר מחרוזות באותו אורך. החזר null במקרה של רשימת הקלט ריקה.\n * >>> longest([])\n * \n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n * \n */\nconst longest = function (strings: Array<string>) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = longest([]);\nlet expected_1 = undefined;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = longest([\"x\", \"y\", \"z\"]);\nlet expected_2 = \"x\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = longest([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]);\nlet expected_3 = \"zzzz\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "מתוך רשימת מחרוזות, החזר את הארוכה ביותר. החזר את הראשונה במקרה של מספר מחרוזות באותו אורך. החזר null במקרה של רשימת הקלט ריקה.", "entry_point": "longest", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/4", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * החזר את המחלק המשותף הגדול ביותר של שני מספרים a ו-b.\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n * \n */\nconst greatest_common_divisor = function (a: number, b: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = greatest_common_divisor(3,7);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = greatest_common_divisor(10,15);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = greatest_common_divisor(49,14);\nlet expected_3 = 7;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = greatest_common_divisor(144,60);\nlet expected_4 = 12;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "החזר את המחלק המשותף הגדול ביותר של שני מספרים a ו-b.", "entry_point": "greatest_common_divisor", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/5", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * הקלט הוא מחרוזת המופרדת ברווחים של מספרים מ-'אפס' עד 'תשע'.\n * האפשרויות החוקיות הן 'אפס', 'אחד', 'שניים', 'שלושה', 'ארבעה', 'חמישה', 'ששה', 'שבעה', 'שמונה' ו-'תשע'.\n * החזר את המחרוזת עם המספרים ממוינים מהקטן לגדול.\n * >>> sort_numbers('three one five')\n * 'one three five'\n * \n */\nconst sort_numbers = function (numbers: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sort_numbers(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sort_numbers(\"three\");\nlet expected_2 = \"three\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sort_numbers(\"three five nine\");\nlet expected_3 = \"three five nine\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sort_numbers(\"five zero four seven nine eight\");\nlet expected_4 = \"zero four five seven eight nine\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sort_numbers(\"six five four three two one zero\");\nlet expected_5 = \"zero one two three four five six\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "הקלט הוא מחרוזת המופרדת ברווחים של מספרים מ-'אפס' עד 'תשע'.\nהאפשרויות החוקיות הן 'אפס', 'אחד', 'שניים', 'שלושה', 'ארבעה', 'חמישה', 'ששה', 'שבעה', 'שמונה' ו-'תשע'.\nהחזר את המחרוזת עם המספרים ממוינים מהקטן לגדול.", "entry_point": "sort_numbers", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/6", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * נתונה רשימה של מספרים (בפחות משני איברים), להחיל המרה לינארית על הרשימה כך שהמספר הקטן ביותר יהפוך ל-0 והגדול ביותר יהפוך ל-1.\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n * \n */\nconst rescale_to_unit = function (numbers: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = rescale_to_unit([2.0, 49.9]);\nlet expected_1 = [0.0, 1.0];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = rescale_to_unit([100.0, 49.9]);\nlet expected_2 = [1.0, 0.0];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]);\nlet expected_3 = [0.0, 0.25, 0.5, 0.75, 1.0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]);\nlet expected_4 = [0.25, 0.0, 1.0, 0.5, 0.75];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]);\nlet expected_5 = [0.25, 0.0, 1.0, 0.5, 0.75];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "נתונה רשימה של מספרים (בפחות משני איברים), להחיל המרה לינארית על הרשימה כך שהמספר הקטן ביותר יהפוך ל-0 והגדול ביותר יהפוך ל-1.", "entry_point": "rescale_to_unit", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/7", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * עבור מחרוזת נתונה, הפוך תווים באותיות קטנות לאותיות גדולות ואותיות גדולות לאותיות קטנות.\n * >>> flip_case('Hello')\n * 'hELLO'\n * \n */\nconst flip_case = function (string0: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = flip_case(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = flip_case(\"Hello!\");\nlet expected_2 = \"hELLO!\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = flip_case(\"These violent delights have violent ends\");\nlet expected_3 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "עבור מחרוזת נתונה, הפוך תווים באותיות קטנות לאותיות גדולות ואותיות גדולות לאותיות קטנות.", "entry_point": "flip_case", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/8", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * החזר רק מספרים חיוביים ברשימה.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n * \n */\nconst get_positive = function (l: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_positive([-1, -2, 4, 5, 6]);\nlet expected_1 = [4, 5, 6];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]);\nlet expected_2 = [5, 3, 2, 3, 3, 9, 123, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_positive([-1, -2]);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_positive([]);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "החזר רק מספרים חיוביים ברשימה.", "entry_point": "get_positive", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/9", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * החזר ערך אמת אם המספר הנתון הוא מספר ראשוני, ושקר אחרת.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n * \n */\nconst is_prime = function (n: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_prime(6);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_prime(101);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_prime(11);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_prime(13441);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_prime(61);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_prime(4);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_prime(1);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_prime(5);\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_prime(11);\nlet expected_9 = true;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_prime(17);\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = is_prime(85);\nlet expected_11 = false;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = is_prime(77);\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = is_prime(255379);\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\n", "language": "typescript", "description": "החזר ערך אמת אם המספר הנתון הוא מספר ראשוני, ושקר אחרת.", "entry_point": "is_prime", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/10", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * החזר אלמנטים ייחודיים ממוינים ברשימה\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n * \n */\nconst unique = function (l: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = unique([5, 3, 5, 2, 3, 3, 9, 0, 123]);\nlet expected_1 = [0, 2, 3, 5, 9, 123];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\n", "language": "typescript", "description": "החזר אלמנטים ייחודיים ממוינים ברשימה", "entry_point": "unique", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/11", "prompt": "import * as math from 'mathjs'\n\n/**\n * אתה מתכנת TypeScript מומחה\n * \n * prime_fib מחזיר את המספר ה-n של סדרת פיבונאצ'י שהוא גם מספר ראשוני.\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n * \n */\nconst prime_fib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = prime_fib(1);\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = prime_fib(2);\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = prime_fib(3);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = prime_fib(4);\nlet expected_4 = 13;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = prime_fib(5);\nlet expected_5 = 89;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = prime_fib(6);\nlet expected_6 = 233;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = prime_fib(7);\nlet expected_7 = 1597;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = prime_fib(8);\nlet expected_8 = 28657;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = prime_fib(9);\nlet expected_9 = 514229;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = prime_fib(10);\nlet expected_10 = 433494437;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "prime_fib מחזיר את המספר ה-n של סדרת פיבונאצ'י שהוא גם מספר ראשוני.", "entry_point": "prime_fib", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/12", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * הפונקציה triples_sum_to_zero מקבלת רשימה של מספרים שלמים כקלט.\n * היא מחזירה True אם יש שלושה איברים שונים ברשימה שסכומם שווה לאפס, ו-False אחרת.\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n * \n */\nconst triples_sum_to_zero = function (l: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = triples_sum_to_zero([1, 3, 5, 0]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = triples_sum_to_zero([1, 3, 5, -1]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = triples_sum_to_zero([1, 3, -2, 1]);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = triples_sum_to_zero([1, 2, 3, 7]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = triples_sum_to_zero([1, 2, 5, 7]);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = triples_sum_to_zero([2, 4, -5, 3, 9, 7]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = triples_sum_to_zero([1]);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = triples_sum_to_zero([1, 3, 5, -100]);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = triples_sum_to_zero([100, 3, 5, -100]);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "הפונקציה triples_sum_to_zero מקבלת רשימה של מספרים שלמים כקלט.\nהיא מחזירה True אם יש שלושה איברים שונים ברשימה שסכומם שווה לאפס, ו-False אחרת.", "entry_point": "triples_sum_to_zero", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/13", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * pairs_sum_to_zero מקבל רשימה של מספרים שלמים כקלט.\n * הפונקציה מחזירה True אם ישנם שני איברים שונים ברשימה שסכומם שווה לאפס, ו-False אחרת.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n * \n */\nconst pairs_sum_to_zero = function (l: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = pairs_sum_to_zero([1, 3, 5, 0]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = pairs_sum_to_zero([1, 3, -2, 1]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = pairs_sum_to_zero([1, 2, 3, 7]);\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = pairs_sum_to_zero([2, 4, -5, 3, 5, 7]);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = pairs_sum_to_zero([1]);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]);\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "pairs_sum_to_zero מקבל רשימה של מספרים שלמים כקלט.\nהפונקציה מחזירה True אם ישנם שני איברים שונים ברשימה שסכומם שווה לאפס, ו-False אחרת.", "entry_point": "pairs_sum_to_zero", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/14", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * סדרת מספרי Fib4 היא סדרה דומה לסדרת פיבונאצ'י המוגדרת כך:\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n *     אנא כתוב פונקציה לחישוב ביצועי של האיבר ה-n של סדרת מספרי Fib4. אין להשתמש ברקורסיה.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n * \n */\nconst fib4 = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fib4(5);\nlet expected_1 = 4;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fib4(8);\nlet expected_2 = 28;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fib4(10);\nlet expected_3 = 104;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fib4(12);\nlet expected_4 = 386;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "סדרת מספרי Fib4 היא סדרה דומה לסדרת פיבונאצ'י המוגדרת כך:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    אנא כתוב פונקציה לחישוב ביצועי של האיבר ה-n של סדרת מספרי Fib4. אין להשתמש ברקורסיה.", "entry_point": "fib4", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/15", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * החזר את החציון של האיברים ברשימה l.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n * \n */\nconst median = function (l: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = median([3, 1, 2, 4, 5]);\nlet expected_1 = 3;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = median([-10, 4, 6, 1000, 10, 20]);\nlet expected_2 = 8.0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = median([5]);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = median([6, 5]);\nlet expected_4 = 5.5;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = median([8, 1, 3, 9, 9, 2, 7]);\nlet expected_5 = 7;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "החזר את החציון של האיברים ברשימה l.", "entry_point": "median", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/16", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * בודק אם המחרוזת הנתונה היא פלינדרום.\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n * \n */\nconst is_palindrome = function (text: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_palindrome(\"\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_palindrome(\"aba\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_palindrome(\"aaaaa\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_palindrome(\"zbcd\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_palindrome(\"xywyx\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_palindrome(\"xywyz\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_palindrome(\"xywzx\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "בודק אם המחרוזת הנתונה היא פלינדרום.", "entry_point": "is_palindrome", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/17", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * remove_vowels היא פונקציה שמקבלת מחרוזת ומחזירה מחרוזת ללא תנועות שפתיים.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n * \n */\nconst remove_vowels = function (text: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = remove_vowels(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = remove_vowels(\"abcdef\\nghijklm\");\nlet expected_2 = \"bcdf\\nghjklm\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = remove_vowels(\"fedcba\");\nlet expected_3 = \"fdcb\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = remove_vowels(\"eeeee\");\nlet expected_4 = \"\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = remove_vowels(\"acBAA\");\nlet expected_5 = \"cB\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = remove_vowels(\"EcBOO\");\nlet expected_6 = \"cB\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = remove_vowels(\"ybcd\");\nlet expected_7 = \"ybcd\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "remove_vowels היא פונקציה שמקבלת מחרוזת ומחזירה מחרוזת ללא תנועות שפתיים.", "entry_point": "remove_vowels", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/18", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * החזר True אם כל המספרים ברשימה l נמצאים מתחת לסף t.\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n * \n */\nconst below_threshold = function (l: Array<number>, t: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = below_threshold([1, 2, 4, 10],100);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = below_threshold([1, 20, 4, 10],5);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = below_threshold([1, 20, 4, 10],21);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = below_threshold([1, 20, 4, 10],22);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = below_threshold([1, 8, 4, 10],11);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = below_threshold([1, 8, 4, 10],10);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "החזר True אם כל המספרים ברשימה l נמצאים מתחת לסף t.", "entry_point": "below_threshold", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/19", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * הוסף שני מספרים x ו-y\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n * \n */\nconst add = function (x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = add(0,1);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = add(1,0);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = add(2,3);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = add(5,7);\nlet expected_4 = 12;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = add(7,5);\nlet expected_5 = 12;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = add(572,725);\nlet expected_6 = 1297;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = add(51,804);\nlet expected_7 = 855;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = add(645,96);\nlet expected_8 = 741;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = add(712,853);\nlet expected_9 = 1565;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = add(223,101);\nlet expected_10 = 324;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = add(76,29);\nlet expected_11 = 105;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = add(416,149);\nlet expected_12 = 565;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = add(145,409);\nlet expected_13 = 554;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = add(535,430);\nlet expected_14 = 965;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = add(118,303);\nlet expected_15 = 421;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = add(287,94);\nlet expected_16 = 381;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\nlet actual_17 = add(768,257);\nlet expected_17 = 1025;\nassert.deepEqual(actual_17, expected_17, \"Exception --- test case 16 failed to pass\");\n\nlet actual_18 = add(421,677);\nlet expected_18 = 1098;\nassert.deepEqual(actual_18, expected_18, \"Exception --- test case 17 failed to pass\");\n\nlet actual_19 = add(802,814);\nlet expected_19 = 1616;\nassert.deepEqual(actual_19, expected_19, \"Exception --- test case 18 failed to pass\");\n\nlet actual_20 = add(510,922);\nlet expected_20 = 1432;\nassert.deepEqual(actual_20, expected_20, \"Exception --- test case 19 failed to pass\");\n\nlet actual_21 = add(345,819);\nlet expected_21 = 1164;\nassert.deepEqual(actual_21, expected_21, \"Exception --- test case 20 failed to pass\");\n\nlet actual_22 = add(895,436);\nlet expected_22 = 1331;\nassert.deepEqual(actual_22, expected_22, \"Exception --- test case 21 failed to pass\");\n\nlet actual_23 = add(123,424);\nlet expected_23 = 547;\nassert.deepEqual(actual_23, expected_23, \"Exception --- test case 22 failed to pass\");\n\nlet actual_24 = add(923,245);\nlet expected_24 = 1168;\nassert.deepEqual(actual_24, expected_24, \"Exception --- test case 23 failed to pass\");\n\nlet actual_25 = add(23,438);\nlet expected_25 = 461;\nassert.deepEqual(actual_25, expected_25, \"Exception --- test case 24 failed to pass\");\n\nlet actual_26 = add(565,133);\nlet expected_26 = 698;\nassert.deepEqual(actual_26, expected_26, \"Exception --- test case 25 failed to pass\");\n\nlet actual_27 = add(945,925);\nlet expected_27 = 1870;\nassert.deepEqual(actual_27, expected_27, \"Exception --- test case 26 failed to pass\");\n\nlet actual_28 = add(261,983);\nlet expected_28 = 1244;\nassert.deepEqual(actual_28, expected_28, \"Exception --- test case 27 failed to pass\");\n\nlet actual_29 = add(139,577);\nlet expected_29 = 716;\nassert.deepEqual(actual_29, expected_29, \"Exception --- test case 28 failed to pass\");\n\nlet actual_30 = add(763,178);\nlet expected_30 = 941;\nassert.deepEqual(actual_30, expected_30, \"Exception --- test case 29 failed to pass\");\n\nlet actual_31 = add(147,892);\nlet expected_31 = 1039;\nassert.deepEqual(actual_31, expected_31, \"Exception --- test case 30 failed to pass\");\n\nlet actual_32 = add(436,402);\nlet expected_32 = 838;\nassert.deepEqual(actual_32, expected_32, \"Exception --- test case 31 failed to pass\");\n\nlet actual_33 = add(610,581);\nlet expected_33 = 1191;\nassert.deepEqual(actual_33, expected_33, \"Exception --- test case 32 failed to pass\");\n\nlet actual_34 = add(103,416);\nlet expected_34 = 519;\nassert.deepEqual(actual_34, expected_34, \"Exception --- test case 33 failed to pass\");\n\nlet actual_35 = add(339,990);\nlet expected_35 = 1329;\nassert.deepEqual(actual_35, expected_35, \"Exception --- test case 34 failed to pass\");\n\nlet actual_36 = add(130,504);\nlet expected_36 = 634;\nassert.deepEqual(actual_36, expected_36, \"Exception --- test case 35 failed to pass\");\n\nlet actual_37 = add(242,717);\nlet expected_37 = 959;\nassert.deepEqual(actual_37, expected_37, \"Exception --- test case 36 failed to pass\");\n\nlet actual_38 = add(562,110);\nlet expected_38 = 672;\nassert.deepEqual(actual_38, expected_38, \"Exception --- test case 37 failed to pass\");\n\nlet actual_39 = add(396,909);\nlet expected_39 = 1305;\nassert.deepEqual(actual_39, expected_39, \"Exception --- test case 38 failed to pass\");\n\nlet actual_40 = add(887,703);\nlet expected_40 = 1590;\nassert.deepEqual(actual_40, expected_40, \"Exception --- test case 39 failed to pass\");\n\nlet actual_41 = add(870,551);\nlet expected_41 = 1421;\nassert.deepEqual(actual_41, expected_41, \"Exception --- test case 40 failed to pass\");\n\nlet actual_42 = add(422,391);\nlet expected_42 = 813;\nassert.deepEqual(actual_42, expected_42, \"Exception --- test case 41 failed to pass\");\n\nlet actual_43 = add(299,505);\nlet expected_43 = 804;\nassert.deepEqual(actual_43, expected_43, \"Exception --- test case 42 failed to pass\");\n\nlet actual_44 = add(346,56);\nlet expected_44 = 402;\nassert.deepEqual(actual_44, expected_44, \"Exception --- test case 43 failed to pass\");\n\nlet actual_45 = add(36,706);\nlet expected_45 = 742;\nassert.deepEqual(actual_45, expected_45, \"Exception --- test case 44 failed to pass\");\n\nlet actual_46 = add(738,411);\nlet expected_46 = 1149;\nassert.deepEqual(actual_46, expected_46, \"Exception --- test case 45 failed to pass\");\n\nlet actual_47 = add(679,87);\nlet expected_47 = 766;\nassert.deepEqual(actual_47, expected_47, \"Exception --- test case 46 failed to pass\");\n\nlet actual_48 = add(25,303);\nlet expected_48 = 328;\nassert.deepEqual(actual_48, expected_48, \"Exception --- test case 47 failed to pass\");\n\nlet actual_49 = add(161,612);\nlet expected_49 = 773;\nassert.deepEqual(actual_49, expected_49, \"Exception --- test case 48 failed to pass\");\n\nlet actual_50 = add(306,841);\nlet expected_50 = 1147;\nassert.deepEqual(actual_50, expected_50, \"Exception --- test case 49 failed to pass\");\n\nlet actual_51 = add(973,411);\nlet expected_51 = 1384;\nassert.deepEqual(actual_51, expected_51, \"Exception --- test case 50 failed to pass\");\n\nlet actual_52 = add(711,157);\nlet expected_52 = 868;\nassert.deepEqual(actual_52, expected_52, \"Exception --- test case 51 failed to pass\");\n\nlet actual_53 = add(471,27);\nlet expected_53 = 498;\nassert.deepEqual(actual_53, expected_53, \"Exception --- test case 52 failed to pass\");\n\nlet actual_54 = add(714,792);\nlet expected_54 = 1506;\nassert.deepEqual(actual_54, expected_54, \"Exception --- test case 53 failed to pass\");\n\nlet actual_55 = add(38,206);\nlet expected_55 = 244;\nassert.deepEqual(actual_55, expected_55, \"Exception --- test case 54 failed to pass\");\n\nlet actual_56 = add(907,343);\nlet expected_56 = 1250;\nassert.deepEqual(actual_56, expected_56, \"Exception --- test case 55 failed to pass\");\n\nlet actual_57 = add(23,760);\nlet expected_57 = 783;\nassert.deepEqual(actual_57, expected_57, \"Exception --- test case 56 failed to pass\");\n\nlet actual_58 = add(524,859);\nlet expected_58 = 1383;\nassert.deepEqual(actual_58, expected_58, \"Exception --- test case 57 failed to pass\");\n\nlet actual_59 = add(30,529);\nlet expected_59 = 559;\nassert.deepEqual(actual_59, expected_59, \"Exception --- test case 58 failed to pass\");\n\nlet actual_60 = add(341,691);\nlet expected_60 = 1032;\nassert.deepEqual(actual_60, expected_60, \"Exception --- test case 59 failed to pass\");\n\nlet actual_61 = add(167,729);\nlet expected_61 = 896;\nassert.deepEqual(actual_61, expected_61, \"Exception --- test case 60 failed to pass\");\n\nlet actual_62 = add(636,289);\nlet expected_62 = 925;\nassert.deepEqual(actual_62, expected_62, \"Exception --- test case 61 failed to pass\");\n\nlet actual_63 = add(503,144);\nlet expected_63 = 647;\nassert.deepEqual(actual_63, expected_63, \"Exception --- test case 62 failed to pass\");\n\nlet actual_64 = add(51,985);\nlet expected_64 = 1036;\nassert.deepEqual(actual_64, expected_64, \"Exception --- test case 63 failed to pass\");\n\nlet actual_65 = add(287,149);\nlet expected_65 = 436;\nassert.deepEqual(actual_65, expected_65, \"Exception --- test case 64 failed to pass\");\n\nlet actual_66 = add(659,75);\nlet expected_66 = 734;\nassert.deepEqual(actual_66, expected_66, \"Exception --- test case 65 failed to pass\");\n\nlet actual_67 = add(462,797);\nlet expected_67 = 1259;\nassert.deepEqual(actual_67, expected_67, \"Exception --- test case 66 failed to pass\");\n\nlet actual_68 = add(406,141);\nlet expected_68 = 547;\nassert.deepEqual(actual_68, expected_68, \"Exception --- test case 67 failed to pass\");\n\nlet actual_69 = add(106,44);\nlet expected_69 = 150;\nassert.deepEqual(actual_69, expected_69, \"Exception --- test case 68 failed to pass\");\n\nlet actual_70 = add(300,934);\nlet expected_70 = 1234;\nassert.deepEqual(actual_70, expected_70, \"Exception --- test case 69 failed to pass\");\n\nlet actual_71 = add(471,524);\nlet expected_71 = 995;\nassert.deepEqual(actual_71, expected_71, \"Exception --- test case 70 failed to pass\");\n\nlet actual_72 = add(122,429);\nlet expected_72 = 551;\nassert.deepEqual(actual_72, expected_72, \"Exception --- test case 71 failed to pass\");\n\nlet actual_73 = add(735,195);\nlet expected_73 = 930;\nassert.deepEqual(actual_73, expected_73, \"Exception --- test case 72 failed to pass\");\n\nlet actual_74 = add(335,484);\nlet expected_74 = 819;\nassert.deepEqual(actual_74, expected_74, \"Exception --- test case 73 failed to pass\");\n\nlet actual_75 = add(28,809);\nlet expected_75 = 837;\nassert.deepEqual(actual_75, expected_75, \"Exception --- test case 74 failed to pass\");\n\nlet actual_76 = add(430,20);\nlet expected_76 = 450;\nassert.deepEqual(actual_76, expected_76, \"Exception --- test case 75 failed to pass\");\n\nlet actual_77 = add(916,635);\nlet expected_77 = 1551;\nassert.deepEqual(actual_77, expected_77, \"Exception --- test case 76 failed to pass\");\n\nlet actual_78 = add(301,999);\nlet expected_78 = 1300;\nassert.deepEqual(actual_78, expected_78, \"Exception --- test case 77 failed to pass\");\n\nlet actual_79 = add(454,466);\nlet expected_79 = 920;\nassert.deepEqual(actual_79, expected_79, \"Exception --- test case 78 failed to pass\");\n\nlet actual_80 = add(905,259);\nlet expected_80 = 1164;\nassert.deepEqual(actual_80, expected_80, \"Exception --- test case 79 failed to pass\");\n\nlet actual_81 = add(168,205);\nlet expected_81 = 373;\nassert.deepEqual(actual_81, expected_81, \"Exception --- test case 80 failed to pass\");\n\nlet actual_82 = add(570,434);\nlet expected_82 = 1004;\nassert.deepEqual(actual_82, expected_82, \"Exception --- test case 81 failed to pass\");\n\nlet actual_83 = add(64,959);\nlet expected_83 = 1023;\nassert.deepEqual(actual_83, expected_83, \"Exception --- test case 82 failed to pass\");\n\nlet actual_84 = add(957,510);\nlet expected_84 = 1467;\nassert.deepEqual(actual_84, expected_84, \"Exception --- test case 83 failed to pass\");\n\nlet actual_85 = add(722,598);\nlet expected_85 = 1320;\nassert.deepEqual(actual_85, expected_85, \"Exception --- test case 84 failed to pass\");\n\nlet actual_86 = add(770,226);\nlet expected_86 = 996;\nassert.deepEqual(actual_86, expected_86, \"Exception --- test case 85 failed to pass\");\n\nlet actual_87 = add(579,66);\nlet expected_87 = 645;\nassert.deepEqual(actual_87, expected_87, \"Exception --- test case 86 failed to pass\");\n\nlet actual_88 = add(117,674);\nlet expected_88 = 791;\nassert.deepEqual(actual_88, expected_88, \"Exception --- test case 87 failed to pass\");\n\nlet actual_89 = add(530,30);\nlet expected_89 = 560;\nassert.deepEqual(actual_89, expected_89, \"Exception --- test case 88 failed to pass\");\n\nlet actual_90 = add(776,345);\nlet expected_90 = 1121;\nassert.deepEqual(actual_90, expected_90, \"Exception --- test case 89 failed to pass\");\n\nlet actual_91 = add(327,389);\nlet expected_91 = 716;\nassert.deepEqual(actual_91, expected_91, \"Exception --- test case 90 failed to pass\");\n\nlet actual_92 = add(596,12);\nlet expected_92 = 608;\nassert.deepEqual(actual_92, expected_92, \"Exception --- test case 91 failed to pass\");\n\nlet actual_93 = add(599,511);\nlet expected_93 = 1110;\nassert.deepEqual(actual_93, expected_93, \"Exception --- test case 92 failed to pass\");\n\nlet actual_94 = add(936,476);\nlet expected_94 = 1412;\nassert.deepEqual(actual_94, expected_94, \"Exception --- test case 93 failed to pass\");\n\nlet actual_95 = add(461,14);\nlet expected_95 = 475;\nassert.deepEqual(actual_95, expected_95, \"Exception --- test case 94 failed to pass\");\n\nlet actual_96 = add(966,157);\nlet expected_96 = 1123;\nassert.deepEqual(actual_96, expected_96, \"Exception --- test case 95 failed to pass\");\n\nlet actual_97 = add(326,91);\nlet expected_97 = 417;\nassert.deepEqual(actual_97, expected_97, \"Exception --- test case 96 failed to pass\");\n\nlet actual_98 = add(392,455);\nlet expected_98 = 847;\nassert.deepEqual(actual_98, expected_98, \"Exception --- test case 97 failed to pass\");\n\nlet actual_99 = add(446,477);\nlet expected_99 = 923;\nassert.deepEqual(actual_99, expected_99, \"Exception --- test case 98 failed to pass\");\n\nlet actual_100 = add(324,860);\nlet expected_100 = 1184;\nassert.deepEqual(actual_100, expected_100, \"Exception --- test case 99 failed to pass\");\n\nlet actual_101 = add(945,85);\nlet expected_101 = 1030;\nassert.deepEqual(actual_101, expected_101, \"Exception --- test case 100 failed to pass\");\n\nlet actual_102 = add(886,582);\nlet expected_102 = 1468;\nassert.deepEqual(actual_102, expected_102, \"Exception --- test case 101 failed to pass\");\n\nlet actual_103 = add(886,712);\nlet expected_103 = 1598;\nassert.deepEqual(actual_103, expected_103, \"Exception --- test case 102 failed to pass\");\n\nlet actual_104 = add(842,953);\nlet expected_104 = 1795;\nassert.deepEqual(actual_104, expected_104, \"Exception --- test case 103 failed to pass\");\n\n", "language": "typescript", "description": "הוסף שני מספרים x ו-y", "entry_point": "add", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/20", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * בדוק אם שתי מילים כוללות את אותם התווים.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n * \n */\nconst same_chars = function (s0: string, s1: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = same_chars(\"eabcdzzzz\",\"dddzzzzzzzddeddabc\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = same_chars(\"abcd\",\"dddddddabc\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = same_chars(\"dddddddabc\",\"abcd\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = same_chars(\"eabcd\",\"dddddddabc\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = same_chars(\"abcd\",\"dddddddabcf\");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = same_chars(\"eabcdzzzz\",\"dddzzzzzzzddddabc\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = same_chars(\"aabb\",\"aaccc\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "בדוק אם שתי מילים כוללות את אותם התווים.", "entry_point": "same_chars", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/21", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * החזר את המספר ה-n של סדרת פיבונאצ'י.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n * \n */\nconst fib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fib(10);\nlet expected_1 = 55;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fib(1);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fib(8);\nlet expected_3 = 21;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fib(11);\nlet expected_4 = 89;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = fib(12);\nlet expected_5 = 144;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "החזר את המספר ה-n של סדרת פיבונאצ'י.", "entry_point": "fib", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/22", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * החזר את האיברים המשותפים והייחודיים של שני רשימות ממוינות.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n * \n * \n */\nconst common = function (l1: Array<number>, l2: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = common([1, 4, 3, 34, 653, 2, 5],[5, 7, 1, 5, 9, 653, 121]);\nlet expected_1 = [1, 5, 653];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = common([5, 3, 2, 8],[3, 2]);\nlet expected_2 = [2, 3];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = common([4, 3, 2, 8],[3, 2, 4]);\nlet expected_3 = [2, 3, 4];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = common([4, 3, 2, 8],[]);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "החזר את האיברים המשותפים והייחודיים של שני רשימות ממוינות.", "entry_point": "common", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/23", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * החזר את הגורם הראשון הגדול ביותר של n. הנח כי n > 1 ואינו מספר ראשוני.\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n * \n */\nconst largest_prime_factor = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = largest_prime_factor(15);\nlet expected_1 = 5;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = largest_prime_factor(27);\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = largest_prime_factor(63);\nlet expected_3 = 7;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = largest_prime_factor(330);\nlet expected_4 = 11;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = largest_prime_factor(13195);\nlet expected_5 = 29;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "החזר את הגורם הראשון הגדול ביותר של n. הנח כי n > 1 ואינו מספר ראשוני.", "entry_point": "largest_prime_factor", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/24", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * sum_to_n הוא פונקציה שמסכמת מספרים מ-1 עד n.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n * \n */\nconst sum_to_n = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_to_n(1);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_to_n(6);\nlet expected_2 = 21;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_to_n(11);\nlet expected_3 = 66;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_to_n(30);\nlet expected_4 = 465;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_to_n(100);\nlet expected_5 = 5050;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "sum_to_n הוא פונקציה שמסכמת מספרים מ-1 עד n.", "entry_point": "sum_to_n", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/25", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * xs מייצגים מקדמים של פולינום.\n *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n *      החזר את הנגזרת של הפולינום הזה באותה הצורה.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n * \n */\nconst derivative = function (xs: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = derivative([3, 1, 2, 4, 5]);\nlet expected_1 = [1, 4, 12, 20];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = derivative([1, 2, 3]);\nlet expected_2 = [2, 6];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = derivative([3, 2, 1]);\nlet expected_3 = [2, 2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = derivative([3, 2, 1, 0, 4]);\nlet expected_4 = [2, 2, 0, 16];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = derivative([1]);\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "xs מייצגים מקדמים של פולינום.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     החזר את הנגזרת של הפולינום הזה באותה הצורה.", "entry_point": "derivative", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/26", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * הרצף מספרי FibFib הוא רצף דומה לרצף פיבונאצ'י המוגדר כך:\n *     fibfib(0) == 0\n *     fibfib(1) == 0\n *     fibfib(2) == 1\n *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n *     אנא כתוב פונקציה לחישוב ביצועי של האיבר ה-n של רצף מספרי FibFib.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n * \n */\nconst fibfib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fibfib(2);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fibfib(1);\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fibfib(5);\nlet expected_3 = 4;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fibfib(8);\nlet expected_4 = 24;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = fibfib(10);\nlet expected_5 = 81;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = fibfib(12);\nlet expected_6 = 274;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = fibfib(14);\nlet expected_7 = 927;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "הרצף מספרי FibFib הוא רצף דומה לרצף פיבונאצ'י המוגדר כך:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    אנא כתוב פונקציה לחישוב ביצועי של האיבר ה-n של רצף מספרי FibFib.", "entry_point": "fibfib", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/27", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * כתוב פונקציה בשם vowels_count המקבלת מחרוזת המייצגת מילה ומחזירה את מספר התווים הקוליים במחרוזת. התווים הקוליים במקרה זה הם 'a', 'e', 'i', 'o', 'u'. כאן, 'y' הוא גם תו קולי, אך רק כאשר הוא בסוף המילה הנתונה.\n * \n * דוגמה:\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n * \n */\nconst vowels_count = function (s: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = vowels_count(\"abcde\");\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = vowels_count(\"Alone\");\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = vowels_count(\"key\");\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = vowels_count(\"bye\");\nlet expected_4 = 1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = vowels_count(\"keY\");\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = vowels_count(\"bYe\");\nlet expected_6 = 1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = vowels_count(\"ACEDY\");\nlet expected_7 = 3;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "כתוב פונקציה בשם vowels_count המקבלת מחרוזת המייצגת מילה ומחזירה את מספר התווים הקוליים במחרוזת. התווים הקוליים במקרה זה הם 'a', 'e', 'i', 'o', 'u'. כאן, 'y' הוא גם תו קולי, אך רק כאשר הוא בסוף המילה הנתונה.\n\nדוגמה:", "entry_point": "vowels_count", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/28", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * קיבלתם רשימה לא ריקה של מספרים שלמים חיוביים. החזירו את המספר הגדול ביותר שהוא גדול מאפס והתדירות שלו גדולה או שווה לערך של המספר עצמו. התדירות של מספר הוא מספר הפעמים שהוא מופיע ברשימה. אם אין ערך כזה, החזירו -1.\n * דוגמאות:\n * \n * search([4, 1, 2, 2, 3, 1]) == 2\n * search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n * search([5, 5, 4, 4, 4]) == -1\n * \n */\nconst search = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = search([5, 5, 5, 5, 1]);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = search([4, 1, 4, 1, 4, 4]);\nlet expected_2 = 4;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = search([3, 3]);\nlet expected_3 = -1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = search([8, 8, 8, 8, 8, 8, 8, 8]);\nlet expected_4 = 8;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = search([2, 3, 3, 2, 2]);\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = search([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]);\nlet expected_6 = 1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = search([3, 2, 8, 2]);\nlet expected_7 = 2;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]);\nlet expected_8 = 1;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = search([8, 8, 3, 6, 5, 6, 4]);\nlet expected_9 = -1;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = search([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]);\nlet expected_10 = 1;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = search([1, 9, 10, 1, 3]);\nlet expected_11 = 1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = search([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]);\nlet expected_12 = 5;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = search([1]);\nlet expected_13 = 1;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = search([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]);\nlet expected_14 = 4;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]);\nlet expected_15 = 2;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]);\nlet expected_16 = 1;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\nlet actual_17 = search([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]);\nlet expected_17 = 4;\nassert.deepEqual(actual_17, expected_17, \"Exception --- test case 16 failed to pass\");\n\nlet actual_18 = search([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]);\nlet expected_18 = 4;\nassert.deepEqual(actual_18, expected_18, \"Exception --- test case 17 failed to pass\");\n\nlet actual_19 = search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]);\nlet expected_19 = 2;\nassert.deepEqual(actual_19, expected_19, \"Exception --- test case 18 failed to pass\");\n\nlet actual_20 = search([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]);\nlet expected_20 = -1;\nassert.deepEqual(actual_20, expected_20, \"Exception --- test case 19 failed to pass\");\n\nlet actual_21 = search([10]);\nlet expected_21 = -1;\nassert.deepEqual(actual_21, expected_21, \"Exception --- test case 20 failed to pass\");\n\nlet actual_22 = search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]);\nlet expected_22 = 2;\nassert.deepEqual(actual_22, expected_22, \"Exception --- test case 21 failed to pass\");\n\nlet actual_23 = search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]);\nlet expected_23 = 1;\nassert.deepEqual(actual_23, expected_23, \"Exception --- test case 22 failed to pass\");\n\nlet actual_24 = search([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]);\nlet expected_24 = 1;\nassert.deepEqual(actual_24, expected_24, \"Exception --- test case 23 failed to pass\");\n\nlet actual_25 = search([3, 10, 10, 9, 2]);\nlet expected_25 = -1;\nassert.deepEqual(actual_25, expected_25, \"Exception --- test case 24 failed to pass\");\n\n", "language": "typescript", "description": "קיבלתם רשימה לא ריקה של מספרים שלמים חיוביים. החזירו את המספר הגדול ביותר שהוא גדול מאפס והתדירות שלו גדולה או שווה לערך של המספר עצמו. התדירות של מספר הוא מספר הפעמים שהוא מופיע ברשימה. אם אין ערך כזה, החזירו -1.\nדוגמאות:", "entry_point": "search", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/29", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * נתונות אורכי הצלעות של משולש. החזר את שטח המשולש מעוגל ל-2 נקודות עשרוניות אם הצלעות מהווים משולש תקין. אחרת, החזר -1. שלושת הצלעות מהוות משולש תקין כאשר סכום כל שני צלעות גדול מהצלע השלישי. דוגמה:\n * \n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n * \n */\nconst triangle_area = function (a: number, b: number, c: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = triangle_area(3,4,5);\nlet expected_1 = 6.0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = triangle_area(1,2,10);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = triangle_area(4,8,5);\nlet expected_3 = 8.18;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = triangle_area(2,2,2);\nlet expected_4 = 1.73;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = triangle_area(1,2,3);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = triangle_area(10,5,7);\nlet expected_6 = 16.25;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = triangle_area(2,6,3);\nlet expected_7 = -1;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = triangle_area(1,1,1);\nlet expected_8 = 0.43;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = triangle_area(2,2,10);\nlet expected_9 = -1;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "נתונות אורכי הצלעות של משולש. החזר את שטח המשולש מעוגל ל-2 נקודות עשרוניות אם הצלעות מהווים משולש תקין. אחרת, החזר -1. שלושת הצלעות מהוות משולש תקין כאשר סכום כל שני צלעות גדול מהצלע השלישי. דוגמה:", "entry_point": "triangle_area", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/30", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * כתוב פונקציה שמחזירה True אם האובייקט q יכול לטוס, ו-False אחרת.\n * האובייקט q יכול לטוס אם הוא מאוזן (זהו רשימה פלינדרומית) וסכום האיברים שלו קטן או שווה למשקל המקסימלי האפשרי w.\n * \n * דוגמה:\n * will_it_fly([1, 2], 5) ➞ False\n * # 1+2 קטן מהמשקל המקסימלי האפשרי, אך הוא לא מאוזן.\n * \n * will_it_fly([3, 2, 3], 1) ➞ False\n * # הוא מאוזן, אך 3+2+3 גדול מהמשקל המקסימלי האפשרי.\n * \n * will_it_fly([3, 2, 3], 9) ➞ True\n * # 3+2+3 קטן מהמשקל המקסימלי האפשרי, והוא מאוזן.\n * \n * will_it_fly([3], 5) ➞ True\n * # 3 קטן מהמשקל המקסימלי האפשרי, והוא מאוזן.\n * \n * \n */\nconst will_it_fly = function (q: Array<number>, w: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = will_it_fly([3, 2, 3],9);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = will_it_fly([1, 2],5);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = will_it_fly([3],5);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = will_it_fly([3, 2, 3],1);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = will_it_fly([1, 2, 3],6);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = will_it_fly([5],5);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "כתוב פונקציה שמחזירה True אם האובייקט q יכול לטוס, ו-False אחרת.\nהאובייקט q יכול לטוס אם הוא מאוזן (זהו רשימה פלינדרומית) וסכום האיברים שלו קטן או שווה למשקל המקסימלי האפשרי w.\n\nדוגמה:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 קטן מהמשקל המקסימלי האפשרי, אך הוא לא מאוזן.\n\nwill_it_fly([3, 2, 3], 1) ➞ False\n# הוא מאוזן, אך 3+2+3 גדול מהמשקל המקסימלי האפשרי.\n\nwill_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 קטן מהמשקל המקסימלי האפשרי, והוא מאוזן.\n\nwill_it_fly([3], 5) ➞ True\n# 3 קטן מהמשקל המקסימלי האפשרי, והוא מאוזן.", "entry_point": "will_it_fly", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/31", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * כתוב פונקציה שמחזירה אמת אם המספר הנתון הוא כפל של 3 מספרים ראשוניים ושקר אחרת.\n *     ידוע ש-(a) קטן מ-100.\n *     לדוגמה:\n * \n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n * \n */\nconst is_multiply_prime = function (a: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_multiply_prime(5);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_multiply_prime(30);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_multiply_prime(8);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_multiply_prime(10);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_multiply_prime(125);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_multiply_prime(105);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_multiply_prime(126);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_multiply_prime(729);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_multiply_prime(891);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_multiply_prime(1001);\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "כתוב פונקציה שמחזירה אמת אם המספר הנתון הוא כפל של 3 מספרים ראשוניים ושקר אחרת.\n    ידוע ש-(a) קטן מ-100.\n    לדוגמה:", "entry_point": "is_multiply_prime", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/32", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * יש לך מספר בצורת עשרונית והמטרה שלך היא להמיר אותו לפורמט בינארי. הפונקציה צריכה להחזיר מחרוזת, כאשר כל תו מייצג מספר בינארי. כל תו במחרוזת יהיה '0' או '1'.\n * \n * יהיו זוג תווים נוספים 'db' בתחילת ובסוף המחרוזת. התווים הנוספים נמצאים שם כדי לעזור עם הפורמט.\n * \n * דוגמאות:\n * \n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n * \n */\nconst decimal_to_binary = function (decimal: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = decimal_to_binary(0);\nlet expected_1 = \"db0db\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = decimal_to_binary(32);\nlet expected_2 = \"db100000db\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = decimal_to_binary(103);\nlet expected_3 = \"db1100111db\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = decimal_to_binary(15);\nlet expected_4 = \"db1111db\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "יש לך מספר בצורת עשרונית והמטרה שלך היא להמיר אותו לפורמט בינארי. הפונקציה צריכה להחזיר מחרוזת, כאשר כל תו מייצג מספר בינארי. כל תו במחרוזת יהיה '0' או '1'.\n\nיהיו זוג תווים נוספים 'db' בתחילת ובסוף המחרוזת. התווים הנוספים נמצאים שם כדי לעזור עם הפורמט.\n\nדוגמאות:", "entry_point": "decimal_to_binary", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/33", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * נתון לך מחרוזת s.\n * המטרה שלך היא לבדוק אם המחרוזת היא שמחה או לא.\n * מחרוזת שמחה היא אם אורכה הוא לפחות 3 וכל 3 אותיות רצופות הם שונים.\n * לדוגמה:\n * \n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n * \n */\nconst is_happy = function (s: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_happy(\"a\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_happy(\"aa\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_happy(\"abcd\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_happy(\"aabb\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_happy(\"adb\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_happy(\"xyy\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_happy(\"iopaxpoi\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_happy(\"iopaxioi\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "נתון לך מחרוזת s.\nהמטרה שלך היא לבדוק אם המחרוזת היא שמחה או לא.\nמחרוזת שמחה היא אם אורכה הוא לפחות 3 וכל 3 אותיות רצופות הם שונים.\nלדוגמה:", "entry_point": "is_happy", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/34", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * זו השבוע האחרון של הסמסטר והמורה צריך לתת את הציונים לתלמידים. המורה יצרה אלגוריתם משלה לציון. הבעיה היחידה היא שהיא איבדה את הקוד שהשתמשה בו לציון. היא נתנה לך רשימה של ציוני GPA לכמה תלמידים ואתה צריך לכתוב פונקציה שיכולה להפיק רשימה של ציוני אותיות באמצעות הטבלה הבאה:\n *              GPA       |    Letter grade\n *               4.0                A+\n *             > 3.7                A \n *             > 3.3                A- \n *             > 3.0                B+\n *             > 2.7                B \n *             > 2.3                B-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                E\n *     \n * \n *     דוגמה:\n * \n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n * \n */\nconst numerical_letter_grade = function (grades: Array<number>) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]);\nlet expected_1 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = numerical_letter_grade([1.2]);\nlet expected_2 = [\"D+\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = numerical_letter_grade([0.5]);\nlet expected_3 = [\"D-\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = numerical_letter_grade([0.0]);\nlet expected_4 = [\"E\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = numerical_letter_grade([1, 0.3, 1.5, 2.8, 3.3]);\nlet expected_5 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = numerical_letter_grade([0, 0.7]);\nlet expected_6 = [\"E\", \"D-\"];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "זו השבוע האחרון של הסמסטר והמורה צריך לתת את הציונים לתלמידים. המורה יצרה אלגוריתם משלה לציון. הבעיה היחידה היא שהיא איבדה את הקוד שהשתמשה בו לציון. היא נתנה לך רשימה של ציוני GPA לכמה תלמידים ואתה צריך לכתוב פונקציה שיכולה להפיק רשימה של ציוני אותיות באמצעות הטבלה הבאה:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    דוגמה:", "entry_point": "numerical_letter_grade", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/35", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * כתוב פונקציה שמקבלת מחרוזת ומחזירה True אם אורך המחרוזת הוא מספר ראשוני או False אחרת\n * דוגמאות\n * \n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n * \n */\nconst prime_length = function (string0: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = prime_length(\"Hello\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = prime_length(\"abcdcba\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = prime_length(\"kittens\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = prime_length(\"orange\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = prime_length(\"wow\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = prime_length(\"world\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = prime_length(\"MadaM\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = prime_length(\"Wow\");\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = prime_length(\"\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = prime_length(\"HI\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = prime_length(\"go\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = prime_length(\"gogo\");\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = prime_length(\"aaaaaaaaaaaaaaa\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = prime_length(\"Madam\");\nlet expected_14 = true;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = prime_length(\"M\");\nlet expected_15 = false;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = prime_length(\"0\");\nlet expected_16 = false;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\n", "language": "typescript", "description": "כתוב פונקציה שמקבלת מחרוזת ומחזירה True אם אורך המחרוזת הוא מספר ראשוני או False אחרת\nדוגמאות", "entry_point": "prime_length", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/36", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * נתון מספר שלם חיובי N, החזר את סכום הספרות שלו במספרים בינאריים.\n * \n * דוגמה:\n * עבור N = 1000, סכום הספרות יהיה 1 והפלט צריך להיות \"1\".\n * עבור N = 150, סכום הספרות יהיה 6 והפלט צריך להיות \"110\".\n * עבור N = 147, סכום הספרות יהיה 12 והפלט צריך להיות \"1100\".\n * \n * משתנים:\n * @N מספר שלם\n *      הגבלות: 0 ≤ N ≤ 10000.\n * \n * פלט:\n * מחרוזת מספר בינארי.\n * \n * \n */\nconst solve = function (N: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = solve(1000);\nlet expected_1 = \"1\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = solve(150);\nlet expected_2 = \"110\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = solve(147);\nlet expected_3 = \"1100\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = solve(333);\nlet expected_4 = \"1001\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = solve(963);\nlet expected_5 = \"10010\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "נתון מספר שלם חיובי N, החזר את סכום הספרות שלו במספרים בינאריים.\n\nדוגמה:\nעבור N = 1000, סכום הספרות יהיה 1 והפלט צריך להיות \"1\".\nעבור N = 150, סכום הספרות יהיה 6 והפלט צריך להיות \"110\".\nעבור N = 147, סכום הספרות יהיה 12 והפלט צריך להיות \"1100\".\n\nמשתנים:\n@N מספר שלם\n     הגבלות: 0 ≤ N ≤ 10000.\n\nפלט:\nמחרוזת מספר בינארי.", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/37", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * נתון לך נתונים דו-ממדיים, בתור רשימות מקוננות, הדומים למטריצה, אך לא כמו מטריצות, כיוון שכל שורה עשויה להכיל מספר שונה של עמודות. נתון רשימה (lst) ומספר שלם (x), מצא מספרים שווים ל-x ברשימה והחזר רשימת זוגות, [(x1, y1), (x2, y2) ...] כך שכל זוג הוא קואורדינטה - (שורה, עמודות), החל מ-0. מיין את הקואורדינטות בהתחלה לפי השורות בסדר עולה. כמו כן, מיין את הקואורדינטות של השורה לפי העמודות בסדר יורד.\n * \n * דוגמאות:\n * \n * get_row([\n * [1,2,3,4,5,6],\n * [1,2,3,4,1,6],\n * [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n * \n */\nconst get_row = function (lst: Array<Array<number>>, x: number) : Array<Array<number>>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],1);\nlet expected_1 = [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],2);\nlet expected_2 = [[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],1);\nlet expected_3 = [[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_row([],1);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = get_row([[1]],2);\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = get_row([[], [1], [1, 2, 3]],3);\nlet expected_6 = [[2, 2]];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "נתון לך נתונים דו-ממדיים, בתור רשימות מקוננות, הדומים למטריצה, אך לא כמו מטריצות, כיוון שכל שורה עשויה להכיל מספר שונה של עמודות. נתון רשימה (lst) ומספר שלם (x), מצא מספרים שווים ל-x ברשימה והחזר רשימת זוגות, [(x1, y1), (x2, y2) ...] כך שכל זוג הוא קואורדינטה - (שורה, עמודות), החל מ-0. מיין את הקואורדינטות בהתחלה לפי השורות בסדר עולה. כמו כן, מיין את הקואורדינטות של השורה לפי העמודות בסדר יורד.\n\nדוגמאות:", "entry_point": "get_row", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/38", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * קיבלת רשימה של מספרים שלמים.\n * כתוב פונקציה next_smallest() שמחזירה את האיבר השני הקטן ביותר ברשימה.\n * החזר null אם אין איבר כזה.\n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n * \n */\nconst next_smallest = function (lst: Array<number>) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = next_smallest([1, 2, 3, 4, 5]);\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = next_smallest([5, 1, 4, 3, 2]);\nlet expected_2 = 2;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = next_smallest([]);\nlet expected_3 = undefined;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = next_smallest([1, 1]);\nlet expected_4 = undefined;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = next_smallest([1, 1, 1, 1, 0]);\nlet expected_5 = 1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = next_smallest([1, 1]);\nlet expected_6 = undefined;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = next_smallest([-35, 34, 12, -45]);\nlet expected_7 = -35;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "קיבלת רשימה של מספרים שלמים.\nכתוב פונקציה next_smallest() שמחזירה את האיבר השני הקטן ביותר ברשימה.\nהחזר null אם אין איבר כזה.", "entry_point": "next_smallest", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/39", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * ינתן לך מחרוזת של מילים, ומטרתך היא לספור את מספר המשעממויות. משעממות הן משפטים שמתחילים עם המילה \"אני\". משפטים מופרדים על ידי '.', '?' או '!'.\n * \n * לדוגמה:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n * \n */\nconst is_bored = function (S: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_bored(\"Hello world\");\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_bored(\"Is the sky blue?\");\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_bored(\"I love It !\");\nlet expected_3 = 1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_bored(\"bIt\");\nlet expected_4 = 0;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_bored(\"I feel good today. I will be productive. will kill It\");\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_bored(\"You and I are going for a walk\");\nlet expected_6 = 0;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "ינתן לך מחרוזת של מילים, ומטרתך היא לספור את מספר המשעממויות. משעממות הן משפטים שמתחילים עם המילה \"אני\". משפטים מופרדים על ידי '.', '?' או '!'.\n\nלדוגמה:", "entry_point": "is_bored", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/40", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * נתונה לך רשימה של מספרים שלמים.\n * עליך למצוא את הערך הראשון הגדול ביותר שהוא מספר ראשוני ולהחזיר את סכום הספרות שלו.\n * \n * דוגמאות:\n * \n * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n * For lst = [0,81,12,3,1,21] the output should be 3\n * For lst = [0,8,1,2,1,7] the output should be 7\n * \n */\nconst skjkasdkd = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]);\nlet expected_1 = 10;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]);\nlet expected_2 = 25;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\nlet expected_3 = 13;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]);\nlet expected_4 = 11;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = skjkasdkd([0, 81, 12, 3, 1, 21]);\nlet expected_5 = 3;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = skjkasdkd([0, 8, 1, 2, 1, 7]);\nlet expected_6 = 7;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = skjkasdkd([8191]);\nlet expected_7 = 19;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = skjkasdkd([8191, 123456, 127, 7]);\nlet expected_8 = 19;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = skjkasdkd([127, 97, 8192]);\nlet expected_9 = 10;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "נתונה לך רשימה של מספרים שלמים.\nעליך למצוא את הערך הראשון הגדול ביותר שהוא מספר ראשוני ולהחזיר את סכום הספרות שלו.\n\nדוגמאות:", "entry_point": "skjkasdkd", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/41", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * נתון מילון, החזר True אם כל המפתחות הם מחרוזות באותיות קטנות או כל המפתחות הם מחרוזות באותיות גדולות, אחרת החזר False. הפונקציה צריכה להחזיר False אם המילון הנתון ריק. דוגמאות:\n * \n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n * \n */\nconst check_dict_case = function (dict: Map<any, string>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [\"b\", \"banana\"]]));\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [\"A\", \"banana\"], [\"B\", \"banana\"]]));\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [5, \"banana\"], [\"a\", \"apple\"]]));\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = check_dict_case(new Map<any, any>([[\"Name\", \"John\"], [\"Age\", \"36\"], [\"City\", \"Houston\"]]));\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = check_dict_case(new Map<any, any>([[\"STATE\", \"NC\"], [\"ZIP\", \"12345\"]]));\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = check_dict_case(new Map<any, any>([[\"fruit\", \"Orange\"], [\"taste\", \"Sweet\"]]));\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = check_dict_case(new Map<any, any>([]));\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "נתון מילון, החזר True אם כל המפתחות הם מחרוזות באותיות קטנות או כל המפתחות הם מחרוזות באותיות גדולות, אחרת החזר False. הפונקציה צריכה להחזיר False אם המילון הנתון ריק. דוגמאות:", "entry_point": "check_dict_case", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/42", "prompt": "import * as math from 'mathjs'\n\n/**\n * אתה מתכנת TypeScript מומחה\n * \n * צור פונקציה שמקבלת ערך (מחרוזת) המייצג מספר ומחזירה את המספר השלם הקרוב ביותר אליו. אם המספר זהה מרחק משני מספרים שלמים, עגל אותו לפי הכיוון המרחק מהאפס.\n * \n * דוגמאות:\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n * \n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n * \n */\nconst closest_integer = function (value: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = closest_integer(\"10\");\nlet expected_1 = 10;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = closest_integer(\"14.5\");\nlet expected_2 = 15;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = closest_integer(\"-15.5\");\nlet expected_3 = -16;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = closest_integer(\"15.3\");\nlet expected_4 = 15;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = closest_integer(\"0\");\nlet expected_5 = 0;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "צור פונקציה שמקבלת ערך (מחרוזת) המייצג מספר ומחזירה את המספר השלם הקרוב ביותר אליו. אם המספר זהה מרחק משני מספרים שלמים, עגל אותו לפי הכיוון המרחק מהאפס.\n\nדוגמאות:", "entry_point": "closest_integer", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/43", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * נתון מספר שלם חיובי n, עליך ליצור ערימה של n רמות אבנים.\n * הרמה הראשונה כוללת n אבנים.\n * מספר האבנים ברמה הבאה הוא:\n * - המספר הבא האי-זוגי אם n הוא מספר אי-זוגי.\n * - המספר הבא הזוגי אם n הוא מספר זוגי.\n * החזר את מספר האבנים בכל רמה ברשימה, כאשר האיבר במקום i מייצג את מספר האבנים ברמה (i+1).\n * \n * דוגמאות:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n * \n */\nconst make_a_pile = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = make_a_pile(3);\nlet expected_1 = [3, 5, 7];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = make_a_pile(4);\nlet expected_2 = [4, 6, 8, 10];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = make_a_pile(5);\nlet expected_3 = [5, 7, 9, 11, 13];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = make_a_pile(6);\nlet expected_4 = [6, 8, 10, 12, 14, 16];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = make_a_pile(8);\nlet expected_5 = [8, 10, 12, 14, 16, 18, 20, 22];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "נתון מספר שלם חיובי n, עליך ליצור ערימה של n רמות אבנים.\nהרמה הראשונה כוללת n אבנים.\nמספר האבנים ברמה הבאה הוא:\n- המספר הבא האי-זוגי אם n הוא מספר אי-זוגי.\n- המספר הבא הזוגי אם n הוא מספר זוגי.\nהחזר את מספר האבנים בכל רמה ברשימה, כאשר האיבר במקום i מייצג את מספר האבנים ברמה (i+1).\n\nדוגמאות:", "entry_point": "make_a_pile", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/44", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * ינתן לך מחרוזת של מילים המופרדות בפסיקים או ברווחים. המטרה שלך היא לפצל את המחרוזת למילים ולהחזיר מערך של המילים.\n * \n * לדוגמה:\n * \n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n * \n */\nconst words_string = function (s: string) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = words_string(\"Hi, my name is John\");\nlet expected_1 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = words_string(\"One, two, three, four, five, six\");\nlet expected_2 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = words_string(\"Hi, my name\");\nlet expected_3 = [\"Hi\", \"my\", \"name\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = words_string(\"One,, two, three, four, five, six,\");\nlet expected_4 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = words_string(\"\");\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = words_string(\"ahmed     , gamal\");\nlet expected_6 = [\"ahmed\", \"gamal\"];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "ינתן לך מחרוזת של מילים המופרדות בפסיקים או ברווחים. המטרה שלך היא לפצל את המחרוזת למילים ולהחזיר מערך של המילים.\n\nלדוגמה:", "entry_point": "words_string", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/45", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * פונקציה זו מקבלת שני מספרים חיוביים x ו-y ומחזירה את המספר הזוגי הגדול ביותר שנמצא בטווח [x, y] כולל. אם אין מספר כזה, הפונקציה צריכה להחזיר -1.\n * \n * לדוגמה:\n * \n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n * \n */\nconst choose_num = function (x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = choose_num(12,15);\nlet expected_1 = 14;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = choose_num(13,12);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = choose_num(33,12354);\nlet expected_3 = 12354;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = choose_num(5234,5233);\nlet expected_4 = -1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = choose_num(6,29);\nlet expected_5 = 28;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = choose_num(27,10);\nlet expected_6 = -1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = choose_num(7,7);\nlet expected_7 = -1;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = choose_num(546,546);\nlet expected_8 = 546;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "פונקציה זו מקבלת שני מספרים חיוביים x ו-y ומחזירה את המספר הזוגי הגדול ביותר שנמצא בטווח [x, y] כולל. אם אין מספר כזה, הפונקציה צריכה להחזיר -1.\n\nלדוגמה:", "entry_point": "choose_num", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/46", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * נתונים שני מספרים שלמים חיוביים n ו-m, והמטרה שלך היא לחשב את הממוצע של המספרים מ-n עד m (כולל n ו-m). עגל את התשובה למספר השלם הקרוב ביותר והמר את זה לבינארי. אם n גדול מ-m, החזר -1. דוגמה:\n * \n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n * \n */\nconst rounded_avg = function (n: number, m: number) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = rounded_avg(1,5);\nlet expected_1 = \"0b11\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = rounded_avg(7,13);\nlet expected_2 = \"0b1010\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = rounded_avg(964,977);\nlet expected_3 = \"0b1111001010\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = rounded_avg(996,997);\nlet expected_4 = \"0b1111100100\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = rounded_avg(560,851);\nlet expected_5 = \"0b1011000010\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = rounded_avg(185,546);\nlet expected_6 = \"0b101101110\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = rounded_avg(362,496);\nlet expected_7 = \"0b110101101\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = rounded_avg(350,902);\nlet expected_8 = \"0b1001110010\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = rounded_avg(197,233);\nlet expected_9 = \"0b11010111\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = rounded_avg(7,5);\nlet expected_10 = -1;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = rounded_avg(5,1);\nlet expected_11 = -1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = rounded_avg(5,5);\nlet expected_12 = \"0b101\";\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\n", "language": "typescript", "description": "נתונים שני מספרים שלמים חיוביים n ו-m, והמטרה שלך היא לחשב את הממוצע של המספרים מ-n עד m (כולל n ו-m). עגל את התשובה למספר השלם הקרוב ביותר והמר את זה לבינארי. אם n גדול מ-m, החזר -1. דוגמה:", "entry_point": "rounded_avg", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/47", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * מימוש הפונקציה f שמקבלת את n כפרמטר ומחזירה רשימה בגודל n, כך שערך האיבר במקום i הוא הפקטוריאל של i אם i הוא מספר זוגי, או סכום המספרים מ-1 עד i אחרת. i מתחיל מ-1. הפקטוריאל של i הוא הכפל של המספרים מ-1 עד i (1 * 2 * ... * i). דוגמה:\n * \n * f(5) == [1, 2, 6, 24, 15]\n * \n */\nconst f = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = f(5);\nlet expected_1 = [1, 2, 6, 24, 15];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = f(7);\nlet expected_2 = [1, 2, 6, 24, 15, 720, 28];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = f(1);\nlet expected_3 = [1];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = f(3);\nlet expected_4 = [1, 2, 6];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "מימוש הפונקציה f שמקבלת את n כפרמטר ומחזירה רשימה בגודל n, כך שערך האיבר במקום i הוא הפקטוריאל של i אם i הוא מספר זוגי, או סכום המספרים מ-1 עד i אחרת. i מתחיל מ-1. הפקטוריאל של i הוא הכפל של המספרים מ-1 עד i (1 * 2 * ... * i). דוגמה:", "entry_point": "f", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/48", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * נתון מספר שלם חיובי n, יש להחזיר טאפל שמכיל את מספר הפלינדרומים הזוגיים והאי זוגיים שנמצאים בטווח (1, n), כולל.\n * \n * דוגמה 1:\n * \n *     קלט: 3\n *     פלט: (1, 2)\n *     הסבר:\n *     פלינדרומים הם 1, 2, 3. אחד מהם הוא זוגי ושניים מהם הם אי זוגיים.\n * \n * דוגמה 2:\n * \n *     קלט: 12\n *     פלט: (4, 6)\n *     הסבר:\n *     פלינדרומים הם 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. ארבעה מהם הם זוגיים וששה מהם הם אי זוגיים.\n * \n * הערה:\n *     1. 1 <= n <= 10^3\n *     2. הטאפל שמוחזר מכיל את מספר הפלינדרומים הזוגיים והאי זוגיים בהתאמה.\n * \n * \n */\nconst even_odd_palindrome = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = even_odd_palindrome(123);\nlet expected_1 = [8, 13];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = even_odd_palindrome(12);\nlet expected_2 = [4, 6];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = even_odd_palindrome(3);\nlet expected_3 = [1, 2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = even_odd_palindrome(63);\nlet expected_4 = [6, 8];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = even_odd_palindrome(25);\nlet expected_5 = [5, 6];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = even_odd_palindrome(19);\nlet expected_6 = [4, 6];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = even_odd_palindrome(9);\nlet expected_7 = [4, 5];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = even_odd_palindrome(1);\nlet expected_8 = [0, 1];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "נתון מספר שלם חיובי n, יש להחזיר טאפל שמכיל את מספר הפלינדרומים הזוגיים והאי זוגיים שנמצאים בטווח (1, n), כולל.\n\nדוגמה 1:\n\n    קלט: 3\n    פלט: (1, 2)\n    הסבר:\n    פלינדרומים הם 1, 2, 3. אחד מהם הוא זוגי ושניים מהם הם אי זוגיים.\n\nדוגמה 2:\n\n    קלט: 12\n    פלט: (4, 6)\n    הסבר:\n    פלינדרומים הם 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. ארבעה מהם הם זוגיים וששה מהם הם אי זוגיים.\n\nהערה:\n    1. 1 <= n <= 10^3\n    2. הטאפל שמוחזר מכיל את מספר הפלינדרומים הזוגיים והאי זוגיים בהתאמה.", "entry_point": "even_odd_palindrome", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/49", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * יש לנו מערך 'arr' של N מספרים arr[1], arr[2], ..., arr[N]. המספרים במערך יהיו בסדר רנדומלי. המטרה שלך היא לקבוע אם ניתן לקבל מערך ממוין בסדר לא יורד על ידי ביצוע הפעולה הבאה על המערך הנתון:\n *     ניתן לבצע פעולת הזזת ימינה כל מספר של פעמים.\n *     \n *     פעולת ההזזה הימנית אחת משמעותה להזיז את כל האיברים של המערך במקום אחד לכיוון הימין. האיבר האחרון של המערך יועבר למקום ההתחלתי במערך, כלומר לאינדקס 0.\n * \n *     אם ניתן לקבל את המערך הממוין על ידי ביצוע הפעולה הנ\"ל, יש להחזיר True, אחרת יש להחזיר False.\n *     אם המערך הנתון ריק, יש להחזיר True.\n * \n *     לתשומת לב: הרשימה הנתונה מובטחת להכיל איברים ייחודיים.\n * \n *     לדוגמה:\n * \n *     move_one_ball([3, 4, 5, 1, 2])==>True\n *     הסבר: על ידי ביצוע 2 פעולות הזזה ימינה, ניתן להשיג סדר לא יורד עבור המערך הנתון.\n *     move_one_ball([3, 5, 4, 1, 2])==>False\n *     הסבר: אי אפשר לקבל סדר לא יורד עבור המערך הנתון על ידי ביצוע כל מספר של פעולות הזזה ימינה.\n * \n * \n * \n */\nconst move_one_ball = function (arr: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = move_one_ball([3, 4, 5, 1, 2]);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = move_one_ball([3, 5, 10, 1, 2]);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = move_one_ball([4, 3, 1, 2]);\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = move_one_ball([3, 5, 4, 1, 2]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = move_one_ball([]);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "יש לנו מערך 'arr' של N מספרים arr[1], arr[2], ..., arr[N]. המספרים במערך יהיו בסדר רנדומלי. המטרה שלך היא לקבוע אם ניתן לקבל מערך ממוין בסדר לא יורד על ידי ביצוע הפעולה הבאה על המערך הנתון:\n    ניתן לבצע פעולת הזזת ימינה כל מספר של פעמים.\n    \n    פעולת ההזזה הימנית אחת משמעותה להזיז את כל האיברים של המערך במקום אחד לכיוון הימין. האיבר האחרון של המערך יועבר למקום ההתחלתי במערך, כלומר לאינדקס 0.\n\n    אם ניתן לקבל את המערך הממוין על ידי ביצוע הפעולה הנ\"ל, יש להחזיר True, אחרת יש להחזיר False.\n    אם המערך הנתון ריק, יש להחזיר True.\n\n    לתשומת לב: הרשימה הנתונה מובטחת להכיל איברים ייחודיים.\n\n    לדוגמה:\n\n    move_one_ball([3, 4, 5, 1, 2])==>True\n    הסבר: על ידי ביצוע 2 פעולות הזזה ימינה, ניתן להשיג סדר לא יורד עבור המערך הנתון.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    הסבר: אי אפשר לקבל סדר לא יורד עבור המערך הנתון על ידי ביצוע כל מספר של פעולות הזזה ימינה.", "entry_point": "move_one_ball", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/50", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * בבעיה זו, תכתבו פונקציה שמקבלת שתי רשימות של מספרים,\n *     ומקבלת החלטה אם ניתן לבצע החלפת איברים\n *     ביניהם כדי להפוך את lst1 לרשימה של מספרים זוגיים בלבד.\n *     אין מגבלה על מספר האיברים שניתן להחליף בין lst1 ו-lst2.\n *     אם ניתן להחליף איברים בין lst1 ו-lst2 כדי להפוך\n *     את כל האיברים של lst1 להיות זוגיים, יש להחזיר \"YES\".\n *     אחרת, יש להחזיר \"NO\".\n *     לדוגמה:\n *     exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n *     exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n *     ניתן להניח כי הרשימות הקלט יהיו לא ריקות.\n * \n * \n */\nconst exchange = function (lst1: Array<number>, lst2: Array<number>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = exchange([1, 2, 3, 4],[1, 2, 3, 4]);\nlet expected_1 = \"YES\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = exchange([1, 2, 3, 4],[1, 5, 3, 4]);\nlet expected_2 = \"NO\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = exchange([1, 2, 3, 4],[2, 1, 4, 3]);\nlet expected_3 = \"YES\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = exchange([5, 7, 3],[2, 6, 4]);\nlet expected_4 = \"YES\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = exchange([5, 7, 3],[2, 6, 3]);\nlet expected_5 = \"NO\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = exchange([3, 2, 6, 1, 8, 9],[3, 5, 5, 1, 1, 1]);\nlet expected_6 = \"NO\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = exchange([100, 200],[200, 200]);\nlet expected_7 = \"YES\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "בבעיה זו, תכתבו פונקציה שמקבלת שתי רשימות של מספרים,\n    ומקבלת החלטה אם ניתן לבצע החלפת איברים\n    ביניהם כדי להפוך את lst1 לרשימה של מספרים זוגיים בלבד.\n    אין מגבלה על מספר האיברים שניתן להחליף בין lst1 ו-lst2.\n    אם ניתן להחליף איברים בין lst1 ו-lst2 כדי להפוך\n    את כל האיברים של lst1 להיות זוגיים, יש להחזיר \"YES\".\n    אחרת, יש להחזיר \"NO\".\n    לדוגמה:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    ניתן להניח כי הרשימות הקלט יהיו לא ריקות.", "entry_point": "exchange", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/51", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * מטלה\n *     נתונות שתי מחרוזות s ו-c, עליכם למחוק את כל התווים ב-s שזהים לכל תו ב-c\n *     ולאחר מכן לבדוק אם המחרוזת התוצאה היא פלינדרום.\n *     מחרוזת נקראת פלינדרום אם היא קוראת אותו הדבר לפנים ולאחור.\n *     עליכם להחזיר טופל המכיל את המחרוזת התוצאה ו-True/False עבור הבדיקה.\n *     דוגמא\n *     עבור s = \"abcde\", c = \"ae\", התוצאה צריכה להיות ('bcd',False)\n *     עבור s = \"abcdef\", c = \"b\" התוצאה צריכה להיות ('acdef',False)\n *     עבור s = \"abcdedcba\", c = \"ab\", התוצאה צריכה להיות ('cdedc',True)\n * \n * \n */\nconst reverse_delete = function (s: string, c: string) : Array<any>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = reverse_delete(\"abcde\",\"ae\");\nlet expected_1 = [\"bcd\", false];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = reverse_delete(\"abcdef\",\"b\");\nlet expected_2 = [\"acdef\", false];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = reverse_delete(\"abcdedcba\",\"ab\");\nlet expected_3 = [\"cdedc\", true];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = reverse_delete(\"dwik\",\"w\");\nlet expected_4 = [\"dik\", false];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = reverse_delete(\"a\",\"a\");\nlet expected_5 = [\"\", true];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = reverse_delete(\"abcdedcba\",\"\");\nlet expected_6 = [\"abcdedcba\", true];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = reverse_delete(\"abcdedcba\",\"v\");\nlet expected_7 = [\"abcdedcba\", true];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = reverse_delete(\"vabba\",\"v\");\nlet expected_8 = [\"abba\", true];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = reverse_delete(\"mamma\",\"mia\");\nlet expected_9 = [\"\", true];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "מטלה\n    נתונות שתי מחרוזות s ו-c, עליכם למחוק את כל התווים ב-s שזהים לכל תו ב-c\n    ולאחר מכן לבדוק אם המחרוזת התוצאה היא פלינדרום.\n    מחרוזת נקראת פלינדרום אם היא קוראת אותו הדבר לפנים ולאחור.\n    עליכם להחזיר טופל המכיל את המחרוזת התוצאה ו-True/False עבור הבדיקה.\n    דוגמא\n    עבור s = \"abcde\", c = \"ae\", התוצאה צריכה להיות ('bcd',False)\n    עבור s = \"abcdef\", c = \"b\" התוצאה צריכה להיות ('acdef',False)\n    עבור s = \"abcdedcba\", c = \"ab\", התוצאה צריכה להיות ('cdedc',True)", "entry_point": "reverse_delete", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/52", "prompt": "import * as math from 'mathjs'\n\n/**\n * אתה מתכנת TypeScript מומחה\n * \n * קיבלתם רשת מלבנית של בארות. כל שורה מייצגת באר יחידה, וכל 1 בשורה מייצג יחידת מים יחידה. לכל באר יש דלי תואם שניתן להשתמש בו כדי לחלץ מים ממנו, וכל הדליים יש להם את אותה הקיבולת. המטרה שלכם היא להשתמש בדליים כדי לרוקן את הבארות. פלט: מספר הפעמים שעליכם להוריד את הדליים.\n * \n * דוגמה 1:\n *     קלט:\n *         grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n *         bucket_capacity : 1\n *     פלט: 6\n * \n * דוגמה 2:\n *     קלט:\n *         grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n *         bucket_capacity : 2\n *     פלט: 5\n * \n * דוגמה 3:\n *     קלט:\n *         grid : [[0,0,0], [0,0,0]]\n *         bucket_capacity : 5\n *     פלט: 0\n * \n * הגבלות:\n *     * כל הבארות יש להם אותו אורך\n *     * 1 <= אורך הרשת <= 10^2\n *     * 1 <= אורך השורה הראשונה של הרשת <= 10^2\n *     * grid[i][j] -> 0 | 1\n *     * 1 <= קיבולת <= 10\n * \n * \n */\nconst max_fill = function (grid: Array<Array<number>>, capacity: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],1);\nlet expected_1 = 6;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],2);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = max_fill([[0, 0, 0], [0, 0, 0]],5);\nlet expected_3 = 0;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = max_fill([[1, 1, 1, 1], [1, 1, 1, 1]],2);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = max_fill([[1, 1, 1, 1], [1, 1, 1, 1]],9);\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "קיבלתם רשת מלבנית של בארות. כל שורה מייצגת באר יחידה, וכל 1 בשורה מייצג יחידת מים יחידה. לכל באר יש דלי תואם שניתן להשתמש בו כדי לחלץ מים ממנו, וכל הדליים יש להם את אותה הקיבולת. המטרה שלכם היא להשתמש בדליים כדי לרוקן את הבארות. פלט: מספר הפעמים שעליכם להוריד את הדליים.\n\nדוגמה 1:\n    קלט:\n        grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        bucket_capacity : 1\n    פלט: 6\n\nדוגמה 2:\n    קלט:\n        grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        bucket_capacity : 2\n    פלט: 5\n\nדוגמה 3:\n    קלט:\n        grid : [[0,0,0], [0,0,0]]\n        bucket_capacity : 5\n    פלט: 0\n\nהגבלות:\n    * כל הבארות יש להם אותו אורך\n    * 1 <= אורך הרשת <= 10^2\n    * 1 <= אורך השורה הראשונה של הרשת <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= קיבולת <= 10", "entry_point": "max_fill", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/53", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * נתון מחרוזת s ומספר טבעי n, עליך לממש פונקציה שמחזירה רשימה של כל המילים מהמחרוזת s שמכילות בדיוק n עיצורים, בסדר שהן מופיעות במחרוזת s. אם המחרוזת s ריקה, הפונקציה צריכה להחזיר רשימה ריקה. שים לב: ניתן להניח שהמחרוזת הקלט מכילה רק אותיות ורווחים. דוגמאות:\n * \n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n * \n */\nconst select_words = function (s: string, n: number) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = select_words(\"Mary had a little lamb\",4);\nlet expected_1 = [\"little\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = select_words(\"Mary had a little lamb\",3);\nlet expected_2 = [\"Mary\", \"lamb\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = select_words(\"simple white space\",2);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = select_words(\"Hello world\",4);\nlet expected_4 = [\"world\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = select_words(\"Uncle sam\",3);\nlet expected_5 = [\"Uncle\"];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = select_words(\"\",4);\nlet expected_6 = [];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = select_words(\"a b c d e f\",1);\nlet expected_7 = [\"b\", \"c\", \"d\", \"f\"];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "נתון מחרוזת s ומספר טבעי n, עליך לממש פונקציה שמחזירה רשימה של כל המילים מהמחרוזת s שמכילות בדיוק n עיצורים, בסדר שהן מופיעות במחרוזת s. אם המחרוזת s ריקה, הפונקציה צריכה להחזיר רשימה ריקה. שים לב: ניתן להניח שהמחרוזת הקלט מכילה רק אותיות ורווחים. דוגמאות:", "entry_point": "select_words", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/54", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * נתון מערך של מספרים שלמים ומספר שלם חיובי k, יש להחזיר רשימה ממוינת בגודל k עם המספרים הגדולים ביותר במערך.\n * \n * דוגמה 1:\n *     קלט: arr = [-3, -4, 5], k = 3\n *     פלט: [-4, -3, 5]\n * \n * דוגמה 2:\n *     קלט: arr = [4, -4, 4], k = 2\n *     פלט: [4, 4]\n * \n * דוגמה 3:\n *     קלט: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n *     פלט: [2]\n * \n * הערות:\n *     1. אורך המערך יהיה בטווח של [1, 1000].\n *     2. האיברים במערך יהיו בטווח של [-1000, 1000].\n *     3. 0 <= k <= אורך המערך.\n * \n * \n */\nconst maximum = function (arr: Array<number>, k: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = maximum([-3, -4, 5],3);\nlet expected_1 = [-4, -3, 5];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = maximum([4, -4, 4],2);\nlet expected_2 = [4, 4];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = maximum([-3, 2, 1, 2, -1, -2, 1],1);\nlet expected_3 = [2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = maximum([123, -123, 20, 0, 1, 2, -3],3);\nlet expected_4 = [2, 20, 123];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = maximum([-123, 20, 0, 1, 2, -3],4);\nlet expected_5 = [0, 1, 2, 20];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = maximum([5, 15, 0, 3, -13, -8, 0],7);\nlet expected_6 = [-13, -8, 0, 0, 3, 5, 15];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = maximum([-1, 0, 2, 5, 3, -10],2);\nlet expected_7 = [3, 5];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = maximum([1, 0, 5, -7],1);\nlet expected_8 = [5];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = maximum([4, -4],2);\nlet expected_9 = [-4, 4];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = maximum([-10, 10],2);\nlet expected_10 = [-10, 10];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = maximum([1, 2, 3, -23, 243, -400, 0],0);\nlet expected_11 = [];\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "נתון מערך של מספרים שלמים ומספר שלם חיובי k, יש להחזיר רשימה ממוינת בגודל k עם המספרים הגדולים ביותר במערך.\n\nדוגמה 1:\n    קלט: arr = [-3, -4, 5], k = 3\n    פלט: [-4, -3, 5]\n\nדוגמה 2:\n    קלט: arr = [4, -4, 4], k = 2\n    פלט: [4, 4]\n\nדוגמה 3:\n    קלט: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    פלט: [2]\n\nהערות:\n    1. אורך המערך יהיה בטווח של [1, 1000].\n    2. האיברים במערך יהיו בטווח של [-1000, 1000].\n    3. 0 <= k <= אורך המערך.", "entry_point": "maximum", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/55", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * נתון מערך של מספרים שלמים לא ריקים arr ומספר שלם k, החזר את סכום האיברים עם לכל היותר שני ספרות מה-k הראשונים של arr.\n * \n * דוגמה:\n * \n *     קלט: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n *     פלט: 24 # סכום של 21 + 3\n * \n * הגבלות:\n *     1. 1 <= len(arr) <= 100\n *     2. 1 <= k <= len(arr)\n * \n * \n */\nconst add_elements = function (arr: Array<number>, k: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = add_elements([1, -2, -3, 41, 57, 76, 87, 88, 99],3);\nlet expected_1 = -4;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = add_elements([111, 121, 3, 4000, 5, 6],2);\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = add_elements([11, 21, 3, 90, 5, 6, 7, 8, 9],4);\nlet expected_3 = 125;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9],4);\nlet expected_4 = 24;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = add_elements([1],1);\nlet expected_5 = 1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "נתון מערך של מספרים שלמים לא ריקים arr ומספר שלם k, החזר את סכום האיברים עם לכל היותר שני ספרות מה-k הראשונים של arr.\n\nדוגמה:\n\n    קלט: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    פלט: 24 # סכום של 21 + 3\n\nהגבלות:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)", "entry_point": "add_elements", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/56", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * נתונים לך שני מרווחים,\n *     כאשר כל מרווח הוא זוג של מספרים שלמים. למשל, מרווח = (התחלה, סיום) = (1, 2).\n *     המרווחים הנתונים הם סגורים, כלומר המרווח (התחלה, סיום)\n *     כולל את ההתחלה והסיום.\n *     עבור כל מרווח נתון, נניח שההתחלה שלו קטנה או שווה לסיום שלו.\n *     המטרה שלך היא לקבוע אם אורך החיתוך של שני המרווחים הוא מספר ראשוני.\n *     למשל, החיתוך של המרווחים (1, 3), (2, 4) הוא (2, 3)\n *     שאורכו הוא 1, שאינו מספר ראשוני.\n *     אם אורך החיתוך הוא מספר ראשוני, החזר \"YES\",\n *     אחרת, החזר \"NO\".\n *     אם שני המרווחים אינם מתקלקלים, החזר \"NO\".\n * \n * \n *     [קלט/פלט] דוגמאות:\n * \n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n * \n */\nconst intersection = function (interval1: Array<number>, interval2: Array<number>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = intersection([1, 2],[2, 3]);\nlet expected_1 = \"NO\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = intersection([-1, 1],[0, 4]);\nlet expected_2 = \"NO\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = intersection([-3, -1],[-5, 5]);\nlet expected_3 = \"YES\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = intersection([-2, 2],[-4, 0]);\nlet expected_4 = \"YES\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = intersection([-11, 2],[-1, -1]);\nlet expected_5 = \"NO\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = intersection([1, 2],[3, 5]);\nlet expected_6 = \"NO\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = intersection([1, 2],[1, 2]);\nlet expected_7 = \"NO\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = intersection([-2, -2],[-3, -2]);\nlet expected_8 = \"NO\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "נתונים לך שני מרווחים,\n    כאשר כל מרווח הוא זוג של מספרים שלמים. למשל, מרווח = (התחלה, סיום) = (1, 2).\n    המרווחים הנתונים הם סגורים, כלומר המרווח (התחלה, סיום)\n    כולל את ההתחלה והסיום.\n    עבור כל מרווח נתון, נניח שההתחלה שלו קטנה או שווה לסיום שלו.\n    המטרה שלך היא לקבוע אם אורך החיתוך של שני המרווחים הוא מספר ראשוני.\n    למשל, החיתוך של המרווחים (1, 3), (2, 4) הוא (2, 3)\n    שאורכו הוא 1, שאינו מספר ראשוני.\n    אם אורך החיתוך הוא מספר ראשוני, החזר \"YES\",\n    אחרת, החזר \"NO\".\n    אם שני המרווחים אינם מתקלקלים, החזר \"NO\".\n\n\n    [קלט/פלט] דוגמאות:", "entry_point": "intersection", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/57", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * כולם מכירים את רצף פיבונאצ'י, הוא נחקר עמוקות על ידי מתמטיקאים במאה האחרונה. אך מה שאנשים לא יודעים זה רצף טריבונאצ'י. רצף טריבונאצ'י מוגדר על ידי הנוסחה הבאה:\n * tri(1) = 3\n * tri(n) = 1 + n / 2, אם n הוא זוגי.\n * tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), אם n הוא אי-זוגי.\n * לדוגמה:\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n * = 2 + 3 + 3 = 8\n * נתון לך מספר שלם לא-שלילי n, עליך להחזיר רשימה של n + 1 המספרים הראשונים ברצף טריבונאצ'י.\n * לדוגמה:\n * tri(3) = [1, 3, 2, 8]\n * \n * \n */\nconst tri = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = tri(3);\nlet expected_1 = [1, 3, 2.0, 8.0];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = tri(4);\nlet expected_2 = [1, 3, 2.0, 8.0, 3.0];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = tri(5);\nlet expected_3 = [1, 3, 2.0, 8.0, 3.0, 15.0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = tri(6);\nlet expected_4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = tri(7);\nlet expected_5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = tri(8);\nlet expected_6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = tri(9);\nlet expected_7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = tri(20);\nlet expected_8 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = tri(0);\nlet expected_9 = [1];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = tri(1);\nlet expected_10 = [1, 3];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "כולם מכירים את רצף פיבונאצ'י, הוא נחקר עמוקות על ידי מתמטיקאים במאה האחרונה. אך מה שאנשים לא יודעים זה רצף טריבונאצ'י. רצף טריבונאצ'י מוגדר על ידי הנוסחה הבאה:\ntri(1) = 3\ntri(n) = 1 + n / 2, אם n הוא זוגי.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), אם n הוא אי-זוגי.\nלדוגמה:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nנתון לך מספר שלם לא-שלילי n, עליך להחזיר רשימה של n + 1 המספרים הראשונים ברצף טריבונאצ'י.\nלדוגמה:\ntri(3) = [1, 3, 2, 8]", "entry_point": "tri", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/58", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * נתון מספר שלם חיובי n, החזר את כפל הספרות האי-זוגיות.\n * החזר 0 אם כל הספרות הן זוגיות.\n * לדוגמה:\n * \n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n * \n */\nconst digits = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = digits(5);\nlet expected_1 = 5;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = digits(54);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = digits(120);\nlet expected_3 = 1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = digits(5014);\nlet expected_4 = 5;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = digits(98765);\nlet expected_5 = 315;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = digits(5576543);\nlet expected_6 = 2625;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = digits(2468);\nlet expected_7 = 0;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "נתון מספר שלם חיובי n, החזר את כפל הספרות האי-זוגיות.\nהחזר 0 אם כל הספרות הן זוגיות.\nלדוגמה:", "entry_point": "digits", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/59", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * צור פונקציה שמקבלת מחרוזת כקלט המכילה רק סוגריים מרובעים.\n * הפונקציה צריכה להחזיר אמת רק אם קיים תת-רצף תקין של סוגריים מרובעים\n * בו לפחות סוגריים מרובעים אחד מכיל סוגריים מרובעים נושאים.\n * is_nested('[[]]') ➞ True\n * is_nested('[]]]]]]][[[[[]') ➞ False\n * is_nested('[][]') ➞ False\n * is_nested('[]') ➞ False\n * is_nested('[[][]]') ➞ True\n * is_nested('[[]][[') ➞ True\n * \n */\nconst is_nested = function (string0: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_nested(\"[[]]\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_nested(\"[]]]]]]][[[[[]\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_nested(\"[][]\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_nested(\"[]\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_nested(\"[[[[]]]]\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_nested(\"[]]]]]]]]]]\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_nested(\"[][][[]]\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_nested(\"[[]\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_nested(\"[]]\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_nested(\"[[]][[\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = is_nested(\"[[][]]\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = is_nested(\"\");\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = is_nested(\"[[[[[[[[\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = is_nested(\"]]]]]]]]\");\nlet expected_14 = false;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\n", "language": "typescript", "description": "צור פונקציה שמקבלת מחרוזת כקלט המכילה רק סוגריים מרובעים.\nהפונקציה צריכה להחזיר אמת רק אם קיים תת-רצף תקין של סוגריים מרובעים\nבו לפחות סוגריים מרובעים אחד מכיל סוגריים מרובעים נושאים.", "entry_point": "is_nested", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/60", "prompt": "import * as math from 'mathjs'\n\n/**\n * אתה מתכנת TypeScript מומחה\n * קיבלת רשימה של מספרים.\n *     עליך להחזיר את סכום המספרים ברשימה שהוצבעו בריבוע,\n *     לעגל כל איבר ברשימה למספר שלם עליון (Ceiling) תחילה.\n *     דוגמאות:\n *     עבור lst = [1,2,3] הפלט צריך להיות 14\n *     עבור lst = [1,4,9] הפלט צריך להיות 98\n *     עבור lst = [1,3,5,7] הפלט צריך להיות 84\n *     עבור lst = [1.4,4.2,0] הפלט צריך להיות 29\n *     עבור lst = [-2.4,1,1] הפלט צריך להיות 6\n * \n * \n * \n * \n */\nconst sum_squares = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_squares([1, 2, 3]);\nlet expected_1 = 14;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_squares([1.0, 2, 3]);\nlet expected_2 = 14;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_squares([1, 3, 5, 7]);\nlet expected_3 = 84;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_squares([1.4, 4.2, 0]);\nlet expected_4 = 29;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_squares([-2.4, 1, 1]);\nlet expected_5 = 6;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = sum_squares([100, 1, 15, 2]);\nlet expected_6 = 10230;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = sum_squares([10000, 10000]);\nlet expected_7 = 200000000;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = sum_squares([-1.4, 4.6, 6.3]);\nlet expected_8 = 75;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = sum_squares([-1.4, 17.9, 18.9, 19.9]);\nlet expected_9 = 1086;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = sum_squares([0]);\nlet expected_10 = 0;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = sum_squares([-1]);\nlet expected_11 = 1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = sum_squares([-1, 1, 0]);\nlet expected_12 = 2;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\n", "language": "typescript", "description": "קיבלת רשימה של מספרים.\n    עליך להחזיר את סכום המספרים ברשימה שהוצבעו בריבוע,\n    לעגל כל איבר ברשימה למספר שלם עליון (Ceiling) תחילה.\n    דוגמאות:\n    עבור lst = [1,2,3] הפלט צריך להיות 14\n    עבור lst = [1,4,9] הפלט צריך להיות 98\n    עבור lst = [1,3,5,7] הפלט צריך להיות 84\n    עבור lst = [1.4,4.2,0] הפלט צריך להיות 29\n    עבור lst = [-2.4,1,1] הפלט צריך להיות 6", "entry_point": "sum_squares", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/61", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * צור פונקציה שמחזירה True אם התו האחרון במחרוזת הנתונה הוא תו אלפביתי ואינו חלק ממילה, ו-False אחרת.\n * לתשומת לב: \"מילה\" היא קבוצת תווים המופרדים באמצעות רווח.\n * \n * דוגמאות:\n * \n * check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n * check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n * check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n * check_if_last_char_is_a_letter(\"\") ➞ False \n * \n */\nconst check_if_last_char_is_a_letter = function (txt: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = check_if_last_char_is_a_letter(\"apple\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = check_if_last_char_is_a_letter(\"apple pi e\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = check_if_last_char_is_a_letter(\"eeeee\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = check_if_last_char_is_a_letter(\"A\");\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = check_if_last_char_is_a_letter(\"Pumpkin pie \");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = check_if_last_char_is_a_letter(\"Pumpkin pie 1\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = check_if_last_char_is_a_letter(\"\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = check_if_last_char_is_a_letter(\"eeeee e \");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = check_if_last_char_is_a_letter(\"apple pie\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = check_if_last_char_is_a_letter(\"apple pi e \");\nlet expected_10 = false;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "צור פונקציה שמחזירה True אם התו האחרון במחרוזת הנתונה הוא תו אלפביתי ואינו חלק ממילה, ו-False אחרת.\nלתשומת לב: \"מילה\" היא קבוצת תווים המופרדים באמצעות רווח.\n\nדוגמאות:", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/62", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * צור פונקציה שמחזירה את האינדקס הגדול ביותר של אלמנט שאינו גדול או שווה לאלמנט הקודם לו. אם לא קיים אלמנט כזה, החזר -1. המערך הנתון לא יכיל ערכים כפולים.\n * \n * דוגמאות:\n * \n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n * \n */\nconst can_arrange = function (arr: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = can_arrange([1, 2, 4, 3, 5]);\nlet expected_1 = 3;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = can_arrange([1, 2, 4, 5]);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = can_arrange([1, 4, 2, 5, 6, 7, 8, 9, 10]);\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = can_arrange([4, 8, 5, 7, 3]);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = can_arrange([]);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "צור פונקציה שמחזירה את האינדקס הגדול ביותר של אלמנט שאינו גדול או שווה לאלמנט הקודם לו. אם לא קיים אלמנט כזה, החזר -1. המערך הנתון לא יכיל ערכים כפולים.\n\nדוגמאות:", "entry_point": "can_arrange", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/63", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * צור פונקציה שמחזירה טופל (a, b), כאשר 'a' הוא המספר השלילי הגדול ביותר, ו-'b' הוא המספר החיובי הקטן ביותר ברשימה.\n *     אם אין מספרים שליליים או חיוביים, החזר אותם כ-None.\n * \n *     דוגמאות:\n * \n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n * \n */\nconst largest_smallest_integers = function (lst: Array<number>) : Array<any>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = largest_smallest_integers([2, 4, 1, 3, 5, 7]);\nlet expected_1 = [undefined, 1];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = largest_smallest_integers([2, 4, 1, 3, 5, 7, 0]);\nlet expected_2 = [undefined, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = largest_smallest_integers([1, 3, 2, 4, 5, 6, -2]);\nlet expected_3 = [-2, 1];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = largest_smallest_integers([4, 5, 3, 6, 2, 7, -7]);\nlet expected_4 = [-7, 2];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = largest_smallest_integers([7, 3, 8, 4, 9, 2, 5, -9]);\nlet expected_5 = [-9, 2];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = largest_smallest_integers([]);\nlet expected_6 = [undefined, undefined];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = largest_smallest_integers([0]);\nlet expected_7 = [undefined, undefined];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = largest_smallest_integers([-1, -3, -5, -6]);\nlet expected_8 = [-1, undefined];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = largest_smallest_integers([-1, -3, -5, -6, 0]);\nlet expected_9 = [-1, undefined];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = largest_smallest_integers([-6, -4, -4, -3, 1]);\nlet expected_10 = [-3, 1];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = largest_smallest_integers([-6, -4, -4, -3, -100, 1]);\nlet expected_11 = [-3, 1];\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "צור פונקציה שמחזירה טופל (a, b), כאשר 'a' הוא המספר השלילי הגדול ביותר, ו-'b' הוא המספר החיובי הקטן ביותר ברשימה.\n    אם אין מספרים שליליים או חיוביים, החזר אותם כ-None.\n\n    דוגמאות:", "entry_point": "largest_smallest_integers", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/64", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * הפקטוריאל הברזילאי מוגדר כך:\n *     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     כאשר n > 0\n * \n *     לדוגמה:\n * >>> special_factorial(4)\n * 288\n * \n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n * \n */\nconst special_factorial = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = special_factorial(4);\nlet expected_1 = 288;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = special_factorial(5);\nlet expected_2 = 34560;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = special_factorial(7);\nlet expected_3 = 125411328000;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = special_factorial(1);\nlet expected_4 = 1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "הפקטוריאל הברזילאי מוגדר כך:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    כאשר n > 0\n\n    לדוגמה:", "entry_point": "special_factorial", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/65", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * קיבלת מחרוזת המייצגת משפט,\n * המשפט מכיל מילים מופרדות על ידי רווח,\n * ועליך להחזיר מחרוזת המכילה את המילים מהמשפט המקורי,\n * שאורכן הוא מספר ראשוני,\n * סדר המילים במחרוזת החדשה צריך להיות זהה למקורי.\n * \n * דוגמה 1:\n *     קלט: sentence = \"This is a test\"\n *     פלט: \"is\"\n * \n * דוגמה 2:\n *     קלט: sentence = \"lets go for swimming\"\n *     פלט: \"go for\"\n * \n * הגבלות:\n *     * 1 <= len(sentence) <= 100\n *     * המשפט מכיל רק אותיות.\n * \n * \n */\nconst words_in_sentence = function (sentence: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = words_in_sentence(\"This is a test\");\nlet expected_1 = \"is\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = words_in_sentence(\"lets go for swimming\");\nlet expected_2 = \"go for\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = words_in_sentence(\"there is no place available here\");\nlet expected_3 = \"there is no place\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = words_in_sentence(\"Hi I am Hussein\");\nlet expected_4 = \"Hi am Hussein\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = words_in_sentence(\"go for it\");\nlet expected_5 = \"go for it\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = words_in_sentence(\"here\");\nlet expected_6 = \"\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = words_in_sentence(\"here is\");\nlet expected_7 = \"is\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "קיבלת מחרוזת המייצגת משפט,\nהמשפט מכיל מילים מופרדות על ידי רווח,\nועליך להחזיר מחרוזת המכילה את המילים מהמשפט המקורי,\nשאורכן הוא מספר ראשוני,\nסדר המילים במחרוזת החדשה צריך להיות זהה למקורי.\n\nדוגמה 1:\n    קלט: sentence = \"This is a test\"\n    פלט: \"is\"\n\nדוגמה 2:\n    קלט: sentence = \"lets go for swimming\"\n    פלט: \"go for\"\n\nהגבלות:\n    * 1 <= len(sentence) <= 100\n    * המשפט מכיל רק אותיות.", "entry_point": "words_in_sentence", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/66", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * המטרה שלך היא ליישם פונקציה שתפשט את הביטוי\n *     x * n. הפונקציה מחזירה True אם x * n מבוצע למספר שלם ו-False\n *     אחרת. המשתנים x ו-n הם מיוצגים כמחרוזות של שבר, ויש להם את הפורמט הבא,\n *     <מונה>/<מכנה> כאשר המונה והמכנה הם מספרים שלמים חיוביים.\n * \n *     אתה יכול להניח ש-x ו-n הם שברים תקינים ואינם מכילים אפס כמכנה.\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n * \n */\nconst simplify = function (x: string, n: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = simplify(\"1/5\",\"5/1\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = simplify(\"1/6\",\"2/1\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = simplify(\"5/1\",\"3/1\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = simplify(\"7/10\",\"10/2\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = simplify(\"2/10\",\"50/10\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = simplify(\"7/2\",\"4/2\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = simplify(\"11/6\",\"6/1\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = simplify(\"2/3\",\"5/2\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = simplify(\"5/2\",\"3/5\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = simplify(\"2/4\",\"8/4\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = simplify(\"2/4\",\"4/2\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = simplify(\"1/5\",\"5/1\");\nlet expected_12 = true;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = simplify(\"1/5\",\"1/5\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\n", "language": "typescript", "description": "המטרה שלך היא ליישם פונקציה שתפשט את הביטוי\n    x * n. הפונקציה מחזירה True אם x * n מבוצע למספר שלם ו-False\n    אחרת. המשתנים x ו-n הם מיוצגים כמחרוזות של שבר, ויש להם את הפורמט הבא,\n    <מונה>/<מכנה> כאשר המונה והמכנה הם מספרים שלמים חיוביים.\n\n    אתה יכול להניח ש-x ו-n הם שברים תקינים ואינם מכילים אפס כמכנה.", "entry_point": "simplify", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/67", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * כתוב פונקציה הממיינת את רשימת המספרים הנתונה בסדר עולה לפי סכום הספרות שלהם. שים לב: אם ישנם פריטים מרובים עם סכום דומה של הספרות שלהם, מיין אותם על פי האינדקס שלהם ברשימה המקורית.\n * \n * לדוגמה:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n * \n */\nconst order_by_points = function (nums: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = order_by_points([1, 11, -1, -11, -12]);\nlet expected_1 = [-1, -11, 1, -12, 11];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = order_by_points([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]);\nlet expected_2 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = order_by_points([]);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = order_by_points([1, -11, -32, 43, 54, -98, 2, -3]);\nlet expected_4 = [-3, -32, -98, -11, 1, 2, 43, 54];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = order_by_points([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\nlet expected_5 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = order_by_points([0, 6, 6, -76, -21, 23, 4]);\nlet expected_6 = [-76, -21, 0, 4, 23, 6, 6];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "כתוב פונקציה הממיינת את רשימת המספרים הנתונה בסדר עולה לפי סכום הספרות שלהם. שים לב: אם ישנם פריטים מרובים עם סכום דומה של הספרות שלהם, מיין אותם על פי האינדקס שלהם ברשימה המקורית.\n\nלדוגמה:", "entry_point": "order_by_points", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/68", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * כתוב פונקציה שמקבלת מערך של מספרים כקלט ומחזירה את מספר האיברים במערך שגדולים מ-10 ושהספרות הראשונות והאחרונות של המספר הן אי-זוגיות (1, 3, 5, 7, 9). לדוגמה:\n * \n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n * \n */\nconst specialFilter = function (nums: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = specialFilter([5, -2, 1, -5]);\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = specialFilter([15, -73, 14, -15]);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = specialFilter([33, -2, -3, 45, 21, 109]);\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = specialFilter([43, -12, 93, 125, 121, 109]);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = specialFilter([71, -2, -33, 75, 21, 19]);\nlet expected_5 = 3;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = specialFilter([1]);\nlet expected_6 = 0;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = specialFilter([]);\nlet expected_7 = 0;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "כתוב פונקציה שמקבלת מערך של מספרים כקלט ומחזירה את מספר האיברים במערך שגדולים מ-10 ושהספרות הראשונות והאחרונות של המספר הן אי-זוגיות (1, 3, 5, 7, 9). לדוגמה:", "entry_point": "specialFilter", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/69", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * קיבלתם מספר שלם חיובי n. עליכם ליצור מערך של מספרים שלמים a באורך n.\n *         עבור כל i (1 ≤ i ≤ n), ערך a[i] יהיה i * i - i + 1.\n *         החזירו את מספר הטריפלטים (a[i], a[j], a[k]) של a כאשר i < j < k, \n *     ו-a[i] + a[j] + a[k] הוא מרובע של 3.\n * \n *     דוגמה :\n *         קלט: n = 5\n *         פלט: 1\n *         הסבר: \n *         a = [1, 3, 7, 13, 21]\n *         הטריפלט היחיד החוקי הוא (1, 7, 13).\n * \n * \n */\nconst get_max_triples = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_max_triples(5);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_max_triples(6);\nlet expected_2 = 4;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_max_triples(10);\nlet expected_3 = 36;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_max_triples(100);\nlet expected_4 = 53361;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "קיבלתם מספר שלם חיובי n. עליכם ליצור מערך של מספרים שלמים a באורך n.\n        עבור כל i (1 ≤ i ≤ n), ערך a[i] יהיה i * i - i + 1.\n        החזירו את מספר הטריפלטים (a[i], a[j], a[k]) של a כאשר i < j < k, \n    ו-a[i] + a[j] + a[k] הוא מרובע של 3.\n\n    דוגמה :\n        קלט: n = 5\n        פלט: 1\n        הסבר: \n        a = [1, 3, 7, 13, 21]\n        הטריפלט היחיד החוקי הוא (1, 7, 13).", "entry_point": "get_max_triples", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/70", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * יש שמונה כוכבי לכת במערכת השמש שלנו: הכוכב הקרוב ביותר לשמש הוא מרקורי, הבא בתור הוא ונוס, אז כדור הארץ, מאדים, יופיטר, כוכב השבת, אורנוס ונפטון. כתוב פונקציה שמקבלת שני שמות כוכבי לכת כמחרוזות planet1 ו- planet2. הפונקציה צריכה להחזיר טופל שמכיל את כל הכוכבים שלהם המסלולים נמצאים בין מסלול הכוכב planet1 למסלול הכוכב planet2, ממוינים לפי הקירבה לשמש. הפונקציה צריכה להחזיר טופל ריק אם planet1 או planet2 אינם שמות כוכבי לכת נכונים. דוגמאות\n * \n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n * \n */\nconst bf = function (planet1: string, planet2: string) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = bf(\"Jupiter\",\"Neptune\");\nlet expected_1 = [\"Saturn\", \"Uranus\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = bf(\"Earth\",\"Mercury\");\nlet expected_2 = [\"Venus\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = bf(\"Mercury\",\"Uranus\");\nlet expected_3 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = bf(\"Neptune\",\"Venus\");\nlet expected_4 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = bf(\"Earth\",\"Earth\");\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = bf(\"Mars\",\"Earth\");\nlet expected_6 = [];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = bf(\"Jupiter\",\"Makemake\");\nlet expected_7 = [];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "יש שמונה כוכבי לכת במערכת השמש שלנו: הכוכב הקרוב ביותר לשמש הוא מרקורי, הבא בתור הוא ונוס, אז כדור הארץ, מאדים, יופיטר, כוכב השבת, אורנוס ונפטון. כתוב פונקציה שמקבלת שני שמות כוכבי לכת כמחרוזות planet1 ו- planet2. הפונקציה צריכה להחזיר טופל שמכיל את כל הכוכבים שלהם המסלולים נמצאים בין מסלול הכוכב planet1 למסלול הכוכב planet2, ממוינים לפי הקירבה לשמש. הפונקציה צריכה להחזיר טופל ריק אם planet1 או planet2 אינם שמות כוכבי לכת נכונים. דוגמאות", "entry_point": "bf", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/71", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * תיאור התוכנית היא תוכנית פשוטה שצריכה להחזיר את ערך x אם n הוא מספר ראשוני ולהחזיר את ערך y אחרת.\n * \n * דוגמאות:\n * \n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n * \n */\nconst x_or_y = function (n: number, x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = x_or_y(7,34,12);\nlet expected_1 = 34;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = x_or_y(15,8,5);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = x_or_y(3,33,5212);\nlet expected_3 = 33;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = x_or_y(1259,3,52);\nlet expected_4 = 3;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = x_or_y(7919,-1,12);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = x_or_y(3609,1245,583);\nlet expected_6 = 583;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = x_or_y(91,56,129);\nlet expected_7 = 129;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = x_or_y(6,34,1234);\nlet expected_8 = 1234;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = x_or_y(1,2,0);\nlet expected_9 = 0;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = x_or_y(2,2,0);\nlet expected_10 = 2;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "תיאור התוכנית היא תוכנית פשוטה שצריכה להחזיר את ערך x אם n הוא מספר ראשוני ולהחזיר את ערך y אחרת.\n\nדוגמאות:", "entry_point": "x_or_y", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/72", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * נתונה רשימה של מספרים, החזר את סכום הריבועים של המספרים ברשימה שזוגיים. התעלם ממספרים שהם שליליים או לא שלמים.\n *     \n *     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n *     double_the_difference([-1, -2, 0]) == 0\n *     double_the_difference([9, -2]) == 81\n *     double_the_difference([0]) == 0  \n *    \n *     אם הרשימה ריקה, החזר 0.\n * \n * \n */\nconst double_the_difference = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = double_the_difference([]);\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = double_the_difference([5, 4]);\nlet expected_2 = 25;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = double_the_difference([0.1, 0.2, 0.3]);\nlet expected_3 = 0;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = double_the_difference([-10, -20, -30]);\nlet expected_4 = 0;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = double_the_difference([-1, -2, 8]);\nlet expected_5 = 0;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = double_the_difference([0.2, 3, 5]);\nlet expected_6 = 34;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = double_the_difference([-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]);\nlet expected_7 = 166650;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "נתונה רשימה של מספרים, החזר את סכום הריבועים של המספרים ברשימה שזוגיים. התעלם ממספרים שהם שליליים או לא שלמים.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    אם הרשימה ריקה, החזר 0.", "entry_point": "double_the_difference", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/73", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * ינתן לך שם של מחלקה (מחרוזת) ורשימת הרחבות.\n * הרחבות יש להשתמש בהן כדי לטעון מחלקות נוספות למחלקה. כוח ההרחבה הוא כדלקמן: תהיינה CAP מספר האותיות הגדולות בשם ההרחבה, ו- SM מספר האותיות הקטנות בשם ההרחבה, הכוח נתון על ידי המנה CAP - SM. עליך למצוא את ההרחבה החזקה ביותר ולהחזיר מחרוזת בפורמט הבא: ClassName.StrongestExtensionName.\n * אם ישנן שתי או יותר הרחבות עם אותו כוח, עליך לבחור את האחת שמופיעה ראשונה ברשימה.\n * לדוגמה, אם ניתן לך \"Slices\" כמחלקה ורשימת הרחבות: ['SErviNGSliCes', 'Cheese', 'StuFfed'] אז עליך להחזיר 'Slices.SErviNGSliCes' מכיוון ש-'SErviNGSliCes' היא ההרחבה החזקה ביותר (הכוח שלה הוא -1).\n * דוגמה:\n * \n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n * \n */\nconst Strongest_Extension = function (class_name: string, extensions: Array<string>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = Strongest_Extension(\"Watashi\",[\"tEN\", \"niNE\", \"eIGHt8OKe\"]);\nlet expected_1 = \"Watashi.eIGHt8OKe\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = Strongest_Extension(\"Boku123\",[\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]);\nlet expected_2 = \"Boku123.YEs.WeCaNe\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = Strongest_Extension(\"__YESIMHERE\",[\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]);\nlet expected_3 = \"__YESIMHERE.NuLl__\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = Strongest_Extension(\"K\",[\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]);\nlet expected_4 = \"K.TAR\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = Strongest_Extension(\"__HAHA\",[\"Tab\", \"123\", \"781345\", \"-_-\"]);\nlet expected_5 = \"__HAHA.123\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = Strongest_Extension(\"YameRore\",[\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]);\nlet expected_6 = \"YameRore.okIWILL123\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = Strongest_Extension(\"finNNalLLly\",[\"Die\", \"NowW\", \"Wow\", \"WoW\"]);\nlet expected_7 = \"finNNalLLly.WoW\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = Strongest_Extension(\"_\",[\"Bb\", \"91245\"]);\nlet expected_8 = \"_.Bb\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = Strongest_Extension(\"Sp\",[\"671235\", \"Bb\"]);\nlet expected_9 = \"Sp.671235\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "ינתן לך שם של מחלקה (מחרוזת) ורשימת הרחבות.\nהרחבות יש להשתמש בהן כדי לטעון מחלקות נוספות למחלקה. כוח ההרחבה הוא כדלקמן: תהיינה CAP מספר האותיות הגדולות בשם ההרחבה, ו- SM מספר האותיות הקטנות בשם ההרחבה, הכוח נתון על ידי המנה CAP - SM. עליך למצוא את ההרחבה החזקה ביותר ולהחזיר מחרוזת בפורמט הבא: ClassName.StrongestExtensionName.\nאם ישנן שתי או יותר הרחבות עם אותו כוח, עליך לבחור את האחת שמופיעה ראשונה ברשימה.\nלדוגמה, אם ניתן לך \"Slices\" כמחלקה ורשימת הרחבות: ['SErviNGSliCes', 'Cheese', 'StuFfed'] אז עליך להחזיר 'Slices.SErviNGSliCes' מכיוון ש-'SErviNGSliCes' היא ההרחבה החזקה ביותר (הכוח שלה הוא -1).\nדוגמה:", "entry_point": "Strongest_Extension", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/74", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * קיבלת שתי מילים. עליך להחזיר True אם המילה השנייה או אף אחת מהסיבובים שלה היא תת מחרוזת במילה הראשונה.\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n * \n * \n */\nconst cycpattern_check = function (a: string, b: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = cycpattern_check(\"xyzw\",\"xyw\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = cycpattern_check(\"yello\",\"ell\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = cycpattern_check(\"whattup\",\"ptut\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = cycpattern_check(\"efef\",\"fee\");\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = cycpattern_check(\"abab\",\"aabb\");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = cycpattern_check(\"winemtt\",\"tinem\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "קיבלת שתי מילים. עליך להחזיר True אם המילה השנייה או אף אחת מהסיבובים שלה היא תת מחרוזת במילה הראשונה.", "entry_point": "cycpattern_check", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/75", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * נתון מספר שלם חיובי, לקבל את המספר הרומי המתאים לו כמחרוזת ולהחזיר אותו באותיות קטנות.\n * הגבלות: 1 <= num <= 1000\n * \n * דוגמאות:\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n * \n */\nconst int_to_mini_roman = function (number0: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = int_to_mini_roman(19);\nlet expected_1 = \"xix\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = int_to_mini_roman(152);\nlet expected_2 = \"clii\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = int_to_mini_roman(251);\nlet expected_3 = \"ccli\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = int_to_mini_roman(426);\nlet expected_4 = \"cdxxvi\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = int_to_mini_roman(500);\nlet expected_5 = \"d\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = int_to_mini_roman(1);\nlet expected_6 = \"i\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = int_to_mini_roman(4);\nlet expected_7 = \"iv\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = int_to_mini_roman(43);\nlet expected_8 = \"xliii\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = int_to_mini_roman(90);\nlet expected_9 = \"xc\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = int_to_mini_roman(94);\nlet expected_10 = \"xciv\";\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = int_to_mini_roman(532);\nlet expected_11 = \"dxxxii\";\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = int_to_mini_roman(900);\nlet expected_12 = \"cm\";\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = int_to_mini_roman(994);\nlet expected_13 = \"cmxciv\";\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = int_to_mini_roman(1000);\nlet expected_14 = \"m\";\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\n", "language": "typescript", "description": "נתון מספר שלם חיובי, לקבל את המספר הרומי המתאים לו כמחרוזת ולהחזיר אותו באותיות קטנות.\nהגבלות: 1 <= num <= 1000\n\nדוגמאות:", "entry_point": "int_to_mini_roman", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/76", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * נתונות אורכי הצלעות של משולש. החזר True אם השלושה צלעים מהווים משולש ישר-זווית, אחרת החזר False. משולש ישר-זווית הוא משולש שבו זווית אחת היא זווית ישרה או 90 מעלות. דוגמה:\n * \n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n * \n */\nconst right_angle_triangle = function (a: number, b: number, c: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = right_angle_triangle(3,4,5);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = right_angle_triangle(1,2,3);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = right_angle_triangle(10,6,8);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = right_angle_triangle(2,2,2);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = right_angle_triangle(7,24,25);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = right_angle_triangle(10,5,7);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = right_angle_triangle(5,12,13);\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = right_angle_triangle(15,8,17);\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = right_angle_triangle(48,55,73);\nlet expected_9 = true;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = right_angle_triangle(1,1,1);\nlet expected_10 = false;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = right_angle_triangle(2,2,10);\nlet expected_11 = false;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "נתונות אורכי הצלעות של משולש. החזר True אם השלושה צלעים מהווים משולש ישר-זווית, אחרת החזר False. משולש ישר-זווית הוא משולש שבו זווית אחת היא זווית ישרה או 90 מעלות. דוגמה:", "entry_point": "right_angle_triangle", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/77", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * נתונה מחרוזת s.\n *     אם s[i] הוא אות, הפוך את המקרה שלו מקטן לגדול או להיפך,\n *     אחרת השאר אותו כפי שהוא.\n *     אם המחרוזת אינה מכילה אותיות, הפוך את המחרוזת.\n *     הפונקציה צריכה להחזיר את המחרוזת התוצאה.\n *     דוגמאות\n * \n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n * \n */\nconst solve = function (s: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = solve(\"AsDf\");\nlet expected_1 = \"aSdF\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = solve(\"1234\");\nlet expected_2 = \"4321\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = solve(\"ab\");\nlet expected_3 = \"AB\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = solve(\"#a@C\");\nlet expected_4 = \"#A@c\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = solve(\"#AsdfW^45\");\nlet expected_5 = \"#aSDFw^45\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = solve(\"#6@2\");\nlet expected_6 = \"2@6#\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = solve(\"#$a^D\");\nlet expected_7 = \"#$A^d\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = solve(\"#ccc\");\nlet expected_8 = \"#CCC\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "נתונה מחרוזת s.\n    אם s[i] הוא אות, הפוך את המקרה שלו מקטן לגדול או להיפך,\n    אחרת השאר אותו כפי שהוא.\n    אם המחרוזת אינה מכילה אותיות, הפוך את המחרוזת.\n    הפונקציה צריכה להחזיר את המחרוזת התוצאה.\n    דוגמאות", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/78", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * נתון מחרוזת 'טקסט', החזר מחרוזת שקולה ל-md5 שלה.\n *     אם 'טקסט' הוא מחרוזת ריקה, החזר null.\n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n * \n */\nconst string_to_md5 = function (text: string) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = string_to_md5(\"Hello world\");\nlet expected_1 = \"3e25960a79dbc69b674cd4ec67a72c62\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = string_to_md5(\"\");\nlet expected_2 = undefined;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = string_to_md5(\"A B C\");\nlet expected_3 = \"0ef78513b0cb8cef12743f5aeb35f888\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = string_to_md5(\"password\");\nlet expected_4 = \"5f4dcc3b5aa765d61d8327deb882cf99\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "נתון מחרוזת 'טקסט', החזר מחרוזת שקולה ל-md5 שלה.\n    אם 'טקסט' הוא מחרוזת ריקה, החזר null.", "entry_point": "string_to_md5", "canonical_solution": NaN, "natural_language": "Hebrew"}
{"task_id": "typescript/79", "prompt": "/**\n * אתה מתכנת TypeScript מומחה\n * \n * נתונים שני מספרים חיוביים a ו-b, החזר את הספרות הזוגיות בין a ל-b, בסדר עולה.\n * \n * לדוגמה:\n * \n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n * \n */\nconst generate_integers = function (a: number, b: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = generate_integers(2,10);\nlet expected_1 = [2, 4, 6, 8];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = generate_integers(10,2);\nlet expected_2 = [2, 4, 6, 8];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = generate_integers(132,2);\nlet expected_3 = [2, 4, 6, 8];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = generate_integers(17,89);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "נתונים שני מספרים חיוביים a ו-b, החזר את הספרות הזוגיות בין a ל-b, בסדר עולה.\n\nלדוגמה:", "entry_point": "generate_integers", "canonical_solution": NaN, "natural_language": "Hebrew"}
