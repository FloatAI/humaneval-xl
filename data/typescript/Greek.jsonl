{"task_id": "typescript/0", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Σας δίνεται μια λίστα με λειτουργίες κατάθεσης και ανάληψης σε έναν τραπεζικό λογαριασμό που ξεκινά με μηδενικό υπόλοιπο. Η εργασία σας είναι να ανιχνεύσετε αν σε οποιοδήποτε σημείο το υπόλοιπο του λογαριασμού πέσει κάτω από το μηδέν, και σε αυτό το σημείο η συνάρτηση θα πρέπει να επιστρέψει True. Διαφορετικά θα πρέπει να επιστρέψει False.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n * \n */\nconst below_zero = function (operations: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = below_zero([]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = below_zero([1, 2, -3, 1, 2, -3]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = below_zero([1, 2, -4, 5, 6]);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = below_zero([1, -1, 2, -2, 5, -5, 4, -4]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = below_zero([1, -1, 2, -2, 5, -5, 4, -5]);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = below_zero([1, -2, 2, -2, 5, -5, 4, -4]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνεται μια λίστα με λειτουργίες κατάθεσης και ανάληψης σε έναν τραπεζικό λογαριασμό που ξεκινά με μηδενικό υπόλοιπο. Η εργασία σας είναι να ανιχνεύσετε αν σε οποιοδήποτε σημείο το υπόλοιπο του λογαριασμού πέσει κάτω από το μηδέν, και σε αυτό το σημείο η συνάρτηση θα πρέπει να επιστρέψει True. Διαφορετικά θα πρέπει να επιστρέψει False.", "entry_point": "below_zero", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/1", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Για μια δεδομένη λίστα ακεραίων, επιστρέψτε ένα tuple που αποτελείται από το άθροισμα και το γινόμενο όλων των ακεραίων στη λίστα.\n * Το άθροισμα της κενής λίστας πρέπει να είναι ίσο με 0 και το γινόμενο της κενής λίστας πρέπει να είναι ίσο με 1.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n * \n */\nconst sum_product = function (numbers: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_product([]);\nlet expected_1 = [0, 1];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_product([1, 1, 1]);\nlet expected_2 = [3, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_product([100, 0]);\nlet expected_3 = [100, 0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_product([3, 5, 7]);\nlet expected_4 = [15, 105];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_product([10]);\nlet expected_5 = [10, 10];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Για μια δεδομένη λίστα ακεραίων, επιστρέψτε ένα tuple που αποτελείται από το άθροισμα και το γινόμενο όλων των ακεραίων στη λίστα.\nΤο άθροισμα της κενής λίστας πρέπει να είναι ίσο με 0 και το γινόμενο της κενής λίστας πρέπει να είναι ίσο με 1.", "entry_point": "sum_product", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/2", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Τα εισαγόμενα είναι δύο συμβολοσειρές a και b που αποτελούνται μόνο από 1s και 0s.\n *     Εκτελέστε δυαδικό XOR σε αυτές τις εισόδους και επιστρέψτε το αποτέλεσμα επίσης ως συμβολοσειρά.\n * >>> string_xor('010', '110')\n * '100'\n * \n */\nconst string_xor = function (a: string, b: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = string_xor(\"111000\",\"101010\");\nlet expected_1 = \"010010\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = string_xor(\"1\",\"1\");\nlet expected_2 = \"0\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = string_xor(\"0101\",\"0000\");\nlet expected_3 = \"0101\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "Τα εισαγόμενα είναι δύο συμβολοσειρές a και b που αποτελούνται μόνο από 1s και 0s.\n    Εκτελέστε δυαδικό XOR σε αυτές τις εισόδους και επιστρέψτε το αποτέλεσμα επίσης ως συμβολοσειρά.", "entry_point": "string_xor", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/3", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Από μια λίστα από αλφαριθμητικά, επιστρέψτε το μακρύτερο. Επιστρέψτε το πρώτο στην περίπτωση πολλαπλών αλφαριθμητικών με το ίδιο μήκος. Επιστρέψτε null στην περίπτωση που η εισαγωγική λίστα είναι άδεια.\n * >>> longest([])\n * \n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n * \n */\nconst longest = function (strings: Array<string>) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = longest([]);\nlet expected_1 = undefined;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = longest([\"x\", \"y\", \"z\"]);\nlet expected_2 = \"x\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = longest([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]);\nlet expected_3 = \"zzzz\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "Από μια λίστα από αλφαριθμητικά, επιστρέψτε το μακρύτερο. Επιστρέψτε το πρώτο στην περίπτωση πολλαπλών αλφαριθμητικών με το ίδιο μήκος. Επιστρέψτε null στην περίπτωση που η εισαγωγική λίστα είναι άδεια.", "entry_point": "longest", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/4", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Επιστροφή του μεγαλύτερου κοινού διαιρέτη δύο ακεραίων αριθμών a και b.\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n * \n */\nconst greatest_common_divisor = function (a: number, b: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = greatest_common_divisor(3,7);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = greatest_common_divisor(10,15);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = greatest_common_divisor(49,14);\nlet expected_3 = 7;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = greatest_common_divisor(144,60);\nlet expected_4 = 12;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Επιστροφή του μεγαλύτερου κοινού διαιρέτη δύο ακεραίων αριθμών a και b.", "entry_point": "greatest_common_divisor", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/5", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Η είσοδος είναι μια συμβολοσειρά διαχωρισμένη με κενό από αριθμητικά χαρακτήρες από το 'μηδέν' έως το 'εννέα'.\n *     Οι έγκυρες επιλογές είναι 'μηδέν', 'ένα', 'δύο', 'τρία', 'τέσσερα', 'πέντε', 'έξι', 'επτά', 'οκτώ' και 'εννέα'.\n *     Επιστρέψτε τη συμβολοσειρά με τους αριθμούς ταξινομημένους από τον μικρότερο στον μεγαλύτερο.\n * >>> sort_numbers('three one five')\n * 'one three five'\n * \n */\nconst sort_numbers = function (numbers: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sort_numbers(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sort_numbers(\"three\");\nlet expected_2 = \"three\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sort_numbers(\"three five nine\");\nlet expected_3 = \"three five nine\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sort_numbers(\"five zero four seven nine eight\");\nlet expected_4 = \"zero four five seven eight nine\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sort_numbers(\"six five four three two one zero\");\nlet expected_5 = \"zero one two three four five six\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Η είσοδος είναι μια συμβολοσειρά διαχωρισμένη με κενό από αριθμητικά χαρακτήρες από το 'μηδέν' έως το 'εννέα'.\n    Οι έγκυρες επιλογές είναι 'μηδέν', 'ένα', 'δύο', 'τρία', 'τέσσερα', 'πέντε', 'έξι', 'επτά', 'οκτώ' και 'εννέα'.\n    Επιστρέψτε τη συμβολοσειρά με τους αριθμούς ταξινομημένους από τον μικρότερο στον μεγαλύτερο.", "entry_point": "sort_numbers", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/6", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Δεδομένης μιας λίστας αριθμών (τουλάχιστον δύο στοιχείων), εφαρμόστε μια γραμμική μετασχηματιστική λειτουργία σε αυτήν τη λίστα, έτσι ώστε ο μικρότερος αριθμός να γίνει 0 και ο μεγαλύτερος να γίνει 1.\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n * \n */\nconst rescale_to_unit = function (numbers: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = rescale_to_unit([2.0, 49.9]);\nlet expected_1 = [0.0, 1.0];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = rescale_to_unit([100.0, 49.9]);\nlet expected_2 = [1.0, 0.0];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]);\nlet expected_3 = [0.0, 0.25, 0.5, 0.75, 1.0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]);\nlet expected_4 = [0.25, 0.0, 1.0, 0.5, 0.75];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]);\nlet expected_5 = [0.25, 0.0, 1.0, 0.5, 0.75];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένης μιας λίστας αριθμών (τουλάχιστον δύο στοιχείων), εφαρμόστε μια γραμμική μετασχηματιστική λειτουργία σε αυτήν τη λίστα, έτσι ώστε ο μικρότερος αριθμός να γίνει 0 και ο μεγαλύτερος να γίνει 1.", "entry_point": "rescale_to_unit", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/7", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Για μια δεδομένη συμβολοσειρά, αντιστρέψτε τους πεζούς χαρακτήρες σε κεφαλαίους και τους κεφαλαίους σε πεζούς.\n * >>> flip_case('Hello')\n * 'hELLO'\n * \n */\nconst flip_case = function (string0: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = flip_case(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = flip_case(\"Hello!\");\nlet expected_2 = \"hELLO!\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = flip_case(\"These violent delights have violent ends\");\nlet expected_3 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "Για μια δεδομένη συμβολοσειρά, αντιστρέψτε τους πεζούς χαρακτήρες σε κεφαλαίους και τους κεφαλαίους σε πεζούς.", "entry_point": "flip_case", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/8", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Επιστρέψτε μόνο θετικούς αριθμούς στη λίστα.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n * \n */\nconst get_positive = function (l: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_positive([-1, -2, 4, 5, 6]);\nlet expected_1 = [4, 5, 6];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]);\nlet expected_2 = [5, 3, 2, 3, 3, 9, 123, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_positive([-1, -2]);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_positive([]);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Επιστρέψτε μόνο θετικούς αριθμούς στη λίστα.", "entry_point": "get_positive", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/9", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Επιστρέφει αληθές αν ένας δεδομένος αριθμός είναι πρώτος και ψευδές σε διαφορετική περίπτωση.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n * \n */\nconst is_prime = function (n: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_prime(6);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_prime(101);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_prime(11);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_prime(13441);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_prime(61);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_prime(4);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_prime(1);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_prime(5);\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_prime(11);\nlet expected_9 = true;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_prime(17);\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = is_prime(85);\nlet expected_11 = false;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = is_prime(77);\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = is_prime(255379);\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\n", "language": "typescript", "description": "Επιστρέφει αληθές αν ένας δεδομένος αριθμός είναι πρώτος και ψευδές σε διαφορετική περίπτωση.", "entry_point": "is_prime", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/10", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Επιστροφή ταξινομημένων μοναδικών στοιχείων σε μια λίστα.\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n * \n */\nconst unique = function (l: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = unique([5, 3, 5, 2, 3, 3, 9, 0, 123]);\nlet expected_1 = [0, 2, 3, 5, 9, 123];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\n", "language": "typescript", "description": "Επιστροφή ταξινομημένων μοναδικών στοιχείων σε μια λίστα.", "entry_point": "unique", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/11", "prompt": "import * as math from 'mathjs'\n\n/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Η prime_fib επιστρέφει τον n-οστό αριθμό που είναι Fibonacci και είναι επίσης πρώτος.\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n * \n */\nconst prime_fib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = prime_fib(1);\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = prime_fib(2);\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = prime_fib(3);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = prime_fib(4);\nlet expected_4 = 13;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = prime_fib(5);\nlet expected_5 = 89;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = prime_fib(6);\nlet expected_6 = 233;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = prime_fib(7);\nlet expected_7 = 1597;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = prime_fib(8);\nlet expected_8 = 28657;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = prime_fib(9);\nlet expected_9 = 514229;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = prime_fib(10);\nlet expected_10 = 433494437;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Η prime_fib επιστρέφει τον n-οστό αριθμό που είναι Fibonacci και είναι επίσης πρώτος.", "entry_point": "prime_fib", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/12", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Η triples_sum_to_zero λαμβάνει μια λίστα ακεραίων ως είσοδο.\n *     επιστρέφει True αν υπάρχουν τρία διακριτά στοιχεία στη λίστα που\n *     άθροισμα τους είναι μηδέν, και False διαφορετικά.\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n * \n */\nconst triples_sum_to_zero = function (l: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = triples_sum_to_zero([1, 3, 5, 0]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = triples_sum_to_zero([1, 3, 5, -1]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = triples_sum_to_zero([1, 3, -2, 1]);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = triples_sum_to_zero([1, 2, 3, 7]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = triples_sum_to_zero([1, 2, 5, 7]);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = triples_sum_to_zero([2, 4, -5, 3, 9, 7]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = triples_sum_to_zero([1]);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = triples_sum_to_zero([1, 3, 5, -100]);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = triples_sum_to_zero([100, 3, 5, -100]);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Η triples_sum_to_zero λαμβάνει μια λίστα ακεραίων ως είσοδο.\n    επιστρέφει True αν υπάρχουν τρία διακριτά στοιχεία στη λίστα που\n    άθροισμα τους είναι μηδέν, και False διαφορετικά.", "entry_point": "triples_sum_to_zero", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/13", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Η συνάρτηση pairs_sum_to_zero παίρνει μια λίστα ακεραίων ως είσοδο.\n *     Επιστρέφει True αν υπάρχουν δύο διακριτά στοιχεία στη λίστα που\n *     έχουν άθροισμα μηδέν, και False αλλιώς.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n * \n */\nconst pairs_sum_to_zero = function (l: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = pairs_sum_to_zero([1, 3, 5, 0]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = pairs_sum_to_zero([1, 3, -2, 1]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = pairs_sum_to_zero([1, 2, 3, 7]);\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = pairs_sum_to_zero([2, 4, -5, 3, 5, 7]);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = pairs_sum_to_zero([1]);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]);\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Η συνάρτηση pairs_sum_to_zero παίρνει μια λίστα ακεραίων ως είσοδο.\n    Επιστρέφει True αν υπάρχουν δύο διακριτά στοιχεία στη λίστα που\n    έχουν άθροισμα μηδέν, και False αλλιώς.", "entry_point": "pairs_sum_to_zero", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/14", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Η ακολουθία αριθμών Fib4 είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n *     Παρακαλούμε γράψτε μια συνάρτηση για τον αποτελεσματικό υπολογισμό του n-οστού στοιχείου της ακολουθίας Fib4. Μην χρησιμοποιήσετε αναδρομή.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n * \n */\nconst fib4 = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fib4(5);\nlet expected_1 = 4;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fib4(8);\nlet expected_2 = 28;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fib4(10);\nlet expected_3 = 104;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fib4(12);\nlet expected_4 = 386;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Η ακολουθία αριθμών Fib4 είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Παρακαλούμε γράψτε μια συνάρτηση για τον αποτελεσματικό υπολογισμό του n-οστού στοιχείου της ακολουθίας Fib4. Μην χρησιμοποιήσετε αναδρομή.", "entry_point": "fib4", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/15", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Επιστροφή της μεσαίας τιμής των στοιχείων στη λίστα l.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n * \n */\nconst median = function (l: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = median([3, 1, 2, 4, 5]);\nlet expected_1 = 3;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = median([-10, 4, 6, 1000, 10, 20]);\nlet expected_2 = 8.0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = median([5]);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = median([6, 5]);\nlet expected_4 = 5.5;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = median([8, 1, 3, 9, 9, 2, 7]);\nlet expected_5 = 7;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Επιστροφή της μεσαίας τιμής των στοιχείων στη λίστα l.", "entry_point": "median", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/16", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Ελέγχει αν η δοθείσα συμβολοσειρά είναι παλίνδρομη.\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n * \n */\nconst is_palindrome = function (text: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_palindrome(\"\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_palindrome(\"aba\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_palindrome(\"aaaaa\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_palindrome(\"zbcd\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_palindrome(\"xywyx\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_palindrome(\"xywyz\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_palindrome(\"xywzx\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Ελέγχει αν η δοθείσα συμβολοσειρά είναι παλίνδρομη.", "entry_point": "is_palindrome", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/17", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Η remove_vowels είναι μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει το αλφαριθμητικό χωρίς φωνήεντα.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n * \n */\nconst remove_vowels = function (text: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = remove_vowels(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = remove_vowels(\"abcdef\\nghijklm\");\nlet expected_2 = \"bcdf\\nghjklm\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = remove_vowels(\"fedcba\");\nlet expected_3 = \"fdcb\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = remove_vowels(\"eeeee\");\nlet expected_4 = \"\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = remove_vowels(\"acBAA\");\nlet expected_5 = \"cB\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = remove_vowels(\"EcBOO\");\nlet expected_6 = \"cB\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = remove_vowels(\"ybcd\");\nlet expected_7 = \"ybcd\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Η remove_vowels είναι μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει το αλφαριθμητικό χωρίς φωνήεντα.", "entry_point": "remove_vowels", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/18", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Επιστρέφει True αν όλοι οι αριθμοί στη λίστα l είναι κάτω από το κατώφλι t.\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n * \n */\nconst below_threshold = function (l: Array<number>, t: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = below_threshold([1, 2, 4, 10],100);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = below_threshold([1, 20, 4, 10],5);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = below_threshold([1, 20, 4, 10],21);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = below_threshold([1, 20, 4, 10],22);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = below_threshold([1, 8, 4, 10],11);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = below_threshold([1, 8, 4, 10],10);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Επιστρέφει True αν όλοι οι αριθμοί στη λίστα l είναι κάτω από το κατώφλι t.", "entry_point": "below_threshold", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/19", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Προσθέστε δύο αριθμούς x και y.\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n * \n */\nconst add = function (x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = add(0,1);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = add(1,0);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = add(2,3);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = add(5,7);\nlet expected_4 = 12;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = add(7,5);\nlet expected_5 = 12;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = add(572,725);\nlet expected_6 = 1297;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = add(51,804);\nlet expected_7 = 855;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = add(645,96);\nlet expected_8 = 741;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = add(712,853);\nlet expected_9 = 1565;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = add(223,101);\nlet expected_10 = 324;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = add(76,29);\nlet expected_11 = 105;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = add(416,149);\nlet expected_12 = 565;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = add(145,409);\nlet expected_13 = 554;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = add(535,430);\nlet expected_14 = 965;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = add(118,303);\nlet expected_15 = 421;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = add(287,94);\nlet expected_16 = 381;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\nlet actual_17 = add(768,257);\nlet expected_17 = 1025;\nassert.deepEqual(actual_17, expected_17, \"Exception --- test case 16 failed to pass\");\n\nlet actual_18 = add(421,677);\nlet expected_18 = 1098;\nassert.deepEqual(actual_18, expected_18, \"Exception --- test case 17 failed to pass\");\n\nlet actual_19 = add(802,814);\nlet expected_19 = 1616;\nassert.deepEqual(actual_19, expected_19, \"Exception --- test case 18 failed to pass\");\n\nlet actual_20 = add(510,922);\nlet expected_20 = 1432;\nassert.deepEqual(actual_20, expected_20, \"Exception --- test case 19 failed to pass\");\n\nlet actual_21 = add(345,819);\nlet expected_21 = 1164;\nassert.deepEqual(actual_21, expected_21, \"Exception --- test case 20 failed to pass\");\n\nlet actual_22 = add(895,436);\nlet expected_22 = 1331;\nassert.deepEqual(actual_22, expected_22, \"Exception --- test case 21 failed to pass\");\n\nlet actual_23 = add(123,424);\nlet expected_23 = 547;\nassert.deepEqual(actual_23, expected_23, \"Exception --- test case 22 failed to pass\");\n\nlet actual_24 = add(923,245);\nlet expected_24 = 1168;\nassert.deepEqual(actual_24, expected_24, \"Exception --- test case 23 failed to pass\");\n\nlet actual_25 = add(23,438);\nlet expected_25 = 461;\nassert.deepEqual(actual_25, expected_25, \"Exception --- test case 24 failed to pass\");\n\nlet actual_26 = add(565,133);\nlet expected_26 = 698;\nassert.deepEqual(actual_26, expected_26, \"Exception --- test case 25 failed to pass\");\n\nlet actual_27 = add(945,925);\nlet expected_27 = 1870;\nassert.deepEqual(actual_27, expected_27, \"Exception --- test case 26 failed to pass\");\n\nlet actual_28 = add(261,983);\nlet expected_28 = 1244;\nassert.deepEqual(actual_28, expected_28, \"Exception --- test case 27 failed to pass\");\n\nlet actual_29 = add(139,577);\nlet expected_29 = 716;\nassert.deepEqual(actual_29, expected_29, \"Exception --- test case 28 failed to pass\");\n\nlet actual_30 = add(763,178);\nlet expected_30 = 941;\nassert.deepEqual(actual_30, expected_30, \"Exception --- test case 29 failed to pass\");\n\nlet actual_31 = add(147,892);\nlet expected_31 = 1039;\nassert.deepEqual(actual_31, expected_31, \"Exception --- test case 30 failed to pass\");\n\nlet actual_32 = add(436,402);\nlet expected_32 = 838;\nassert.deepEqual(actual_32, expected_32, \"Exception --- test case 31 failed to pass\");\n\nlet actual_33 = add(610,581);\nlet expected_33 = 1191;\nassert.deepEqual(actual_33, expected_33, \"Exception --- test case 32 failed to pass\");\n\nlet actual_34 = add(103,416);\nlet expected_34 = 519;\nassert.deepEqual(actual_34, expected_34, \"Exception --- test case 33 failed to pass\");\n\nlet actual_35 = add(339,990);\nlet expected_35 = 1329;\nassert.deepEqual(actual_35, expected_35, \"Exception --- test case 34 failed to pass\");\n\nlet actual_36 = add(130,504);\nlet expected_36 = 634;\nassert.deepEqual(actual_36, expected_36, \"Exception --- test case 35 failed to pass\");\n\nlet actual_37 = add(242,717);\nlet expected_37 = 959;\nassert.deepEqual(actual_37, expected_37, \"Exception --- test case 36 failed to pass\");\n\nlet actual_38 = add(562,110);\nlet expected_38 = 672;\nassert.deepEqual(actual_38, expected_38, \"Exception --- test case 37 failed to pass\");\n\nlet actual_39 = add(396,909);\nlet expected_39 = 1305;\nassert.deepEqual(actual_39, expected_39, \"Exception --- test case 38 failed to pass\");\n\nlet actual_40 = add(887,703);\nlet expected_40 = 1590;\nassert.deepEqual(actual_40, expected_40, \"Exception --- test case 39 failed to pass\");\n\nlet actual_41 = add(870,551);\nlet expected_41 = 1421;\nassert.deepEqual(actual_41, expected_41, \"Exception --- test case 40 failed to pass\");\n\nlet actual_42 = add(422,391);\nlet expected_42 = 813;\nassert.deepEqual(actual_42, expected_42, \"Exception --- test case 41 failed to pass\");\n\nlet actual_43 = add(299,505);\nlet expected_43 = 804;\nassert.deepEqual(actual_43, expected_43, \"Exception --- test case 42 failed to pass\");\n\nlet actual_44 = add(346,56);\nlet expected_44 = 402;\nassert.deepEqual(actual_44, expected_44, \"Exception --- test case 43 failed to pass\");\n\nlet actual_45 = add(36,706);\nlet expected_45 = 742;\nassert.deepEqual(actual_45, expected_45, \"Exception --- test case 44 failed to pass\");\n\nlet actual_46 = add(738,411);\nlet expected_46 = 1149;\nassert.deepEqual(actual_46, expected_46, \"Exception --- test case 45 failed to pass\");\n\nlet actual_47 = add(679,87);\nlet expected_47 = 766;\nassert.deepEqual(actual_47, expected_47, \"Exception --- test case 46 failed to pass\");\n\nlet actual_48 = add(25,303);\nlet expected_48 = 328;\nassert.deepEqual(actual_48, expected_48, \"Exception --- test case 47 failed to pass\");\n\nlet actual_49 = add(161,612);\nlet expected_49 = 773;\nassert.deepEqual(actual_49, expected_49, \"Exception --- test case 48 failed to pass\");\n\nlet actual_50 = add(306,841);\nlet expected_50 = 1147;\nassert.deepEqual(actual_50, expected_50, \"Exception --- test case 49 failed to pass\");\n\nlet actual_51 = add(973,411);\nlet expected_51 = 1384;\nassert.deepEqual(actual_51, expected_51, \"Exception --- test case 50 failed to pass\");\n\nlet actual_52 = add(711,157);\nlet expected_52 = 868;\nassert.deepEqual(actual_52, expected_52, \"Exception --- test case 51 failed to pass\");\n\nlet actual_53 = add(471,27);\nlet expected_53 = 498;\nassert.deepEqual(actual_53, expected_53, \"Exception --- test case 52 failed to pass\");\n\nlet actual_54 = add(714,792);\nlet expected_54 = 1506;\nassert.deepEqual(actual_54, expected_54, \"Exception --- test case 53 failed to pass\");\n\nlet actual_55 = add(38,206);\nlet expected_55 = 244;\nassert.deepEqual(actual_55, expected_55, \"Exception --- test case 54 failed to pass\");\n\nlet actual_56 = add(907,343);\nlet expected_56 = 1250;\nassert.deepEqual(actual_56, expected_56, \"Exception --- test case 55 failed to pass\");\n\nlet actual_57 = add(23,760);\nlet expected_57 = 783;\nassert.deepEqual(actual_57, expected_57, \"Exception --- test case 56 failed to pass\");\n\nlet actual_58 = add(524,859);\nlet expected_58 = 1383;\nassert.deepEqual(actual_58, expected_58, \"Exception --- test case 57 failed to pass\");\n\nlet actual_59 = add(30,529);\nlet expected_59 = 559;\nassert.deepEqual(actual_59, expected_59, \"Exception --- test case 58 failed to pass\");\n\nlet actual_60 = add(341,691);\nlet expected_60 = 1032;\nassert.deepEqual(actual_60, expected_60, \"Exception --- test case 59 failed to pass\");\n\nlet actual_61 = add(167,729);\nlet expected_61 = 896;\nassert.deepEqual(actual_61, expected_61, \"Exception --- test case 60 failed to pass\");\n\nlet actual_62 = add(636,289);\nlet expected_62 = 925;\nassert.deepEqual(actual_62, expected_62, \"Exception --- test case 61 failed to pass\");\n\nlet actual_63 = add(503,144);\nlet expected_63 = 647;\nassert.deepEqual(actual_63, expected_63, \"Exception --- test case 62 failed to pass\");\n\nlet actual_64 = add(51,985);\nlet expected_64 = 1036;\nassert.deepEqual(actual_64, expected_64, \"Exception --- test case 63 failed to pass\");\n\nlet actual_65 = add(287,149);\nlet expected_65 = 436;\nassert.deepEqual(actual_65, expected_65, \"Exception --- test case 64 failed to pass\");\n\nlet actual_66 = add(659,75);\nlet expected_66 = 734;\nassert.deepEqual(actual_66, expected_66, \"Exception --- test case 65 failed to pass\");\n\nlet actual_67 = add(462,797);\nlet expected_67 = 1259;\nassert.deepEqual(actual_67, expected_67, \"Exception --- test case 66 failed to pass\");\n\nlet actual_68 = add(406,141);\nlet expected_68 = 547;\nassert.deepEqual(actual_68, expected_68, \"Exception --- test case 67 failed to pass\");\n\nlet actual_69 = add(106,44);\nlet expected_69 = 150;\nassert.deepEqual(actual_69, expected_69, \"Exception --- test case 68 failed to pass\");\n\nlet actual_70 = add(300,934);\nlet expected_70 = 1234;\nassert.deepEqual(actual_70, expected_70, \"Exception --- test case 69 failed to pass\");\n\nlet actual_71 = add(471,524);\nlet expected_71 = 995;\nassert.deepEqual(actual_71, expected_71, \"Exception --- test case 70 failed to pass\");\n\nlet actual_72 = add(122,429);\nlet expected_72 = 551;\nassert.deepEqual(actual_72, expected_72, \"Exception --- test case 71 failed to pass\");\n\nlet actual_73 = add(735,195);\nlet expected_73 = 930;\nassert.deepEqual(actual_73, expected_73, \"Exception --- test case 72 failed to pass\");\n\nlet actual_74 = add(335,484);\nlet expected_74 = 819;\nassert.deepEqual(actual_74, expected_74, \"Exception --- test case 73 failed to pass\");\n\nlet actual_75 = add(28,809);\nlet expected_75 = 837;\nassert.deepEqual(actual_75, expected_75, \"Exception --- test case 74 failed to pass\");\n\nlet actual_76 = add(430,20);\nlet expected_76 = 450;\nassert.deepEqual(actual_76, expected_76, \"Exception --- test case 75 failed to pass\");\n\nlet actual_77 = add(916,635);\nlet expected_77 = 1551;\nassert.deepEqual(actual_77, expected_77, \"Exception --- test case 76 failed to pass\");\n\nlet actual_78 = add(301,999);\nlet expected_78 = 1300;\nassert.deepEqual(actual_78, expected_78, \"Exception --- test case 77 failed to pass\");\n\nlet actual_79 = add(454,466);\nlet expected_79 = 920;\nassert.deepEqual(actual_79, expected_79, \"Exception --- test case 78 failed to pass\");\n\nlet actual_80 = add(905,259);\nlet expected_80 = 1164;\nassert.deepEqual(actual_80, expected_80, \"Exception --- test case 79 failed to pass\");\n\nlet actual_81 = add(168,205);\nlet expected_81 = 373;\nassert.deepEqual(actual_81, expected_81, \"Exception --- test case 80 failed to pass\");\n\nlet actual_82 = add(570,434);\nlet expected_82 = 1004;\nassert.deepEqual(actual_82, expected_82, \"Exception --- test case 81 failed to pass\");\n\nlet actual_83 = add(64,959);\nlet expected_83 = 1023;\nassert.deepEqual(actual_83, expected_83, \"Exception --- test case 82 failed to pass\");\n\nlet actual_84 = add(957,510);\nlet expected_84 = 1467;\nassert.deepEqual(actual_84, expected_84, \"Exception --- test case 83 failed to pass\");\n\nlet actual_85 = add(722,598);\nlet expected_85 = 1320;\nassert.deepEqual(actual_85, expected_85, \"Exception --- test case 84 failed to pass\");\n\nlet actual_86 = add(770,226);\nlet expected_86 = 996;\nassert.deepEqual(actual_86, expected_86, \"Exception --- test case 85 failed to pass\");\n\nlet actual_87 = add(579,66);\nlet expected_87 = 645;\nassert.deepEqual(actual_87, expected_87, \"Exception --- test case 86 failed to pass\");\n\nlet actual_88 = add(117,674);\nlet expected_88 = 791;\nassert.deepEqual(actual_88, expected_88, \"Exception --- test case 87 failed to pass\");\n\nlet actual_89 = add(530,30);\nlet expected_89 = 560;\nassert.deepEqual(actual_89, expected_89, \"Exception --- test case 88 failed to pass\");\n\nlet actual_90 = add(776,345);\nlet expected_90 = 1121;\nassert.deepEqual(actual_90, expected_90, \"Exception --- test case 89 failed to pass\");\n\nlet actual_91 = add(327,389);\nlet expected_91 = 716;\nassert.deepEqual(actual_91, expected_91, \"Exception --- test case 90 failed to pass\");\n\nlet actual_92 = add(596,12);\nlet expected_92 = 608;\nassert.deepEqual(actual_92, expected_92, \"Exception --- test case 91 failed to pass\");\n\nlet actual_93 = add(599,511);\nlet expected_93 = 1110;\nassert.deepEqual(actual_93, expected_93, \"Exception --- test case 92 failed to pass\");\n\nlet actual_94 = add(936,476);\nlet expected_94 = 1412;\nassert.deepEqual(actual_94, expected_94, \"Exception --- test case 93 failed to pass\");\n\nlet actual_95 = add(461,14);\nlet expected_95 = 475;\nassert.deepEqual(actual_95, expected_95, \"Exception --- test case 94 failed to pass\");\n\nlet actual_96 = add(966,157);\nlet expected_96 = 1123;\nassert.deepEqual(actual_96, expected_96, \"Exception --- test case 95 failed to pass\");\n\nlet actual_97 = add(326,91);\nlet expected_97 = 417;\nassert.deepEqual(actual_97, expected_97, \"Exception --- test case 96 failed to pass\");\n\nlet actual_98 = add(392,455);\nlet expected_98 = 847;\nassert.deepEqual(actual_98, expected_98, \"Exception --- test case 97 failed to pass\");\n\nlet actual_99 = add(446,477);\nlet expected_99 = 923;\nassert.deepEqual(actual_99, expected_99, \"Exception --- test case 98 failed to pass\");\n\nlet actual_100 = add(324,860);\nlet expected_100 = 1184;\nassert.deepEqual(actual_100, expected_100, \"Exception --- test case 99 failed to pass\");\n\nlet actual_101 = add(945,85);\nlet expected_101 = 1030;\nassert.deepEqual(actual_101, expected_101, \"Exception --- test case 100 failed to pass\");\n\nlet actual_102 = add(886,582);\nlet expected_102 = 1468;\nassert.deepEqual(actual_102, expected_102, \"Exception --- test case 101 failed to pass\");\n\nlet actual_103 = add(886,712);\nlet expected_103 = 1598;\nassert.deepEqual(actual_103, expected_103, \"Exception --- test case 102 failed to pass\");\n\nlet actual_104 = add(842,953);\nlet expected_104 = 1795;\nassert.deepEqual(actual_104, expected_104, \"Exception --- test case 103 failed to pass\");\n\n", "language": "typescript", "description": "Προσθέστε δύο αριθμούς x και y.", "entry_point": "add", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/20", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Ελέγξτε αν δύο λέξεις έχουν τους ίδιους χαρακτήρες.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n * \n */\nconst same_chars = function (s0: string, s1: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = same_chars(\"eabcdzzzz\",\"dddzzzzzzzddeddabc\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = same_chars(\"abcd\",\"dddddddabc\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = same_chars(\"dddddddabc\",\"abcd\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = same_chars(\"eabcd\",\"dddddddabc\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = same_chars(\"abcd\",\"dddddddabcf\");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = same_chars(\"eabcdzzzz\",\"dddzzzzzzzddddabc\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = same_chars(\"aabb\",\"aaccc\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Ελέγξτε αν δύο λέξεις έχουν τους ίδιους χαρακτήρες.", "entry_point": "same_chars", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/21", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Επιστροφή του n-οστού αριθμού Fibonacci.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n * \n */\nconst fib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fib(10);\nlet expected_1 = 55;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fib(1);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fib(8);\nlet expected_3 = 21;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fib(11);\nlet expected_4 = 89;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = fib(12);\nlet expected_5 = 144;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Επιστροφή του n-οστού αριθμού Fibonacci.", "entry_point": "fib", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/22", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Επιστροφή ταξινομημένων μοναδικών κοινών στοιχείων για δύο λίστες.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n * \n * \n */\nconst common = function (l1: Array<number>, l2: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = common([1, 4, 3, 34, 653, 2, 5],[5, 7, 1, 5, 9, 653, 121]);\nlet expected_1 = [1, 5, 653];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = common([5, 3, 2, 8],[3, 2]);\nlet expected_2 = [2, 3];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = common([4, 3, 2, 8],[3, 2, 4]);\nlet expected_3 = [2, 3, 4];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = common([4, 3, 2, 8],[]);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Επιστροφή ταξινομημένων μοναδικών κοινών στοιχείων για δύο λίστες.", "entry_point": "common", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/23", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Επιστρέφει το μεγαλύτερο πρώτο παράγοντα του n. Υποθέτουμε ότι το n > 1 και δεν είναι πρώτος.\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n * \n */\nconst largest_prime_factor = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = largest_prime_factor(15);\nlet expected_1 = 5;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = largest_prime_factor(27);\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = largest_prime_factor(63);\nlet expected_3 = 7;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = largest_prime_factor(330);\nlet expected_4 = 11;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = largest_prime_factor(13195);\nlet expected_5 = 29;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Επιστρέφει το μεγαλύτερο πρώτο παράγοντα του n. Υποθέτουμε ότι το n > 1 και δεν είναι πρώτος.", "entry_point": "largest_prime_factor", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/24", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Η sum_to_n είναι μια συνάρτηση που αθροίζει αριθμούς από το 1 έως το n.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n * \n */\nconst sum_to_n = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_to_n(1);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_to_n(6);\nlet expected_2 = 21;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_to_n(11);\nlet expected_3 = 66;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_to_n(30);\nlet expected_4 = 465;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_to_n(100);\nlet expected_5 = 5050;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Η sum_to_n είναι μια συνάρτηση που αθροίζει αριθμούς από το 1 έως το n.", "entry_point": "sum_to_n", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/25", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Οι xs αντιπροσωπεύουν τους συντελεστές ενός πολυωνύμου.\n *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n *     Επιστρέφει την παράγωγο αυτού του πολυωνύμου στην ίδια μορφή.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n * \n */\nconst derivative = function (xs: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = derivative([3, 1, 2, 4, 5]);\nlet expected_1 = [1, 4, 12, 20];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = derivative([1, 2, 3]);\nlet expected_2 = [2, 6];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = derivative([3, 2, 1]);\nlet expected_3 = [2, 2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = derivative([3, 2, 1, 0, 4]);\nlet expected_4 = [2, 2, 0, 16];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = derivative([1]);\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Οι xs αντιπροσωπεύουν τους συντελεστές ενός πολυωνύμου.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Επιστρέφει την παράγωγο αυτού του πολυωνύμου στην ίδια μορφή.", "entry_point": "derivative", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/26", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Η ακολουθία αριθμών FibFib είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n *     fibfib(0) == 0\n *     fibfib(1) == 0\n *     fibfib(2) == 1\n *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n *     Παρακαλούμε γράψτε μια συνάρτηση για τον αποδοτικό υπολογισμό του n-οστού στοιχείου της ακολουθίας αριθμών FibFib.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n * \n */\nconst fibfib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fibfib(2);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fibfib(1);\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fibfib(5);\nlet expected_3 = 4;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fibfib(8);\nlet expected_4 = 24;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = fibfib(10);\nlet expected_5 = 81;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = fibfib(12);\nlet expected_6 = 274;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = fibfib(14);\nlet expected_7 = 927;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Η ακολουθία αριθμών FibFib είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Παρακαλούμε γράψτε μια συνάρτηση για τον αποδοτικό υπολογισμό του n-οστού στοιχείου της ακολουθίας αριθμών FibFib.", "entry_point": "fibfib", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/27", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Γράψτε μια συνάρτηση vowels_count η οποία παίρνει ως είσοδο μια συμβολοσειρά που αναπαριστά ένα λέξη και επιστρέφει τον αριθμό των φωνηέντων στη συμβολοσειρά. Τα φωνήεντα σε αυτήν την περίπτωση είναι 'a', 'e', 'i', 'o', 'u'. Εδώ, το 'y' είναι επίσης ένα φωνήεν, αλλά μόνο όταν βρίσκεται στο τέλος της δοθείσας λέξης.\n * \n * Παράδειγμα:\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n * \n */\nconst vowels_count = function (s: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = vowels_count(\"abcde\");\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = vowels_count(\"Alone\");\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = vowels_count(\"key\");\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = vowels_count(\"bye\");\nlet expected_4 = 1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = vowels_count(\"keY\");\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = vowels_count(\"bYe\");\nlet expected_6 = 1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = vowels_count(\"ACEDY\");\nlet expected_7 = 3;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Γράψτε μια συνάρτηση vowels_count η οποία παίρνει ως είσοδο μια συμβολοσειρά που αναπαριστά ένα λέξη και επιστρέφει τον αριθμό των φωνηέντων στη συμβολοσειρά. Τα φωνήεντα σε αυτήν την περίπτωση είναι 'a', 'e', 'i', 'o', 'u'. Εδώ, το 'y' είναι επίσης ένα φωνήεν, αλλά μόνο όταν βρίσκεται στο τέλος της δοθείσας λέξης.\n\nΠαράδειγμα:", "entry_point": "vowels_count", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/28", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Σας δίνεται μια μη κενή λίστα θετικών ακεραίων. Επιστρέψτε το μεγαλύτερο ακέραιο που είναι μεγαλύτερο από το μηδέν και έχει συχνότητα μεγαλύτερη ή ίση με την τιμή του ακεραίου. Η συχνότητα ενός ακεραίου είναι ο αριθμός των φορών που εμφανίζεται στη λίστα. Εάν δεν υπάρχει τέτοια τιμή, επιστρέψτε -1. Παραδείγματα:\n * \n * search([4, 1, 2, 2, 3, 1]) == 2\n * search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n * search([5, 5, 4, 4, 4]) == -1\n * \n */\nconst search = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = search([5, 5, 5, 5, 1]);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = search([4, 1, 4, 1, 4, 4]);\nlet expected_2 = 4;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = search([3, 3]);\nlet expected_3 = -1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = search([8, 8, 8, 8, 8, 8, 8, 8]);\nlet expected_4 = 8;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = search([2, 3, 3, 2, 2]);\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = search([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]);\nlet expected_6 = 1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = search([3, 2, 8, 2]);\nlet expected_7 = 2;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]);\nlet expected_8 = 1;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = search([8, 8, 3, 6, 5, 6, 4]);\nlet expected_9 = -1;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = search([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]);\nlet expected_10 = 1;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = search([1, 9, 10, 1, 3]);\nlet expected_11 = 1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = search([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]);\nlet expected_12 = 5;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = search([1]);\nlet expected_13 = 1;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = search([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]);\nlet expected_14 = 4;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]);\nlet expected_15 = 2;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]);\nlet expected_16 = 1;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\nlet actual_17 = search([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]);\nlet expected_17 = 4;\nassert.deepEqual(actual_17, expected_17, \"Exception --- test case 16 failed to pass\");\n\nlet actual_18 = search([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]);\nlet expected_18 = 4;\nassert.deepEqual(actual_18, expected_18, \"Exception --- test case 17 failed to pass\");\n\nlet actual_19 = search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]);\nlet expected_19 = 2;\nassert.deepEqual(actual_19, expected_19, \"Exception --- test case 18 failed to pass\");\n\nlet actual_20 = search([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]);\nlet expected_20 = -1;\nassert.deepEqual(actual_20, expected_20, \"Exception --- test case 19 failed to pass\");\n\nlet actual_21 = search([10]);\nlet expected_21 = -1;\nassert.deepEqual(actual_21, expected_21, \"Exception --- test case 20 failed to pass\");\n\nlet actual_22 = search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]);\nlet expected_22 = 2;\nassert.deepEqual(actual_22, expected_22, \"Exception --- test case 21 failed to pass\");\n\nlet actual_23 = search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]);\nlet expected_23 = 1;\nassert.deepEqual(actual_23, expected_23, \"Exception --- test case 22 failed to pass\");\n\nlet actual_24 = search([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]);\nlet expected_24 = 1;\nassert.deepEqual(actual_24, expected_24, \"Exception --- test case 23 failed to pass\");\n\nlet actual_25 = search([3, 10, 10, 9, 2]);\nlet expected_25 = -1;\nassert.deepEqual(actual_25, expected_25, \"Exception --- test case 24 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνεται μια μη κενή λίστα θετικών ακεραίων. Επιστρέψτε το μεγαλύτερο ακέραιο που είναι μεγαλύτερο από το μηδέν και έχει συχνότητα μεγαλύτερη ή ίση με την τιμή του ακεραίου. Η συχνότητα ενός ακεραίου είναι ο αριθμός των φορών που εμφανίζεται στη λίστα. Εάν δεν υπάρχει τέτοια τιμή, επιστρέψτε -1. Παραδείγματα:", "entry_point": "search", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/29", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέψτε την περιοχή του τριγώνου στρογγυλοποιημένη στα 2 δεκαδικά ψηφία αν οι τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο. Διαφορετικά, επιστρέψτε -1. Τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο όταν το άθροισμα οποιωνδήποτε δύο πλευρών είναι μεγαλύτερο από την τρίτη πλευρά. Παράδειγμα:\n * \n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n * \n */\nconst triangle_area = function (a: number, b: number, c: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = triangle_area(3,4,5);\nlet expected_1 = 6.0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = triangle_area(1,2,10);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = triangle_area(4,8,5);\nlet expected_3 = 8.18;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = triangle_area(2,2,2);\nlet expected_4 = 1.73;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = triangle_area(1,2,3);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = triangle_area(10,5,7);\nlet expected_6 = 16.25;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = triangle_area(2,6,3);\nlet expected_7 = -1;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = triangle_area(1,1,1);\nlet expected_8 = 0.43;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = triangle_area(2,2,10);\nlet expected_9 = -1;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέψτε την περιοχή του τριγώνου στρογγυλοποιημένη στα 2 δεκαδικά ψηφία αν οι τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο. Διαφορετικά, επιστρέψτε -1. Τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο όταν το άθροισμα οποιωνδήποτε δύο πλευρών είναι μεγαλύτερο από την τρίτη πλευρά. Παράδειγμα:", "entry_point": "triangle_area", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/30", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Γράψτε μια συνάρτηση που επιστρέφει True αν το αντικείμενο q θα πετάξει, και False αλλιώς.\n * Το αντικείμενο q θα πετάξει αν είναι ισορροπημένο (είναι παλινδρομική λίστα) και άθροισμα των στοιχείων του είναι μικρότερο ή ίσο του μέγιστου δυνατού βάρους w.\n * \n * Παράδειγμα:\n * will_it_fly([1, 2], 5) ➞ False\n * # 1+2 είναι μικρότερο από το μέγιστο δυνατό βάρος, αλλά δεν είναι ισορροπημένο.\n * \n * will_it_fly([3, 2, 3], 1) ➞ False\n * # είναι ισορροπημένο, αλλά 3+2+3 είναι περισσότερο από το μέγιστο δυνατό βάρος.\n * \n * will_it_fly([3, 2, 3], 9) ➞ True\n * # 3+2+3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n * \n * will_it_fly([3], 5) ➞ True\n * # 3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n * \n * \n */\nconst will_it_fly = function (q: Array<number>, w: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = will_it_fly([3, 2, 3],9);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = will_it_fly([1, 2],5);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = will_it_fly([3],5);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = will_it_fly([3, 2, 3],1);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = will_it_fly([1, 2, 3],6);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = will_it_fly([5],5);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Γράψτε μια συνάρτηση που επιστρέφει True αν το αντικείμενο q θα πετάξει, και False αλλιώς.\nΤο αντικείμενο q θα πετάξει αν είναι ισορροπημένο (είναι παλινδρομική λίστα) και άθροισμα των στοιχείων του είναι μικρότερο ή ίσο του μέγιστου δυνατού βάρους w.\n\nΠαράδειγμα:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 είναι μικρότερο από το μέγιστο δυνατό βάρος, αλλά δεν είναι ισορροπημένο.\n\nwill_it_fly([3, 2, 3], 1) ➞ False\n# είναι ισορροπημένο, αλλά 3+2+3 είναι περισσότερο από το μέγιστο δυνατό βάρος.\n\nwill_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n\nwill_it_fly([3], 5) ➞ True\n# 3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.", "entry_point": "will_it_fly", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/31", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Γράψτε μια συνάρτηση που επιστρέφει true αν το δοθέν αριθμός είναι το γινόμενο τριών πρώτων αριθμών και false σε διαφορετική περίπτωση.\n *     Γνωρίζοντας ότι (α) είναι μικρότερο από το 100.\n *     Παράδειγμα:\n * \n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n * \n */\nconst is_multiply_prime = function (a: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_multiply_prime(5);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_multiply_prime(30);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_multiply_prime(8);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_multiply_prime(10);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_multiply_prime(125);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_multiply_prime(105);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_multiply_prime(126);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_multiply_prime(729);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_multiply_prime(891);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_multiply_prime(1001);\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Γράψτε μια συνάρτηση που επιστρέφει true αν το δοθέν αριθμός είναι το γινόμενο τριών πρώτων αριθμών και false σε διαφορετική περίπτωση.\n    Γνωρίζοντας ότι (α) είναι μικρότερο από το 100.\n    Παράδειγμα:", "entry_point": "is_multiply_prime", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/32", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Θα σας δοθεί ένας αριθμός σε δεκαδική μορφή και η εργασία σας είναι να τον μετατρέψετε σε δυαδική μορφή. Η συνάρτηση θα πρέπει να επιστρέφει μια συμβολοσειρά, με κάθε χαρακτήρα που αντιπροσωπεύει ένα δυαδικό αριθμό. Κάθε χαρακτήρας στη συμβολοσειρά θα είναι '0' ή '1'.\n * \n * Θα υπάρχουν μερικοί επιπλέον χαρακτήρες 'db' στην αρχή και στο τέλος της συμβολοσειράς. Οι επιπλέον χαρακτήρες είναι εκεί για να βοηθήσουν με τη μορφοποίηση.\n * \n * Παραδείγματα:\n * \n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n * \n */\nconst decimal_to_binary = function (decimal: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = decimal_to_binary(0);\nlet expected_1 = \"db0db\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = decimal_to_binary(32);\nlet expected_2 = \"db100000db\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = decimal_to_binary(103);\nlet expected_3 = \"db1100111db\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = decimal_to_binary(15);\nlet expected_4 = \"db1111db\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Θα σας δοθεί ένας αριθμός σε δεκαδική μορφή και η εργασία σας είναι να τον μετατρέψετε σε δυαδική μορφή. Η συνάρτηση θα πρέπει να επιστρέφει μια συμβολοσειρά, με κάθε χαρακτήρα που αντιπροσωπεύει ένα δυαδικό αριθμό. Κάθε χαρακτήρας στη συμβολοσειρά θα είναι '0' ή '1'.\n\nΘα υπάρχουν μερικοί επιπλέον χαρακτήρες 'db' στην αρχή και στο τέλος της συμβολοσειράς. Οι επιπλέον χαρακτήρες είναι εκεί για να βοηθήσουν με τη μορφοποίηση.\n\nΠαραδείγματα:", "entry_point": "decimal_to_binary", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/33", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Σας δίνεται μια συμβολοσειρά s.\n *     Η εργασία σας είναι να ελέγξετε αν η συμβολοσειρά είναι ευτυχισμένη ή όχι.\n *     Μια συμβολοσειρά είναι ευτυχισμένη αν η μήκος της είναι τουλάχιστον 3 και κάθε 3 συνεχόμενα γράμματα είναι διαφορετικά.\n *     Για παράδειγμα:\n * \n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n * \n */\nconst is_happy = function (s: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_happy(\"a\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_happy(\"aa\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_happy(\"abcd\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_happy(\"aabb\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_happy(\"adb\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_happy(\"xyy\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_happy(\"iopaxpoi\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_happy(\"iopaxioi\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνεται μια συμβολοσειρά s.\n    Η εργασία σας είναι να ελέγξετε αν η συμβολοσειρά είναι ευτυχισμένη ή όχι.\n    Μια συμβολοσειρά είναι ευτυχισμένη αν η μήκος της είναι τουλάχιστον 3 και κάθε 3 συνεχόμενα γράμματα είναι διαφορετικά.\n    Για παράδειγμα:", "entry_point": "is_happy", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/34", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Είναι η τελευταία εβδομάδα του εξαμήνου και ο καθηγητής πρέπει να δώσει τους βαθμούς στους μαθητές. Ο καθηγητής έχει δημιουργήσει το δικό του αλγόριθμο για τη βαθμολογία. Το μόνο πρόβλημα είναι ότι έχασε τον κώδικα που χρησιμοποιούσε για τη βαθμολογία. Σας έχει δώσει μια λίστα με τα GPA για μερικούς μαθητές και πρέπει να γράψετε μια συνάρτηση που μπορεί να εξάγει μια λίστα με τις βαθμολογίες γραμμάτων χρησιμοποιώντας τον παρακάτω πίνακα:\n *              GPA       |    Βαθμός γράμματος\n *               4.0                Α+\n *             > 3.7                Α \n *             > 3.3                Α- \n *             > 3.0                Β+\n *             > 2.7                Β \n *             > 2.3                Β-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                Ε\n *     \n * \n *     Παράδειγμα:\n * \n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n * \n */\nconst numerical_letter_grade = function (grades: Array<number>) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]);\nlet expected_1 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = numerical_letter_grade([1.2]);\nlet expected_2 = [\"D+\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = numerical_letter_grade([0.5]);\nlet expected_3 = [\"D-\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = numerical_letter_grade([0.0]);\nlet expected_4 = [\"E\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = numerical_letter_grade([1, 0.3, 1.5, 2.8, 3.3]);\nlet expected_5 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = numerical_letter_grade([0, 0.7]);\nlet expected_6 = [\"E\", \"D-\"];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Είναι η τελευταία εβδομάδα του εξαμήνου και ο καθηγητής πρέπει να δώσει τους βαθμούς στους μαθητές. Ο καθηγητής έχει δημιουργήσει το δικό του αλγόριθμο για τη βαθμολογία. Το μόνο πρόβλημα είναι ότι έχασε τον κώδικα που χρησιμοποιούσε για τη βαθμολογία. Σας έχει δώσει μια λίστα με τα GPA για μερικούς μαθητές και πρέπει να γράψετε μια συνάρτηση που μπορεί να εξάγει μια λίστα με τις βαθμολογίες γραμμάτων χρησιμοποιώντας τον παρακάτω πίνακα:\n             GPA       |    Βαθμός γράμματος\n              4.0                Α+\n            > 3.7                Α \n            > 3.3                Α- \n            > 3.0                Β+\n            > 2.7                Β \n            > 2.3                Β-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                Ε\n    \n\n    Παράδειγμα:", "entry_point": "numerical_letter_grade", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/35", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Γράψτε μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει True αν το μήκος του αλφαριθμητικού είναι πρώτος αριθμός ή False αλλιώς. Παραδείγματα.\n * \n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n * \n */\nconst prime_length = function (string0: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = prime_length(\"Hello\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = prime_length(\"abcdcba\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = prime_length(\"kittens\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = prime_length(\"orange\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = prime_length(\"wow\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = prime_length(\"world\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = prime_length(\"MadaM\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = prime_length(\"Wow\");\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = prime_length(\"\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = prime_length(\"HI\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = prime_length(\"go\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = prime_length(\"gogo\");\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = prime_length(\"aaaaaaaaaaaaaaa\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = prime_length(\"Madam\");\nlet expected_14 = true;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = prime_length(\"M\");\nlet expected_15 = false;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = prime_length(\"0\");\nlet expected_16 = false;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\n", "language": "typescript", "description": "Γράψτε μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει True αν το μήκος του αλφαριθμητικού είναι πρώτος αριθμός ή False αλλιώς. Παραδείγματα.", "entry_point": "prime_length", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/36", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Δεδομένου ενός θετικού ακεραίου N, επιστρέφεται το συνολικό άθροισμα των ψηφίων του σε δυαδική μορφή.\n * \n *     Παράδειγμα\n *         Για N = 1000, το άθροισμα των ψηφίων θα είναι 1 και η έξοδος θα πρέπει να είναι \"1\".\n *         Για N = 150, το άθροισμα των ψηφίων θα είναι 6 και η έξοδος θα πρέπει να είναι \"110\".\n *         Για N = 147, το άθροισμα των ψηφίων θα είναι 12 και η έξοδος θα πρέπει να είναι \"1100\".\n *     \n *     Μεταβλητές:\n *         @N ακέραιος\n *              Περιορισμοί: 0 ≤ N ≤ 10000.\n *     Έξοδος:\n *          μια συμβολοσειρά δυαδικού αριθμού\n * \n * \n */\nconst solve = function (N: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = solve(1000);\nlet expected_1 = \"1\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = solve(150);\nlet expected_2 = \"110\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = solve(147);\nlet expected_3 = \"1100\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = solve(333);\nlet expected_4 = \"1001\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = solve(963);\nlet expected_5 = \"10010\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένου ενός θετικού ακεραίου N, επιστρέφεται το συνολικό άθροισμα των ψηφίων του σε δυαδική μορφή.\n\n    Παράδειγμα\n        Για N = 1000, το άθροισμα των ψηφίων θα είναι 1 και η έξοδος θα πρέπει να είναι \"1\".\n        Για N = 150, το άθροισμα των ψηφίων θα είναι 6 και η έξοδος θα πρέπει να είναι \"110\".\n        Για N = 147, το άθροισμα των ψηφίων θα είναι 12 και η έξοδος θα πρέπει να είναι \"1100\".\n    \n    Μεταβλητές:\n        @N ακέραιος\n             Περιορισμοί: 0 ≤ N ≤ 10000.\n    Έξοδος:\n         μια συμβολοσειρά δυαδικού αριθμού", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/37", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Σας δίνεται μια δισδιάστατη δομή δεδομένων, ως εμφωλευμένες λίστες, που είναι παρόμοια με μια πίνακα, αλλά, αντίθετα από τους πίνακες, κάθε γραμμή μπορεί να περιέχει διαφορετικό αριθμό στηλών. Δεδομένης της λίστας lst και του ακεραίου x, βρείτε τους ακεραίους x στη λίστα και επιστρέψτε μια λίστα από tuples, [(x1, y1), (x2, y2) ...] ώστε κάθε tuple να είναι μια συντεταγμένη - (γραμμή, στήλες), ξεκινώντας από το 0. Ταξινομήστε αρχικά τις συντεταγμένες ανά γραμμή με αύξουσα σειρά. Επίσης, ταξινομήστε τις συντεταγμένες της γραμμής με φθίνουσα σειρά.\n * \n * Παραδείγματα:\n * \n * get_row([\n * [1,2,3,4,5,6],\n * [1,2,3,4,1,6],\n * [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n * \n */\nconst get_row = function (lst: Array<Array<number>>, x: number) : Array<Array<number>>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],1);\nlet expected_1 = [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],2);\nlet expected_2 = [[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],1);\nlet expected_3 = [[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_row([],1);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = get_row([[1]],2);\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = get_row([[], [1], [1, 2, 3]],3);\nlet expected_6 = [[2, 2]];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνεται μια δισδιάστατη δομή δεδομένων, ως εμφωλευμένες λίστες, που είναι παρόμοια με μια πίνακα, αλλά, αντίθετα από τους πίνακες, κάθε γραμμή μπορεί να περιέχει διαφορετικό αριθμό στηλών. Δεδομένης της λίστας lst και του ακεραίου x, βρείτε τους ακεραίους x στη λίστα και επιστρέψτε μια λίστα από tuples, [(x1, y1), (x2, y2) ...] ώστε κάθε tuple να είναι μια συντεταγμένη - (γραμμή, στήλες), ξεκινώντας από το 0. Ταξινομήστε αρχικά τις συντεταγμένες ανά γραμμή με αύξουσα σειρά. Επίσης, ταξινομήστε τις συντεταγμένες της γραμμής με φθίνουσα σειρά.\n\nΠαραδείγματα:", "entry_point": "get_row", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/38", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Σας δίνεται μια λίστα ακεραίων.\n * Γράψτε μια συνάρτηση next_smallest() που επιστρέφει τον δεύτερο μικρότερο στοιχείο της λίστας.\n * Επιστρέψτε null αν δεν υπάρχει τέτοιο στοιχείο.\n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n * \n */\nconst next_smallest = function (lst: Array<number>) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = next_smallest([1, 2, 3, 4, 5]);\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = next_smallest([5, 1, 4, 3, 2]);\nlet expected_2 = 2;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = next_smallest([]);\nlet expected_3 = undefined;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = next_smallest([1, 1]);\nlet expected_4 = undefined;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = next_smallest([1, 1, 1, 1, 0]);\nlet expected_5 = 1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = next_smallest([1, 1]);\nlet expected_6 = undefined;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = next_smallest([-35, 34, 12, -45]);\nlet expected_7 = -35;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνεται μια λίστα ακεραίων.\nΓράψτε μια συνάρτηση next_smallest() που επιστρέφει τον δεύτερο μικρότερο στοιχείο της λίστας.\nΕπιστρέψτε null αν δεν υπάρχει τέτοιο στοιχείο.", "entry_point": "next_smallest", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/39", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Θα σας δοθεί μια συμβολοσειρά λέξεων και η εργασία σας είναι να μετρήσετε τον αριθμό των βαρεμάρων. Μια βαρεμάρα είναι μια πρόταση που ξεκινά με τη λέξη \"Εγώ\". Οι προτάσεις διαχωρίζονται μεταξύ τους με '.' , '?' ή '!'.\n * \n * Για παράδειγμα:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n * \n */\nconst is_bored = function (S: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_bored(\"Hello world\");\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_bored(\"Is the sky blue?\");\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_bored(\"I love It !\");\nlet expected_3 = 1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_bored(\"bIt\");\nlet expected_4 = 0;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_bored(\"I feel good today. I will be productive. will kill It\");\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_bored(\"You and I are going for a walk\");\nlet expected_6 = 0;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Θα σας δοθεί μια συμβολοσειρά λέξεων και η εργασία σας είναι να μετρήσετε τον αριθμό των βαρεμάρων. Μια βαρεμάρα είναι μια πρόταση που ξεκινά με τη λέξη \"Εγώ\". Οι προτάσεις διαχωρίζονται μεταξύ τους με '.' , '?' ή '!'.\n\nΓια παράδειγμα:", "entry_point": "is_bored", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/40", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Σας δίνεται μια λίστα ακεραίων.\n *     Πρέπει να βρείτε τη μεγαλύτερη πρώτη τιμή και να επιστρέψετε το άθροισμα των ψηφίων της.\n * \n *     Παραδείγματα:\n * \n * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n * For lst = [0,81,12,3,1,21] the output should be 3\n * For lst = [0,8,1,2,1,7] the output should be 7\n * \n */\nconst skjkasdkd = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]);\nlet expected_1 = 10;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]);\nlet expected_2 = 25;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\nlet expected_3 = 13;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]);\nlet expected_4 = 11;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = skjkasdkd([0, 81, 12, 3, 1, 21]);\nlet expected_5 = 3;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = skjkasdkd([0, 8, 1, 2, 1, 7]);\nlet expected_6 = 7;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = skjkasdkd([8191]);\nlet expected_7 = 19;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = skjkasdkd([8191, 123456, 127, 7]);\nlet expected_8 = 19;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = skjkasdkd([127, 97, 8192]);\nlet expected_9 = 10;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνεται μια λίστα ακεραίων.\n    Πρέπει να βρείτε τη μεγαλύτερη πρώτη τιμή και να επιστρέψετε το άθροισμα των ψηφίων της.\n\n    Παραδείγματα:", "entry_point": "skjkasdkd", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/41", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δεδομένου ενός λεξικού, επιστρέψτε True αν όλα τα κλειδιά είναι συμβολοσειρές σε πεζά γράμματα ή όλα τα κλειδιά είναι συμβολοσειρές σε κεφαλαία γράμματα, αλλιώς επιστρέψτε False. Η συνάρτηση πρέπει να επιστρέφει False αν το δοσμένο λεξικό είναι κενό. Παραδείγματα:\n * \n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n * \n */\nconst check_dict_case = function (dict: Map<any, string>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [\"b\", \"banana\"]]));\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [\"A\", \"banana\"], [\"B\", \"banana\"]]));\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [5, \"banana\"], [\"a\", \"apple\"]]));\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = check_dict_case(new Map<any, any>([[\"Name\", \"John\"], [\"Age\", \"36\"], [\"City\", \"Houston\"]]));\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = check_dict_case(new Map<any, any>([[\"STATE\", \"NC\"], [\"ZIP\", \"12345\"]]));\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = check_dict_case(new Map<any, any>([[\"fruit\", \"Orange\"], [\"taste\", \"Sweet\"]]));\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = check_dict_case(new Map<any, any>([]));\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένου ενός λεξικού, επιστρέψτε True αν όλα τα κλειδιά είναι συμβολοσειρές σε πεζά γράμματα ή όλα τα κλειδιά είναι συμβολοσειρές σε κεφαλαία γράμματα, αλλιώς επιστρέψτε False. Η συνάρτηση πρέπει να επιστρέφει False αν το δοσμένο λεξικό είναι κενό. Παραδείγματα:", "entry_point": "check_dict_case", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/42", "prompt": "import * as math from 'mathjs'\n\n/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δημιουργήστε μια συνάρτηση που παίρνει μια τιμή (συμβολοσειρά) που αναπαριστά έναν αριθμό και επιστρέφει τον πλησιέστερο ακέραιο αριθμό σε αυτόν. Εάν ο αριθμός είναι ισοαπόστακτος από δύο ακεραίους, στρογγυλοποιήστε τον μακριά από το μηδέν.\n * \n * Παραδείγματα\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n * \n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n * \n */\nconst closest_integer = function (value: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = closest_integer(\"10\");\nlet expected_1 = 10;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = closest_integer(\"14.5\");\nlet expected_2 = 15;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = closest_integer(\"-15.5\");\nlet expected_3 = -16;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = closest_integer(\"15.3\");\nlet expected_4 = 15;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = closest_integer(\"0\");\nlet expected_5 = 0;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Δημιουργήστε μια συνάρτηση που παίρνει μια τιμή (συμβολοσειρά) που αναπαριστά έναν αριθμό και επιστρέφει τον πλησιέστερο ακέραιο αριθμό σε αυτόν. Εάν ο αριθμός είναι ισοαπόστακτος από δύο ακεραίους, στρογγυλοποιήστε τον μακριά από το μηδέν.\n\nΠαραδείγματα", "entry_point": "closest_integer", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/43", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δεδομένου ενός θετικού ακεραίου n, πρέπει να φτιάξετε ένα σωρό από n επίπεδα πέτρες.\n *     Το πρώτο επίπεδο έχει n πέτρες.\n *     Ο αριθμός των πετρών στο επόμενο επίπεδο είναι:\n *         - ο επόμενος μονός αριθμός αν το n είναι περιττός.\n *         - ο επόμενος άρτιος αριθμός αν το n είναι άρτιος.\n *     Επιστρέψτε τον αριθμό των πετρών σε κάθε επίπεδο σε μια λίστα, όπου το στοιχείο στη θέση\n *     i αντιπροσωπεύει τον αριθμό των πετρών στο επίπεδο (i + 1).\n * \n *     Παραδείγματα:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n * \n */\nconst make_a_pile = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = make_a_pile(3);\nlet expected_1 = [3, 5, 7];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = make_a_pile(4);\nlet expected_2 = [4, 6, 8, 10];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = make_a_pile(5);\nlet expected_3 = [5, 7, 9, 11, 13];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = make_a_pile(6);\nlet expected_4 = [6, 8, 10, 12, 14, 16];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = make_a_pile(8);\nlet expected_5 = [8, 10, 12, 14, 16, 18, 20, 22];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένου ενός θετικού ακεραίου n, πρέπει να φτιάξετε ένα σωρό από n επίπεδα πέτρες.\n    Το πρώτο επίπεδο έχει n πέτρες.\n    Ο αριθμός των πετρών στο επόμενο επίπεδο είναι:\n        - ο επόμενος μονός αριθμός αν το n είναι περιττός.\n        - ο επόμενος άρτιος αριθμός αν το n είναι άρτιος.\n    Επιστρέψτε τον αριθμό των πετρών σε κάθε επίπεδο σε μια λίστα, όπου το στοιχείο στη θέση\n    i αντιπροσωπεύει τον αριθμό των πετρών στο επίπεδο (i + 1).\n\n    Παραδείγματα:", "entry_point": "make_a_pile", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/44", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Θα σας δοθεί μια συμβολοσειρά λέξεων που χωρίζονται με κόμματα ή κενά. Η εργασία σας είναι να χωρίσετε τη συμβολοσειρά σε λέξεις και να επιστρέψετε έναν πίνακα με τις λέξεις.\n * \n * Για παράδειγμα:\n * \n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n * \n */\nconst words_string = function (s: string) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = words_string(\"Hi, my name is John\");\nlet expected_1 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = words_string(\"One, two, three, four, five, six\");\nlet expected_2 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = words_string(\"Hi, my name\");\nlet expected_3 = [\"Hi\", \"my\", \"name\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = words_string(\"One,, two, three, four, five, six,\");\nlet expected_4 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = words_string(\"\");\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = words_string(\"ahmed     , gamal\");\nlet expected_6 = [\"ahmed\", \"gamal\"];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Θα σας δοθεί μια συμβολοσειρά λέξεων που χωρίζονται με κόμματα ή κενά. Η εργασία σας είναι να χωρίσετε τη συμβολοσειρά σε λέξεις και να επιστρέψετε έναν πίνακα με τις λέξεις.\n\nΓια παράδειγμα:", "entry_point": "words_string", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/45", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Αυτή η συνάρτηση παίρνει δύο θετικούς αριθμούς x και y και επιστρέφει το μεγαλύτερο άρτιο ακέραιο αριθμό που βρίσκεται στο διάστημα [x, y] συμπεριλαμβανομένου. Εάν δεν υπάρχει τέτοιος αριθμός, η συνάρτηση θα πρέπει να επιστρέψει -1.\n * \n * Για παράδειγμα:\n * \n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n * \n */\nconst choose_num = function (x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = choose_num(12,15);\nlet expected_1 = 14;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = choose_num(13,12);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = choose_num(33,12354);\nlet expected_3 = 12354;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = choose_num(5234,5233);\nlet expected_4 = -1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = choose_num(6,29);\nlet expected_5 = 28;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = choose_num(27,10);\nlet expected_6 = -1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = choose_num(7,7);\nlet expected_7 = -1;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = choose_num(546,546);\nlet expected_8 = 546;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "Αυτή η συνάρτηση παίρνει δύο θετικούς αριθμούς x και y και επιστρέφει το μεγαλύτερο άρτιο ακέραιο αριθμό που βρίσκεται στο διάστημα [x, y] συμπεριλαμβανομένου. Εάν δεν υπάρχει τέτοιος αριθμός, η συνάρτηση θα πρέπει να επιστρέψει -1.\n\nΓια παράδειγμα:", "entry_point": "choose_num", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/46", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Σας δίνονται δύο θετικοί ακέραιοι αριθμοί n και m, και η εργασία σας είναι να υπολογίσετε τον μέσο όρο των ακεραίων από το n έως το m (συμπεριλαμβανομένων του n και του m). Στρογγυλοποιήστε την απάντηση στον πλησιέστερο ακέραιο και μετατρέψτε τον σε δυαδικό. Εάν το n είναι μεγαλύτερο από το m, επιστρέψτε -1. Παράδειγμα:\n * \n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n * \n */\nconst rounded_avg = function (n: number, m: number) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = rounded_avg(1,5);\nlet expected_1 = \"0b11\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = rounded_avg(7,13);\nlet expected_2 = \"0b1010\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = rounded_avg(964,977);\nlet expected_3 = \"0b1111001010\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = rounded_avg(996,997);\nlet expected_4 = \"0b1111100100\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = rounded_avg(560,851);\nlet expected_5 = \"0b1011000010\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = rounded_avg(185,546);\nlet expected_6 = \"0b101101110\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = rounded_avg(362,496);\nlet expected_7 = \"0b110101101\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = rounded_avg(350,902);\nlet expected_8 = \"0b1001110010\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = rounded_avg(197,233);\nlet expected_9 = \"0b11010111\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = rounded_avg(7,5);\nlet expected_10 = -1;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = rounded_avg(5,1);\nlet expected_11 = -1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = rounded_avg(5,5);\nlet expected_12 = \"0b101\";\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνονται δύο θετικοί ακέραιοι αριθμοί n και m, και η εργασία σας είναι να υπολογίσετε τον μέσο όρο των ακεραίων από το n έως το m (συμπεριλαμβανομένων του n και του m). Στρογγυλοποιήστε την απάντηση στον πλησιέστερο ακέραιο και μετατρέψτε τον σε δυαδικό. Εάν το n είναι μεγαλύτερο από το m, επιστρέψτε -1. Παράδειγμα:", "entry_point": "rounded_avg", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/47", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Υλοποιήστε τη συνάρτηση f που παίρνει το n ως παράμετρο και επιστρέφει μια λίστα μεγέθους n, όπου η τιμή του στοιχείου στη θέση i είναι το παραγοντικό του i αν είναι άρτιος ή άθροισμα αριθμών από 1 έως i αλλιώς. Το i ξεκινά από 1. Το παραγοντικό του i είναι ο πολλαπλασιασμός των αριθμών από 1 έως i (1 * 2 * ... * i). Παράδειγμα:\n * \n * f(5) == [1, 2, 6, 24, 15]\n * \n */\nconst f = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = f(5);\nlet expected_1 = [1, 2, 6, 24, 15];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = f(7);\nlet expected_2 = [1, 2, 6, 24, 15, 720, 28];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = f(1);\nlet expected_3 = [1];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = f(3);\nlet expected_4 = [1, 2, 6];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Υλοποιήστε τη συνάρτηση f που παίρνει το n ως παράμετρο και επιστρέφει μια λίστα μεγέθους n, όπου η τιμή του στοιχείου στη θέση i είναι το παραγοντικό του i αν είναι άρτιος ή άθροισμα αριθμών από 1 έως i αλλιώς. Το i ξεκινά από 1. Το παραγοντικό του i είναι ο πολλαπλασιασμός των αριθμών από 1 έως i (1 * 2 * ... * i). Παράδειγμα:", "entry_point": "f", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/48", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δεδομένου ενός θετικού ακεραίου n, επιστρέφεται ένα tuple που περιέχει τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών που βρίσκονται στο εύρος (1, n), συμπεριλαμβανομένου του n.\n * \n *     Παράδειγμα 1:\n * \n *         Είσοδος: 3\n *         Έξοδος: (1, 2)\n *         Εξήγηση:\n *         Οι παλινδρομικοί αριθμοί είναι 1, 2, 3. Ένας από αυτούς είναι άρτιος και δύο είναι περιττοί.\n * \n *     Παράδειγμα 2:\n * \n *         Είσοδος: 12\n *         Έξοδος: (4, 6)\n *         Εξήγηση:\n *         Οι παλινδρομικοί αριθμοί είναι 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Τέσσερις από αυτούς είναι άρτιοι και έξι είναι περιττοί.\n * \n *     Σημείωση:\n *         1. 1 <= n <= 10^3\n *         2. Το επιστρεφόμενο tuple περιέχει αντίστοιχα τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών.\n * \n * \n */\nconst even_odd_palindrome = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = even_odd_palindrome(123);\nlet expected_1 = [8, 13];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = even_odd_palindrome(12);\nlet expected_2 = [4, 6];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = even_odd_palindrome(3);\nlet expected_3 = [1, 2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = even_odd_palindrome(63);\nlet expected_4 = [6, 8];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = even_odd_palindrome(25);\nlet expected_5 = [5, 6];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = even_odd_palindrome(19);\nlet expected_6 = [4, 6];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = even_odd_palindrome(9);\nlet expected_7 = [4, 5];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = even_odd_palindrome(1);\nlet expected_8 = [0, 1];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένου ενός θετικού ακεραίου n, επιστρέφεται ένα tuple που περιέχει τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών που βρίσκονται στο εύρος (1, n), συμπεριλαμβανομένου του n.\n\n    Παράδειγμα 1:\n\n        Είσοδος: 3\n        Έξοδος: (1, 2)\n        Εξήγηση:\n        Οι παλινδρομικοί αριθμοί είναι 1, 2, 3. Ένας από αυτούς είναι άρτιος και δύο είναι περιττοί.\n\n    Παράδειγμα 2:\n\n        Είσοδος: 12\n        Έξοδος: (4, 6)\n        Εξήγηση:\n        Οι παλινδρομικοί αριθμοί είναι 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Τέσσερις από αυτούς είναι άρτιοι και έξι είναι περιττοί.\n\n    Σημείωση:\n        1. 1 <= n <= 10^3\n        2. Το επιστρεφόμενο tuple περιέχει αντίστοιχα τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών.", "entry_point": "even_odd_palindrome", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/49", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Έχουμε έναν πίνακα 'arr' από N ακεραίους arr[1], arr[2], ..., arr[N]. Οι αριθμοί στον πίνακα θα είναι τυχαία ταξινομημένοι. Η εργασία σας είναι να καθορίσετε εάν είναι δυνατόν να λάβετε έναν ταξινομημένο πίνακα σε μη φθίνουσα σειρά εκτελώντας την ακόλουθη λειτουργία στον δοσμένο πίνακα:\n *         Σας επιτρέπεται να εκτελέσετε τη λειτουργία μετατόπισης δεξιά οποιοδήποτε αριθμό φορών.\n *     \n *     Μια λειτουργία μετατόπισης δεξιά σημαίνει τη μετατόπιση όλων των στοιχείων του πίνακα κατά ένα θέση προς τη δεξιά κατεύθυνση. Το τελευταίο στοιχείο του πίνακα θα μετακινηθεί στην αρχική θέση στον πίνακα, δηλαδή στη θέση 0. \n * \n *     Εάν είναι δυνατόν να λάβετε τον ταξινομημένο πίνακα εκτελώντας την παραπάνω λειτουργία, τότε επιστρέψτε True, αλλιώς επιστρέψτε False.\n *     Εάν ο δοσμένος πίνακας είναι κενός, τότε επιστρέψτε True.\n * \n *     Σημείωση: Εγγυόμαστε ότι ο δοσμένος πίνακας θα έχει μοναδικά στοιχεία.\n * \n *     Για παράδειγμα:\n *     \n *     move_one_ball([3, 4, 5, 1, 2])==>True\n *     Εξήγηση: Εκτελώντας 2 λειτουργίες μετατόπισης δεξιά, μπορεί να επιτευχθεί μη φθίνουσα σειρά για τον δοσμένο πίνακα.\n *     move_one_ball([3, 5, 4, 1, 2])==>False\n *     Εξήγηση: Δεν είναι δυνατόν να λάβετε μη φθίνουσα σειρά για τον δοσμένο πίνακα εκτελώντας οποιονδήποτε αριθμό λειτουργιών μετατόπισης δεξιά.\n * \n * \n * \n */\nconst move_one_ball = function (arr: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = move_one_ball([3, 4, 5, 1, 2]);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = move_one_ball([3, 5, 10, 1, 2]);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = move_one_ball([4, 3, 1, 2]);\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = move_one_ball([3, 5, 4, 1, 2]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = move_one_ball([]);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Έχουμε έναν πίνακα 'arr' από N ακεραίους arr[1], arr[2], ..., arr[N]. Οι αριθμοί στον πίνακα θα είναι τυχαία ταξινομημένοι. Η εργασία σας είναι να καθορίσετε εάν είναι δυνατόν να λάβετε έναν ταξινομημένο πίνακα σε μη φθίνουσα σειρά εκτελώντας την ακόλουθη λειτουργία στον δοσμένο πίνακα:\n        Σας επιτρέπεται να εκτελέσετε τη λειτουργία μετατόπισης δεξιά οποιοδήποτε αριθμό φορών.\n    \n    Μια λειτουργία μετατόπισης δεξιά σημαίνει τη μετατόπιση όλων των στοιχείων του πίνακα κατά ένα θέση προς τη δεξιά κατεύθυνση. Το τελευταίο στοιχείο του πίνακα θα μετακινηθεί στην αρχική θέση στον πίνακα, δηλαδή στη θέση 0. \n\n    Εάν είναι δυνατόν να λάβετε τον ταξινομημένο πίνακα εκτελώντας την παραπάνω λειτουργία, τότε επιστρέψτε True, αλλιώς επιστρέψτε False.\n    Εάν ο δοσμένος πίνακας είναι κενός, τότε επιστρέψτε True.\n\n    Σημείωση: Εγγυόμαστε ότι ο δοσμένος πίνακας θα έχει μοναδικά στοιχεία.\n\n    Για παράδειγμα:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Εξήγηση: Εκτελώντας 2 λειτουργίες μετατόπισης δεξιά, μπορεί να επιτευχθεί μη φθίνουσα σειρά για τον δοσμένο πίνακα.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Εξήγηση: Δεν είναι δυνατόν να λάβετε μη φθίνουσα σειρά για τον δοσμένο πίνακα εκτελώντας οποιονδήποτε αριθμό λειτουργιών μετατόπισης δεξιά.", "entry_point": "move_one_ball", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/50", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Σε αυτό το πρόβλημα, θα υλοποιήσετε μια συνάρτηση που παίρνει δύο λίστες αριθμών και καθορίζει εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ τους για να κάνει την lst1 μια λίστα μόνο με άρτιους αριθμούς. Δεν υπάρχει όριο στον αριθμό των ανταλλαγών στοιχείων μεταξύ lst1 και lst2. Εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ των lst1 και lst2 για να κάνει όλα τα στοιχεία της lst1 να είναι άρτια, επιστρέψτε \"YES\". Διαφορετικά, επιστρέψτε \"NO\". Για παράδειγμα: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\", exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Υποθέτειται ότι οι λίστες εισόδου θα είναι μη κενές.\n * \n * \n */\nconst exchange = function (lst1: Array<number>, lst2: Array<number>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = exchange([1, 2, 3, 4],[1, 2, 3, 4]);\nlet expected_1 = \"YES\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = exchange([1, 2, 3, 4],[1, 5, 3, 4]);\nlet expected_2 = \"NO\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = exchange([1, 2, 3, 4],[2, 1, 4, 3]);\nlet expected_3 = \"YES\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = exchange([5, 7, 3],[2, 6, 4]);\nlet expected_4 = \"YES\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = exchange([5, 7, 3],[2, 6, 3]);\nlet expected_5 = \"NO\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = exchange([3, 2, 6, 1, 8, 9],[3, 5, 5, 1, 1, 1]);\nlet expected_6 = \"NO\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = exchange([100, 200],[200, 200]);\nlet expected_7 = \"YES\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Σε αυτό το πρόβλημα, θα υλοποιήσετε μια συνάρτηση που παίρνει δύο λίστες αριθμών και καθορίζει εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ τους για να κάνει την lst1 μια λίστα μόνο με άρτιους αριθμούς. Δεν υπάρχει όριο στον αριθμό των ανταλλαγών στοιχείων μεταξύ lst1 και lst2. Εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ των lst1 και lst2 για να κάνει όλα τα στοιχεία της lst1 να είναι άρτια, επιστρέψτε \"YES\". Διαφορετικά, επιστρέψτε \"NO\". Για παράδειγμα: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\", exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Υποθέτειται ότι οι λίστες εισόδου θα είναι μη κενές.", "entry_point": "exchange", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/51", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Εργασία\n *     Δίνονται δύο αλφαριθμητικά s και c, πρέπει να διαγράψετε όλους τους χαρακτήρες στο s που είναι ίσοι με οποιονδήποτε χαρακτήρα στο c\n *     και στη συνέχεια να ελέγξετε αν το αποτέλεσμα είναι παλίνδρομο.\n *     Ένα αλφαριθμητικό ονομάζεται παλίνδρομο αν διαβάζεται το ίδιο προς τα πίσω και προς τα εμπρός.\n *     Θα πρέπει να επιστρέψετε ένα tuple που περιέχει το αποτέλεσμα αλφαριθμητικό και True/False για τον έλεγχο.\n *     Παράδειγμα\n *     Για s = \"abcde\", c = \"ae\", το αποτέλεσμα θα πρέπει να είναι ('bcd',False)\n *     Για s = \"abcdef\", c = \"b\" το αποτέλεσμα θα πρέπει να είναι ('acdef',False)\n *     Για s = \"abcdedcba\", c = \"ab\", το αποτέλεσμα θα πρέπει να είναι ('cdedc',True)\n * \n * \n */\nconst reverse_delete = function (s: string, c: string) : Array<any>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = reverse_delete(\"abcde\",\"ae\");\nlet expected_1 = [\"bcd\", false];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = reverse_delete(\"abcdef\",\"b\");\nlet expected_2 = [\"acdef\", false];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = reverse_delete(\"abcdedcba\",\"ab\");\nlet expected_3 = [\"cdedc\", true];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = reverse_delete(\"dwik\",\"w\");\nlet expected_4 = [\"dik\", false];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = reverse_delete(\"a\",\"a\");\nlet expected_5 = [\"\", true];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = reverse_delete(\"abcdedcba\",\"\");\nlet expected_6 = [\"abcdedcba\", true];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = reverse_delete(\"abcdedcba\",\"v\");\nlet expected_7 = [\"abcdedcba\", true];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = reverse_delete(\"vabba\",\"v\");\nlet expected_8 = [\"abba\", true];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = reverse_delete(\"mamma\",\"mia\");\nlet expected_9 = [\"\", true];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Εργασία\n    Δίνονται δύο αλφαριθμητικά s και c, πρέπει να διαγράψετε όλους τους χαρακτήρες στο s που είναι ίσοι με οποιονδήποτε χαρακτήρα στο c\n    και στη συνέχεια να ελέγξετε αν το αποτέλεσμα είναι παλίνδρομο.\n    Ένα αλφαριθμητικό ονομάζεται παλίνδρομο αν διαβάζεται το ίδιο προς τα πίσω και προς τα εμπρός.\n    Θα πρέπει να επιστρέψετε ένα tuple που περιέχει το αποτέλεσμα αλφαριθμητικό και True/False για τον έλεγχο.\n    Παράδειγμα\n    Για s = \"abcde\", c = \"ae\", το αποτέλεσμα θα πρέπει να είναι ('bcd',False)\n    Για s = \"abcdef\", c = \"b\" το αποτέλεσμα θα πρέπει να είναι ('acdef',False)\n    Για s = \"abcdedcba\", c = \"ab\", το αποτέλεσμα θα πρέπει να είναι ('cdedc',True)", "entry_point": "reverse_delete", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/52", "prompt": "import * as math from 'mathjs'\n\n/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Σας δίνεται ένα ορθογώνιο πλέγμα από πηγάδια. Κάθε σειρά αντιπροσωπεύει ένα μόνο πηγάδι, και κάθε 1 σε μια σειρά αντιπροσωπεύει μια μονάδα νερού. Κάθε πηγάδι έχει ένα αντίστοιχο κουβά που μπορεί να χρησιμοποιηθεί για να αντλήσει νερό από αυτό, και όλοι οι κουβάδες έχουν την ίδια χωρητικότητα. Η εργασία σας είναι να χρησιμοποιήσετε τους κουβάδες για να αδειάσετε τα πηγάδια. Εξαγάγετε τον αριθμό των φορών που χρειάζεται να χαμηλώσετε τους κουβάδες.\n * \n *     Παράδειγμα 1:\n *         Είσοδος:\n *             grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n *             χωρητικότητα κουβά: 1\n *         Έξοδος: 6\n * \n *     Παράδειγμα 2:\n *         Είσοδος:\n *             grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n *             χωρητικότητα κουβά: 2\n *         Έξοδος: 5\n *     \n *     Παράδειγμα 3:\n *         Είσοδος:\n *             grid: [[0,0,0], [0,0,0]]\n *             χωρητικότητα κουβά: 5\n *         Έξοδος: 0\n * \n *     Περιορισμοί:\n *         * όλα τα πηγάδια έχουν το ίδιο μήκος\n *         * 1 <= μήκος πλέγματος <= 10^2\n *         * 1 <= μήκος grid[:,1] <= 10^2\n *         * grid[i][j] -> 0 | 1\n *         * 1 <= χωρητικότητα <= 10\n * \n * \n */\nconst max_fill = function (grid: Array<Array<number>>, capacity: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],1);\nlet expected_1 = 6;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],2);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = max_fill([[0, 0, 0], [0, 0, 0]],5);\nlet expected_3 = 0;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = max_fill([[1, 1, 1, 1], [1, 1, 1, 1]],2);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = max_fill([[1, 1, 1, 1], [1, 1, 1, 1]],9);\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνεται ένα ορθογώνιο πλέγμα από πηγάδια. Κάθε σειρά αντιπροσωπεύει ένα μόνο πηγάδι, και κάθε 1 σε μια σειρά αντιπροσωπεύει μια μονάδα νερού. Κάθε πηγάδι έχει ένα αντίστοιχο κουβά που μπορεί να χρησιμοποιηθεί για να αντλήσει νερό από αυτό, και όλοι οι κουβάδες έχουν την ίδια χωρητικότητα. Η εργασία σας είναι να χρησιμοποιήσετε τους κουβάδες για να αδειάσετε τα πηγάδια. Εξαγάγετε τον αριθμό των φορών που χρειάζεται να χαμηλώσετε τους κουβάδες.\n\n    Παράδειγμα 1:\n        Είσοδος:\n            grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            χωρητικότητα κουβά: 1\n        Έξοδος: 6\n\n    Παράδειγμα 2:\n        Είσοδος:\n            grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            χωρητικότητα κουβά: 2\n        Έξοδος: 5\n    \n    Παράδειγμα 3:\n        Είσοδος:\n            grid: [[0,0,0], [0,0,0]]\n            χωρητικότητα κουβά: 5\n        Έξοδος: 0\n\n    Περιορισμοί:\n        * όλα τα πηγάδια έχουν το ίδιο μήκος\n        * 1 <= μήκος πλέγματος <= 10^2\n        * 1 <= μήκος grid[:,1] <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= χωρητικότητα <= 10", "entry_point": "max_fill", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/53", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Δεδομένου ενός αλφαριθμητικού s και ενός φυσικού αριθμού n, σας έχει ανατεθεί να υλοποιήσετε μια συνάρτηση που επιστρέφει μια λίστα με όλες τις λέξεις από το αλφαριθμητικό s που περιέχουν ακριβώς n σύμφωνα, με τη σειρά που εμφανίζονται στο αλφαριθμητικό s. Εάν το αλφαριθμητικό s είναι κενό, τότε η συνάρτηση θα πρέπει να επιστρέψει μια κενή λίστα. Σημείωση: μπορείτε να υποθέσετε ότι το εισαγόμενο αλφαριθμητικό περιέχει μόνο γράμματα και κενά. Παραδείγματα:\n * \n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n * \n */\nconst select_words = function (s: string, n: number) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = select_words(\"Mary had a little lamb\",4);\nlet expected_1 = [\"little\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = select_words(\"Mary had a little lamb\",3);\nlet expected_2 = [\"Mary\", \"lamb\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = select_words(\"simple white space\",2);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = select_words(\"Hello world\",4);\nlet expected_4 = [\"world\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = select_words(\"Uncle sam\",3);\nlet expected_5 = [\"Uncle\"];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = select_words(\"\",4);\nlet expected_6 = [];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = select_words(\"a b c d e f\",1);\nlet expected_7 = [\"b\", \"c\", \"d\", \"f\"];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένου ενός αλφαριθμητικού s και ενός φυσικού αριθμού n, σας έχει ανατεθεί να υλοποιήσετε μια συνάρτηση που επιστρέφει μια λίστα με όλες τις λέξεις από το αλφαριθμητικό s που περιέχουν ακριβώς n σύμφωνα, με τη σειρά που εμφανίζονται στο αλφαριθμητικό s. Εάν το αλφαριθμητικό s είναι κενό, τότε η συνάρτηση θα πρέπει να επιστρέψει μια κενή λίστα. Σημείωση: μπορείτε να υποθέσετε ότι το εισαγόμενο αλφαριθμητικό περιέχει μόνο γράμματα και κενά. Παραδείγματα:", "entry_point": "select_words", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/54", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δεδομένου ενός πίνακα arr ακεραίων και ενός θετικού ακεραίου k, επιστρέφει μια ταξινομημένη λίστα μήκους k με τους μεγαλύτερους k αριθμούς στον πίνακα arr.\n * \n *     Παράδειγμα 1:\n * \n *         Είσοδος: arr = [-3, -4, 5], k = 3\n *         Έξοδος: [-4, -3, 5]\n * \n *     Παράδειγμα 2:\n * \n *         Είσοδος: arr = [4, -4, 4], k = 2\n *         Έξοδος: [4, 4]\n * \n *     Παράδειγμα 3:\n * \n *         Είσοδος: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n *         Έξοδος: [2]\n * \n *     Σημείωση:\n *         1. Το μήκος του πίνακα θα είναι στο εύρος [1, 1000].\n *         2. Τα στοιχεία του πίνακα θα είναι στο εύρος [-1000, 1000].\n *         3. 0 <= k <= len(arr)\n * \n * \n */\nconst maximum = function (arr: Array<number>, k: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = maximum([-3, -4, 5],3);\nlet expected_1 = [-4, -3, 5];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = maximum([4, -4, 4],2);\nlet expected_2 = [4, 4];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = maximum([-3, 2, 1, 2, -1, -2, 1],1);\nlet expected_3 = [2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = maximum([123, -123, 20, 0, 1, 2, -3],3);\nlet expected_4 = [2, 20, 123];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = maximum([-123, 20, 0, 1, 2, -3],4);\nlet expected_5 = [0, 1, 2, 20];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = maximum([5, 15, 0, 3, -13, -8, 0],7);\nlet expected_6 = [-13, -8, 0, 0, 3, 5, 15];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = maximum([-1, 0, 2, 5, 3, -10],2);\nlet expected_7 = [3, 5];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = maximum([1, 0, 5, -7],1);\nlet expected_8 = [5];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = maximum([4, -4],2);\nlet expected_9 = [-4, 4];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = maximum([-10, 10],2);\nlet expected_10 = [-10, 10];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = maximum([1, 2, 3, -23, 243, -400, 0],0);\nlet expected_11 = [];\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένου ενός πίνακα arr ακεραίων και ενός θετικού ακεραίου k, επιστρέφει μια ταξινομημένη λίστα μήκους k με τους μεγαλύτερους k αριθμούς στον πίνακα arr.\n\n    Παράδειγμα 1:\n\n        Είσοδος: arr = [-3, -4, 5], k = 3\n        Έξοδος: [-4, -3, 5]\n\n    Παράδειγμα 2:\n\n        Είσοδος: arr = [4, -4, 4], k = 2\n        Έξοδος: [4, 4]\n\n    Παράδειγμα 3:\n\n        Είσοδος: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Έξοδος: [2]\n\n    Σημείωση:\n        1. Το μήκος του πίνακα θα είναι στο εύρος [1, 1000].\n        2. Τα στοιχεία του πίνακα θα είναι στο εύρος [-1000, 1000].\n        3. 0 <= k <= len(arr)", "entry_point": "maximum", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/55", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δεδομένου ενός μη κενού πίνακα ακεραίων arr και ενός ακεραίου k, επιστρέφεται\n *     το άθροισμα των στοιχείων με τουλάχιστον δύο ψηφία από τα πρώτα k στοιχεία του arr.\n * \n *     Παράδειγμα:\n * \n *         Είσοδος: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n *         Έξοδος: 24 # άθροισμα των 21 + 3\n * \n *     Περιορισμοί:\n *         1. 1 <= len(arr) <= 100\n *         2. 1 <= k <= len(arr)\n * \n * \n */\nconst add_elements = function (arr: Array<number>, k: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = add_elements([1, -2, -3, 41, 57, 76, 87, 88, 99],3);\nlet expected_1 = -4;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = add_elements([111, 121, 3, 4000, 5, 6],2);\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = add_elements([11, 21, 3, 90, 5, 6, 7, 8, 9],4);\nlet expected_3 = 125;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9],4);\nlet expected_4 = 24;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = add_elements([1],1);\nlet expected_5 = 1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένου ενός μη κενού πίνακα ακεραίων arr και ενός ακεραίου k, επιστρέφεται\n    το άθροισμα των στοιχείων με τουλάχιστον δύο ψηφία από τα πρώτα k στοιχεία του arr.\n\n    Παράδειγμα:\n\n        Είσοδος: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Έξοδος: 24 # άθροισμα των 21 + 3\n\n    Περιορισμοί:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)", "entry_point": "add_elements", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/56", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Σας δίνονται δύο διαστήματα,\n *     όπου κάθε διάστημα είναι ένα ζευγάρι ακεραίων. Για παράδειγμα, διάστημα = (αρχή, τέλος) = (1, 2).\n *     Τα δεδομένα διαστήματα είναι κλειστά, που σημαίνει ότι το διάστημα (αρχή, τέλος)\n *     περιλαμβάνει τόσο την αρχή όσο και το τέλος.\n *     Για κάθε δοσμένο διάστημα, υποθέτεται ότι η αρχή του είναι μικρότερη ή ίση με το τέλος του.\n *     Η εργασία σας είναι να καθορίσετε εάν το μήκος της τομής αυτών των δύο\n *     διαστημάτων είναι ένας πρώτος αριθμός.\n *     Για παράδειγμα, η τομή των διαστημάτων (1, 3), (2, 4) είναι (2, 3)\n *     το οποίο το μήκος του είναι 1, που δεν είναι πρώτος αριθμός.\n *     Εάν το μήκος της τομής είναι ένας πρώτος αριθμός, επιστρέψτε \"YES\",\n *     διαφορετικά, επιστρέψτε \"NO\".\n *     Εάν τα δύο διαστήματα δεν τέμνονται, επιστρέψτε \"NO\".\n * \n * \n *     [είσοδος/έξοδος] δείγματα:\n * \n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n * \n */\nconst intersection = function (interval1: Array<number>, interval2: Array<number>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = intersection([1, 2],[2, 3]);\nlet expected_1 = \"NO\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = intersection([-1, 1],[0, 4]);\nlet expected_2 = \"NO\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = intersection([-3, -1],[-5, 5]);\nlet expected_3 = \"YES\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = intersection([-2, 2],[-4, 0]);\nlet expected_4 = \"YES\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = intersection([-11, 2],[-1, -1]);\nlet expected_5 = \"NO\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = intersection([1, 2],[3, 5]);\nlet expected_6 = \"NO\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = intersection([1, 2],[1, 2]);\nlet expected_7 = \"NO\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = intersection([-2, -2],[-3, -2]);\nlet expected_8 = \"NO\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνονται δύο διαστήματα,\n    όπου κάθε διάστημα είναι ένα ζευγάρι ακεραίων. Για παράδειγμα, διάστημα = (αρχή, τέλος) = (1, 2).\n    Τα δεδομένα διαστήματα είναι κλειστά, που σημαίνει ότι το διάστημα (αρχή, τέλος)\n    περιλαμβάνει τόσο την αρχή όσο και το τέλος.\n    Για κάθε δοσμένο διάστημα, υποθέτεται ότι η αρχή του είναι μικρότερη ή ίση με το τέλος του.\n    Η εργασία σας είναι να καθορίσετε εάν το μήκος της τομής αυτών των δύο\n    διαστημάτων είναι ένας πρώτος αριθμός.\n    Για παράδειγμα, η τομή των διαστημάτων (1, 3), (2, 4) είναι (2, 3)\n    το οποίο το μήκος του είναι 1, που δεν είναι πρώτος αριθμός.\n    Εάν το μήκος της τομής είναι ένας πρώτος αριθμός, επιστρέψτε \"YES\",\n    διαφορετικά, επιστρέψτε \"NO\".\n    Εάν τα δύο διαστήματα δεν τέμνονται, επιστρέψτε \"NO\".\n\n\n    [είσοδος/έξοδος] δείγματα:", "entry_point": "intersection", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/57", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Όλοι γνωρίζουν την ακολουθία του Fibonacci, η οποία μελετήθηκε βαθιά από μαθηματικούς τα τελευταία δύο αιώνες. Ωστόσο, αυτό που οι άνθρωποι δεν γνωρίζουν είναι η ακολουθία του Tribonacci. Η ακολουθία του Tribonacci ορίζεται από την επανάληψη:\n *     tri(1) = 3\n *     tri(n) = 1 + n / 2, αν το n είναι ζυγός.\n *     tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), αν το n είναι περιττό.\n *     Για παράδειγμα:\n *     tri(2) = 1 + (2 / 2) = 2\n *     tri(4) = 3\n *     tri(3) = tri(2) + tri(1) + tri(4)\n *            = 2 + 3 + 3 = 8 \n *     Σας δίνεται ένας μη αρνητικός ακέραιος αριθμός n, πρέπει να επιστρέψετε μια λίστα με τους πρώτους n + 1 αριθμούς της ακολουθίας του Tribonacci.\n *     Παραδείγματα:\n *     tri(3) = [1, 3, 2, 8]\n * \n * \n */\nconst tri = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = tri(3);\nlet expected_1 = [1, 3, 2.0, 8.0];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = tri(4);\nlet expected_2 = [1, 3, 2.0, 8.0, 3.0];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = tri(5);\nlet expected_3 = [1, 3, 2.0, 8.0, 3.0, 15.0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = tri(6);\nlet expected_4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = tri(7);\nlet expected_5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = tri(8);\nlet expected_6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = tri(9);\nlet expected_7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = tri(20);\nlet expected_8 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = tri(0);\nlet expected_9 = [1];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = tri(1);\nlet expected_10 = [1, 3];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Όλοι γνωρίζουν την ακολουθία του Fibonacci, η οποία μελετήθηκε βαθιά από μαθηματικούς τα τελευταία δύο αιώνες. Ωστόσο, αυτό που οι άνθρωποι δεν γνωρίζουν είναι η ακολουθία του Tribonacci. Η ακολουθία του Tribonacci ορίζεται από την επανάληψη:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, αν το n είναι ζυγός.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), αν το n είναι περιττό.\n    Για παράδειγμα:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    Σας δίνεται ένας μη αρνητικός ακέραιος αριθμός n, πρέπει να επιστρέψετε μια λίστα με τους πρώτους n + 1 αριθμούς της ακολουθίας του Tribonacci.\n    Παραδείγματα:\n    tri(3) = [1, 3, 2, 8]", "entry_point": "tri", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/58", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Δεδομένου ενός θετικού ακεραίου n, επιστρέφει το γινόμενο των μονών ψηφίων.\n *     Επιστρέφει 0 αν όλα τα ψηφία είναι άρτια.\n *     Για παράδειγμα:\n * \n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n * \n */\nconst digits = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = digits(5);\nlet expected_1 = 5;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = digits(54);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = digits(120);\nlet expected_3 = 1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = digits(5014);\nlet expected_4 = 5;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = digits(98765);\nlet expected_5 = 315;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = digits(5576543);\nlet expected_6 = 2625;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = digits(2468);\nlet expected_7 = 0;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένου ενός θετικού ακεραίου n, επιστρέφει το γινόμενο των μονών ψηφίων.\n    Επιστρέφει 0 αν όλα τα ψηφία είναι άρτια.\n    Για παράδειγμα:", "entry_point": "digits", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/59", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δημιουργήστε μια συνάρτηση που παίρνει μια συμβολοσειρά ως είσοδο η οποία περιέχει μόνο αγκύλες.\n *     Η συνάρτηση θα πρέπει να επιστρέφει True μόνο αν υπάρχει μια έγκυρη υποακολουθία αγκυλών \n *     όπου τουλάχιστον μια αγκύλη στην υποακολουθία είναι ενσωματωμένη.\n * is_nested('[[]]') ➞ True\n * is_nested('[]]]]]]][[[[[]') ➞ False\n * is_nested('[][]') ➞ False\n * is_nested('[]') ➞ False\n * is_nested('[[][]]') ➞ True\n * is_nested('[[]][[') ➞ True\n * \n */\nconst is_nested = function (string0: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_nested(\"[[]]\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_nested(\"[]]]]]]][[[[[]\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_nested(\"[][]\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_nested(\"[]\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_nested(\"[[[[]]]]\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_nested(\"[]]]]]]]]]]\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_nested(\"[][][[]]\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_nested(\"[[]\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_nested(\"[]]\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_nested(\"[[]][[\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = is_nested(\"[[][]]\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = is_nested(\"\");\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = is_nested(\"[[[[[[[[\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = is_nested(\"]]]]]]]]\");\nlet expected_14 = false;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\n", "language": "typescript", "description": "Δημιουργήστε μια συνάρτηση που παίρνει μια συμβολοσειρά ως είσοδο η οποία περιέχει μόνο αγκύλες.\n    Η συνάρτηση θα πρέπει να επιστρέφει True μόνο αν υπάρχει μια έγκυρη υποακολουθία αγκυλών \n    όπου τουλάχιστον μια αγκύλη στην υποακολουθία είναι ενσωματωμένη.", "entry_point": "is_nested", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/60", "prompt": "import * as math from 'mathjs'\n\n/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Σας δίνεται μια λίστα αριθμών.\n *     Χρειάζεστε να επιστρέψετε το άθροισμα των τετραγωνισμένων αριθμών στην δεδομένη λίστα,\n *     στρογγυλοποιήστε κάθε στοιχείο στη λίστα στο ανώτατο ακέραιο (Ceiling) πρώτα.\n *     Παραδείγματα:\n *     Για lst = [1,2,3] η έξοδος πρέπει να είναι 14\n *     Για lst = [1,4,9] η έξοδος πρέπει να είναι 98\n *     Για lst = [1,3,5,7] η έξοδος πρέπει να είναι 84\n *     Για lst = [1.4,4.2,0] η έξοδος πρέπει να είναι 29\n *     Για lst = [-2.4,1,1] η έξοδος πρέπει να είναι 6\n * \n * \n * \n * \n */\nconst sum_squares = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_squares([1, 2, 3]);\nlet expected_1 = 14;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_squares([1.0, 2, 3]);\nlet expected_2 = 14;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_squares([1, 3, 5, 7]);\nlet expected_3 = 84;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_squares([1.4, 4.2, 0]);\nlet expected_4 = 29;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_squares([-2.4, 1, 1]);\nlet expected_5 = 6;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = sum_squares([100, 1, 15, 2]);\nlet expected_6 = 10230;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = sum_squares([10000, 10000]);\nlet expected_7 = 200000000;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = sum_squares([-1.4, 4.6, 6.3]);\nlet expected_8 = 75;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = sum_squares([-1.4, 17.9, 18.9, 19.9]);\nlet expected_9 = 1086;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = sum_squares([0]);\nlet expected_10 = 0;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = sum_squares([-1]);\nlet expected_11 = 1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = sum_squares([-1, 1, 0]);\nlet expected_12 = 2;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνεται μια λίστα αριθμών.\n    Χρειάζεστε να επιστρέψετε το άθροισμα των τετραγωνισμένων αριθμών στην δεδομένη λίστα,\n    στρογγυλοποιήστε κάθε στοιχείο στη λίστα στο ανώτατο ακέραιο (Ceiling) πρώτα.\n    Παραδείγματα:\n    Για lst = [1,2,3] η έξοδος πρέπει να είναι 14\n    Για lst = [1,4,9] η έξοδος πρέπει να είναι 98\n    Για lst = [1,3,5,7] η έξοδος πρέπει να είναι 84\n    Για lst = [1.4,4.2,0] η έξοδος πρέπει να είναι 29\n    Για lst = [-2.4,1,1] η έξοδος πρέπει να είναι 6", "entry_point": "sum_squares", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/61", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δημιουργήστε μια συνάρτηση που επιστρέφει True αν ο τελευταίος χαρακτήρας\n *     ενός δεδομένου string είναι αλφαβητικός χαρακτήρας και δεν είναι\n *     μέρος ενός λέξης, και False αλλιώς.\n *     Σημείωση: \"λέξη\" είναι μια ομάδα χαρακτήρων που χωρίζονται από κενό.\n * \n *     Παραδείγματα:\n * \n * check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n * check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n * check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n * check_if_last_char_is_a_letter(\"\") ➞ False \n * \n */\nconst check_if_last_char_is_a_letter = function (txt: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = check_if_last_char_is_a_letter(\"apple\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = check_if_last_char_is_a_letter(\"apple pi e\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = check_if_last_char_is_a_letter(\"eeeee\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = check_if_last_char_is_a_letter(\"A\");\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = check_if_last_char_is_a_letter(\"Pumpkin pie \");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = check_if_last_char_is_a_letter(\"Pumpkin pie 1\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = check_if_last_char_is_a_letter(\"\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = check_if_last_char_is_a_letter(\"eeeee e \");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = check_if_last_char_is_a_letter(\"apple pie\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = check_if_last_char_is_a_letter(\"apple pi e \");\nlet expected_10 = false;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Δημιουργήστε μια συνάρτηση που επιστρέφει True αν ο τελευταίος χαρακτήρας\n    ενός δεδομένου string είναι αλφαβητικός χαρακτήρας και δεν είναι\n    μέρος ενός λέξης, και False αλλιώς.\n    Σημείωση: \"λέξη\" είναι μια ομάδα χαρακτήρων που χωρίζονται από κενό.\n\n    Παραδείγματα:", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/62", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Δημιουργήστε μια συνάρτηση η οποία επιστρέφει το μεγαλύτερο δείκτη ενός στοιχείου που δεν είναι μεγαλύτερο ή ίσο από το στοιχείο που ακολουθεί αμέσως πριν από αυτό. Εάν δεν υπάρχει τέτοιο στοιχείο, τότε επιστρέψτε -1. Ο δοσμένος πίνακας δεν θα περιέχει διπλότυπες τιμές.\n * \n * Παραδείγματα:\n * \n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n * \n */\nconst can_arrange = function (arr: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = can_arrange([1, 2, 4, 3, 5]);\nlet expected_1 = 3;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = can_arrange([1, 2, 4, 5]);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = can_arrange([1, 4, 2, 5, 6, 7, 8, 9, 10]);\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = can_arrange([4, 8, 5, 7, 3]);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = can_arrange([]);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Δημιουργήστε μια συνάρτηση η οποία επιστρέφει το μεγαλύτερο δείκτη ενός στοιχείου που δεν είναι μεγαλύτερο ή ίσο από το στοιχείο που ακολουθεί αμέσως πριν από αυτό. Εάν δεν υπάρχει τέτοιο στοιχείο, τότε επιστρέψτε -1. Ο δοσμένος πίνακας δεν θα περιέχει διπλότυπες τιμές.\n\nΠαραδείγματα:", "entry_point": "can_arrange", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/63", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δημιουργήστε μια συνάρτηση που επιστρέφει ένα tuple (a, b), όπου 'a' είναι ο μεγαλύτερος από τους αρνητικούς ακέραιους και 'b' είναι ο μικρότερος από τους θετικούς ακέραιους σε μια λίστα. Εάν δεν υπάρχουν αρνητικοί ή θετικοί ακέραιοι, επιστρέψτε τους ως None.\n * \n * Παραδείγματα:\n * \n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n * \n */\nconst largest_smallest_integers = function (lst: Array<number>) : Array<any>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = largest_smallest_integers([2, 4, 1, 3, 5, 7]);\nlet expected_1 = [undefined, 1];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = largest_smallest_integers([2, 4, 1, 3, 5, 7, 0]);\nlet expected_2 = [undefined, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = largest_smallest_integers([1, 3, 2, 4, 5, 6, -2]);\nlet expected_3 = [-2, 1];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = largest_smallest_integers([4, 5, 3, 6, 2, 7, -7]);\nlet expected_4 = [-7, 2];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = largest_smallest_integers([7, 3, 8, 4, 9, 2, 5, -9]);\nlet expected_5 = [-9, 2];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = largest_smallest_integers([]);\nlet expected_6 = [undefined, undefined];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = largest_smallest_integers([0]);\nlet expected_7 = [undefined, undefined];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = largest_smallest_integers([-1, -3, -5, -6]);\nlet expected_8 = [-1, undefined];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = largest_smallest_integers([-1, -3, -5, -6, 0]);\nlet expected_9 = [-1, undefined];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = largest_smallest_integers([-6, -4, -4, -3, 1]);\nlet expected_10 = [-3, 1];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = largest_smallest_integers([-6, -4, -4, -3, -100, 1]);\nlet expected_11 = [-3, 1];\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "Δημιουργήστε μια συνάρτηση που επιστρέφει ένα tuple (a, b), όπου 'a' είναι ο μεγαλύτερος από τους αρνητικούς ακέραιους και 'b' είναι ο μικρότερος από τους θετικούς ακέραιους σε μια λίστα. Εάν δεν υπάρχουν αρνητικοί ή θετικοί ακέραιοι, επιστρέψτε τους ως None.\n\nΠαραδείγματα:", "entry_point": "largest_smallest_integers", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/64", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Το βραζιλιάνικο παραγοντικό ορίζεται ως:\n *     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     όπου n > 0\n * \n *     Για παράδειγμα:\n * >>> special_factorial(4)\n * 288\n * \n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n * \n */\nconst special_factorial = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = special_factorial(4);\nlet expected_1 = 288;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = special_factorial(5);\nlet expected_2 = 34560;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = special_factorial(7);\nlet expected_3 = 125411328000;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = special_factorial(1);\nlet expected_4 = 1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Το βραζιλιάνικο παραγοντικό ορίζεται ως:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    όπου n > 0\n\n    Για παράδειγμα:", "entry_point": "special_factorial", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/65", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Σας δίνεται μια συμβολοσειρά που αντιπροσωπεύει μια πρόταση,\n *     η πρόταση περιέχει μερικές λέξεις που χωρίζονται από ένα κενό,\n *     και πρέπει να επιστρέψετε μια συμβολοσειρά που περιέχει τις λέξεις από την αρχική πρόταση,\n *     οι οποίες έχουν πρωταρχικά μήκη,\n *     η σειρά των λέξεων στη νέα συμβολοσειρά πρέπει να είναι η ίδια με την αρχική.\n * \n *     Παράδειγμα 1:\n *         Είσοδος: πρόταση = \"Αυτό είναι ένα τεστ\"\n *         Έξοδος: \"είναι\"\n * \n *     Παράδειγμα 2:\n *         Είσοδος: πρόταση = \"πάμε για κολύμπι\"\n *         Έξοδος: \"για\"\n * \n *     Περιορισμοί:\n *         * 1 <= len(sentence) <= 100\n *         * Η πρόταση περιέχει μόνο γράμματα.\n * \n * \n */\nconst words_in_sentence = function (sentence: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = words_in_sentence(\"This is a test\");\nlet expected_1 = \"is\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = words_in_sentence(\"lets go for swimming\");\nlet expected_2 = \"go for\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = words_in_sentence(\"there is no place available here\");\nlet expected_3 = \"there is no place\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = words_in_sentence(\"Hi I am Hussein\");\nlet expected_4 = \"Hi am Hussein\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = words_in_sentence(\"go for it\");\nlet expected_5 = \"go for it\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = words_in_sentence(\"here\");\nlet expected_6 = \"\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = words_in_sentence(\"here is\");\nlet expected_7 = \"is\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνεται μια συμβολοσειρά που αντιπροσωπεύει μια πρόταση,\n    η πρόταση περιέχει μερικές λέξεις που χωρίζονται από ένα κενό,\n    και πρέπει να επιστρέψετε μια συμβολοσειρά που περιέχει τις λέξεις από την αρχική πρόταση,\n    οι οποίες έχουν πρωταρχικά μήκη,\n    η σειρά των λέξεων στη νέα συμβολοσειρά πρέπει να είναι η ίδια με την αρχική.\n\n    Παράδειγμα 1:\n        Είσοδος: πρόταση = \"Αυτό είναι ένα τεστ\"\n        Έξοδος: \"είναι\"\n\n    Παράδειγμα 2:\n        Είσοδος: πρόταση = \"πάμε για κολύμπι\"\n        Έξοδος: \"για\"\n\n    Περιορισμοί:\n        * 1 <= len(sentence) <= 100\n        * Η πρόταση περιέχει μόνο γράμματα.", "entry_point": "words_in_sentence", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/66", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Η εργασία σας είναι να υλοποιήσετε μια συνάρτηση που θα απλοποιεί την έκφραση x * n. Η συνάρτηση επιστρέφει True αν το x * n αξιολογείται σε έναν ακέραιο αριθμό και False διαφορετικά. Και τα δύο x και n είναι αναπαράσταση συντελεστή, και έχουν την ακόλουθη μορφή, <αριθμητέας>/<παρονομαστής> όπου και ο αριθμητέας και ο παρονομαστής είναι θετικοί ακέραιοι αριθμοί.\n * \n * Μπορείτε να υποθέσετε ότι το x και το n είναι έγκυροι συντελεστές και δεν έχουν μηδέν ως παρονομαστή.\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n * \n */\nconst simplify = function (x: string, n: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = simplify(\"1/5\",\"5/1\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = simplify(\"1/6\",\"2/1\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = simplify(\"5/1\",\"3/1\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = simplify(\"7/10\",\"10/2\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = simplify(\"2/10\",\"50/10\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = simplify(\"7/2\",\"4/2\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = simplify(\"11/6\",\"6/1\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = simplify(\"2/3\",\"5/2\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = simplify(\"5/2\",\"3/5\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = simplify(\"2/4\",\"8/4\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = simplify(\"2/4\",\"4/2\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = simplify(\"1/5\",\"5/1\");\nlet expected_12 = true;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = simplify(\"1/5\",\"1/5\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\n", "language": "typescript", "description": "Η εργασία σας είναι να υλοποιήσετε μια συνάρτηση που θα απλοποιεί την έκφραση x * n. Η συνάρτηση επιστρέφει True αν το x * n αξιολογείται σε έναν ακέραιο αριθμό και False διαφορετικά. Και τα δύο x και n είναι αναπαράσταση συντελεστή, και έχουν την ακόλουθη μορφή, <αριθμητέας>/<παρονομαστής> όπου και ο αριθμητέας και ο παρονομαστής είναι θετικοί ακέραιοι αριθμοί.\n\nΜπορείτε να υποθέσετε ότι το x και το n είναι έγκυροι συντελεστές και δεν έχουν μηδέν ως παρονομαστή.", "entry_point": "simplify", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/67", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Γράψτε μια συνάρτηση η οποία ταξινομεί τη δοσμένη λίστα ακεραίων σε αύξουσα σειρά βάσει του αθροίσματος των ψηφίων τους. Σημείωση: αν υπάρχουν πολλά στοιχεία με παρόμοιο άθροισμα των ψηφίων τους, ταξινομήστε τα βάσει της θέσης τους στην αρχική λίστα.\n * \n * Παράδειγμα:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n * \n */\nconst order_by_points = function (nums: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = order_by_points([1, 11, -1, -11, -12]);\nlet expected_1 = [-1, -11, 1, -12, 11];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = order_by_points([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]);\nlet expected_2 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = order_by_points([]);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = order_by_points([1, -11, -32, 43, 54, -98, 2, -3]);\nlet expected_4 = [-3, -32, -98, -11, 1, 2, 43, 54];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = order_by_points([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\nlet expected_5 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = order_by_points([0, 6, 6, -76, -21, 23, 4]);\nlet expected_6 = [-76, -21, 0, 4, 23, 6, 6];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Γράψτε μια συνάρτηση η οποία ταξινομεί τη δοσμένη λίστα ακεραίων σε αύξουσα σειρά βάσει του αθροίσματος των ψηφίων τους. Σημείωση: αν υπάρχουν πολλά στοιχεία με παρόμοιο άθροισμα των ψηφίων τους, ταξινομήστε τα βάσει της θέσης τους στην αρχική λίστα.\n\nΠαράδειγμα:", "entry_point": "order_by_points", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/68", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Γράψτε μια συνάρτηση που παίρνει έναν πίνακα αριθμών ως είσοδο και επιστρέφει τον αριθμό των στοιχείων στον πίνακα που είναι μεγαλύτερα από 10 και και οι πρώτοι και οι τελευταίοι αριθμοί ενός αριθμού είναι περιττοί (1, 3, 5, 7, 9). Για παράδειγμα:\n * \n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n * \n */\nconst specialFilter = function (nums: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = specialFilter([5, -2, 1, -5]);\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = specialFilter([15, -73, 14, -15]);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = specialFilter([33, -2, -3, 45, 21, 109]);\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = specialFilter([43, -12, 93, 125, 121, 109]);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = specialFilter([71, -2, -33, 75, 21, 19]);\nlet expected_5 = 3;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = specialFilter([1]);\nlet expected_6 = 0;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = specialFilter([]);\nlet expected_7 = 0;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Γράψτε μια συνάρτηση που παίρνει έναν πίνακα αριθμών ως είσοδο και επιστρέφει τον αριθμό των στοιχείων στον πίνακα που είναι μεγαλύτερα από 10 και και οι πρώτοι και οι τελευταίοι αριθμοί ενός αριθμού είναι περιττοί (1, 3, 5, 7, 9). Για παράδειγμα:", "entry_point": "specialFilter", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/69", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Σας δίνεται ένα θετικό ακέραιο n. Πρέπει να δημιουργήσετε έναν πίνακα ακεραίων a μήκους n. Για κάθε i (1 ≤ i ≤ n), η τιμή του a[i] = i * i - i + 1. Επιστρέψτε τον αριθμό των τριάδων (a[i], a[j], a[k]) του a όπου i < j < k, και a[i] + a[j] + a[k] είναι πολλαπλάσιο του 3.\n * \n * Παράδειγμα:\n *     Είσοδος: n = 5\n *     Έξοδος: 1\n *     Εξήγηση:\n *     a = [1, 3, 7, 13, 21]\n *     Η μόνη έγκυρη τριάδα είναι (1, 7, 13).\n * \n * \n */\nconst get_max_triples = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_max_triples(5);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_max_triples(6);\nlet expected_2 = 4;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_max_triples(10);\nlet expected_3 = 36;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_max_triples(100);\nlet expected_4 = 53361;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνεται ένα θετικό ακέραιο n. Πρέπει να δημιουργήσετε έναν πίνακα ακεραίων a μήκους n. Για κάθε i (1 ≤ i ≤ n), η τιμή του a[i] = i * i - i + 1. Επιστρέψτε τον αριθμό των τριάδων (a[i], a[j], a[k]) του a όπου i < j < k, και a[i] + a[j] + a[k] είναι πολλαπλάσιο του 3.\n\nΠαράδειγμα:\n    Είσοδος: n = 5\n    Έξοδος: 1\n    Εξήγηση:\n    a = [1, 3, 7, 13, 21]\n    Η μόνη έγκυρη τριάδα είναι (1, 7, 13).", "entry_point": "get_max_triples", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/70", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Υπάρχουν οκτώ πλανήτες στο ηλιακό μας σύστημα: ο πλανήτης που βρίσκεται πιο κοντά στον Ήλιο είναι ο Ερμής, ο επόμενος είναι η Αφροδίτη, έπειτα η Γη, ο Άρης, ο Δίας, ο Κρόνος, ο Ουρανός και ο Ποσειδώνας. \n * Γράψτε μια συνάρτηση που παίρνει δύο ονόματα πλανητών ως αλφαριθμητικά planet1 και planet2. Η συνάρτηση θα πρέπει να επιστρέφει ένα tuple που περιέχει όλους τους πλανήτες των οποίων οι τροχιές βρίσκονται μεταξύ της τροχιάς του πλανήτη1 και της τροχιάς του πλανήτη2, ταξινομημένους κατά την εγγύτητά τους στον Ήλιο. Η συνάρτηση θα πρέπει να επιστρέφει ένα κενό tuple εάν το planet1 ή το planet2 δεν είναι σωστά ονόματα πλανητών. \n * Παραδείγματα:\n * \n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n * \n */\nconst bf = function (planet1: string, planet2: string) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = bf(\"Jupiter\",\"Neptune\");\nlet expected_1 = [\"Saturn\", \"Uranus\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = bf(\"Earth\",\"Mercury\");\nlet expected_2 = [\"Venus\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = bf(\"Mercury\",\"Uranus\");\nlet expected_3 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = bf(\"Neptune\",\"Venus\");\nlet expected_4 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = bf(\"Earth\",\"Earth\");\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = bf(\"Mars\",\"Earth\");\nlet expected_6 = [];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = bf(\"Jupiter\",\"Makemake\");\nlet expected_7 = [];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Υπάρχουν οκτώ πλανήτες στο ηλιακό μας σύστημα: ο πλανήτης που βρίσκεται πιο κοντά στον Ήλιο είναι ο Ερμής, ο επόμενος είναι η Αφροδίτη, έπειτα η Γη, ο Άρης, ο Δίας, ο Κρόνος, ο Ουρανός και ο Ποσειδώνας. \nΓράψτε μια συνάρτηση που παίρνει δύο ονόματα πλανητών ως αλφαριθμητικά planet1 και planet2. Η συνάρτηση θα πρέπει να επιστρέφει ένα tuple που περιέχει όλους τους πλανήτες των οποίων οι τροχιές βρίσκονται μεταξύ της τροχιάς του πλανήτη1 και της τροχιάς του πλανήτη2, ταξινομημένους κατά την εγγύτητά τους στον Ήλιο. Η συνάρτηση θα πρέπει να επιστρέφει ένα κενό tuple εάν το planet1 ή το planet2 δεν είναι σωστά ονόματα πλανητών. \nΠαραδείγματα:", "entry_point": "bf", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/71", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Ένα απλό πρόγραμμα που θα πρέπει να επιστρέφει την τιμή του x αν το n είναι πρώτος αριθμός και θα πρέπει να επιστρέφει την τιμή του y σε διαφορετική περίπτωση.\n * \n * Παραδείγματα:\n * \n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n * \n */\nconst x_or_y = function (n: number, x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = x_or_y(7,34,12);\nlet expected_1 = 34;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = x_or_y(15,8,5);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = x_or_y(3,33,5212);\nlet expected_3 = 33;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = x_or_y(1259,3,52);\nlet expected_4 = 3;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = x_or_y(7919,-1,12);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = x_or_y(3609,1245,583);\nlet expected_6 = 583;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = x_or_y(91,56,129);\nlet expected_7 = 129;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = x_or_y(6,34,1234);\nlet expected_8 = 1234;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = x_or_y(1,2,0);\nlet expected_9 = 0;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = x_or_y(2,2,0);\nlet expected_10 = 2;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Ένα απλό πρόγραμμα που θα πρέπει να επιστρέφει την τιμή του x αν το n είναι πρώτος αριθμός και θα πρέπει να επιστρέφει την τιμή του y σε διαφορετική περίπτωση.\n\nΠαραδείγματα:", "entry_point": "x_or_y", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/72", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δεδομένης μιας λίστας αριθμών, επιστρέψτε το άθροισμα των τετραγώνων των αριθμών στη λίστα που είναι περιττοί. Αγνοήστε τους αριθμούς που είναι αρνητικοί ή δεν είναι ακέραιοι.\n * \n *     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n *     double_the_difference([-1, -2, 0]) == 0\n *     double_the_difference([9, -2]) == 81\n *     double_the_difference([0]) == 0\n * \n *     Εάν η είσοδος είναι κενή λίστα, επιστρέψτε 0.\n * \n * \n */\nconst double_the_difference = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = double_the_difference([]);\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = double_the_difference([5, 4]);\nlet expected_2 = 25;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = double_the_difference([0.1, 0.2, 0.3]);\nlet expected_3 = 0;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = double_the_difference([-10, -20, -30]);\nlet expected_4 = 0;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = double_the_difference([-1, -2, 8]);\nlet expected_5 = 0;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = double_the_difference([0.2, 3, 5]);\nlet expected_6 = 34;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = double_the_difference([-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]);\nlet expected_7 = 166650;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένης μιας λίστας αριθμών, επιστρέψτε το άθροισμα των τετραγώνων των αριθμών στη λίστα που είναι περιττοί. Αγνοήστε τους αριθμούς που είναι αρνητικοί ή δεν είναι ακέραιοι.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    Εάν η είσοδος είναι κενή λίστα, επιστρέψτε 0.", "entry_point": "double_the_difference", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/73", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Θα σας δοθεί το όνομα μιας κλάσης (ένα string) και μια λίστα επεκτάσεων. Οι επεκτάσεις πρέπει να χρησιμοποιηθούν για να φορτώσουν επιπλέον κλάσεις στην κλάση. Η δύναμη της επέκτασης είναι ως εξής: Ας είναι CAP ο αριθμός των κεφαλαίων γραμμάτων στο όνομα της επέκτασης και ας είναι SM ο αριθμός των πεζών γραμμάτων στο όνομα της επέκτασης, η δύναμη δίνεται από το κλάσμα CAP - SM. Θα πρέπει να βρείτε την ισχυρότερη επέκταση και να επιστρέψετε ένα string σε αυτή τη μορφή: ClassName.StrongestExtensionName. Εάν υπάρχουν δύο ή περισσότερες επεκτάσεις με την ίδια δύναμη, θα πρέπει να επιλέξετε αυτή που έρχεται πρώτη στη λίστα. Για παράδειγμα, εάν σας δοθεί \"Slices\" ως κλάση και μια λίστα επεκτάσεων: ['SErviNGSliCes', 'Cheese', 'StuFfed'], τότε θα πρέπει να επιστρέψετε 'Slices.SErviNGSliCes' καθώς η 'SErviNGSliCes' είναι η ισχυρότερη επέκταση (η δύναμή της είναι -1). Παράδειγμα:\n * \n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n * \n */\nconst Strongest_Extension = function (class_name: string, extensions: Array<string>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = Strongest_Extension(\"Watashi\",[\"tEN\", \"niNE\", \"eIGHt8OKe\"]);\nlet expected_1 = \"Watashi.eIGHt8OKe\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = Strongest_Extension(\"Boku123\",[\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]);\nlet expected_2 = \"Boku123.YEs.WeCaNe\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = Strongest_Extension(\"__YESIMHERE\",[\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]);\nlet expected_3 = \"__YESIMHERE.NuLl__\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = Strongest_Extension(\"K\",[\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]);\nlet expected_4 = \"K.TAR\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = Strongest_Extension(\"__HAHA\",[\"Tab\", \"123\", \"781345\", \"-_-\"]);\nlet expected_5 = \"__HAHA.123\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = Strongest_Extension(\"YameRore\",[\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]);\nlet expected_6 = \"YameRore.okIWILL123\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = Strongest_Extension(\"finNNalLLly\",[\"Die\", \"NowW\", \"Wow\", \"WoW\"]);\nlet expected_7 = \"finNNalLLly.WoW\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = Strongest_Extension(\"_\",[\"Bb\", \"91245\"]);\nlet expected_8 = \"_.Bb\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = Strongest_Extension(\"Sp\",[\"671235\", \"Bb\"]);\nlet expected_9 = \"Sp.671235\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Θα σας δοθεί το όνομα μιας κλάσης (ένα string) και μια λίστα επεκτάσεων. Οι επεκτάσεις πρέπει να χρησιμοποιηθούν για να φορτώσουν επιπλέον κλάσεις στην κλάση. Η δύναμη της επέκτασης είναι ως εξής: Ας είναι CAP ο αριθμός των κεφαλαίων γραμμάτων στο όνομα της επέκτασης και ας είναι SM ο αριθμός των πεζών γραμμάτων στο όνομα της επέκτασης, η δύναμη δίνεται από το κλάσμα CAP - SM. Θα πρέπει να βρείτε την ισχυρότερη επέκταση και να επιστρέψετε ένα string σε αυτή τη μορφή: ClassName.StrongestExtensionName. Εάν υπάρχουν δύο ή περισσότερες επεκτάσεις με την ίδια δύναμη, θα πρέπει να επιλέξετε αυτή που έρχεται πρώτη στη λίστα. Για παράδειγμα, εάν σας δοθεί \"Slices\" ως κλάση και μια λίστα επεκτάσεων: ['SErviNGSliCes', 'Cheese', 'StuFfed'], τότε θα πρέπει να επιστρέψετε 'Slices.SErviNGSliCes' καθώς η 'SErviNGSliCes' είναι η ισχυρότερη επέκταση (η δύναμή της είναι -1). Παράδειγμα:", "entry_point": "Strongest_Extension", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/74", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Σας δίνονται 2 λέξεις. Χρειάζεται να επιστρέψετε True αν η δεύτερη λέξη ή οποιαδήποτε από τις περιστροφές της είναι υποσυμβολοσειρά στην πρώτη λέξη.\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n * \n * \n */\nconst cycpattern_check = function (a: string, b: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = cycpattern_check(\"xyzw\",\"xyw\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = cycpattern_check(\"yello\",\"ell\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = cycpattern_check(\"whattup\",\"ptut\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = cycpattern_check(\"efef\",\"fee\");\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = cycpattern_check(\"abab\",\"aabb\");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = cycpattern_check(\"winemtt\",\"tinem\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνονται 2 λέξεις. Χρειάζεται να επιστρέψετε True αν η δεύτερη λέξη ή οποιαδήποτε από τις περιστροφές της είναι υποσυμβολοσειρά στην πρώτη λέξη.", "entry_point": "cycpattern_check", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/75", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δεδομένου ενός θετικού ακεραίου, να ανακτηθεί η αντίστοιχη ρωμαϊκή αριθμητική του σε μορφή συμβολοσειράς και να επιστραφεί σε πεζά γράμματα.\n *     Περιορισμοί: 1 <= num <= 1000\n * \n *     Παραδείγματα:\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n * \n */\nconst int_to_mini_roman = function (number0: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = int_to_mini_roman(19);\nlet expected_1 = \"xix\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = int_to_mini_roman(152);\nlet expected_2 = \"clii\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = int_to_mini_roman(251);\nlet expected_3 = \"ccli\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = int_to_mini_roman(426);\nlet expected_4 = \"cdxxvi\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = int_to_mini_roman(500);\nlet expected_5 = \"d\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = int_to_mini_roman(1);\nlet expected_6 = \"i\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = int_to_mini_roman(4);\nlet expected_7 = \"iv\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = int_to_mini_roman(43);\nlet expected_8 = \"xliii\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = int_to_mini_roman(90);\nlet expected_9 = \"xc\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = int_to_mini_roman(94);\nlet expected_10 = \"xciv\";\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = int_to_mini_roman(532);\nlet expected_11 = \"dxxxii\";\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = int_to_mini_roman(900);\nlet expected_12 = \"cm\";\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = int_to_mini_roman(994);\nlet expected_13 = \"cmxciv\";\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = int_to_mini_roman(1000);\nlet expected_14 = \"m\";\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένου ενός θετικού ακεραίου, να ανακτηθεί η αντίστοιχη ρωμαϊκή αριθμητική του σε μορφή συμβολοσειράς και να επιστραφεί σε πεζά γράμματα.\n    Περιορισμοί: 1 <= num <= 1000\n\n    Παραδείγματα:", "entry_point": "int_to_mini_roman", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/76", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέφει True αν οι τρεις πλευρές σχηματίζουν ένα ορθογώνιο τρίγωνο, False διαφορετικά. Ένα ορθογώνιο τρίγωνο είναι ένα τρίγωνο στο οποίο ένα γωνία είναι ορθή ή 90 μοίρες. Παράδειγμα:\n * \n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n * \n */\nconst right_angle_triangle = function (a: number, b: number, c: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = right_angle_triangle(3,4,5);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = right_angle_triangle(1,2,3);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = right_angle_triangle(10,6,8);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = right_angle_triangle(2,2,2);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = right_angle_triangle(7,24,25);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = right_angle_triangle(10,5,7);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = right_angle_triangle(5,12,13);\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = right_angle_triangle(15,8,17);\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = right_angle_triangle(48,55,73);\nlet expected_9 = true;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = right_angle_triangle(1,1,1);\nlet expected_10 = false;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = right_angle_triangle(2,2,10);\nlet expected_11 = false;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέφει True αν οι τρεις πλευρές σχηματίζουν ένα ορθογώνιο τρίγωνο, False διαφορετικά. Ένα ορθογώνιο τρίγωνο είναι ένα τρίγωνο στο οποίο ένα γωνία είναι ορθή ή 90 μοίρες. Παράδειγμα:", "entry_point": "right_angle_triangle", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/77", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * Σας δίνεται μια συμβολοσειρά s.\n *     Αν s[i] είναι γράμμα, αντιστρέψτε την πεζή πεζή σε κεφαλαία ή αντίστροφα, \n *     διαφορετικά κρατήστε το όπως είναι.\n *     Εάν η συμβολοσειρά δεν περιέχει γράμματα, αντιστρέψτε τη συμβολοσειρά.\n *     Η συνάρτηση πρέπει να επιστρέψει τη συμβολοσειρά που προέκυψε.\n *     Παραδείγματα\n * \n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n * \n */\nconst solve = function (s: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = solve(\"AsDf\");\nlet expected_1 = \"aSdF\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = solve(\"1234\");\nlet expected_2 = \"4321\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = solve(\"ab\");\nlet expected_3 = \"AB\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = solve(\"#a@C\");\nlet expected_4 = \"#A@c\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = solve(\"#AsdfW^45\");\nlet expected_5 = \"#aSDFw^45\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = solve(\"#6@2\");\nlet expected_6 = \"2@6#\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = solve(\"#$a^D\");\nlet expected_7 = \"#$A^d\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = solve(\"#ccc\");\nlet expected_8 = \"#CCC\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "Σας δίνεται μια συμβολοσειρά s.\n    Αν s[i] είναι γράμμα, αντιστρέψτε την πεζή πεζή σε κεφαλαία ή αντίστροφα, \n    διαφορετικά κρατήστε το όπως είναι.\n    Εάν η συμβολοσειρά δεν περιέχει γράμματα, αντιστρέψτε τη συμβολοσειρά.\n    Η συνάρτηση πρέπει να επιστρέψει τη συμβολοσειρά που προέκυψε.\n    Παραδείγματα", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/78", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δεδομένου ενός αλφαριθμητικού 'text', επιστρέψτε ένα αντίστοιχο αλφαριθμητικό md5 hash του. Εάν το 'text' είναι ένα κενό αλφαριθμητικό, επιστρέψτε null.\n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n * \n */\nconst string_to_md5 = function (text: string) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = string_to_md5(\"Hello world\");\nlet expected_1 = \"3e25960a79dbc69b674cd4ec67a72c62\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = string_to_md5(\"\");\nlet expected_2 = undefined;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = string_to_md5(\"A B C\");\nlet expected_3 = \"0ef78513b0cb8cef12743f5aeb35f888\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = string_to_md5(\"password\");\nlet expected_4 = \"5f4dcc3b5aa765d61d8327deb882cf99\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένου ενός αλφαριθμητικού 'text', επιστρέψτε ένα αντίστοιχο αλφαριθμητικό md5 hash του. Εάν το 'text' είναι ένα κενό αλφαριθμητικό, επιστρέψτε null.", "entry_point": "string_to_md5", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "typescript/79", "prompt": "/**\n * Είστε ένας ειδικός προγραμματιστής TypeScript.\n * \n * Δεδομένων δύο θετικών ακεραίων a και b, επιστρέφονται οι άρτιοι αριθμοί μεταξύ a και b, με αύξουσα σειρά.\n * \n * Για παράδειγμα:\n * \n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n * \n */\nconst generate_integers = function (a: number, b: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = generate_integers(2,10);\nlet expected_1 = [2, 4, 6, 8];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = generate_integers(10,2);\nlet expected_2 = [2, 4, 6, 8];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = generate_integers(132,2);\nlet expected_3 = [2, 4, 6, 8];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = generate_integers(17,89);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Δεδομένων δύο θετικών ακεραίων a και b, επιστρέφονται οι άρτιοι αριθμοί μεταξύ a και b, με αύξουσα σειρά.\n\nΓια παράδειγμα:", "entry_point": "generate_integers", "canonical_solution": NaN, "natural_language": "Greek"}
