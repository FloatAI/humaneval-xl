{"task_id": "typescript/0", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 你会得到一个银行账户的存款和取款操作列表，该账户从零余额开始。你的任务是检测账户余额是否在任何时候降至零以下，并在该点返回True。否则应返回False。\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n * \n */\nconst below_zero = function (operations: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = below_zero([]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = below_zero([1, 2, -3, 1, 2, -3]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = below_zero([1, 2, -4, 5, 6]);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = below_zero([1, -1, 2, -2, 5, -5, 4, -4]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = below_zero([1, -1, 2, -2, 5, -5, 4, -5]);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = below_zero([1, -2, 2, -2, 5, -5, 4, -4]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "你会得到一个银行账户的存款和取款操作列表，该账户从零余额开始。你的任务是检测账户余额是否在任何时候降至零以下，并在该点返回True。否则应返回False。", "entry_point": "below_zero", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/1", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 对于给定的整数列表，返回一个元组，其中包含列表中所有整数的和与积。\n * 空列表的和应该等于0，空列表的积应该等于1。\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n * \n */\nconst sum_product = function (numbers: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_product([]);\nlet expected_1 = [0, 1];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_product([1, 1, 1]);\nlet expected_2 = [3, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_product([100, 0]);\nlet expected_3 = [100, 0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_product([3, 5, 7]);\nlet expected_4 = [15, 105];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_product([10]);\nlet expected_5 = [10, 10];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "对于给定的整数列表，返回一个元组，其中包含列表中所有整数的和与积。\n空列表的和应该等于0，空列表的积应该等于1。", "entry_point": "sum_product", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/2", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 输入两个仅由1和0组成的字符串a和b。\n * 对这些输入执行二进制异或，并将结果作为字符串返回。\n * >>> string_xor('010', '110')\n * '100'\n * \n */\nconst string_xor = function (a: string, b: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = string_xor(\"111000\",\"101010\");\nlet expected_1 = \"010010\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = string_xor(\"1\",\"1\");\nlet expected_2 = \"0\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = string_xor(\"0101\",\"0000\");\nlet expected_3 = \"0101\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "输入两个仅由1和0组成的字符串a和b。\n对这些输入执行二进制异或，并将结果作为字符串返回。", "entry_point": "string_xor", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/3", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 从字符串列表中返回最长的字符串。如果有多个长度相同的字符串，则返回第一个字符串。如果输入列表为空，则返回null。\n * >>> longest([])\n * \n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n * \n */\nconst longest = function (strings: Array<string>) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = longest([]);\nlet expected_1 = undefined;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = longest([\"x\", \"y\", \"z\"]);\nlet expected_2 = \"x\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = longest([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]);\nlet expected_3 = \"zzzz\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "从字符串列表中返回最长的字符串。如果有多个长度相同的字符串，则返回第一个字符串。如果输入列表为空，则返回null。", "entry_point": "longest", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/4", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 返回两个整数a和b的最大公约数\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n * \n */\nconst greatest_common_divisor = function (a: number, b: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = greatest_common_divisor(3,7);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = greatest_common_divisor(10,15);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = greatest_common_divisor(49,14);\nlet expected_3 = 7;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = greatest_common_divisor(144,60);\nlet expected_4 = 12;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "返回两个整数a和b的最大公约数", "entry_point": "greatest_common_divisor", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/5", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 输入一个由“零”到“九”数字组成的以空格分隔的字符串。\n * 有效选择为“零”、“一”、“二”、“三”、“四”、“五”、“六”、“七”、“八”和“九”。\n * 返回按从小到大排序的数字字符串。\n * >>> sort_numbers('three one five')\n * 'one three five'\n * \n */\nconst sort_numbers = function (numbers: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sort_numbers(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sort_numbers(\"three\");\nlet expected_2 = \"three\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sort_numbers(\"three five nine\");\nlet expected_3 = \"three five nine\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sort_numbers(\"five zero four seven nine eight\");\nlet expected_4 = \"zero four five seven eight nine\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sort_numbers(\"six five four three two one zero\");\nlet expected_5 = \"zero one two three four five six\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "输入一个由“零”到“九”数字组成的以空格分隔的字符串。\n有效选择为“零”、“一”、“二”、“三”、“四”、“五”、“六”、“七”、“八”和“九”。\n返回按从小到大排序的数字字符串。", "entry_point": "sort_numbers", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/6", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 给定一个数字列表（至少有两个元素），对该列表应用线性变换，使最小的数字变为0，最大的数字变为1。\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n * \n */\nconst rescale_to_unit = function (numbers: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = rescale_to_unit([2.0, 49.9]);\nlet expected_1 = [0.0, 1.0];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = rescale_to_unit([100.0, 49.9]);\nlet expected_2 = [1.0, 0.0];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]);\nlet expected_3 = [0.0, 0.25, 0.5, 0.75, 1.0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]);\nlet expected_4 = [0.25, 0.0, 1.0, 0.5, 0.75];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]);\nlet expected_5 = [0.25, 0.0, 1.0, 0.5, 0.75];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "给定一个数字列表（至少有两个元素），对该列表应用线性变换，使最小的数字变为0，最大的数字变为1。", "entry_point": "rescale_to_unit", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/7", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 对于给定的字符串，将小写字符翻转为大写，将大写字符翻转为小写。\n * >>> flip_case('Hello')\n * 'hELLO'\n * \n */\nconst flip_case = function (string0: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = flip_case(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = flip_case(\"Hello!\");\nlet expected_2 = \"hELLO!\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = flip_case(\"These violent delights have violent ends\");\nlet expected_3 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "对于给定的字符串，将小写字符翻转为大写，将大写字符翻转为小写。", "entry_point": "flip_case", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/8", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 返回列表中仅为正数的数字。\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n * \n */\nconst get_positive = function (l: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_positive([-1, -2, 4, 5, 6]);\nlet expected_1 = [4, 5, 6];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]);\nlet expected_2 = [5, 3, 2, 3, 3, 9, 123, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_positive([-1, -2]);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_positive([]);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "返回列表中仅为正数的数字。", "entry_point": "get_positive", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/9", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 如果给定的数字是质数，则返回true，否则返回false。\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n * \n */\nconst is_prime = function (n: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_prime(6);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_prime(101);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_prime(11);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_prime(13441);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_prime(61);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_prime(4);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_prime(1);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_prime(5);\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_prime(11);\nlet expected_9 = true;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_prime(17);\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = is_prime(85);\nlet expected_11 = false;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = is_prime(77);\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = is_prime(255379);\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\n", "language": "typescript", "description": "如果给定的数字是质数，则返回true，否则返回false。", "entry_point": "is_prime", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/10", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 返回列表中排序后的唯一元素\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n * \n */\nconst unique = function (l: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = unique([5, 3, 5, 2, 3, 3, 9, 0, 123]);\nlet expected_1 = [0, 2, 3, 5, 9, 123];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\n", "language": "typescript", "description": "返回列表中排序后的唯一元素", "entry_point": "unique", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/11", "prompt": "import * as math from 'mathjs'\n\n/**\n * 你是一位熟练的TypeScript程序员。\n * \n * prime_fib 返回第 n 个既是斐波那契数又是质数的数。\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n * \n */\nconst prime_fib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = prime_fib(1);\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = prime_fib(2);\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = prime_fib(3);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = prime_fib(4);\nlet expected_4 = 13;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = prime_fib(5);\nlet expected_5 = 89;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = prime_fib(6);\nlet expected_6 = 233;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = prime_fib(7);\nlet expected_7 = 1597;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = prime_fib(8);\nlet expected_8 = 28657;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = prime_fib(9);\nlet expected_9 = 514229;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = prime_fib(10);\nlet expected_10 = 433494437;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "prime_fib 返回第 n 个既是斐波那契数又是质数的数。", "entry_point": "prime_fib", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/12", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * triples_sum_to_zero 接受一个整数列表作为输入。\n * 如果列表中存在三个不同的元素相加等于零，则返回True，否则返回False。\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n * \n */\nconst triples_sum_to_zero = function (l: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = triples_sum_to_zero([1, 3, 5, 0]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = triples_sum_to_zero([1, 3, 5, -1]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = triples_sum_to_zero([1, 3, -2, 1]);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = triples_sum_to_zero([1, 2, 3, 7]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = triples_sum_to_zero([1, 2, 5, 7]);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = triples_sum_to_zero([2, 4, -5, 3, 9, 7]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = triples_sum_to_zero([1]);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = triples_sum_to_zero([1, 3, 5, -100]);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = triples_sum_to_zero([100, 3, 5, -100]);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "triples_sum_to_zero 接受一个整数列表作为输入。\n如果列表中存在三个不同的元素相加等于零，则返回True，否则返回False。", "entry_point": "triples_sum_to_zero", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/13", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * pairs_sum_to_zero 接受一个整数列表作为输入。\n * 如果列表中存在两个不同的元素相加等于零，则返回True，否则返回False。\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n * \n */\nconst pairs_sum_to_zero = function (l: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = pairs_sum_to_zero([1, 3, 5, 0]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = pairs_sum_to_zero([1, 3, -2, 1]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = pairs_sum_to_zero([1, 2, 3, 7]);\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = pairs_sum_to_zero([2, 4, -5, 3, 5, 7]);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = pairs_sum_to_zero([1]);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]);\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "pairs_sum_to_zero 接受一个整数列表作为输入。\n如果列表中存在两个不同的元素相加等于零，则返回True，否则返回False。", "entry_point": "pairs_sum_to_zero", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/14", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * Fib4数列是一种类似于斐波那契数列的数列，定义如下：\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)。\n *     请编写一个函数高效地计算Fib4数列的第n个元素。不要使用递归。\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n * \n */\nconst fib4 = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fib4(5);\nlet expected_1 = 4;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fib4(8);\nlet expected_2 = 28;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fib4(10);\nlet expected_3 = 104;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fib4(12);\nlet expected_4 = 386;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Fib4数列是一种类似于斐波那契数列的数列，定义如下：\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)。\n    请编写一个函数高效地计算Fib4数列的第n个元素。不要使用递归。", "entry_point": "fib4", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/15", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 返回列表l中元素的中位数。\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n * \n */\nconst median = function (l: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = median([3, 1, 2, 4, 5]);\nlet expected_1 = 3;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = median([-10, 4, 6, 1000, 10, 20]);\nlet expected_2 = 8.0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = median([5]);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = median([6, 5]);\nlet expected_4 = 5.5;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = median([8, 1, 3, 9, 9, 2, 7]);\nlet expected_5 = 7;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "返回列表l中元素的中位数。", "entry_point": "median", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/16", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 检查给定的字符串是否为回文。\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n * \n */\nconst is_palindrome = function (text: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_palindrome(\"\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_palindrome(\"aba\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_palindrome(\"aaaaa\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_palindrome(\"zbcd\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_palindrome(\"xywyx\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_palindrome(\"xywyz\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_palindrome(\"xywzx\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "检查给定的字符串是否为回文。", "entry_point": "is_palindrome", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/17", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * remove_vowels是一个函数，它接受一个字符串并返回没有元音字母的字符串。\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n * \n */\nconst remove_vowels = function (text: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = remove_vowels(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = remove_vowels(\"abcdef\\nghijklm\");\nlet expected_2 = \"bcdf\\nghjklm\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = remove_vowels(\"fedcba\");\nlet expected_3 = \"fdcb\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = remove_vowels(\"eeeee\");\nlet expected_4 = \"\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = remove_vowels(\"acBAA\");\nlet expected_5 = \"cB\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = remove_vowels(\"EcBOO\");\nlet expected_6 = \"cB\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = remove_vowels(\"ybcd\");\nlet expected_7 = \"ybcd\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "remove_vowels是一个函数，它接受一个字符串并返回没有元音字母的字符串。", "entry_point": "remove_vowels", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/18", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 如果列表l中的所有数字都低于阈值t，则返回True。\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n * \n */\nconst below_threshold = function (l: Array<number>, t: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = below_threshold([1, 2, 4, 10],100);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = below_threshold([1, 20, 4, 10],5);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = below_threshold([1, 20, 4, 10],21);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = below_threshold([1, 20, 4, 10],22);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = below_threshold([1, 8, 4, 10],11);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = below_threshold([1, 8, 4, 10],10);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "如果列表l中的所有数字都低于阈值t，则返回True。", "entry_point": "below_threshold", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/19", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 添加两个数字 x 和 y\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n * \n */\nconst add = function (x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = add(0,1);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = add(1,0);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = add(2,3);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = add(5,7);\nlet expected_4 = 12;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = add(7,5);\nlet expected_5 = 12;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = add(572,725);\nlet expected_6 = 1297;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = add(51,804);\nlet expected_7 = 855;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = add(645,96);\nlet expected_8 = 741;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = add(712,853);\nlet expected_9 = 1565;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = add(223,101);\nlet expected_10 = 324;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = add(76,29);\nlet expected_11 = 105;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = add(416,149);\nlet expected_12 = 565;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = add(145,409);\nlet expected_13 = 554;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = add(535,430);\nlet expected_14 = 965;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = add(118,303);\nlet expected_15 = 421;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = add(287,94);\nlet expected_16 = 381;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\nlet actual_17 = add(768,257);\nlet expected_17 = 1025;\nassert.deepEqual(actual_17, expected_17, \"Exception --- test case 16 failed to pass\");\n\nlet actual_18 = add(421,677);\nlet expected_18 = 1098;\nassert.deepEqual(actual_18, expected_18, \"Exception --- test case 17 failed to pass\");\n\nlet actual_19 = add(802,814);\nlet expected_19 = 1616;\nassert.deepEqual(actual_19, expected_19, \"Exception --- test case 18 failed to pass\");\n\nlet actual_20 = add(510,922);\nlet expected_20 = 1432;\nassert.deepEqual(actual_20, expected_20, \"Exception --- test case 19 failed to pass\");\n\nlet actual_21 = add(345,819);\nlet expected_21 = 1164;\nassert.deepEqual(actual_21, expected_21, \"Exception --- test case 20 failed to pass\");\n\nlet actual_22 = add(895,436);\nlet expected_22 = 1331;\nassert.deepEqual(actual_22, expected_22, \"Exception --- test case 21 failed to pass\");\n\nlet actual_23 = add(123,424);\nlet expected_23 = 547;\nassert.deepEqual(actual_23, expected_23, \"Exception --- test case 22 failed to pass\");\n\nlet actual_24 = add(923,245);\nlet expected_24 = 1168;\nassert.deepEqual(actual_24, expected_24, \"Exception --- test case 23 failed to pass\");\n\nlet actual_25 = add(23,438);\nlet expected_25 = 461;\nassert.deepEqual(actual_25, expected_25, \"Exception --- test case 24 failed to pass\");\n\nlet actual_26 = add(565,133);\nlet expected_26 = 698;\nassert.deepEqual(actual_26, expected_26, \"Exception --- test case 25 failed to pass\");\n\nlet actual_27 = add(945,925);\nlet expected_27 = 1870;\nassert.deepEqual(actual_27, expected_27, \"Exception --- test case 26 failed to pass\");\n\nlet actual_28 = add(261,983);\nlet expected_28 = 1244;\nassert.deepEqual(actual_28, expected_28, \"Exception --- test case 27 failed to pass\");\n\nlet actual_29 = add(139,577);\nlet expected_29 = 716;\nassert.deepEqual(actual_29, expected_29, \"Exception --- test case 28 failed to pass\");\n\nlet actual_30 = add(763,178);\nlet expected_30 = 941;\nassert.deepEqual(actual_30, expected_30, \"Exception --- test case 29 failed to pass\");\n\nlet actual_31 = add(147,892);\nlet expected_31 = 1039;\nassert.deepEqual(actual_31, expected_31, \"Exception --- test case 30 failed to pass\");\n\nlet actual_32 = add(436,402);\nlet expected_32 = 838;\nassert.deepEqual(actual_32, expected_32, \"Exception --- test case 31 failed to pass\");\n\nlet actual_33 = add(610,581);\nlet expected_33 = 1191;\nassert.deepEqual(actual_33, expected_33, \"Exception --- test case 32 failed to pass\");\n\nlet actual_34 = add(103,416);\nlet expected_34 = 519;\nassert.deepEqual(actual_34, expected_34, \"Exception --- test case 33 failed to pass\");\n\nlet actual_35 = add(339,990);\nlet expected_35 = 1329;\nassert.deepEqual(actual_35, expected_35, \"Exception --- test case 34 failed to pass\");\n\nlet actual_36 = add(130,504);\nlet expected_36 = 634;\nassert.deepEqual(actual_36, expected_36, \"Exception --- test case 35 failed to pass\");\n\nlet actual_37 = add(242,717);\nlet expected_37 = 959;\nassert.deepEqual(actual_37, expected_37, \"Exception --- test case 36 failed to pass\");\n\nlet actual_38 = add(562,110);\nlet expected_38 = 672;\nassert.deepEqual(actual_38, expected_38, \"Exception --- test case 37 failed to pass\");\n\nlet actual_39 = add(396,909);\nlet expected_39 = 1305;\nassert.deepEqual(actual_39, expected_39, \"Exception --- test case 38 failed to pass\");\n\nlet actual_40 = add(887,703);\nlet expected_40 = 1590;\nassert.deepEqual(actual_40, expected_40, \"Exception --- test case 39 failed to pass\");\n\nlet actual_41 = add(870,551);\nlet expected_41 = 1421;\nassert.deepEqual(actual_41, expected_41, \"Exception --- test case 40 failed to pass\");\n\nlet actual_42 = add(422,391);\nlet expected_42 = 813;\nassert.deepEqual(actual_42, expected_42, \"Exception --- test case 41 failed to pass\");\n\nlet actual_43 = add(299,505);\nlet expected_43 = 804;\nassert.deepEqual(actual_43, expected_43, \"Exception --- test case 42 failed to pass\");\n\nlet actual_44 = add(346,56);\nlet expected_44 = 402;\nassert.deepEqual(actual_44, expected_44, \"Exception --- test case 43 failed to pass\");\n\nlet actual_45 = add(36,706);\nlet expected_45 = 742;\nassert.deepEqual(actual_45, expected_45, \"Exception --- test case 44 failed to pass\");\n\nlet actual_46 = add(738,411);\nlet expected_46 = 1149;\nassert.deepEqual(actual_46, expected_46, \"Exception --- test case 45 failed to pass\");\n\nlet actual_47 = add(679,87);\nlet expected_47 = 766;\nassert.deepEqual(actual_47, expected_47, \"Exception --- test case 46 failed to pass\");\n\nlet actual_48 = add(25,303);\nlet expected_48 = 328;\nassert.deepEqual(actual_48, expected_48, \"Exception --- test case 47 failed to pass\");\n\nlet actual_49 = add(161,612);\nlet expected_49 = 773;\nassert.deepEqual(actual_49, expected_49, \"Exception --- test case 48 failed to pass\");\n\nlet actual_50 = add(306,841);\nlet expected_50 = 1147;\nassert.deepEqual(actual_50, expected_50, \"Exception --- test case 49 failed to pass\");\n\nlet actual_51 = add(973,411);\nlet expected_51 = 1384;\nassert.deepEqual(actual_51, expected_51, \"Exception --- test case 50 failed to pass\");\n\nlet actual_52 = add(711,157);\nlet expected_52 = 868;\nassert.deepEqual(actual_52, expected_52, \"Exception --- test case 51 failed to pass\");\n\nlet actual_53 = add(471,27);\nlet expected_53 = 498;\nassert.deepEqual(actual_53, expected_53, \"Exception --- test case 52 failed to pass\");\n\nlet actual_54 = add(714,792);\nlet expected_54 = 1506;\nassert.deepEqual(actual_54, expected_54, \"Exception --- test case 53 failed to pass\");\n\nlet actual_55 = add(38,206);\nlet expected_55 = 244;\nassert.deepEqual(actual_55, expected_55, \"Exception --- test case 54 failed to pass\");\n\nlet actual_56 = add(907,343);\nlet expected_56 = 1250;\nassert.deepEqual(actual_56, expected_56, \"Exception --- test case 55 failed to pass\");\n\nlet actual_57 = add(23,760);\nlet expected_57 = 783;\nassert.deepEqual(actual_57, expected_57, \"Exception --- test case 56 failed to pass\");\n\nlet actual_58 = add(524,859);\nlet expected_58 = 1383;\nassert.deepEqual(actual_58, expected_58, \"Exception --- test case 57 failed to pass\");\n\nlet actual_59 = add(30,529);\nlet expected_59 = 559;\nassert.deepEqual(actual_59, expected_59, \"Exception --- test case 58 failed to pass\");\n\nlet actual_60 = add(341,691);\nlet expected_60 = 1032;\nassert.deepEqual(actual_60, expected_60, \"Exception --- test case 59 failed to pass\");\n\nlet actual_61 = add(167,729);\nlet expected_61 = 896;\nassert.deepEqual(actual_61, expected_61, \"Exception --- test case 60 failed to pass\");\n\nlet actual_62 = add(636,289);\nlet expected_62 = 925;\nassert.deepEqual(actual_62, expected_62, \"Exception --- test case 61 failed to pass\");\n\nlet actual_63 = add(503,144);\nlet expected_63 = 647;\nassert.deepEqual(actual_63, expected_63, \"Exception --- test case 62 failed to pass\");\n\nlet actual_64 = add(51,985);\nlet expected_64 = 1036;\nassert.deepEqual(actual_64, expected_64, \"Exception --- test case 63 failed to pass\");\n\nlet actual_65 = add(287,149);\nlet expected_65 = 436;\nassert.deepEqual(actual_65, expected_65, \"Exception --- test case 64 failed to pass\");\n\nlet actual_66 = add(659,75);\nlet expected_66 = 734;\nassert.deepEqual(actual_66, expected_66, \"Exception --- test case 65 failed to pass\");\n\nlet actual_67 = add(462,797);\nlet expected_67 = 1259;\nassert.deepEqual(actual_67, expected_67, \"Exception --- test case 66 failed to pass\");\n\nlet actual_68 = add(406,141);\nlet expected_68 = 547;\nassert.deepEqual(actual_68, expected_68, \"Exception --- test case 67 failed to pass\");\n\nlet actual_69 = add(106,44);\nlet expected_69 = 150;\nassert.deepEqual(actual_69, expected_69, \"Exception --- test case 68 failed to pass\");\n\nlet actual_70 = add(300,934);\nlet expected_70 = 1234;\nassert.deepEqual(actual_70, expected_70, \"Exception --- test case 69 failed to pass\");\n\nlet actual_71 = add(471,524);\nlet expected_71 = 995;\nassert.deepEqual(actual_71, expected_71, \"Exception --- test case 70 failed to pass\");\n\nlet actual_72 = add(122,429);\nlet expected_72 = 551;\nassert.deepEqual(actual_72, expected_72, \"Exception --- test case 71 failed to pass\");\n\nlet actual_73 = add(735,195);\nlet expected_73 = 930;\nassert.deepEqual(actual_73, expected_73, \"Exception --- test case 72 failed to pass\");\n\nlet actual_74 = add(335,484);\nlet expected_74 = 819;\nassert.deepEqual(actual_74, expected_74, \"Exception --- test case 73 failed to pass\");\n\nlet actual_75 = add(28,809);\nlet expected_75 = 837;\nassert.deepEqual(actual_75, expected_75, \"Exception --- test case 74 failed to pass\");\n\nlet actual_76 = add(430,20);\nlet expected_76 = 450;\nassert.deepEqual(actual_76, expected_76, \"Exception --- test case 75 failed to pass\");\n\nlet actual_77 = add(916,635);\nlet expected_77 = 1551;\nassert.deepEqual(actual_77, expected_77, \"Exception --- test case 76 failed to pass\");\n\nlet actual_78 = add(301,999);\nlet expected_78 = 1300;\nassert.deepEqual(actual_78, expected_78, \"Exception --- test case 77 failed to pass\");\n\nlet actual_79 = add(454,466);\nlet expected_79 = 920;\nassert.deepEqual(actual_79, expected_79, \"Exception --- test case 78 failed to pass\");\n\nlet actual_80 = add(905,259);\nlet expected_80 = 1164;\nassert.deepEqual(actual_80, expected_80, \"Exception --- test case 79 failed to pass\");\n\nlet actual_81 = add(168,205);\nlet expected_81 = 373;\nassert.deepEqual(actual_81, expected_81, \"Exception --- test case 80 failed to pass\");\n\nlet actual_82 = add(570,434);\nlet expected_82 = 1004;\nassert.deepEqual(actual_82, expected_82, \"Exception --- test case 81 failed to pass\");\n\nlet actual_83 = add(64,959);\nlet expected_83 = 1023;\nassert.deepEqual(actual_83, expected_83, \"Exception --- test case 82 failed to pass\");\n\nlet actual_84 = add(957,510);\nlet expected_84 = 1467;\nassert.deepEqual(actual_84, expected_84, \"Exception --- test case 83 failed to pass\");\n\nlet actual_85 = add(722,598);\nlet expected_85 = 1320;\nassert.deepEqual(actual_85, expected_85, \"Exception --- test case 84 failed to pass\");\n\nlet actual_86 = add(770,226);\nlet expected_86 = 996;\nassert.deepEqual(actual_86, expected_86, \"Exception --- test case 85 failed to pass\");\n\nlet actual_87 = add(579,66);\nlet expected_87 = 645;\nassert.deepEqual(actual_87, expected_87, \"Exception --- test case 86 failed to pass\");\n\nlet actual_88 = add(117,674);\nlet expected_88 = 791;\nassert.deepEqual(actual_88, expected_88, \"Exception --- test case 87 failed to pass\");\n\nlet actual_89 = add(530,30);\nlet expected_89 = 560;\nassert.deepEqual(actual_89, expected_89, \"Exception --- test case 88 failed to pass\");\n\nlet actual_90 = add(776,345);\nlet expected_90 = 1121;\nassert.deepEqual(actual_90, expected_90, \"Exception --- test case 89 failed to pass\");\n\nlet actual_91 = add(327,389);\nlet expected_91 = 716;\nassert.deepEqual(actual_91, expected_91, \"Exception --- test case 90 failed to pass\");\n\nlet actual_92 = add(596,12);\nlet expected_92 = 608;\nassert.deepEqual(actual_92, expected_92, \"Exception --- test case 91 failed to pass\");\n\nlet actual_93 = add(599,511);\nlet expected_93 = 1110;\nassert.deepEqual(actual_93, expected_93, \"Exception --- test case 92 failed to pass\");\n\nlet actual_94 = add(936,476);\nlet expected_94 = 1412;\nassert.deepEqual(actual_94, expected_94, \"Exception --- test case 93 failed to pass\");\n\nlet actual_95 = add(461,14);\nlet expected_95 = 475;\nassert.deepEqual(actual_95, expected_95, \"Exception --- test case 94 failed to pass\");\n\nlet actual_96 = add(966,157);\nlet expected_96 = 1123;\nassert.deepEqual(actual_96, expected_96, \"Exception --- test case 95 failed to pass\");\n\nlet actual_97 = add(326,91);\nlet expected_97 = 417;\nassert.deepEqual(actual_97, expected_97, \"Exception --- test case 96 failed to pass\");\n\nlet actual_98 = add(392,455);\nlet expected_98 = 847;\nassert.deepEqual(actual_98, expected_98, \"Exception --- test case 97 failed to pass\");\n\nlet actual_99 = add(446,477);\nlet expected_99 = 923;\nassert.deepEqual(actual_99, expected_99, \"Exception --- test case 98 failed to pass\");\n\nlet actual_100 = add(324,860);\nlet expected_100 = 1184;\nassert.deepEqual(actual_100, expected_100, \"Exception --- test case 99 failed to pass\");\n\nlet actual_101 = add(945,85);\nlet expected_101 = 1030;\nassert.deepEqual(actual_101, expected_101, \"Exception --- test case 100 failed to pass\");\n\nlet actual_102 = add(886,582);\nlet expected_102 = 1468;\nassert.deepEqual(actual_102, expected_102, \"Exception --- test case 101 failed to pass\");\n\nlet actual_103 = add(886,712);\nlet expected_103 = 1598;\nassert.deepEqual(actual_103, expected_103, \"Exception --- test case 102 failed to pass\");\n\nlet actual_104 = add(842,953);\nlet expected_104 = 1795;\nassert.deepEqual(actual_104, expected_104, \"Exception --- test case 103 failed to pass\");\n\n", "language": "typescript", "description": "添加两个数字 x 和 y", "entry_point": "add", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/20", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 检查两个单词是否具有相同的字符。\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n * \n */\nconst same_chars = function (s0: string, s1: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = same_chars(\"eabcdzzzz\",\"dddzzzzzzzddeddabc\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = same_chars(\"abcd\",\"dddddddabc\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = same_chars(\"dddddddabc\",\"abcd\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = same_chars(\"eabcd\",\"dddddddabc\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = same_chars(\"abcd\",\"dddddddabcf\");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = same_chars(\"eabcdzzzz\",\"dddzzzzzzzddddabc\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = same_chars(\"aabb\",\"aaccc\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "检查两个单词是否具有相同的字符。", "entry_point": "same_chars", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/21", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 返回第n个斐波那契数。\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n * \n */\nconst fib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fib(10);\nlet expected_1 = 55;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fib(1);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fib(8);\nlet expected_3 = 21;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fib(11);\nlet expected_4 = 89;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = fib(12);\nlet expected_5 = 144;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "返回第n个斐波那契数。", "entry_point": "fib", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/22", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 返回两个列表中排序后的唯一公共元素。\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n * \n * \n */\nconst common = function (l1: Array<number>, l2: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = common([1, 4, 3, 34, 653, 2, 5],[5, 7, 1, 5, 9, 653, 121]);\nlet expected_1 = [1, 5, 653];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = common([5, 3, 2, 8],[3, 2]);\nlet expected_2 = [2, 3];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = common([4, 3, 2, 8],[3, 2, 4]);\nlet expected_3 = [2, 3, 4];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = common([4, 3, 2, 8],[]);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "返回两个列表中排序后的唯一公共元素。", "entry_point": "common", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/23", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 返回n的最大质因数。假设n>1且不是质数。\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n * \n */\nconst largest_prime_factor = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = largest_prime_factor(15);\nlet expected_1 = 5;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = largest_prime_factor(27);\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = largest_prime_factor(63);\nlet expected_3 = 7;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = largest_prime_factor(330);\nlet expected_4 = 11;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = largest_prime_factor(13195);\nlet expected_5 = 29;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "返回n的最大质因数。假设n>1且不是质数。", "entry_point": "largest_prime_factor", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/24", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * sum_to_n是一个函数，它将从1加到n的数字相加。\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n * \n */\nconst sum_to_n = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_to_n(1);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_to_n(6);\nlet expected_2 = 21;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_to_n(11);\nlet expected_3 = 66;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_to_n(30);\nlet expected_4 = 465;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_to_n(100);\nlet expected_5 = 5050;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "sum_to_n是一个函数，它将从1加到n的数字相加。", "entry_point": "sum_to_n", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/25", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * xs表示一个多项式的系数。\n *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n *     返回该多项式的导数，形式不变。\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n * \n */\nconst derivative = function (xs: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = derivative([3, 1, 2, 4, 5]);\nlet expected_1 = [1, 4, 12, 20];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = derivative([1, 2, 3]);\nlet expected_2 = [2, 6];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = derivative([3, 2, 1]);\nlet expected_3 = [2, 2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = derivative([3, 2, 1, 0, 4]);\nlet expected_4 = [2, 2, 0, 16];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = derivative([1]);\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "xs表示一个多项式的系数。\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    返回该多项式的导数，形式不变。", "entry_point": "derivative", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/26", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * FibFib数列是一种类似于斐波那契数列的数列，定义如下：\n *     fibfib(0) == 0\n *     fibfib(1) == 0\n *     fibfib(2) == 1\n *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)。\n *     请编写一个函数，高效地计算FibFib数列的第n个元素。\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n * \n */\nconst fibfib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fibfib(2);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fibfib(1);\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fibfib(5);\nlet expected_3 = 4;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fibfib(8);\nlet expected_4 = 24;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = fibfib(10);\nlet expected_5 = 81;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = fibfib(12);\nlet expected_6 = 274;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = fibfib(14);\nlet expected_7 = 927;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "FibFib数列是一种类似于斐波那契数列的数列，定义如下：\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)。\n    请编写一个函数，高效地计算FibFib数列的第n个元素。", "entry_point": "fibfib", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/27", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 编写一个函数vowels_count，它接受表示单词的字符串作为输入，并返回字符串中元音字母的数量。在这种情况下，元音字母是'a'，'e'，'i'，'o'，'u'。在这里，'y'也是元音字母，但仅当它在给定单词的末尾时。\n * \n * 例：\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n * \n */\nconst vowels_count = function (s: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = vowels_count(\"abcde\");\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = vowels_count(\"Alone\");\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = vowels_count(\"key\");\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = vowels_count(\"bye\");\nlet expected_4 = 1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = vowels_count(\"keY\");\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = vowels_count(\"bYe\");\nlet expected_6 = 1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = vowels_count(\"ACEDY\");\nlet expected_7 = 3;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "编写一个函数vowels_count，它接受表示单词的字符串作为输入，并返回字符串中元音字母的数量。在这种情况下，元音字母是'a'，'e'，'i'，'o'，'u'。在这里，'y'也是元音字母，但仅当它在给定单词的末尾时。\n\n例：", "entry_point": "vowels_count", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/28", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定一个非空的正整数列表。返回大于零且频率大于或等于该整数本身值的最大整数。整数的频率是它在列表中出现的次数。如果不存在这样的值，则返回-1。示例：\n * \n * search([4, 1, 2, 2, 3, 1]) == 2\n * search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n * search([5, 5, 4, 4, 4]) == -1\n * \n */\nconst search = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = search([5, 5, 5, 5, 1]);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = search([4, 1, 4, 1, 4, 4]);\nlet expected_2 = 4;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = search([3, 3]);\nlet expected_3 = -1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = search([8, 8, 8, 8, 8, 8, 8, 8]);\nlet expected_4 = 8;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = search([2, 3, 3, 2, 2]);\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = search([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]);\nlet expected_6 = 1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = search([3, 2, 8, 2]);\nlet expected_7 = 2;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]);\nlet expected_8 = 1;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = search([8, 8, 3, 6, 5, 6, 4]);\nlet expected_9 = -1;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = search([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]);\nlet expected_10 = 1;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = search([1, 9, 10, 1, 3]);\nlet expected_11 = 1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = search([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]);\nlet expected_12 = 5;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = search([1]);\nlet expected_13 = 1;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = search([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]);\nlet expected_14 = 4;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]);\nlet expected_15 = 2;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]);\nlet expected_16 = 1;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\nlet actual_17 = search([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]);\nlet expected_17 = 4;\nassert.deepEqual(actual_17, expected_17, \"Exception --- test case 16 failed to pass\");\n\nlet actual_18 = search([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]);\nlet expected_18 = 4;\nassert.deepEqual(actual_18, expected_18, \"Exception --- test case 17 failed to pass\");\n\nlet actual_19 = search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]);\nlet expected_19 = 2;\nassert.deepEqual(actual_19, expected_19, \"Exception --- test case 18 failed to pass\");\n\nlet actual_20 = search([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]);\nlet expected_20 = -1;\nassert.deepEqual(actual_20, expected_20, \"Exception --- test case 19 failed to pass\");\n\nlet actual_21 = search([10]);\nlet expected_21 = -1;\nassert.deepEqual(actual_21, expected_21, \"Exception --- test case 20 failed to pass\");\n\nlet actual_22 = search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]);\nlet expected_22 = 2;\nassert.deepEqual(actual_22, expected_22, \"Exception --- test case 21 failed to pass\");\n\nlet actual_23 = search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]);\nlet expected_23 = 1;\nassert.deepEqual(actual_23, expected_23, \"Exception --- test case 22 failed to pass\");\n\nlet actual_24 = search([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]);\nlet expected_24 = 1;\nassert.deepEqual(actual_24, expected_24, \"Exception --- test case 23 failed to pass\");\n\nlet actual_25 = search([3, 10, 10, 9, 2]);\nlet expected_25 = -1;\nassert.deepEqual(actual_25, expected_25, \"Exception --- test case 24 failed to pass\");\n\n", "language": "typescript", "description": "给定一个非空的正整数列表。返回大于零且频率大于或等于该整数本身值的最大整数。整数的频率是它在列表中出现的次数。如果不存在这样的值，则返回-1。示例：", "entry_point": "search", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/29", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定三角形的三条边长。如果这三条边可以组成一个有效的三角形，则返回保留两位小数的三角形面积。否则返回-1。当任意两条边的和大于第三条边时，三条边才能组成一个有效的三角形。例如：\n * \n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n * \n */\nconst triangle_area = function (a: number, b: number, c: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = triangle_area(3,4,5);\nlet expected_1 = 6.0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = triangle_area(1,2,10);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = triangle_area(4,8,5);\nlet expected_3 = 8.18;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = triangle_area(2,2,2);\nlet expected_4 = 1.73;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = triangle_area(1,2,3);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = triangle_area(10,5,7);\nlet expected_6 = 16.25;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = triangle_area(2,6,3);\nlet expected_7 = -1;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = triangle_area(1,1,1);\nlet expected_8 = 0.43;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = triangle_area(2,2,10);\nlet expected_9 = -1;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "给定三角形的三条边长。如果这三条边可以组成一个有效的三角形，则返回保留两位小数的三角形面积。否则返回-1。当任意两条边的和大于第三条边时，三条边才能组成一个有效的三角形。例如：", "entry_point": "triangle_area", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/30", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 编写一个函数，如果对象q能够飞行则返回True，否则返回False。\n *     如果对象q平衡（它是一个回文列表）且其元素的总和小于或等于最大可能重量w，则对象q将飞行。\n * \n *     示例：\n *     will_it_fly([1, 2], 5) ➞ False \n *     # 1+2小于最大可能重量，但不平衡。\n * \n *     will_it_fly([3, 2, 3], 1) ➞ False\n *     # 它是平衡的，但3+2+3大于最大可能重量。\n * \n *     will_it_fly([3, 2, 3], 9) ➞ True\n *     # 3+2+3小于最大可能重量，且平衡。\n * \n *     will_it_fly([3], 5) ➞ True\n *     # 3小于最大可能重量，且平衡。\n * \n * \n */\nconst will_it_fly = function (q: Array<number>, w: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = will_it_fly([3, 2, 3],9);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = will_it_fly([1, 2],5);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = will_it_fly([3],5);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = will_it_fly([3, 2, 3],1);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = will_it_fly([1, 2, 3],6);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = will_it_fly([5],5);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "编写一个函数，如果对象q能够飞行则返回True，否则返回False。\n    如果对象q平衡（它是一个回文列表）且其元素的总和小于或等于最大可能重量w，则对象q将飞行。\n\n    示例：\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2小于最大可能重量，但不平衡。\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # 它是平衡的，但3+2+3大于最大可能重量。\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3小于最大可能重量，且平衡。\n\n    will_it_fly([3], 5) ➞ True\n    # 3小于最大可能重量，且平衡。", "entry_point": "will_it_fly", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/31", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 编写一个函数，如果给定的数字是3个质数的乘积，则返回true，否则返回false。已知（a）小于100。示例：\n * \n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n * \n */\nconst is_multiply_prime = function (a: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_multiply_prime(5);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_multiply_prime(30);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_multiply_prime(8);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_multiply_prime(10);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_multiply_prime(125);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_multiply_prime(105);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_multiply_prime(126);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_multiply_prime(729);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_multiply_prime(891);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_multiply_prime(1001);\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "编写一个函数，如果给定的数字是3个质数的乘积，则返回true，否则返回false。已知（a）小于100。示例：", "entry_point": "is_multiply_prime", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/32", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 你将会得到一个十进制数，你的任务是将它转换成二进制格式。该函数应该返回一个字符串，每个字符代表一个二进制数。字符串中的每个字符都将是'0'或'1'。\n * \n * 字符串开头和结尾会有额外的字符'db'。这些额外的字符是为了帮助格式化。\n * \n * 例子：\n * \n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n * \n */\nconst decimal_to_binary = function (decimal: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = decimal_to_binary(0);\nlet expected_1 = \"db0db\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = decimal_to_binary(32);\nlet expected_2 = \"db100000db\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = decimal_to_binary(103);\nlet expected_3 = \"db1100111db\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = decimal_to_binary(15);\nlet expected_4 = \"db1111db\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "你将会得到一个十进制数，你的任务是将它转换成二进制格式。该函数应该返回一个字符串，每个字符代表一个二进制数。字符串中的每个字符都将是'0'或'1'。\n\n字符串开头和结尾会有额外的字符'db'。这些额外的字符是为了帮助格式化。\n\n例子：", "entry_point": "decimal_to_binary", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/33", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 给定一个字符串s。\n * 你的任务是检查该字符串是否快乐。\n * 如果字符串的长度至少为3且每3个连续的字母都不同，则该字符串是快乐的。\n * 例如：\n * \n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n * \n */\nconst is_happy = function (s: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_happy(\"a\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_happy(\"aa\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_happy(\"abcd\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_happy(\"aabb\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_happy(\"adb\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_happy(\"xyy\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_happy(\"iopaxpoi\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_happy(\"iopaxioi\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "给定一个字符串s。\n你的任务是检查该字符串是否快乐。\n如果字符串的长度至少为3且每3个连续的字母都不同，则该字符串是快乐的。\n例如：", "entry_point": "is_happy", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/34", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 这是学期的最后一周，老师需要给学生们打分。老师一直在制定自己的评分算法。唯一的问题是，她丢失了用于评分的代码。她给了你一份学生的GPA清单，你需要编写一个函数，根据以下表格输出字母等级的清单：\n * \n *              GPA       |    Letter grade\n *               4.0                A+\n *             > 3.7                A \n *             > 3.3                A- \n *             > 3.0                B+\n *             > 2.7                B \n *             > 2.3                B-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                E\n *     \n * \n *     例如：\n * \n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n * \n */\nconst numerical_letter_grade = function (grades: Array<number>) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]);\nlet expected_1 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = numerical_letter_grade([1.2]);\nlet expected_2 = [\"D+\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = numerical_letter_grade([0.5]);\nlet expected_3 = [\"D-\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = numerical_letter_grade([0.0]);\nlet expected_4 = [\"E\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = numerical_letter_grade([1, 0.3, 1.5, 2.8, 3.3]);\nlet expected_5 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = numerical_letter_grade([0, 0.7]);\nlet expected_6 = [\"E\", \"D-\"];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "这是学期的最后一周，老师需要给学生们打分。老师一直在制定自己的评分算法。唯一的问题是，她丢失了用于评分的代码。她给了你一份学生的GPA清单，你需要编写一个函数，根据以下表格输出字母等级的清单：\n\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    例如：", "entry_point": "numerical_letter_grade", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/35", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 编写一个函数，它接受一个字符串并返回True，如果字符串长度是一个质数，否则返回False。\n * 示例：\n * \n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n * \n */\nconst prime_length = function (string0: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = prime_length(\"Hello\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = prime_length(\"abcdcba\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = prime_length(\"kittens\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = prime_length(\"orange\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = prime_length(\"wow\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = prime_length(\"world\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = prime_length(\"MadaM\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = prime_length(\"Wow\");\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = prime_length(\"\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = prime_length(\"HI\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = prime_length(\"go\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = prime_length(\"gogo\");\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = prime_length(\"aaaaaaaaaaaaaaa\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = prime_length(\"Madam\");\nlet expected_14 = true;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = prime_length(\"M\");\nlet expected_15 = false;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = prime_length(\"0\");\nlet expected_16 = false;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\n", "language": "typescript", "description": "编写一个函数，它接受一个字符串并返回True，如果字符串长度是一个质数，否则返回False。\n示例：", "entry_point": "prime_length", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/36", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 给定一个正整数N，返回其二进制表示下所有数字的总和。\n * \n *     示例\n *         对于N = 1000，数字总和为1，输出应为“1”。\n *         对于N = 150，数字总和为6，输出应为“110”。\n *         对于N = 147，数字总和为12，输出应为“1100”。\n * \n *     变量：\n *         @N 整数\n *              约束条件：0 ≤ N ≤ 10000。\n *     输出：\n *          一个二进制数字的字符串。\n * \n * \n */\nconst solve = function (N: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = solve(1000);\nlet expected_1 = \"1\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = solve(150);\nlet expected_2 = \"110\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = solve(147);\nlet expected_3 = \"1100\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = solve(333);\nlet expected_4 = \"1001\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = solve(963);\nlet expected_5 = \"10010\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "给定一个正整数N，返回其二进制表示下所有数字的总和。\n\n    示例\n        对于N = 1000，数字总和为1，输出应为“1”。\n        对于N = 150，数字总和为6，输出应为“110”。\n        对于N = 147，数字总和为12，输出应为“1100”。\n\n    变量：\n        @N 整数\n             约束条件：0 ≤ N ≤ 10000。\n    输出：\n         一个二进制数字的字符串。", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/37", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定一个二维数据，作为嵌套列表，类似于矩阵，但与矩阵不同的是，每行可能包含不同数量的列。给定lst和整数x，在列表中查找整数x，并返回元组列表[(x1，y1)，（x2，y2）...]，使得每个元组都是一个坐标-（行，列），从0开始。最初按行按升序排序坐标。此外，按列按降序排序行的坐标。\n * \n * 例子：\n * \n * get_row([\n * [1,2,3,4,5,6],\n * [1,2,3,4,1,6],\n * [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n * \n */\nconst get_row = function (lst: Array<Array<number>>, x: number) : Array<Array<number>>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],1);\nlet expected_1 = [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],2);\nlet expected_2 = [[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],1);\nlet expected_3 = [[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_row([],1);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = get_row([[1]],2);\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = get_row([[], [1], [1, 2, 3]],3);\nlet expected_6 = [[2, 2]];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "给定一个二维数据，作为嵌套列表，类似于矩阵，但与矩阵不同的是，每行可能包含不同数量的列。给定lst和整数x，在列表中查找整数x，并返回元组列表[(x1，y1)，（x2，y2）...]，使得每个元组都是一个坐标-（行，列），从0开始。最初按行按升序排序坐标。此外，按列按降序排序行的坐标。\n\n例子：", "entry_point": "get_row", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/38", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 你有一个整数列表。\n * 编写一个函数next_smallest()，返回列表中第二小的元素。\n * 如果没有这样的元素，则返回null。\n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n * \n */\nconst next_smallest = function (lst: Array<number>) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = next_smallest([1, 2, 3, 4, 5]);\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = next_smallest([5, 1, 4, 3, 2]);\nlet expected_2 = 2;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = next_smallest([]);\nlet expected_3 = undefined;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = next_smallest([1, 1]);\nlet expected_4 = undefined;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = next_smallest([1, 1, 1, 1, 0]);\nlet expected_5 = 1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = next_smallest([1, 1]);\nlet expected_6 = undefined;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = next_smallest([-35, 34, 12, -45]);\nlet expected_7 = -35;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "你有一个整数列表。\n编写一个函数next_smallest()，返回列表中第二小的元素。\n如果没有这样的元素，则返回null。", "entry_point": "next_smallest", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/39", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 你将会得到一个由单词组成的字符串，你的任务是计算无聊的数量。无聊的句子是以单词\"I\"开头的句子。句子以'.'、'?'或'!'为分隔符。\n * \n * 例如：\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n * \n */\nconst is_bored = function (S: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_bored(\"Hello world\");\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_bored(\"Is the sky blue?\");\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_bored(\"I love It !\");\nlet expected_3 = 1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_bored(\"bIt\");\nlet expected_4 = 0;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_bored(\"I feel good today. I will be productive. will kill It\");\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_bored(\"You and I are going for a walk\");\nlet expected_6 = 0;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "你将会得到一个由单词组成的字符串，你的任务是计算无聊的数量。无聊的句子是以单词\"I\"开头的句子。句子以'.'、'?'或'!'为分隔符。\n\n例如：", "entry_point": "is_bored", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/40", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 给定一个整数列表。\n * 你需要找到最大的质数值并返回其数字之和。\n * \n * 例子：\n * \n * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n * For lst = [0,81,12,3,1,21] the output should be 3\n * For lst = [0,8,1,2,1,7] the output should be 7\n * \n */\nconst skjkasdkd = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]);\nlet expected_1 = 10;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]);\nlet expected_2 = 25;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\nlet expected_3 = 13;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]);\nlet expected_4 = 11;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = skjkasdkd([0, 81, 12, 3, 1, 21]);\nlet expected_5 = 3;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = skjkasdkd([0, 8, 1, 2, 1, 7]);\nlet expected_6 = 7;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = skjkasdkd([8191]);\nlet expected_7 = 19;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = skjkasdkd([8191, 123456, 127, 7]);\nlet expected_8 = 19;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = skjkasdkd([127, 97, 8192]);\nlet expected_9 = 10;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "给定一个整数列表。\n你需要找到最大的质数值并返回其数字之和。\n\n例子：", "entry_point": "skjkasdkd", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/41", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定一个字典，如果所有键都是小写字符串或所有键都是大写字符串，则返回True，否则返回False。如果给定的字典为空，则函数应返回False。示例：\n * \n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n * \n */\nconst check_dict_case = function (dict: Map<any, string>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [\"b\", \"banana\"]]));\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [\"A\", \"banana\"], [\"B\", \"banana\"]]));\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [5, \"banana\"], [\"a\", \"apple\"]]));\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = check_dict_case(new Map<any, any>([[\"Name\", \"John\"], [\"Age\", \"36\"], [\"City\", \"Houston\"]]));\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = check_dict_case(new Map<any, any>([[\"STATE\", \"NC\"], [\"ZIP\", \"12345\"]]));\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = check_dict_case(new Map<any, any>([[\"fruit\", \"Orange\"], [\"taste\", \"Sweet\"]]));\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = check_dict_case(new Map<any, any>([]));\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "给定一个字典，如果所有键都是小写字符串或所有键都是大写字符串，则返回True，否则返回False。如果给定的字典为空，则函数应返回False。示例：", "entry_point": "check_dict_case", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/42", "prompt": "import * as math from 'mathjs'\n\n/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 创建一个函数，它接受一个表示数字的值（字符串），并返回最接近它的整数。如果该数字距离两个整数相等，则将其四舍五入到远离零的方向。\n * \n * 例子：\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n * \n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n * \n */\nconst closest_integer = function (value: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = closest_integer(\"10\");\nlet expected_1 = 10;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = closest_integer(\"14.5\");\nlet expected_2 = 15;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = closest_integer(\"-15.5\");\nlet expected_3 = -16;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = closest_integer(\"15.3\");\nlet expected_4 = 15;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = closest_integer(\"0\");\nlet expected_5 = 0;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "创建一个函数，它接受一个表示数字的值（字符串），并返回最接近它的整数。如果该数字距离两个整数相等，则将其四舍五入到远离零的方向。\n\n例子：", "entry_point": "closest_integer", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/43", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定一个正整数n，你需要建立一个n级的石头堆。\n * 第一层有n个石头。\n * 下一层的石头数量为：\n * - 如果n是奇数，则为下一个奇数。\n * - 如果n是偶数，则为下一个偶数。\n * 返回一个列表，其中索引为i的元素表示第(i+1)层的石头数量。\n * \n * 例子：\n * >>> make_a_pile(3)\n * [3, 5, 7]\n * \n */\nconst make_a_pile = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = make_a_pile(3);\nlet expected_1 = [3, 5, 7];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = make_a_pile(4);\nlet expected_2 = [4, 6, 8, 10];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = make_a_pile(5);\nlet expected_3 = [5, 7, 9, 11, 13];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = make_a_pile(6);\nlet expected_4 = [6, 8, 10, 12, 14, 16];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = make_a_pile(8);\nlet expected_5 = [8, 10, 12, 14, 16, 18, 20, 22];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "给定一个正整数n，你需要建立一个n级的石头堆。\n第一层有n个石头。\n下一层的石头数量为：\n- 如果n是奇数，则为下一个奇数。\n- 如果n是偶数，则为下一个偶数。\n返回一个列表，其中索引为i的元素表示第(i+1)层的石头数量。\n\n例子：", "entry_point": "make_a_pile", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/44", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 你将会得到一个由逗号或空格分隔的单词字符串。你的任务是将字符串分割成单词并返回一个单词数组。\n * \n * 例如：\n * \n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n * \n */\nconst words_string = function (s: string) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = words_string(\"Hi, my name is John\");\nlet expected_1 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = words_string(\"One, two, three, four, five, six\");\nlet expected_2 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = words_string(\"Hi, my name\");\nlet expected_3 = [\"Hi\", \"my\", \"name\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = words_string(\"One,, two, three, four, five, six,\");\nlet expected_4 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = words_string(\"\");\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = words_string(\"ahmed     , gamal\");\nlet expected_6 = [\"ahmed\", \"gamal\"];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "你将会得到一个由逗号或空格分隔的单词字符串。你的任务是将字符串分割成单词并返回一个单词数组。\n\n例如：", "entry_point": "words_string", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/45", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 这个函数接受两个正整数x和y，并返回在[x，y]范围内的最大偶数整数。如果没有这样的数字，则函数应返回-1。\n * \n * 例如：\n * \n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n * \n */\nconst choose_num = function (x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = choose_num(12,15);\nlet expected_1 = 14;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = choose_num(13,12);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = choose_num(33,12354);\nlet expected_3 = 12354;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = choose_num(5234,5233);\nlet expected_4 = -1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = choose_num(6,29);\nlet expected_5 = 28;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = choose_num(27,10);\nlet expected_6 = -1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = choose_num(7,7);\nlet expected_7 = -1;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = choose_num(546,546);\nlet expected_8 = 546;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "这个函数接受两个正整数x和y，并返回在[x，y]范围内的最大偶数整数。如果没有这样的数字，则函数应返回-1。\n\n例如：", "entry_point": "choose_num", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/46", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 给定两个正整数n和m，你的任务是计算从n到m（包括n和m）的整数的平均值。\n * 将答案四舍五入为最接近的整数，并将其转换为二进制。\n * 如果n大于m，则返回-1。\n * 例子：\n * \n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n * \n */\nconst rounded_avg = function (n: number, m: number) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = rounded_avg(1,5);\nlet expected_1 = \"0b11\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = rounded_avg(7,13);\nlet expected_2 = \"0b1010\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = rounded_avg(964,977);\nlet expected_3 = \"0b1111001010\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = rounded_avg(996,997);\nlet expected_4 = \"0b1111100100\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = rounded_avg(560,851);\nlet expected_5 = \"0b1011000010\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = rounded_avg(185,546);\nlet expected_6 = \"0b101101110\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = rounded_avg(362,496);\nlet expected_7 = \"0b110101101\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = rounded_avg(350,902);\nlet expected_8 = \"0b1001110010\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = rounded_avg(197,233);\nlet expected_9 = \"0b11010111\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = rounded_avg(7,5);\nlet expected_10 = -1;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = rounded_avg(5,1);\nlet expected_11 = -1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = rounded_avg(5,5);\nlet expected_12 = \"0b101\";\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\n", "language": "typescript", "description": "给定两个正整数n和m，你的任务是计算从n到m（包括n和m）的整数的平均值。\n将答案四舍五入为最接近的整数，并将其转换为二进制。\n如果n大于m，则返回-1。\n例子：", "entry_point": "rounded_avg", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/47", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 实现函数f，它以n为参数，返回一个大小为n的列表，其中索引i处的元素值为i的阶乘（如果i为偶数）或1到i的数字之和（如果i为奇数）。i从1开始。i的阶乘是从1到i的数字的乘积（1 * 2 * ... * i）。例如：\n * \n * f(5) == [1, 2, 6, 24, 15]\n * \n */\nconst f = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = f(5);\nlet expected_1 = [1, 2, 6, 24, 15];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = f(7);\nlet expected_2 = [1, 2, 6, 24, 15, 720, 28];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = f(1);\nlet expected_3 = [1];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = f(3);\nlet expected_4 = [1, 2, 6];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "实现函数f，它以n为参数，返回一个大小为n的列表，其中索引i处的元素值为i的阶乘（如果i为偶数）或1到i的数字之和（如果i为奇数）。i从1开始。i的阶乘是从1到i的数字的乘积（1 * 2 * ... * i）。例如：", "entry_point": "f", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/48", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定一个正整数n，返回一个元组，其中包含在范围（1，n）内的偶数和奇数整数回文数的数量。\n * \n *     示例1：\n * \n *         输入：3\n *         输出：（1，2）\n *         说明：\n *         整数回文是1、2、3。其中一个是偶数，两个是奇数。\n * \n *     示例2：\n * \n *         输入：12\n *         输出：（4，6）\n *         说明：\n *         整数回文是1、2、3、4、5、6、7、8、9、11。其中4个是偶数，6个是奇数。\n * \n *     注意：\n *         1. 1 <= n <= 10^3\n *         2. 返回的元组分别是偶数和奇数整数回文数的数量。\n * \n * \n */\nconst even_odd_palindrome = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = even_odd_palindrome(123);\nlet expected_1 = [8, 13];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = even_odd_palindrome(12);\nlet expected_2 = [4, 6];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = even_odd_palindrome(3);\nlet expected_3 = [1, 2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = even_odd_palindrome(63);\nlet expected_4 = [6, 8];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = even_odd_palindrome(25);\nlet expected_5 = [5, 6];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = even_odd_palindrome(19);\nlet expected_6 = [4, 6];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = even_odd_palindrome(9);\nlet expected_7 = [4, 5];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = even_odd_palindrome(1);\nlet expected_8 = [0, 1];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "给定一个正整数n，返回一个元组，其中包含在范围（1，n）内的偶数和奇数整数回文数的数量。\n\n    示例1：\n\n        输入：3\n        输出：（1，2）\n        说明：\n        整数回文是1、2、3。其中一个是偶数，两个是奇数。\n\n    示例2：\n\n        输入：12\n        输出：（4，6）\n        说明：\n        整数回文是1、2、3、4、5、6、7、8、9、11。其中4个是偶数，6个是奇数。\n\n    注意：\n        1. 1 <= n <= 10^3\n        2. 返回的元组分别是偶数和奇数整数回文数的数量。", "entry_point": "even_odd_palindrome", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/49", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 我们有一个由N个整数组成的数组'arr'，数组中的数字将是随机排序的。你的任务是确定是否可以通过对给定数组执行以下操作来获得按非递减顺序排序的数组：\n * \n *     您可以执行任意次数的右移操作。\n *     \n *     一个右移操作意味着将数组的所有元素向右移动一个位置。数组的最后一个元素将移动到数组的起始位置，即0号索引。\n * \n *     如果可以通过执行上述操作获得排序后的数组，则返回True，否则返回False。\n *     如果给定的数组为空，则返回True。\n * \n *     注意：给定的列表保证具有唯一元素。\n * \n *     例如：\n *     \n *     move_one_ball([3, 4, 5, 1, 2])==>True\n *     解释：通过执行2次右移操作，可以为给定数组实现非递减顺序。\n *     move_one_ball([3, 5, 4, 1, 2])==>False\n *     解释：通过执行任意数量的右移操作，无法为给定数组获得非递减顺序。\n * \n * \n * \n */\nconst move_one_ball = function (arr: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = move_one_ball([3, 4, 5, 1, 2]);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = move_one_ball([3, 5, 10, 1, 2]);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = move_one_ball([4, 3, 1, 2]);\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = move_one_ball([3, 5, 4, 1, 2]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = move_one_ball([]);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "我们有一个由N个整数组成的数组'arr'，数组中的数字将是随机排序的。你的任务是确定是否可以通过对给定数组执行以下操作来获得按非递减顺序排序的数组：\n\n    您可以执行任意次数的右移操作。\n    \n    一个右移操作意味着将数组的所有元素向右移动一个位置。数组的最后一个元素将移动到数组的起始位置，即0号索引。\n\n    如果可以通过执行上述操作获得排序后的数组，则返回True，否则返回False。\n    如果给定的数组为空，则返回True。\n\n    注意：给定的列表保证具有唯一元素。\n\n    例如：\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释：通过执行2次右移操作，可以为给定数组实现非递减顺序。\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    解释：通过执行任意数量的右移操作，无法为给定数组获得非递减顺序。", "entry_point": "move_one_ball", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/50", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 在这个问题中，您将实现一个函数，该函数接受两个数字列表，并确定是否可以执行元素交换，使lst1成为仅包含偶数的列表。在lst1和lst2之间交换元素的数量没有限制。如果可以在lst1和lst2之间交换元素以使lst1的所有元素都是偶数，则返回“YES”。否则，返回“NO”。例如：exchange（[1,2,3,4]，[1,2,3,4]）=>“YES”exchange（[1,2,3,4]，[1,5,3,4]）=>“NO”假定输入列表将不为空。\n * \n * \n */\nconst exchange = function (lst1: Array<number>, lst2: Array<number>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = exchange([1, 2, 3, 4],[1, 2, 3, 4]);\nlet expected_1 = \"YES\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = exchange([1, 2, 3, 4],[1, 5, 3, 4]);\nlet expected_2 = \"NO\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = exchange([1, 2, 3, 4],[2, 1, 4, 3]);\nlet expected_3 = \"YES\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = exchange([5, 7, 3],[2, 6, 4]);\nlet expected_4 = \"YES\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = exchange([5, 7, 3],[2, 6, 3]);\nlet expected_5 = \"NO\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = exchange([3, 2, 6, 1, 8, 9],[3, 5, 5, 1, 1, 1]);\nlet expected_6 = \"NO\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = exchange([100, 200],[200, 200]);\nlet expected_7 = \"YES\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "在这个问题中，您将实现一个函数，该函数接受两个数字列表，并确定是否可以执行元素交换，使lst1成为仅包含偶数的列表。在lst1和lst2之间交换元素的数量没有限制。如果可以在lst1和lst2之间交换元素以使lst1的所有元素都是偶数，则返回“YES”。否则，返回“NO”。例如：exchange（[1,2,3,4]，[1,2,3,4]）=>“YES”exchange（[1,2,3,4]，[1,5,3,4]）=>“NO”假定输入列表将不为空。", "entry_point": "exchange", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/51", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 任务\n * 给定两个字符串s和c，您必须删除s中所有与c中任何字符相等的字符，然后检查结果字符串是否为回文。\n * 如果一个字符串从前往后读和从后往前读是一样的，那么这个字符串就是回文的。\n * 您应该返回一个包含结果字符串和True/False检查的元组。\n * 例子\n * 对于s =“abcde”，c =“ae”，结果应该是（'bcd'，False）\n * 对于s =“abcdef”，c =“b”，结果应该是（'acdef'，False）\n * 对于s =“abcdedcba”，c =“ab”，结果应该是（'cdedc'，True）\n * \n * \n */\nconst reverse_delete = function (s: string, c: string) : Array<any>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = reverse_delete(\"abcde\",\"ae\");\nlet expected_1 = [\"bcd\", false];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = reverse_delete(\"abcdef\",\"b\");\nlet expected_2 = [\"acdef\", false];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = reverse_delete(\"abcdedcba\",\"ab\");\nlet expected_3 = [\"cdedc\", true];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = reverse_delete(\"dwik\",\"w\");\nlet expected_4 = [\"dik\", false];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = reverse_delete(\"a\",\"a\");\nlet expected_5 = [\"\", true];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = reverse_delete(\"abcdedcba\",\"\");\nlet expected_6 = [\"abcdedcba\", true];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = reverse_delete(\"abcdedcba\",\"v\");\nlet expected_7 = [\"abcdedcba\", true];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = reverse_delete(\"vabba\",\"v\");\nlet expected_8 = [\"abba\", true];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = reverse_delete(\"mamma\",\"mia\");\nlet expected_9 = [\"\", true];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "任务\n给定两个字符串s和c，您必须删除s中所有与c中任何字符相等的字符，然后检查结果字符串是否为回文。\n如果一个字符串从前往后读和从后往前读是一样的，那么这个字符串就是回文的。\n您应该返回一个包含结果字符串和True/False检查的元组。\n例子\n对于s =“abcde”，c =“ae”，结果应该是（'bcd'，False）\n对于s =“abcdef”，c =“b”，结果应该是（'acdef'，False）\n对于s =“abcdedcba”，c =“ab”，结果应该是（'cdedc'，True）", "entry_point": "reverse_delete", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/52", "prompt": "import * as math from 'mathjs'\n\n/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 你有一个井的矩形网格。每一行代表一个井，每一行中的1代表一个单位的水。每个井都有一个对应的桶，可以用来从中提取水，所有桶的容量相同。你的任务是使用桶来排空井。输出你需要降低桶的次数。\n * \n * 例1：\n * 输入：\n *     grid：[[0,0,1,0]，[0,1,0,0]，[1,1,1,1]]\n *     bucket_capacity：1\n * 输出：6\n * \n * 例2：\n * 输入：\n *     grid：[[0,0,1,1]，[0,0,0,0]，[1,1,1,1]，[0,1,1,1]]\n *     bucket_capacity：2\n * 输出：5\n * \n * 例3：\n * 输入：\n *     grid：[[0,0,0]，[0,0,0]]\n *     bucket_capacity：5\n * 输出：0\n * \n * 约束：\n * *所有井的长度相同\n * *1 <= grid.length <= 10^2\n * *1 <= grid [:,1].length <= 10^2\n * *grid [i] [j] -> 0 | 1\n * *1 <= capacity <= 10\n * \n * \n */\nconst max_fill = function (grid: Array<Array<number>>, capacity: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],1);\nlet expected_1 = 6;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],2);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = max_fill([[0, 0, 0], [0, 0, 0]],5);\nlet expected_3 = 0;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = max_fill([[1, 1, 1, 1], [1, 1, 1, 1]],2);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = max_fill([[1, 1, 1, 1], [1, 1, 1, 1]],9);\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "你有一个井的矩形网格。每一行代表一个井，每一行中的1代表一个单位的水。每个井都有一个对应的桶，可以用来从中提取水，所有桶的容量相同。你的任务是使用桶来排空井。输出你需要降低桶的次数。\n\n例1：\n输入：\n    grid：[[0,0,1,0]，[0,1,0,0]，[1,1,1,1]]\n    bucket_capacity：1\n输出：6\n\n例2：\n输入：\n    grid：[[0,0,1,1]，[0,0,0,0]，[1,1,1,1]，[0,1,1,1]]\n    bucket_capacity：2\n输出：5\n\n例3：\n输入：\n    grid：[[0,0,0]，[0,0,0]]\n    bucket_capacity：5\n输出：0\n\n约束：\n*所有井的长度相同\n*1 <= grid.length <= 10^2\n*1 <= grid [:,1].length <= 10^2\n*grid [i] [j] -> 0 | 1\n*1 <= capacity <= 10", "entry_point": "max_fill", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/53", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 给定一个字符串s和一个自然数n，你被要求实现一个函数，该函数返回字符串s中包含恰好n个辅音字母的所有单词的列表，按照它们在字符串s中出现的顺序。\n * 如果字符串s为空，则函数应返回一个空列表。\n * 注意：您可以假设输入字符串仅包含字母和空格。\n * 示例：\n * \n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n * \n */\nconst select_words = function (s: string, n: number) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = select_words(\"Mary had a little lamb\",4);\nlet expected_1 = [\"little\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = select_words(\"Mary had a little lamb\",3);\nlet expected_2 = [\"Mary\", \"lamb\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = select_words(\"simple white space\",2);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = select_words(\"Hello world\",4);\nlet expected_4 = [\"world\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = select_words(\"Uncle sam\",3);\nlet expected_5 = [\"Uncle\"];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = select_words(\"\",4);\nlet expected_6 = [];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = select_words(\"a b c d e f\",1);\nlet expected_7 = [\"b\", \"c\", \"d\", \"f\"];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "给定一个字符串s和一个自然数n，你被要求实现一个函数，该函数返回字符串s中包含恰好n个辅音字母的所有单词的列表，按照它们在字符串s中出现的顺序。\n如果字符串s为空，则函数应返回一个空列表。\n注意：您可以假设输入字符串仅包含字母和空格。\n示例：", "entry_point": "select_words", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/54", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定一个整数数组arr和一个正整数k，返回一个长度为k的排序列表，其中包含arr中最大的k个数字。\n * \n * 示例1：\n * \n *     输入：arr = [-3，-4，5]，k = 3\n *     输出：[-4，-3，5]\n * \n * 示例2：\n * \n *     输入：arr = [4，-4，4]，k = 2\n *     输出：[4，4]\n * \n * 示例3：\n * \n *     输入：arr = [-3，2，1，2，-1，-2，1]，k = 1\n *     输出：[2]\n * \n * 注意：\n * \n *     1.数组的长度将在[1，1000]范围内。\n *     2.数组中的元素将在[-1000，1000]范围内。\n *     3.0 <= k <= len（arr）\n * \n * \n */\nconst maximum = function (arr: Array<number>, k: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = maximum([-3, -4, 5],3);\nlet expected_1 = [-4, -3, 5];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = maximum([4, -4, 4],2);\nlet expected_2 = [4, 4];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = maximum([-3, 2, 1, 2, -1, -2, 1],1);\nlet expected_3 = [2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = maximum([123, -123, 20, 0, 1, 2, -3],3);\nlet expected_4 = [2, 20, 123];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = maximum([-123, 20, 0, 1, 2, -3],4);\nlet expected_5 = [0, 1, 2, 20];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = maximum([5, 15, 0, 3, -13, -8, 0],7);\nlet expected_6 = [-13, -8, 0, 0, 3, 5, 15];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = maximum([-1, 0, 2, 5, 3, -10],2);\nlet expected_7 = [3, 5];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = maximum([1, 0, 5, -7],1);\nlet expected_8 = [5];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = maximum([4, -4],2);\nlet expected_9 = [-4, 4];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = maximum([-10, 10],2);\nlet expected_10 = [-10, 10];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = maximum([1, 2, 3, -23, 243, -400, 0],0);\nlet expected_11 = [];\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "给定一个整数数组arr和一个正整数k，返回一个长度为k的排序列表，其中包含arr中最大的k个数字。\n\n示例1：\n\n    输入：arr = [-3，-4，5]，k = 3\n    输出：[-4，-3，5]\n\n示例2：\n\n    输入：arr = [4，-4，4]，k = 2\n    输出：[4，4]\n\n示例3：\n\n    输入：arr = [-3，2，1，2，-1，-2，1]，k = 1\n    输出：[2]\n\n注意：\n\n    1.数组的长度将在[1，1000]范围内。\n    2.数组中的元素将在[-1000，1000]范围内。\n    3.0 <= k <= len（arr）", "entry_point": "maximum", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/55", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定一个非空整数数组 arr 和一个整数 k，返回 arr 的前 k 个元素中最多有两位数的元素的和。\n * \n * 示例：\n * \n *     输入：arr = [111,21,3,4000,5,6,7,8,9]，k = 4\n *     输出：24 # 21 + 3 的和\n * \n * 限制条件：\n *     1. 1 <= len(arr) <= 100\n *     2. 1 <= k <= len(arr)\n * \n * \n */\nconst add_elements = function (arr: Array<number>, k: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = add_elements([1, -2, -3, 41, 57, 76, 87, 88, 99],3);\nlet expected_1 = -4;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = add_elements([111, 121, 3, 4000, 5, 6],2);\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = add_elements([11, 21, 3, 90, 5, 6, 7, 8, 9],4);\nlet expected_3 = 125;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9],4);\nlet expected_4 = 24;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = add_elements([1],1);\nlet expected_5 = 1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "给定一个非空整数数组 arr 和一个整数 k，返回 arr 的前 k 个元素中最多有两位数的元素的和。\n\n示例：\n\n    输入：arr = [111,21,3,4000,5,6,7,8,9]，k = 4\n    输出：24 # 21 + 3 的和\n\n限制条件：\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)", "entry_point": "add_elements", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/56", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 给定两个区间，\n *     每个区间都是一对整数。例如，区间 = (起始，结束) = (1，2)。\n *     给定的区间是闭合的，这意味着区间（起始，结束）\n *     包括起始和结束。\n *     对于每个给定的区间，假定其起始小于或等于其结束。\n *     您的任务是确定这两个区间的交集长度是否为质数。\n *     例如，区间（1，3），（2，4）的交集是（2，3）\n *     其长度为1，不是质数。\n *     如果交集的长度是质数，则返回“YES”，\n *     否则返回“NO”。\n *     如果两个区间不相交，则返回“NO”。\n * \n *     [输入/输出]示例：\n * \n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n * \n */\nconst intersection = function (interval1: Array<number>, interval2: Array<number>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = intersection([1, 2],[2, 3]);\nlet expected_1 = \"NO\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = intersection([-1, 1],[0, 4]);\nlet expected_2 = \"NO\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = intersection([-3, -1],[-5, 5]);\nlet expected_3 = \"YES\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = intersection([-2, 2],[-4, 0]);\nlet expected_4 = \"YES\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = intersection([-11, 2],[-1, -1]);\nlet expected_5 = \"NO\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = intersection([1, 2],[3, 5]);\nlet expected_6 = \"NO\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = intersection([1, 2],[1, 2]);\nlet expected_7 = \"NO\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = intersection([-2, -2],[-3, -2]);\nlet expected_8 = \"NO\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "给定两个区间，\n    每个区间都是一对整数。例如，区间 = (起始，结束) = (1，2)。\n    给定的区间是闭合的，这意味着区间（起始，结束）\n    包括起始和结束。\n    对于每个给定的区间，假定其起始小于或等于其结束。\n    您的任务是确定这两个区间的交集长度是否为质数。\n    例如，区间（1，3），（2，4）的交集是（2，3）\n    其长度为1，不是质数。\n    如果交集的长度是质数，则返回“YES”，\n    否则返回“NO”。\n    如果两个区间不相交，则返回“NO”。\n\n    [输入/输出]示例：", "entry_point": "intersection", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/57", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 每个人都知道斐波那契数列，在过去的几个世纪里，数学家们对其进行了深入研究。然而，人们不知道的是特里波那契数列。特里波那契数列由递归定义：\n * tri(1) = 3\n * tri(n) = 1 + n / 2，如果n是偶数。\n * tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)，如果n是奇数。\n * 例如：\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n * = 2 + 3 + 3 = 8\n * 给定一个非负整数n，您必须返回特里波那契数列的前n + 1个数字的列表。\n * 例子：\n * tri(3) = [1, 3, 2, 8]\n * \n * \n */\nconst tri = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = tri(3);\nlet expected_1 = [1, 3, 2.0, 8.0];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = tri(4);\nlet expected_2 = [1, 3, 2.0, 8.0, 3.0];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = tri(5);\nlet expected_3 = [1, 3, 2.0, 8.0, 3.0, 15.0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = tri(6);\nlet expected_4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = tri(7);\nlet expected_5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = tri(8);\nlet expected_6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = tri(9);\nlet expected_7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = tri(20);\nlet expected_8 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = tri(0);\nlet expected_9 = [1];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = tri(1);\nlet expected_10 = [1, 3];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "每个人都知道斐波那契数列，在过去的几个世纪里，数学家们对其进行了深入研究。然而，人们不知道的是特里波那契数列。特里波那契数列由递归定义：\ntri(1) = 3\ntri(n) = 1 + n / 2，如果n是偶数。\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)，如果n是奇数。\n例如：\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\n给定一个非负整数n，您必须返回特里波那契数列的前n + 1个数字的列表。\n例子：\ntri(3) = [1, 3, 2, 8]", "entry_point": "tri", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/58", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 给定一个正整数n，返回所有奇数位数字的乘积。\n * 如果所有数字都是偶数，则返回0。\n * 例如：\n * \n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n * \n */\nconst digits = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = digits(5);\nlet expected_1 = 5;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = digits(54);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = digits(120);\nlet expected_3 = 1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = digits(5014);\nlet expected_4 = 5;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = digits(98765);\nlet expected_5 = 315;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = digits(5576543);\nlet expected_6 = 2625;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = digits(2468);\nlet expected_7 = 0;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "给定一个正整数n，返回所有奇数位数字的乘积。\n如果所有数字都是偶数，则返回0。\n例如：", "entry_point": "digits", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/59", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 创建一个函数，该函数以仅包含方括号的字符串作为输入。\n *     如果存在有效的括号子序列且至少有一个括号嵌套，则函数应返回True。\n * is_nested('[[]]') ➞ True\n * is_nested('[]]]]]]][[[[[]') ➞ False\n * is_nested('[][]') ➞ False\n * is_nested('[]') ➞ False\n * is_nested('[[][]]') ➞ True\n * is_nested('[[]][[') ➞ True\n * \n */\nconst is_nested = function (string0: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_nested(\"[[]]\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_nested(\"[]]]]]]][[[[[]\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_nested(\"[][]\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_nested(\"[]\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_nested(\"[[[[]]]]\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_nested(\"[]]]]]]]]]]\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_nested(\"[][][[]]\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_nested(\"[[]\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_nested(\"[]]\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_nested(\"[[]][[\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = is_nested(\"[[][]]\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = is_nested(\"\");\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = is_nested(\"[[[[[[[[\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = is_nested(\"]]]]]]]]\");\nlet expected_14 = false;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\n", "language": "typescript", "description": "创建一个函数，该函数以仅包含方括号的字符串作为输入。\n    如果存在有效的括号子序列且至少有一个括号嵌套，则函数应返回True。", "entry_point": "is_nested", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/60", "prompt": "import * as math from 'mathjs'\n\n/**\n * 你是一位熟练的TypeScript程序员。\n * 给定一个数字列表。\n * 你需要返回给定列表中平方数的总和，\n * 首先将列表中的每个元素四舍五入到上限整数（Ceiling）。\n * 例子：\n * 对于lst = [1,2,3]，输出应该是14\n * 对于lst = [1,4,9]，输出应该是98\n * 对于lst = [1,3,5,7]，输出应该是84\n * 对于lst = [1.4,4.2,0]，输出应该是29\n * 对于lst = [-2.4,1,1]，输出应该是6\n * \n * \n * \n * \n */\nconst sum_squares = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_squares([1, 2, 3]);\nlet expected_1 = 14;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_squares([1.0, 2, 3]);\nlet expected_2 = 14;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_squares([1, 3, 5, 7]);\nlet expected_3 = 84;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_squares([1.4, 4.2, 0]);\nlet expected_4 = 29;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_squares([-2.4, 1, 1]);\nlet expected_5 = 6;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = sum_squares([100, 1, 15, 2]);\nlet expected_6 = 10230;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = sum_squares([10000, 10000]);\nlet expected_7 = 200000000;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = sum_squares([-1.4, 4.6, 6.3]);\nlet expected_8 = 75;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = sum_squares([-1.4, 17.9, 18.9, 19.9]);\nlet expected_9 = 1086;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = sum_squares([0]);\nlet expected_10 = 0;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = sum_squares([-1]);\nlet expected_11 = 1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = sum_squares([-1, 1, 0]);\nlet expected_12 = 2;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\n", "language": "typescript", "description": "给定一个数字列表。\n你需要返回给定列表中平方数的总和，\n首先将列表中的每个元素四舍五入到上限整数（Ceiling）。\n例子：\n对于lst = [1,2,3]，输出应该是14\n对于lst = [1,4,9]，输出应该是98\n对于lst = [1,3,5,7]，输出应该是84\n对于lst = [1.4,4.2,0]，输出应该是29\n对于lst = [-2.4,1,1]，输出应该是6", "entry_point": "sum_squares", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/61", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 创建一个函数，如果给定字符串的最后一个字符是字母字符且不是单词的一部分，则返回True，否则返回False。\n * 注意：“单词”是由空格分隔的一组字符。\n * \n * 例子：\n * \n * check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n * check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n * check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n * check_if_last_char_is_a_letter(\"\") ➞ False \n * \n */\nconst check_if_last_char_is_a_letter = function (txt: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = check_if_last_char_is_a_letter(\"apple\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = check_if_last_char_is_a_letter(\"apple pi e\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = check_if_last_char_is_a_letter(\"eeeee\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = check_if_last_char_is_a_letter(\"A\");\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = check_if_last_char_is_a_letter(\"Pumpkin pie \");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = check_if_last_char_is_a_letter(\"Pumpkin pie 1\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = check_if_last_char_is_a_letter(\"\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = check_if_last_char_is_a_letter(\"eeeee e \");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = check_if_last_char_is_a_letter(\"apple pie\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = check_if_last_char_is_a_letter(\"apple pi e \");\nlet expected_10 = false;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "创建一个函数，如果给定字符串的最后一个字符是字母字符且不是单词的一部分，则返回True，否则返回False。\n注意：“单词”是由空格分隔的一组字符。\n\n例子：", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/62", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 创建一个函数，该函数返回一个元素的最大索引，该元素不大于或等于其前面的元素。如果不存在这样的元素，则返回-1。给定的数组不包含重复值。\n * \n * 例子：\n * \n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n * \n */\nconst can_arrange = function (arr: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = can_arrange([1, 2, 4, 3, 5]);\nlet expected_1 = 3;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = can_arrange([1, 2, 4, 5]);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = can_arrange([1, 4, 2, 5, 6, 7, 8, 9, 10]);\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = can_arrange([4, 8, 5, 7, 3]);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = can_arrange([]);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "创建一个函数，该函数返回一个元素的最大索引，该元素不大于或等于其前面的元素。如果不存在这样的元素，则返回-1。给定的数组不包含重复值。\n\n例子：", "entry_point": "can_arrange", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/63", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 创建一个函数，返回一个元组（a，b），其中'a'是负整数中最大的，'b'是正整数中最小的。如果列表中没有负数或正数，则将它们作为None返回。\n * \n * 例子：\n * \n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n * \n */\nconst largest_smallest_integers = function (lst: Array<number>) : Array<any>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = largest_smallest_integers([2, 4, 1, 3, 5, 7]);\nlet expected_1 = [undefined, 1];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = largest_smallest_integers([2, 4, 1, 3, 5, 7, 0]);\nlet expected_2 = [undefined, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = largest_smallest_integers([1, 3, 2, 4, 5, 6, -2]);\nlet expected_3 = [-2, 1];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = largest_smallest_integers([4, 5, 3, 6, 2, 7, -7]);\nlet expected_4 = [-7, 2];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = largest_smallest_integers([7, 3, 8, 4, 9, 2, 5, -9]);\nlet expected_5 = [-9, 2];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = largest_smallest_integers([]);\nlet expected_6 = [undefined, undefined];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = largest_smallest_integers([0]);\nlet expected_7 = [undefined, undefined];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = largest_smallest_integers([-1, -3, -5, -6]);\nlet expected_8 = [-1, undefined];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = largest_smallest_integers([-1, -3, -5, -6, 0]);\nlet expected_9 = [-1, undefined];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = largest_smallest_integers([-6, -4, -4, -3, 1]);\nlet expected_10 = [-3, 1];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = largest_smallest_integers([-6, -4, -4, -3, -100, 1]);\nlet expected_11 = [-3, 1];\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "创建一个函数，返回一个元组（a，b），其中'a'是负整数中最大的，'b'是正整数中最小的。如果列表中没有负数或正数，则将它们作为None返回。\n\n例子：", "entry_point": "largest_smallest_integers", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/64", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 巴西阶乘被定义为：\n *     巴西阶乘(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     其中 n > 0\n * \n *     例如：\n * >>> special_factorial(4)\n * 288\n * \n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n * \n */\nconst special_factorial = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = special_factorial(4);\nlet expected_1 = 288;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = special_factorial(5);\nlet expected_2 = 34560;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = special_factorial(7);\nlet expected_3 = 125411328000;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = special_factorial(1);\nlet expected_4 = 1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "巴西阶乘被定义为：\n    巴西阶乘(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    其中 n > 0\n\n    例如：", "entry_point": "special_factorial", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/65", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定一个表示句子的字符串，\n * 句子包含一些由空格分隔的单词，\n * 您必须返回一个字符串，其中包含原始句子中长度为质数的单词，\n * 新字符串中单词的顺序应与原始字符串相同。\n * \n * 示例1：\n *     输入：sentence = \"This is a test\"\n *     输出：\"is\"\n * \n * 示例2：\n *     输入：sentence = \"lets go for swimming\"\n *     输出：\"go for\"\n * \n * 限制：\n *     * 1 <= len(sentence) <= 100\n *     * 句子只包含字母\n * \n * \n */\nconst words_in_sentence = function (sentence: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = words_in_sentence(\"This is a test\");\nlet expected_1 = \"is\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = words_in_sentence(\"lets go for swimming\");\nlet expected_2 = \"go for\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = words_in_sentence(\"there is no place available here\");\nlet expected_3 = \"there is no place\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = words_in_sentence(\"Hi I am Hussein\");\nlet expected_4 = \"Hi am Hussein\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = words_in_sentence(\"go for it\");\nlet expected_5 = \"go for it\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = words_in_sentence(\"here\");\nlet expected_6 = \"\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = words_in_sentence(\"here is\");\nlet expected_7 = \"is\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "给定一个表示句子的字符串，\n句子包含一些由空格分隔的单词，\n您必须返回一个字符串，其中包含原始句子中长度为质数的单词，\n新字符串中单词的顺序应与原始字符串相同。\n\n示例1：\n    输入：sentence = \"This is a test\"\n    输出：\"is\"\n\n示例2：\n    输入：sentence = \"lets go for swimming\"\n    输出：\"go for\"\n\n限制：\n    * 1 <= len(sentence) <= 100\n    * 句子只包含字母", "entry_point": "words_in_sentence", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/66", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 你的任务是实现一个函数，简化表达式 x * n。如果 x * n 可以计算为整数，则函数返回 True，否则返回 False。x 和 n 都是分数的字符串表示形式，格式为 <分子>/<分母>，其中分子和分母都是正整数。\n * \n * 你可以假设 x 和 n 都是有效的分数，并且分母不为零。\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n * \n */\nconst simplify = function (x: string, n: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = simplify(\"1/5\",\"5/1\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = simplify(\"1/6\",\"2/1\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = simplify(\"5/1\",\"3/1\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = simplify(\"7/10\",\"10/2\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = simplify(\"2/10\",\"50/10\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = simplify(\"7/2\",\"4/2\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = simplify(\"11/6\",\"6/1\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = simplify(\"2/3\",\"5/2\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = simplify(\"5/2\",\"3/5\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = simplify(\"2/4\",\"8/4\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = simplify(\"2/4\",\"4/2\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = simplify(\"1/5\",\"5/1\");\nlet expected_12 = true;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = simplify(\"1/5\",\"1/5\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\n", "language": "typescript", "description": "你的任务是实现一个函数，简化表达式 x * n。如果 x * n 可以计算为整数，则函数返回 True，否则返回 False。x 和 n 都是分数的字符串表示形式，格式为 <分子>/<分母>，其中分子和分母都是正整数。\n\n你可以假设 x 和 n 都是有效的分数，并且分母不为零。", "entry_point": "simplify", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/67", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 编写一个函数，根据数字的各位数字之和，将给定的整数列表按升序排序。\n * 注意：如果有多个数字的各位数字之和相似，则按照它们在原始列表中的索引排序。\n * \n * 例如：\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n * \n */\nconst order_by_points = function (nums: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = order_by_points([1, 11, -1, -11, -12]);\nlet expected_1 = [-1, -11, 1, -12, 11];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = order_by_points([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]);\nlet expected_2 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = order_by_points([]);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = order_by_points([1, -11, -32, 43, 54, -98, 2, -3]);\nlet expected_4 = [-3, -32, -98, -11, 1, 2, 43, 54];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = order_by_points([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\nlet expected_5 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = order_by_points([0, 6, 6, -76, -21, 23, 4]);\nlet expected_6 = [-76, -21, 0, 4, 23, 6, 6];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "编写一个函数，根据数字的各位数字之和，将给定的整数列表按升序排序。\n注意：如果有多个数字的各位数字之和相似，则按照它们在原始列表中的索引排序。\n\n例如：", "entry_point": "order_by_points", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/68", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 编写一个函数，它以数字数组作为输入，并返回数组中大于10且数字的第一个和最后一个数字都是奇数（1、3、5、7、9）的元素数量。例如：\n * \n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n * \n */\nconst specialFilter = function (nums: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = specialFilter([5, -2, 1, -5]);\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = specialFilter([15, -73, 14, -15]);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = specialFilter([33, -2, -3, 45, 21, 109]);\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = specialFilter([43, -12, 93, 125, 121, 109]);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = specialFilter([71, -2, -33, 75, 21, 19]);\nlet expected_5 = 3;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = specialFilter([1]);\nlet expected_6 = 0;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = specialFilter([]);\nlet expected_7 = 0;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "编写一个函数，它以数字数组作为输入，并返回数组中大于10且数字的第一个和最后一个数字都是奇数（1、3、5、7、9）的元素数量。例如：", "entry_point": "specialFilter", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/69", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定一个正整数n。你需要创建一个长度为n的整数数组a。\n * 对于每个i（1≤i≤n），a[i]的值=i * i-i + 1。\n * 返回a中i <j <k的三元组（a[i]，a[j]，a[k]）的数量，\n * 并且a[i] + a[j] + a[k]是3的倍数。\n * \n * 例子：\n * 输入：n = 5\n * 输出：1\n * 解释：\n * a = [1, 3, 7, 13, 21]\n * 唯一有效的三元组是（1，7，13）。\n * \n * \n */\nconst get_max_triples = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_max_triples(5);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_max_triples(6);\nlet expected_2 = 4;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_max_triples(10);\nlet expected_3 = 36;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_max_triples(100);\nlet expected_4 = 53361;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "给定一个正整数n。你需要创建一个长度为n的整数数组a。\n对于每个i（1≤i≤n），a[i]的值=i * i-i + 1。\n返回a中i <j <k的三元组（a[i]，a[j]，a[k]）的数量，\n并且a[i] + a[j] + a[k]是3的倍数。\n\n例子：\n输入：n = 5\n输出：1\n解释：\na = [1, 3, 7, 13, 21]\n唯一有效的三元组是（1，7，13）。", "entry_point": "get_max_triples", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/70", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 我们的太阳系中有八颗行星：最靠近太阳的是水星，其次是金星，然后是地球、火星、木星、土星、天王星和海王星。编写一个函数，该函数接受两个行星名称作为字符串planet1和planet2。该函数应返回一个元组，其中包含所有轨道位于planet1和planet2之间的行星，按距离太阳的近度排序。如果planet1或planet2不是正确的行星名称，则函数应返回一个空元组。示例\n * \n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n * \n */\nconst bf = function (planet1: string, planet2: string) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = bf(\"Jupiter\",\"Neptune\");\nlet expected_1 = [\"Saturn\", \"Uranus\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = bf(\"Earth\",\"Mercury\");\nlet expected_2 = [\"Venus\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = bf(\"Mercury\",\"Uranus\");\nlet expected_3 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = bf(\"Neptune\",\"Venus\");\nlet expected_4 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = bf(\"Earth\",\"Earth\");\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = bf(\"Mars\",\"Earth\");\nlet expected_6 = [];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = bf(\"Jupiter\",\"Makemake\");\nlet expected_7 = [];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "我们的太阳系中有八颗行星：最靠近太阳的是水星，其次是金星，然后是地球、火星、木星、土星、天王星和海王星。编写一个函数，该函数接受两个行星名称作为字符串planet1和planet2。该函数应返回一个元组，其中包含所有轨道位于planet1和planet2之间的行星，按距离太阳的近度排序。如果planet1或planet2不是正确的行星名称，则函数应返回一个空元组。示例", "entry_point": "bf", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/71", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 一个简单的程序，如果n是质数，则应返回x的值，否则应返回y的值。\n * \n * 例子：\n * \n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n * \n */\nconst x_or_y = function (n: number, x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = x_or_y(7,34,12);\nlet expected_1 = 34;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = x_or_y(15,8,5);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = x_or_y(3,33,5212);\nlet expected_3 = 33;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = x_or_y(1259,3,52);\nlet expected_4 = 3;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = x_or_y(7919,-1,12);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = x_or_y(3609,1245,583);\nlet expected_6 = 583;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = x_or_y(91,56,129);\nlet expected_7 = 129;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = x_or_y(6,34,1234);\nlet expected_8 = 1234;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = x_or_y(1,2,0);\nlet expected_9 = 0;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = x_or_y(2,2,0);\nlet expected_10 = 2;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "一个简单的程序，如果n是质数，则应返回x的值，否则应返回y的值。\n\n例子：", "entry_point": "x_or_y", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/72", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定一个数字列表，返回列表中奇数的平方和。忽略负数或非整数。\n * \n * double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n * double_the_difference([-1, -2, 0]) == 0\n * double_the_difference([9, -2]) == 81\n * double_the_difference([0]) == 0\n * \n * 如果输入列表为空，则返回0。\n * \n * \n */\nconst double_the_difference = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = double_the_difference([]);\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = double_the_difference([5, 4]);\nlet expected_2 = 25;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = double_the_difference([0.1, 0.2, 0.3]);\nlet expected_3 = 0;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = double_the_difference([-10, -20, -30]);\nlet expected_4 = 0;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = double_the_difference([-1, -2, 8]);\nlet expected_5 = 0;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = double_the_difference([0.2, 3, 5]);\nlet expected_6 = 34;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = double_the_difference([-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]);\nlet expected_7 = 166650;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "给定一个数字列表，返回列表中奇数的平方和。忽略负数或非整数。\n\ndouble_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0\n\n如果输入列表为空，则返回0。", "entry_point": "double_the_difference", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/73", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 你将得到一个类的名称（一个字符串）和一个扩展名列表。扩展名用于加载附加的类到该类中。扩展名的强度如下：让CAP为扩展名中大写字母的数量，让SM为扩展名中小写字母的数量，强度由CAP-SM分数给出。您应该找到最强的扩展名并返回一个字符串，格式为：ClassName.StrongestExtensionName。如果有两个或更多的扩展名具有相同的强度，则应选择列表中先出现的扩展名。例如，如果您给出“Slices”作为类和扩展名列表：['SErviNGSliCes'，'Cheese'，'StuFfed']，则应返回'Slices.SErviNGSliCes'，因为'SErviNGSliCes'是最强的扩展名（其强度为-1）。示例：\n * \n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n * \n */\nconst Strongest_Extension = function (class_name: string, extensions: Array<string>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = Strongest_Extension(\"Watashi\",[\"tEN\", \"niNE\", \"eIGHt8OKe\"]);\nlet expected_1 = \"Watashi.eIGHt8OKe\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = Strongest_Extension(\"Boku123\",[\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]);\nlet expected_2 = \"Boku123.YEs.WeCaNe\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = Strongest_Extension(\"__YESIMHERE\",[\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]);\nlet expected_3 = \"__YESIMHERE.NuLl__\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = Strongest_Extension(\"K\",[\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]);\nlet expected_4 = \"K.TAR\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = Strongest_Extension(\"__HAHA\",[\"Tab\", \"123\", \"781345\", \"-_-\"]);\nlet expected_5 = \"__HAHA.123\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = Strongest_Extension(\"YameRore\",[\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]);\nlet expected_6 = \"YameRore.okIWILL123\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = Strongest_Extension(\"finNNalLLly\",[\"Die\", \"NowW\", \"Wow\", \"WoW\"]);\nlet expected_7 = \"finNNalLLly.WoW\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = Strongest_Extension(\"_\",[\"Bb\", \"91245\"]);\nlet expected_8 = \"_.Bb\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = Strongest_Extension(\"Sp\",[\"671235\", \"Bb\"]);\nlet expected_9 = \"Sp.671235\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "你将得到一个类的名称（一个字符串）和一个扩展名列表。扩展名用于加载附加的类到该类中。扩展名的强度如下：让CAP为扩展名中大写字母的数量，让SM为扩展名中小写字母的数量，强度由CAP-SM分数给出。您应该找到最强的扩展名并返回一个字符串，格式为：ClassName.StrongestExtensionName。如果有两个或更多的扩展名具有相同的强度，则应选择列表中先出现的扩展名。例如，如果您给出“Slices”作为类和扩展名列表：['SErviNGSliCes'，'Cheese'，'StuFfed']，则应返回'Slices.SErviNGSliCes'，因为'SErviNGSliCes'是最强的扩展名（其强度为-1）。示例：", "entry_point": "Strongest_Extension", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/74", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 给定两个单词。如果第二个单词或其任何旋转是第一个单词的子字符串，则需要返回True。\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n * \n * \n */\nconst cycpattern_check = function (a: string, b: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = cycpattern_check(\"xyzw\",\"xyw\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = cycpattern_check(\"yello\",\"ell\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = cycpattern_check(\"whattup\",\"ptut\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = cycpattern_check(\"efef\",\"fee\");\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = cycpattern_check(\"abab\",\"aabb\");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = cycpattern_check(\"winemtt\",\"tinem\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "给定两个单词。如果第二个单词或其任何旋转是第一个单词的子字符串，则需要返回True。", "entry_point": "cycpattern_check", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/75", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定一个正整数，将其转换为罗马数字字符串，并以小写形式返回。\n * 限制条件：1 <= num <= 1000\n * \n * 示例：\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n * \n */\nconst int_to_mini_roman = function (number0: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = int_to_mini_roman(19);\nlet expected_1 = \"xix\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = int_to_mini_roman(152);\nlet expected_2 = \"clii\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = int_to_mini_roman(251);\nlet expected_3 = \"ccli\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = int_to_mini_roman(426);\nlet expected_4 = \"cdxxvi\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = int_to_mini_roman(500);\nlet expected_5 = \"d\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = int_to_mini_roman(1);\nlet expected_6 = \"i\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = int_to_mini_roman(4);\nlet expected_7 = \"iv\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = int_to_mini_roman(43);\nlet expected_8 = \"xliii\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = int_to_mini_roman(90);\nlet expected_9 = \"xc\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = int_to_mini_roman(94);\nlet expected_10 = \"xciv\";\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = int_to_mini_roman(532);\nlet expected_11 = \"dxxxii\";\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = int_to_mini_roman(900);\nlet expected_12 = \"cm\";\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = int_to_mini_roman(994);\nlet expected_13 = \"cmxciv\";\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = int_to_mini_roman(1000);\nlet expected_14 = \"m\";\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\n", "language": "typescript", "description": "给定一个正整数，将其转换为罗马数字字符串，并以小写形式返回。\n限制条件：1 <= num <= 1000\n\n示例：", "entry_point": "int_to_mini_roman", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/76", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定三角形的三条边长。如果这三条边可以组成一个直角三角形，则返回True，否则返回False。\n *     直角三角形是一个其中一个角是直角或90度的三角形。\n *     例子：\n * \n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n * \n */\nconst right_angle_triangle = function (a: number, b: number, c: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = right_angle_triangle(3,4,5);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = right_angle_triangle(1,2,3);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = right_angle_triangle(10,6,8);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = right_angle_triangle(2,2,2);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = right_angle_triangle(7,24,25);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = right_angle_triangle(10,5,7);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = right_angle_triangle(5,12,13);\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = right_angle_triangle(15,8,17);\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = right_angle_triangle(48,55,73);\nlet expected_9 = true;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = right_angle_triangle(1,1,1);\nlet expected_10 = false;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = right_angle_triangle(2,2,10);\nlet expected_11 = false;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "给定三角形的三条边长。如果这三条边可以组成一个直角三角形，则返回True，否则返回False。\n    直角三角形是一个其中一个角是直角或90度的三角形。\n    例子：", "entry_point": "right_angle_triangle", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/77", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * 给定一个字符串s。\n * 如果s[i]是一个字母，将其大小写反转，从小写变为大写或反之亦然，\n * 否则保持不变。\n * 如果字符串不包含字母，则反转字符串。\n * 函数应返回结果字符串。\n * 例子\n * \n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n * \n */\nconst solve = function (s: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = solve(\"AsDf\");\nlet expected_1 = \"aSdF\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = solve(\"1234\");\nlet expected_2 = \"4321\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = solve(\"ab\");\nlet expected_3 = \"AB\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = solve(\"#a@C\");\nlet expected_4 = \"#A@c\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = solve(\"#AsdfW^45\");\nlet expected_5 = \"#aSDFw^45\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = solve(\"#6@2\");\nlet expected_6 = \"2@6#\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = solve(\"#$a^D\");\nlet expected_7 = \"#$A^d\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = solve(\"#ccc\");\nlet expected_8 = \"#CCC\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "给定一个字符串s。\n如果s[i]是一个字母，将其大小写反转，从小写变为大写或反之亦然，\n否则保持不变。\n如果字符串不包含字母，则反转字符串。\n函数应返回结果字符串。\n例子", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/78", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定一个字符串“text”，返回其MD5哈希等效字符串。\n * 如果“text”是一个空字符串，则返回null。\n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n * \n */\nconst string_to_md5 = function (text: string) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = string_to_md5(\"Hello world\");\nlet expected_1 = \"3e25960a79dbc69b674cd4ec67a72c62\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = string_to_md5(\"\");\nlet expected_2 = undefined;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = string_to_md5(\"A B C\");\nlet expected_3 = \"0ef78513b0cb8cef12743f5aeb35f888\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = string_to_md5(\"password\");\nlet expected_4 = \"5f4dcc3b5aa765d61d8327deb882cf99\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "给定一个字符串“text”，返回其MD5哈希等效字符串。\n如果“text”是一个空字符串，则返回null。", "entry_point": "string_to_md5", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "typescript/79", "prompt": "/**\n * 你是一位熟练的TypeScript程序员。\n * \n * 给定两个正整数a和b，返回a和b之间的偶数位数字，按升序排列。\n * \n * 例如：\n * \n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n * \n */\nconst generate_integers = function (a: number, b: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = generate_integers(2,10);\nlet expected_1 = [2, 4, 6, 8];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = generate_integers(10,2);\nlet expected_2 = [2, 4, 6, 8];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = generate_integers(132,2);\nlet expected_3 = [2, 4, 6, 8];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = generate_integers(17,89);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "给定两个正整数a和b，返回a和b之间的偶数位数字，按升序排列。\n\n例如：", "entry_point": "generate_integers", "canonical_solution": NaN, "natural_language": "Chinese"}
