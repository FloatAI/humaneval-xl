{"task_id": "typescript/0", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Vous disposez d'une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde de zéro. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit renvoyer True. Sinon, elle doit renvoyer False.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n * \n */\nconst below_zero = function (operations: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = below_zero([]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = below_zero([1, 2, -3, 1, 2, -3]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = below_zero([1, 2, -4, 5, 6]);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = below_zero([1, -1, 2, -2, 5, -5, 4, -4]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = below_zero([1, -1, 2, -2, 5, -5, 4, -5]);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = below_zero([1, -2, 2, -2, 5, -5, 4, -4]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Vous disposez d'une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde de zéro. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit renvoyer True. Sinon, elle doit renvoyer False.", "entry_point": "below_zero", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/1", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Pour une liste donnée d'entiers, retourner un tuple composé d'une somme et d'un produit de tous les entiers de la liste. La somme vide doit être égale à 0 et le produit vide doit être égal à 1.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n * \n */\nconst sum_product = function (numbers: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_product([]);\nlet expected_1 = [0, 1];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_product([1, 1, 1]);\nlet expected_2 = [3, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_product([100, 0]);\nlet expected_3 = [100, 0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_product([3, 5, 7]);\nlet expected_4 = [15, 105];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_product([10]);\nlet expected_5 = [10, 10];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Pour une liste donnée d'entiers, retourner un tuple composé d'une somme et d'un produit de tous les entiers de la liste. La somme vide doit être égale à 0 et le produit vide doit être égal à 1.", "entry_point": "sum_product", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/2", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Les entrées sont deux chaînes de caractères a et b composées uniquement de 1 et de 0.\n * Effectuez une opération XOR binaire sur ces entrées et renvoyez le résultat également sous forme de chaîne de caractères.\n * >>> string_xor('010', '110')\n * '100'\n * \n */\nconst string_xor = function (a: string, b: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = string_xor(\"111000\",\"101010\");\nlet expected_1 = \"010010\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = string_xor(\"1\",\"1\");\nlet expected_2 = \"0\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = string_xor(\"0101\",\"0000\");\nlet expected_3 = \"0101\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "Les entrées sont deux chaînes de caractères a et b composées uniquement de 1 et de 0.\nEffectuez une opération XOR binaire sur ces entrées et renvoyez le résultat également sous forme de chaîne de caractères.", "entry_point": "string_xor", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/3", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * À partir d'une liste de chaînes de caractères, renvoyer la plus longue. Renvoyer la première en cas de plusieurs chaînes de même longueur. Renvoyer null si la liste d'entrée est vide.\n * >>> longest([])\n * \n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n * \n */\nconst longest = function (strings: Array<string>) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = longest([]);\nlet expected_1 = undefined;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = longest([\"x\", \"y\", \"z\"]);\nlet expected_2 = \"x\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = longest([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]);\nlet expected_3 = \"zzzz\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "À partir d'une liste de chaînes de caractères, renvoyer la plus longue. Renvoyer la première en cas de plusieurs chaînes de même longueur. Renvoyer null si la liste d'entrée est vide.", "entry_point": "longest", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/4", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Retourne le plus grand commun diviseur de deux entiers a et b.\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n * \n */\nconst greatest_common_divisor = function (a: number, b: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = greatest_common_divisor(3,7);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = greatest_common_divisor(10,15);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = greatest_common_divisor(49,14);\nlet expected_3 = 7;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = greatest_common_divisor(144,60);\nlet expected_4 = 12;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Retourne le plus grand commun diviseur de deux entiers a et b.", "entry_point": "greatest_common_divisor", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/5", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * L'entrée est une chaîne de caractères séparée par des espaces contenant des chiffres de 'zéro' à 'neuf'.\n *     Les choix valides sont 'zéro', 'un', 'deux', 'trois', 'quatre', 'cinq', 'six', 'sept', 'huit' et 'neuf'.\n *     Renvoyer la chaîne avec les chiffres triés par ordre croissant.\n * >>> sort_numbers('three one five')\n * 'one three five'\n * \n */\nconst sort_numbers = function (numbers: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sort_numbers(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sort_numbers(\"three\");\nlet expected_2 = \"three\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sort_numbers(\"three five nine\");\nlet expected_3 = \"three five nine\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sort_numbers(\"five zero four seven nine eight\");\nlet expected_4 = \"zero four five seven eight nine\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sort_numbers(\"six five four three two one zero\");\nlet expected_5 = \"zero one two three four five six\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "L'entrée est une chaîne de caractères séparée par des espaces contenant des chiffres de 'zéro' à 'neuf'.\n    Les choix valides sont 'zéro', 'un', 'deux', 'trois', 'quatre', 'cinq', 'six', 'sept', 'huit' et 'neuf'.\n    Renvoyer la chaîne avec les chiffres triés par ordre croissant.", "entry_point": "sort_numbers", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/6", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Étant donné une liste de nombres (d'au moins deux éléments), appliquez une transformation linéaire à cette liste, de sorte que le plus petit nombre devienne 0 et le plus grand devienne 1.\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n * \n */\nconst rescale_to_unit = function (numbers: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = rescale_to_unit([2.0, 49.9]);\nlet expected_1 = [0.0, 1.0];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = rescale_to_unit([100.0, 49.9]);\nlet expected_2 = [1.0, 0.0];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]);\nlet expected_3 = [0.0, 0.25, 0.5, 0.75, 1.0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]);\nlet expected_4 = [0.25, 0.0, 1.0, 0.5, 0.75];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]);\nlet expected_5 = [0.25, 0.0, 1.0, 0.5, 0.75];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné une liste de nombres (d'au moins deux éléments), appliquez une transformation linéaire à cette liste, de sorte que le plus petit nombre devienne 0 et le plus grand devienne 1.", "entry_point": "rescale_to_unit", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/7", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Pour une chaîne de caractères donnée, inverser les caractères en minuscules en majuscules et les caractères en majuscules en minuscules.\n * >>> flip_case('Hello')\n * 'hELLO'\n * \n */\nconst flip_case = function (string0: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = flip_case(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = flip_case(\"Hello!\");\nlet expected_2 = \"hELLO!\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = flip_case(\"These violent delights have violent ends\");\nlet expected_3 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "Pour une chaîne de caractères donnée, inverser les caractères en minuscules en majuscules et les caractères en majuscules en minuscules.", "entry_point": "flip_case", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/8", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Retourner seulement les nombres positifs dans la liste.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n * \n */\nconst get_positive = function (l: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_positive([-1, -2, 4, 5, 6]);\nlet expected_1 = [4, 5, 6];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]);\nlet expected_2 = [5, 3, 2, 3, 3, 9, 123, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_positive([-1, -2]);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_positive([]);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Retourner seulement les nombres positifs dans la liste.", "entry_point": "get_positive", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/9", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Retourne vrai si un nombre donné est premier, et faux sinon.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n * \n */\nconst is_prime = function (n: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_prime(6);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_prime(101);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_prime(11);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_prime(13441);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_prime(61);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_prime(4);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_prime(1);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_prime(5);\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_prime(11);\nlet expected_9 = true;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_prime(17);\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = is_prime(85);\nlet expected_11 = false;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = is_prime(77);\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = is_prime(255379);\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\n", "language": "typescript", "description": "Retourne vrai si un nombre donné est premier, et faux sinon.", "entry_point": "is_prime", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/10", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Retourner les éléments uniques triés dans une liste.\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n * \n */\nconst unique = function (l: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = unique([5, 3, 5, 2, 3, 3, 9, 0, 123]);\nlet expected_1 = [0, 2, 3, 5, 9, 123];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\n", "language": "typescript", "description": "Retourner les éléments uniques triés dans une liste.", "entry_point": "unique", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/11", "prompt": "import * as math from 'mathjs'\n\n/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * prime_fib renvoie le n-ième nombre qui est à la fois un nombre de Fibonacci et un nombre premier.\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n * \n */\nconst prime_fib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = prime_fib(1);\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = prime_fib(2);\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = prime_fib(3);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = prime_fib(4);\nlet expected_4 = 13;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = prime_fib(5);\nlet expected_5 = 89;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = prime_fib(6);\nlet expected_6 = 233;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = prime_fib(7);\nlet expected_7 = 1597;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = prime_fib(8);\nlet expected_8 = 28657;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = prime_fib(9);\nlet expected_9 = 514229;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = prime_fib(10);\nlet expected_10 = 433494437;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "prime_fib renvoie le n-ième nombre qui est à la fois un nombre de Fibonacci et un nombre premier.", "entry_point": "prime_fib", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/12", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * triples_sum_to_zero prend une liste d'entiers en entrée.\n *     Elle renvoie True s'il y a trois éléments distincts dans la liste qui\n *     s'additionnent à zéro, et False sinon.\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n * \n */\nconst triples_sum_to_zero = function (l: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = triples_sum_to_zero([1, 3, 5, 0]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = triples_sum_to_zero([1, 3, 5, -1]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = triples_sum_to_zero([1, 3, -2, 1]);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = triples_sum_to_zero([1, 2, 3, 7]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = triples_sum_to_zero([1, 2, 5, 7]);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = triples_sum_to_zero([2, 4, -5, 3, 9, 7]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = triples_sum_to_zero([1]);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = triples_sum_to_zero([1, 3, 5, -100]);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = triples_sum_to_zero([100, 3, 5, -100]);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "triples_sum_to_zero prend une liste d'entiers en entrée.\n    Elle renvoie True s'il y a trois éléments distincts dans la liste qui\n    s'additionnent à zéro, et False sinon.", "entry_point": "triples_sum_to_zero", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/13", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * pairs_sum_to_zero prend une liste d'entiers en entrée.\n *     Elle renvoie True s'il y a deux éléments distincts dans la liste qui\n *     s'additionnent à zéro, et False sinon.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n * \n */\nconst pairs_sum_to_zero = function (l: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = pairs_sum_to_zero([1, 3, 5, 0]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = pairs_sum_to_zero([1, 3, -2, 1]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = pairs_sum_to_zero([1, 2, 3, 7]);\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = pairs_sum_to_zero([2, 4, -5, 3, 5, 7]);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = pairs_sum_to_zero([1]);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]);\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "pairs_sum_to_zero prend une liste d'entiers en entrée.\n    Elle renvoie True s'il y a deux éléments distincts dans la liste qui\n    s'additionnent à zéro, et False sinon.", "entry_point": "pairs_sum_to_zero", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/14", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * La séquence de nombres Fib4 est une séquence similaire à la séquence de Fibonacci définie comme suit:\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n *     Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres Fib4. N'utilisez pas la récursivité.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n * \n */\nconst fib4 = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fib4(5);\nlet expected_1 = 4;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fib4(8);\nlet expected_2 = 28;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fib4(10);\nlet expected_3 = 104;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fib4(12);\nlet expected_4 = 386;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "La séquence de nombres Fib4 est une séquence similaire à la séquence de Fibonacci définie comme suit:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres Fib4. N'utilisez pas la récursivité.", "entry_point": "fib4", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/15", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Retourne la médiane des éléments de la liste l.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n * \n */\nconst median = function (l: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = median([3, 1, 2, 4, 5]);\nlet expected_1 = 3;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = median([-10, 4, 6, 1000, 10, 20]);\nlet expected_2 = 8.0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = median([5]);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = median([6, 5]);\nlet expected_4 = 5.5;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = median([8, 1, 3, 9, 9, 2, 7]);\nlet expected_5 = 7;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Retourne la médiane des éléments de la liste l.", "entry_point": "median", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/16", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Vérifie si la chaîne de caractères donnée est un palindrome.\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n * \n */\nconst is_palindrome = function (text: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_palindrome(\"\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_palindrome(\"aba\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_palindrome(\"aaaaa\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_palindrome(\"zbcd\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_palindrome(\"xywyx\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_palindrome(\"xywyz\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_palindrome(\"xywzx\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Vérifie si la chaîne de caractères donnée est un palindrome.", "entry_point": "is_palindrome", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/17", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * remove_vowels est une fonction qui prend une chaîne de caractères et renvoie une chaîne de caractères sans voyelles.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n * \n */\nconst remove_vowels = function (text: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = remove_vowels(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = remove_vowels(\"abcdef\\nghijklm\");\nlet expected_2 = \"bcdf\\nghjklm\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = remove_vowels(\"fedcba\");\nlet expected_3 = \"fdcb\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = remove_vowels(\"eeeee\");\nlet expected_4 = \"\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = remove_vowels(\"acBAA\");\nlet expected_5 = \"cB\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = remove_vowels(\"EcBOO\");\nlet expected_6 = \"cB\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = remove_vowels(\"ybcd\");\nlet expected_7 = \"ybcd\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "remove_vowels est une fonction qui prend une chaîne de caractères et renvoie une chaîne de caractères sans voyelles.", "entry_point": "remove_vowels", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/18", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Retourne True si tous les nombres de la liste l sont en dessous du seuil t.\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n * \n */\nconst below_threshold = function (l: Array<number>, t: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = below_threshold([1, 2, 4, 10],100);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = below_threshold([1, 20, 4, 10],5);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = below_threshold([1, 20, 4, 10],21);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = below_threshold([1, 20, 4, 10],22);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = below_threshold([1, 8, 4, 10],11);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = below_threshold([1, 8, 4, 10],10);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Retourne True si tous les nombres de la liste l sont en dessous du seuil t.", "entry_point": "below_threshold", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/19", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Ajouter deux nombres x et y\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n * \n */\nconst add = function (x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = add(0,1);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = add(1,0);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = add(2,3);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = add(5,7);\nlet expected_4 = 12;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = add(7,5);\nlet expected_5 = 12;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = add(572,725);\nlet expected_6 = 1297;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = add(51,804);\nlet expected_7 = 855;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = add(645,96);\nlet expected_8 = 741;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = add(712,853);\nlet expected_9 = 1565;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = add(223,101);\nlet expected_10 = 324;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = add(76,29);\nlet expected_11 = 105;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = add(416,149);\nlet expected_12 = 565;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = add(145,409);\nlet expected_13 = 554;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = add(535,430);\nlet expected_14 = 965;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = add(118,303);\nlet expected_15 = 421;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = add(287,94);\nlet expected_16 = 381;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\nlet actual_17 = add(768,257);\nlet expected_17 = 1025;\nassert.deepEqual(actual_17, expected_17, \"Exception --- test case 16 failed to pass\");\n\nlet actual_18 = add(421,677);\nlet expected_18 = 1098;\nassert.deepEqual(actual_18, expected_18, \"Exception --- test case 17 failed to pass\");\n\nlet actual_19 = add(802,814);\nlet expected_19 = 1616;\nassert.deepEqual(actual_19, expected_19, \"Exception --- test case 18 failed to pass\");\n\nlet actual_20 = add(510,922);\nlet expected_20 = 1432;\nassert.deepEqual(actual_20, expected_20, \"Exception --- test case 19 failed to pass\");\n\nlet actual_21 = add(345,819);\nlet expected_21 = 1164;\nassert.deepEqual(actual_21, expected_21, \"Exception --- test case 20 failed to pass\");\n\nlet actual_22 = add(895,436);\nlet expected_22 = 1331;\nassert.deepEqual(actual_22, expected_22, \"Exception --- test case 21 failed to pass\");\n\nlet actual_23 = add(123,424);\nlet expected_23 = 547;\nassert.deepEqual(actual_23, expected_23, \"Exception --- test case 22 failed to pass\");\n\nlet actual_24 = add(923,245);\nlet expected_24 = 1168;\nassert.deepEqual(actual_24, expected_24, \"Exception --- test case 23 failed to pass\");\n\nlet actual_25 = add(23,438);\nlet expected_25 = 461;\nassert.deepEqual(actual_25, expected_25, \"Exception --- test case 24 failed to pass\");\n\nlet actual_26 = add(565,133);\nlet expected_26 = 698;\nassert.deepEqual(actual_26, expected_26, \"Exception --- test case 25 failed to pass\");\n\nlet actual_27 = add(945,925);\nlet expected_27 = 1870;\nassert.deepEqual(actual_27, expected_27, \"Exception --- test case 26 failed to pass\");\n\nlet actual_28 = add(261,983);\nlet expected_28 = 1244;\nassert.deepEqual(actual_28, expected_28, \"Exception --- test case 27 failed to pass\");\n\nlet actual_29 = add(139,577);\nlet expected_29 = 716;\nassert.deepEqual(actual_29, expected_29, \"Exception --- test case 28 failed to pass\");\n\nlet actual_30 = add(763,178);\nlet expected_30 = 941;\nassert.deepEqual(actual_30, expected_30, \"Exception --- test case 29 failed to pass\");\n\nlet actual_31 = add(147,892);\nlet expected_31 = 1039;\nassert.deepEqual(actual_31, expected_31, \"Exception --- test case 30 failed to pass\");\n\nlet actual_32 = add(436,402);\nlet expected_32 = 838;\nassert.deepEqual(actual_32, expected_32, \"Exception --- test case 31 failed to pass\");\n\nlet actual_33 = add(610,581);\nlet expected_33 = 1191;\nassert.deepEqual(actual_33, expected_33, \"Exception --- test case 32 failed to pass\");\n\nlet actual_34 = add(103,416);\nlet expected_34 = 519;\nassert.deepEqual(actual_34, expected_34, \"Exception --- test case 33 failed to pass\");\n\nlet actual_35 = add(339,990);\nlet expected_35 = 1329;\nassert.deepEqual(actual_35, expected_35, \"Exception --- test case 34 failed to pass\");\n\nlet actual_36 = add(130,504);\nlet expected_36 = 634;\nassert.deepEqual(actual_36, expected_36, \"Exception --- test case 35 failed to pass\");\n\nlet actual_37 = add(242,717);\nlet expected_37 = 959;\nassert.deepEqual(actual_37, expected_37, \"Exception --- test case 36 failed to pass\");\n\nlet actual_38 = add(562,110);\nlet expected_38 = 672;\nassert.deepEqual(actual_38, expected_38, \"Exception --- test case 37 failed to pass\");\n\nlet actual_39 = add(396,909);\nlet expected_39 = 1305;\nassert.deepEqual(actual_39, expected_39, \"Exception --- test case 38 failed to pass\");\n\nlet actual_40 = add(887,703);\nlet expected_40 = 1590;\nassert.deepEqual(actual_40, expected_40, \"Exception --- test case 39 failed to pass\");\n\nlet actual_41 = add(870,551);\nlet expected_41 = 1421;\nassert.deepEqual(actual_41, expected_41, \"Exception --- test case 40 failed to pass\");\n\nlet actual_42 = add(422,391);\nlet expected_42 = 813;\nassert.deepEqual(actual_42, expected_42, \"Exception --- test case 41 failed to pass\");\n\nlet actual_43 = add(299,505);\nlet expected_43 = 804;\nassert.deepEqual(actual_43, expected_43, \"Exception --- test case 42 failed to pass\");\n\nlet actual_44 = add(346,56);\nlet expected_44 = 402;\nassert.deepEqual(actual_44, expected_44, \"Exception --- test case 43 failed to pass\");\n\nlet actual_45 = add(36,706);\nlet expected_45 = 742;\nassert.deepEqual(actual_45, expected_45, \"Exception --- test case 44 failed to pass\");\n\nlet actual_46 = add(738,411);\nlet expected_46 = 1149;\nassert.deepEqual(actual_46, expected_46, \"Exception --- test case 45 failed to pass\");\n\nlet actual_47 = add(679,87);\nlet expected_47 = 766;\nassert.deepEqual(actual_47, expected_47, \"Exception --- test case 46 failed to pass\");\n\nlet actual_48 = add(25,303);\nlet expected_48 = 328;\nassert.deepEqual(actual_48, expected_48, \"Exception --- test case 47 failed to pass\");\n\nlet actual_49 = add(161,612);\nlet expected_49 = 773;\nassert.deepEqual(actual_49, expected_49, \"Exception --- test case 48 failed to pass\");\n\nlet actual_50 = add(306,841);\nlet expected_50 = 1147;\nassert.deepEqual(actual_50, expected_50, \"Exception --- test case 49 failed to pass\");\n\nlet actual_51 = add(973,411);\nlet expected_51 = 1384;\nassert.deepEqual(actual_51, expected_51, \"Exception --- test case 50 failed to pass\");\n\nlet actual_52 = add(711,157);\nlet expected_52 = 868;\nassert.deepEqual(actual_52, expected_52, \"Exception --- test case 51 failed to pass\");\n\nlet actual_53 = add(471,27);\nlet expected_53 = 498;\nassert.deepEqual(actual_53, expected_53, \"Exception --- test case 52 failed to pass\");\n\nlet actual_54 = add(714,792);\nlet expected_54 = 1506;\nassert.deepEqual(actual_54, expected_54, \"Exception --- test case 53 failed to pass\");\n\nlet actual_55 = add(38,206);\nlet expected_55 = 244;\nassert.deepEqual(actual_55, expected_55, \"Exception --- test case 54 failed to pass\");\n\nlet actual_56 = add(907,343);\nlet expected_56 = 1250;\nassert.deepEqual(actual_56, expected_56, \"Exception --- test case 55 failed to pass\");\n\nlet actual_57 = add(23,760);\nlet expected_57 = 783;\nassert.deepEqual(actual_57, expected_57, \"Exception --- test case 56 failed to pass\");\n\nlet actual_58 = add(524,859);\nlet expected_58 = 1383;\nassert.deepEqual(actual_58, expected_58, \"Exception --- test case 57 failed to pass\");\n\nlet actual_59 = add(30,529);\nlet expected_59 = 559;\nassert.deepEqual(actual_59, expected_59, \"Exception --- test case 58 failed to pass\");\n\nlet actual_60 = add(341,691);\nlet expected_60 = 1032;\nassert.deepEqual(actual_60, expected_60, \"Exception --- test case 59 failed to pass\");\n\nlet actual_61 = add(167,729);\nlet expected_61 = 896;\nassert.deepEqual(actual_61, expected_61, \"Exception --- test case 60 failed to pass\");\n\nlet actual_62 = add(636,289);\nlet expected_62 = 925;\nassert.deepEqual(actual_62, expected_62, \"Exception --- test case 61 failed to pass\");\n\nlet actual_63 = add(503,144);\nlet expected_63 = 647;\nassert.deepEqual(actual_63, expected_63, \"Exception --- test case 62 failed to pass\");\n\nlet actual_64 = add(51,985);\nlet expected_64 = 1036;\nassert.deepEqual(actual_64, expected_64, \"Exception --- test case 63 failed to pass\");\n\nlet actual_65 = add(287,149);\nlet expected_65 = 436;\nassert.deepEqual(actual_65, expected_65, \"Exception --- test case 64 failed to pass\");\n\nlet actual_66 = add(659,75);\nlet expected_66 = 734;\nassert.deepEqual(actual_66, expected_66, \"Exception --- test case 65 failed to pass\");\n\nlet actual_67 = add(462,797);\nlet expected_67 = 1259;\nassert.deepEqual(actual_67, expected_67, \"Exception --- test case 66 failed to pass\");\n\nlet actual_68 = add(406,141);\nlet expected_68 = 547;\nassert.deepEqual(actual_68, expected_68, \"Exception --- test case 67 failed to pass\");\n\nlet actual_69 = add(106,44);\nlet expected_69 = 150;\nassert.deepEqual(actual_69, expected_69, \"Exception --- test case 68 failed to pass\");\n\nlet actual_70 = add(300,934);\nlet expected_70 = 1234;\nassert.deepEqual(actual_70, expected_70, \"Exception --- test case 69 failed to pass\");\n\nlet actual_71 = add(471,524);\nlet expected_71 = 995;\nassert.deepEqual(actual_71, expected_71, \"Exception --- test case 70 failed to pass\");\n\nlet actual_72 = add(122,429);\nlet expected_72 = 551;\nassert.deepEqual(actual_72, expected_72, \"Exception --- test case 71 failed to pass\");\n\nlet actual_73 = add(735,195);\nlet expected_73 = 930;\nassert.deepEqual(actual_73, expected_73, \"Exception --- test case 72 failed to pass\");\n\nlet actual_74 = add(335,484);\nlet expected_74 = 819;\nassert.deepEqual(actual_74, expected_74, \"Exception --- test case 73 failed to pass\");\n\nlet actual_75 = add(28,809);\nlet expected_75 = 837;\nassert.deepEqual(actual_75, expected_75, \"Exception --- test case 74 failed to pass\");\n\nlet actual_76 = add(430,20);\nlet expected_76 = 450;\nassert.deepEqual(actual_76, expected_76, \"Exception --- test case 75 failed to pass\");\n\nlet actual_77 = add(916,635);\nlet expected_77 = 1551;\nassert.deepEqual(actual_77, expected_77, \"Exception --- test case 76 failed to pass\");\n\nlet actual_78 = add(301,999);\nlet expected_78 = 1300;\nassert.deepEqual(actual_78, expected_78, \"Exception --- test case 77 failed to pass\");\n\nlet actual_79 = add(454,466);\nlet expected_79 = 920;\nassert.deepEqual(actual_79, expected_79, \"Exception --- test case 78 failed to pass\");\n\nlet actual_80 = add(905,259);\nlet expected_80 = 1164;\nassert.deepEqual(actual_80, expected_80, \"Exception --- test case 79 failed to pass\");\n\nlet actual_81 = add(168,205);\nlet expected_81 = 373;\nassert.deepEqual(actual_81, expected_81, \"Exception --- test case 80 failed to pass\");\n\nlet actual_82 = add(570,434);\nlet expected_82 = 1004;\nassert.deepEqual(actual_82, expected_82, \"Exception --- test case 81 failed to pass\");\n\nlet actual_83 = add(64,959);\nlet expected_83 = 1023;\nassert.deepEqual(actual_83, expected_83, \"Exception --- test case 82 failed to pass\");\n\nlet actual_84 = add(957,510);\nlet expected_84 = 1467;\nassert.deepEqual(actual_84, expected_84, \"Exception --- test case 83 failed to pass\");\n\nlet actual_85 = add(722,598);\nlet expected_85 = 1320;\nassert.deepEqual(actual_85, expected_85, \"Exception --- test case 84 failed to pass\");\n\nlet actual_86 = add(770,226);\nlet expected_86 = 996;\nassert.deepEqual(actual_86, expected_86, \"Exception --- test case 85 failed to pass\");\n\nlet actual_87 = add(579,66);\nlet expected_87 = 645;\nassert.deepEqual(actual_87, expected_87, \"Exception --- test case 86 failed to pass\");\n\nlet actual_88 = add(117,674);\nlet expected_88 = 791;\nassert.deepEqual(actual_88, expected_88, \"Exception --- test case 87 failed to pass\");\n\nlet actual_89 = add(530,30);\nlet expected_89 = 560;\nassert.deepEqual(actual_89, expected_89, \"Exception --- test case 88 failed to pass\");\n\nlet actual_90 = add(776,345);\nlet expected_90 = 1121;\nassert.deepEqual(actual_90, expected_90, \"Exception --- test case 89 failed to pass\");\n\nlet actual_91 = add(327,389);\nlet expected_91 = 716;\nassert.deepEqual(actual_91, expected_91, \"Exception --- test case 90 failed to pass\");\n\nlet actual_92 = add(596,12);\nlet expected_92 = 608;\nassert.deepEqual(actual_92, expected_92, \"Exception --- test case 91 failed to pass\");\n\nlet actual_93 = add(599,511);\nlet expected_93 = 1110;\nassert.deepEqual(actual_93, expected_93, \"Exception --- test case 92 failed to pass\");\n\nlet actual_94 = add(936,476);\nlet expected_94 = 1412;\nassert.deepEqual(actual_94, expected_94, \"Exception --- test case 93 failed to pass\");\n\nlet actual_95 = add(461,14);\nlet expected_95 = 475;\nassert.deepEqual(actual_95, expected_95, \"Exception --- test case 94 failed to pass\");\n\nlet actual_96 = add(966,157);\nlet expected_96 = 1123;\nassert.deepEqual(actual_96, expected_96, \"Exception --- test case 95 failed to pass\");\n\nlet actual_97 = add(326,91);\nlet expected_97 = 417;\nassert.deepEqual(actual_97, expected_97, \"Exception --- test case 96 failed to pass\");\n\nlet actual_98 = add(392,455);\nlet expected_98 = 847;\nassert.deepEqual(actual_98, expected_98, \"Exception --- test case 97 failed to pass\");\n\nlet actual_99 = add(446,477);\nlet expected_99 = 923;\nassert.deepEqual(actual_99, expected_99, \"Exception --- test case 98 failed to pass\");\n\nlet actual_100 = add(324,860);\nlet expected_100 = 1184;\nassert.deepEqual(actual_100, expected_100, \"Exception --- test case 99 failed to pass\");\n\nlet actual_101 = add(945,85);\nlet expected_101 = 1030;\nassert.deepEqual(actual_101, expected_101, \"Exception --- test case 100 failed to pass\");\n\nlet actual_102 = add(886,582);\nlet expected_102 = 1468;\nassert.deepEqual(actual_102, expected_102, \"Exception --- test case 101 failed to pass\");\n\nlet actual_103 = add(886,712);\nlet expected_103 = 1598;\nassert.deepEqual(actual_103, expected_103, \"Exception --- test case 102 failed to pass\");\n\nlet actual_104 = add(842,953);\nlet expected_104 = 1795;\nassert.deepEqual(actual_104, expected_104, \"Exception --- test case 103 failed to pass\");\n\n", "language": "typescript", "description": "Ajouter deux nombres x et y", "entry_point": "add", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/20", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Vérifiez si deux mots ont les mêmes caractères.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n * \n */\nconst same_chars = function (s0: string, s1: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = same_chars(\"eabcdzzzz\",\"dddzzzzzzzddeddabc\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = same_chars(\"abcd\",\"dddddddabc\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = same_chars(\"dddddddabc\",\"abcd\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = same_chars(\"eabcd\",\"dddddddabc\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = same_chars(\"abcd\",\"dddddddabcf\");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = same_chars(\"eabcdzzzz\",\"dddzzzzzzzddddabc\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = same_chars(\"aabb\",\"aaccc\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Vérifiez si deux mots ont les mêmes caractères.", "entry_point": "same_chars", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/21", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Retourne le n-ième nombre de Fibonacci.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n * \n */\nconst fib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fib(10);\nlet expected_1 = 55;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fib(1);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fib(8);\nlet expected_3 = 21;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fib(11);\nlet expected_4 = 89;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = fib(12);\nlet expected_5 = 144;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Retourne le n-ième nombre de Fibonacci.", "entry_point": "fib", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/22", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Retourne les éléments communs uniques triés pour deux listes.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n * \n * \n */\nconst common = function (l1: Array<number>, l2: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = common([1, 4, 3, 34, 653, 2, 5],[5, 7, 1, 5, 9, 653, 121]);\nlet expected_1 = [1, 5, 653];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = common([5, 3, 2, 8],[3, 2]);\nlet expected_2 = [2, 3];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = common([4, 3, 2, 8],[3, 2, 4]);\nlet expected_3 = [2, 3, 4];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = common([4, 3, 2, 8],[]);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Retourne les éléments communs uniques triés pour deux listes.", "entry_point": "common", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/23", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Retourne le plus grand facteur premier de n. Supposons que n > 1 et n'est pas un nombre premier.\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n * \n */\nconst largest_prime_factor = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = largest_prime_factor(15);\nlet expected_1 = 5;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = largest_prime_factor(27);\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = largest_prime_factor(63);\nlet expected_3 = 7;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = largest_prime_factor(330);\nlet expected_4 = 11;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = largest_prime_factor(13195);\nlet expected_5 = 29;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Retourne le plus grand facteur premier de n. Supposons que n > 1 et n'est pas un nombre premier.", "entry_point": "largest_prime_factor", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/24", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * sum_to_n est une fonction qui additionne les nombres de 1 à n.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n * \n */\nconst sum_to_n = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_to_n(1);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_to_n(6);\nlet expected_2 = 21;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_to_n(11);\nlet expected_3 = 66;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_to_n(30);\nlet expected_4 = 465;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_to_n(100);\nlet expected_5 = 5050;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "sum_to_n est une fonction qui additionne les nombres de 1 à n.", "entry_point": "sum_to_n", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/25", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * xs représente les coefficients d'un polynôme.\n *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n *      Renvoyer la dérivée de ce polynôme sous la même forme.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n * \n */\nconst derivative = function (xs: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = derivative([3, 1, 2, 4, 5]);\nlet expected_1 = [1, 4, 12, 20];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = derivative([1, 2, 3]);\nlet expected_2 = [2, 6];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = derivative([3, 2, 1]);\nlet expected_3 = [2, 2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = derivative([3, 2, 1, 0, 4]);\nlet expected_4 = [2, 2, 0, 16];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = derivative([1]);\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "xs représente les coefficients d'un polynôme.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Renvoyer la dérivée de ce polynôme sous la même forme.", "entry_point": "derivative", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/26", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * La séquence de nombres FibFib est une séquence similaire à la séquence de Fibonacci définie comme suit :\n *     fibfib(0) == 0\n *     fibfib(1) == 0\n *     fibfib(2) == 1\n *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n *     Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres FibFib.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n * \n */\nconst fibfib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fibfib(2);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fibfib(1);\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fibfib(5);\nlet expected_3 = 4;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fibfib(8);\nlet expected_4 = 24;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = fibfib(10);\nlet expected_5 = 81;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = fibfib(12);\nlet expected_6 = 274;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = fibfib(14);\nlet expected_7 = 927;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "La séquence de nombres FibFib est une séquence similaire à la séquence de Fibonacci définie comme suit :\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres FibFib.", "entry_point": "fibfib", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/27", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Écrivez une fonction vowels_count qui prend une chaîne de caractères représentant un mot en entrée et renvoie le nombre de voyelles dans la chaîne. Les voyelles dans ce cas sont 'a', 'e', 'i', 'o', 'u'. Ici, 'y' est également une voyelle, mais seulement lorsqu'elle est à la fin du mot donné.\n * \n * Exemple :\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n * \n */\nconst vowels_count = function (s: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = vowels_count(\"abcde\");\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = vowels_count(\"Alone\");\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = vowels_count(\"key\");\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = vowels_count(\"bye\");\nlet expected_4 = 1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = vowels_count(\"keY\");\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = vowels_count(\"bYe\");\nlet expected_6 = 1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = vowels_count(\"ACEDY\");\nlet expected_7 = 3;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Écrivez une fonction vowels_count qui prend une chaîne de caractères représentant un mot en entrée et renvoie le nombre de voyelles dans la chaîne. Les voyelles dans ce cas sont 'a', 'e', 'i', 'o', 'u'. Ici, 'y' est également une voyelle, mais seulement lorsqu'elle est à la fin du mot donné.\n\nExemple :", "entry_point": "vowels_count", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/28", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Vous disposez d'une liste non vide d'entiers positifs. Renvoyez l'entier le plus grand qui est supérieur à zéro et dont la fréquence est supérieure ou égale à la valeur de l'entier lui-même. La fréquence d'un entier est le nombre de fois où il apparaît dans la liste. Si aucune valeur de ce type n'existe, renvoyez -1. Exemples :\n * \n * search([4, 1, 2, 2, 3, 1]) == 2\n * search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n * search([5, 5, 4, 4, 4]) == -1\n * \n */\nconst search = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = search([5, 5, 5, 5, 1]);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = search([4, 1, 4, 1, 4, 4]);\nlet expected_2 = 4;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = search([3, 3]);\nlet expected_3 = -1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = search([8, 8, 8, 8, 8, 8, 8, 8]);\nlet expected_4 = 8;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = search([2, 3, 3, 2, 2]);\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = search([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]);\nlet expected_6 = 1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = search([3, 2, 8, 2]);\nlet expected_7 = 2;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]);\nlet expected_8 = 1;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = search([8, 8, 3, 6, 5, 6, 4]);\nlet expected_9 = -1;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = search([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]);\nlet expected_10 = 1;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = search([1, 9, 10, 1, 3]);\nlet expected_11 = 1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = search([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]);\nlet expected_12 = 5;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = search([1]);\nlet expected_13 = 1;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = search([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]);\nlet expected_14 = 4;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]);\nlet expected_15 = 2;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]);\nlet expected_16 = 1;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\nlet actual_17 = search([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]);\nlet expected_17 = 4;\nassert.deepEqual(actual_17, expected_17, \"Exception --- test case 16 failed to pass\");\n\nlet actual_18 = search([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]);\nlet expected_18 = 4;\nassert.deepEqual(actual_18, expected_18, \"Exception --- test case 17 failed to pass\");\n\nlet actual_19 = search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]);\nlet expected_19 = 2;\nassert.deepEqual(actual_19, expected_19, \"Exception --- test case 18 failed to pass\");\n\nlet actual_20 = search([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]);\nlet expected_20 = -1;\nassert.deepEqual(actual_20, expected_20, \"Exception --- test case 19 failed to pass\");\n\nlet actual_21 = search([10]);\nlet expected_21 = -1;\nassert.deepEqual(actual_21, expected_21, \"Exception --- test case 20 failed to pass\");\n\nlet actual_22 = search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]);\nlet expected_22 = 2;\nassert.deepEqual(actual_22, expected_22, \"Exception --- test case 21 failed to pass\");\n\nlet actual_23 = search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]);\nlet expected_23 = 1;\nassert.deepEqual(actual_23, expected_23, \"Exception --- test case 22 failed to pass\");\n\nlet actual_24 = search([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]);\nlet expected_24 = 1;\nassert.deepEqual(actual_24, expected_24, \"Exception --- test case 23 failed to pass\");\n\nlet actual_25 = search([3, 10, 10, 9, 2]);\nlet expected_25 = -1;\nassert.deepEqual(actual_25, expected_25, \"Exception --- test case 24 failed to pass\");\n\n", "language": "typescript", "description": "Vous disposez d'une liste non vide d'entiers positifs. Renvoyez l'entier le plus grand qui est supérieur à zéro et dont la fréquence est supérieure ou égale à la valeur de l'entier lui-même. La fréquence d'un entier est le nombre de fois où il apparaît dans la liste. Si aucune valeur de ce type n'existe, renvoyez -1. Exemples :", "entry_point": "search", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/29", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Étant donné les longueurs des trois côtés d'un triangle. Renvoyer l'aire du triangle arrondie à 2 décimales si les trois côtés forment un triangle valide. Sinon, retourner -1. Trois côtés forment un triangle valide lorsque la somme de deux côtés est supérieure au troisième côté. Exemple :\n * \n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n * \n */\nconst triangle_area = function (a: number, b: number, c: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = triangle_area(3,4,5);\nlet expected_1 = 6.0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = triangle_area(1,2,10);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = triangle_area(4,8,5);\nlet expected_3 = 8.18;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = triangle_area(2,2,2);\nlet expected_4 = 1.73;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = triangle_area(1,2,3);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = triangle_area(10,5,7);\nlet expected_6 = 16.25;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = triangle_area(2,6,3);\nlet expected_7 = -1;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = triangle_area(1,1,1);\nlet expected_8 = 0.43;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = triangle_area(2,2,10);\nlet expected_9 = -1;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné les longueurs des trois côtés d'un triangle. Renvoyer l'aire du triangle arrondie à 2 décimales si les trois côtés forment un triangle valide. Sinon, retourner -1. Trois côtés forment un triangle valide lorsque la somme de deux côtés est supérieure au troisième côté. Exemple :", "entry_point": "triangle_area", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/30", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Écrivez une fonction qui renvoie True si l'objet q va voler, et False sinon.\n *     L'objet q volera s'il est équilibré (c'est une liste palindromique) et que la somme de ses éléments est inférieure ou égale au poids maximum possible w.\n * \n *     Exemple:\n *     will_it_fly([1, 2], 5) ➞ False \n *     # 1+2 est inférieur au poids maximum possible, mais c'est déséquilibré.\n * \n *     will_it_fly([3, 2, 3], 1) ➞ False\n *     # c'est équilibré, mais 3+2+3 est plus que le poids maximum possible.\n * \n *     will_it_fly([3, 2, 3], 9) ➞ True\n *     # 3+2+3 est inférieur au poids maximum possible, et c'est équilibré.\n * \n *     will_it_fly([3], 5) ➞ True\n *     # 3 est inférieur au poids maximum possible, et c'est équilibré.\n * \n * \n */\nconst will_it_fly = function (q: Array<number>, w: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = will_it_fly([3, 2, 3],9);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = will_it_fly([1, 2],5);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = will_it_fly([3],5);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = will_it_fly([3, 2, 3],1);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = will_it_fly([1, 2, 3],6);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = will_it_fly([5],5);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Écrivez une fonction qui renvoie True si l'objet q va voler, et False sinon.\n    L'objet q volera s'il est équilibré (c'est une liste palindromique) et que la somme de ses éléments est inférieure ou égale au poids maximum possible w.\n\n    Exemple:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 est inférieur au poids maximum possible, mais c'est déséquilibré.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # c'est équilibré, mais 3+2+3 est plus que le poids maximum possible.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 est inférieur au poids maximum possible, et c'est équilibré.\n\n    will_it_fly([3], 5) ➞ True\n    # 3 est inférieur au poids maximum possible, et c'est équilibré.", "entry_point": "will_it_fly", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/31", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Écrivez une fonction qui renvoie vrai si le nombre donné est le produit de 3 nombres premiers\n *     et faux sinon.\n *     Sachant que (a) est inférieur à 100.\n *     Exemple:\n * \n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n * \n */\nconst is_multiply_prime = function (a: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_multiply_prime(5);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_multiply_prime(30);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_multiply_prime(8);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_multiply_prime(10);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_multiply_prime(125);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_multiply_prime(105);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_multiply_prime(126);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_multiply_prime(729);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_multiply_prime(891);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_multiply_prime(1001);\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Écrivez une fonction qui renvoie vrai si le nombre donné est le produit de 3 nombres premiers\n    et faux sinon.\n    Sachant que (a) est inférieur à 100.\n    Exemple:", "entry_point": "is_multiply_prime", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/32", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Vous recevrez un nombre en forme décimale et votre tâche consiste à le convertir en format binaire. La fonction doit renvoyer une chaîne de caractères, chaque caractère représentant un nombre binaire. Chaque caractère dans la chaîne sera '0' ou '1'.\n * \n * Il y aura quelques caractères supplémentaires 'db' au début et à la fin de la chaîne. Les caractères supplémentaires sont là pour aider avec le format.\n * \n * Exemples :\n * \n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n * \n */\nconst decimal_to_binary = function (decimal: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = decimal_to_binary(0);\nlet expected_1 = \"db0db\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = decimal_to_binary(32);\nlet expected_2 = \"db100000db\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = decimal_to_binary(103);\nlet expected_3 = \"db1100111db\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = decimal_to_binary(15);\nlet expected_4 = \"db1111db\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Vous recevrez un nombre en forme décimale et votre tâche consiste à le convertir en format binaire. La fonction doit renvoyer une chaîne de caractères, chaque caractère représentant un nombre binaire. Chaque caractère dans la chaîne sera '0' ou '1'.\n\nIl y aura quelques caractères supplémentaires 'db' au début et à la fin de la chaîne. Les caractères supplémentaires sont là pour aider avec le format.\n\nExemples :", "entry_point": "decimal_to_binary", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/33", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * On vous donne une chaîne de caractères s.\n *     Votre tâche est de vérifier si la chaîne est heureuse ou non.\n *     Une chaîne est heureuse si sa longueur est d'au moins 3 et que chaque groupe de 3 lettres consécutives est distinct.\n *     Par exemple :\n * \n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n * \n */\nconst is_happy = function (s: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_happy(\"a\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_happy(\"aa\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_happy(\"abcd\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_happy(\"aabb\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_happy(\"adb\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_happy(\"xyy\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_happy(\"iopaxpoi\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_happy(\"iopaxioi\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "On vous donne une chaîne de caractères s.\n    Votre tâche est de vérifier si la chaîne est heureuse ou non.\n    Une chaîne est heureuse si sa longueur est d'au moins 3 et que chaque groupe de 3 lettres consécutives est distinct.\n    Par exemple :", "entry_point": "is_happy", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/34", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * C'est la dernière semaine du semestre et le professeur doit donner les notes aux étudiants. Le professeur a créé son propre algorithme pour noter. Le seul problème est qu'elle a perdu le code qu'elle utilisait pour noter. Elle vous a donné une liste de GPA pour certains étudiants et vous devez écrire une fonction qui peut produire une liste de notes en utilisant le tableau suivant :\n *              GPA       |    Note\n *               4.0                A+\n *             > 3.7                A \n *             > 3.3                A- \n *             > 3.0                B+\n *             > 2.7                B \n *             > 2.3                B-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                E\n *     \n * \n *     Exemple :\n * \n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n * \n */\nconst numerical_letter_grade = function (grades: Array<number>) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]);\nlet expected_1 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = numerical_letter_grade([1.2]);\nlet expected_2 = [\"D+\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = numerical_letter_grade([0.5]);\nlet expected_3 = [\"D-\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = numerical_letter_grade([0.0]);\nlet expected_4 = [\"E\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = numerical_letter_grade([1, 0.3, 1.5, 2.8, 3.3]);\nlet expected_5 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = numerical_letter_grade([0, 0.7]);\nlet expected_6 = [\"E\", \"D-\"];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "C'est la dernière semaine du semestre et le professeur doit donner les notes aux étudiants. Le professeur a créé son propre algorithme pour noter. Le seul problème est qu'elle a perdu le code qu'elle utilisait pour noter. Elle vous a donné une liste de GPA pour certains étudiants et vous devez écrire une fonction qui peut produire une liste de notes en utilisant le tableau suivant :\n             GPA       |    Note\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Exemple :", "entry_point": "numerical_letter_grade", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/35", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Écrivez une fonction qui prend une chaîne de caractères et renvoie True si la longueur de la chaîne est un nombre premier ou False sinon.\n * Exemples\n * \n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n * \n */\nconst prime_length = function (string0: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = prime_length(\"Hello\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = prime_length(\"abcdcba\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = prime_length(\"kittens\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = prime_length(\"orange\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = prime_length(\"wow\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = prime_length(\"world\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = prime_length(\"MadaM\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = prime_length(\"Wow\");\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = prime_length(\"\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = prime_length(\"HI\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = prime_length(\"go\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = prime_length(\"gogo\");\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = prime_length(\"aaaaaaaaaaaaaaa\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = prime_length(\"Madam\");\nlet expected_14 = true;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = prime_length(\"M\");\nlet expected_15 = false;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = prime_length(\"0\");\nlet expected_16 = false;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\n", "language": "typescript", "description": "Écrivez une fonction qui prend une chaîne de caractères et renvoie True si la longueur de la chaîne est un nombre premier ou False sinon.\nExemples", "entry_point": "prime_length", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/36", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Étant donné un entier positif N, retournez la somme totale de ses chiffres en binaire.\n * \n *     Exemple\n *         Pour N = 1000, la somme des chiffres sera 1, la sortie devrait être \"1\".\n *         Pour N = 150, la somme des chiffres sera 6, la sortie devrait être \"110\".\n *         Pour N = 147, la somme des chiffres sera 12, la sortie devrait être \"1100\".\n *     \n *     Variables:\n *         @N entier\n *              Contraintes : 0 ≤ N ≤ 10000.\n *     Sortie :\n *          une chaîne de nombre binaire\n * \n * \n */\nconst solve = function (N: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = solve(1000);\nlet expected_1 = \"1\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = solve(150);\nlet expected_2 = \"110\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = solve(147);\nlet expected_3 = \"1100\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = solve(333);\nlet expected_4 = \"1001\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = solve(963);\nlet expected_5 = \"10010\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné un entier positif N, retournez la somme totale de ses chiffres en binaire.\n\n    Exemple\n        Pour N = 1000, la somme des chiffres sera 1, la sortie devrait être \"1\".\n        Pour N = 150, la somme des chiffres sera 6, la sortie devrait être \"110\".\n        Pour N = 147, la somme des chiffres sera 12, la sortie devrait être \"1100\".\n    \n    Variables:\n        @N entier\n             Contraintes : 0 ≤ N ≤ 10000.\n    Sortie :\n         une chaîne de nombre binaire", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/37", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * On vous donne des données en deux dimensions, sous forme de listes imbriquées,\n * qui ressemblent à une matrice, mais contrairement aux matrices,\n * chaque ligne peut contenir un nombre différent de colonnes.\n * Étant donné lst et un entier x, trouvez les entiers x dans la liste,\n * et renvoyez une liste de tuples, [(x1, y1), (x2, y2) ...] tels que\n * chaque tuple est une coordonnée - (ligne, colonnes), en commençant par 0.\n * Triez les coordonnées initialement par lignes par ordre croissant.\n * De plus, triez les coordonnées de la ligne par colonnes par ordre décroissant.\n * \n * Exemples :\n * \n * get_row([\n * [1,2,3,4,5,6],\n * [1,2,3,4,1,6],\n * [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n * \n */\nconst get_row = function (lst: Array<Array<number>>, x: number) : Array<Array<number>>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],1);\nlet expected_1 = [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],2);\nlet expected_2 = [[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],1);\nlet expected_3 = [[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_row([],1);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = get_row([[1]],2);\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = get_row([[], [1], [1, 2, 3]],3);\nlet expected_6 = [[2, 2]];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "On vous donne des données en deux dimensions, sous forme de listes imbriquées,\nqui ressemblent à une matrice, mais contrairement aux matrices,\nchaque ligne peut contenir un nombre différent de colonnes.\nÉtant donné lst et un entier x, trouvez les entiers x dans la liste,\net renvoyez une liste de tuples, [(x1, y1), (x2, y2) ...] tels que\nchaque tuple est une coordonnée - (ligne, colonnes), en commençant par 0.\nTriez les coordonnées initialement par lignes par ordre croissant.\nDe plus, triez les coordonnées de la ligne par colonnes par ordre décroissant.\n\nExemples :", "entry_point": "get_row", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/38", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Vous disposez d'une liste d'entiers.\n *     Écrivez une fonction next_smallest() qui renvoie le deuxième élément le plus petit de la liste.\n *     Renvoyez null s'il n'y a pas un tel élément.\n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n * \n */\nconst next_smallest = function (lst: Array<number>) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = next_smallest([1, 2, 3, 4, 5]);\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = next_smallest([5, 1, 4, 3, 2]);\nlet expected_2 = 2;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = next_smallest([]);\nlet expected_3 = undefined;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = next_smallest([1, 1]);\nlet expected_4 = undefined;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = next_smallest([1, 1, 1, 1, 0]);\nlet expected_5 = 1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = next_smallest([1, 1]);\nlet expected_6 = undefined;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = next_smallest([-35, 34, 12, -45]);\nlet expected_7 = -35;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Vous disposez d'une liste d'entiers.\n    Écrivez une fonction next_smallest() qui renvoie le deuxième élément le plus petit de la liste.\n    Renvoyez null s'il n'y a pas un tel élément.", "entry_point": "next_smallest", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/39", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Vous recevrez une chaîne de mots et votre tâche consiste à compter le nombre d'ennuis. Un ennui est une phrase qui commence par le mot \"Je\". Les phrases sont délimitées par '.', '?' ou '!'.\n * \n * Par exemple:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n * \n */\nconst is_bored = function (S: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_bored(\"Hello world\");\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_bored(\"Is the sky blue?\");\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_bored(\"I love It !\");\nlet expected_3 = 1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_bored(\"bIt\");\nlet expected_4 = 0;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_bored(\"I feel good today. I will be productive. will kill It\");\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_bored(\"You and I are going for a walk\");\nlet expected_6 = 0;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Vous recevrez une chaîne de mots et votre tâche consiste à compter le nombre d'ennuis. Un ennui est une phrase qui commence par le mot \"Je\". Les phrases sont délimitées par '.', '?' ou '!'.\n\nPar exemple:", "entry_point": "is_bored", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/40", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Vous avez une liste d'entiers.\n *     Vous devez trouver la plus grande valeur première et retourner la somme de ses chiffres.\n * \n *     Exemples:\n * \n * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n * For lst = [0,81,12,3,1,21] the output should be 3\n * For lst = [0,8,1,2,1,7] the output should be 7\n * \n */\nconst skjkasdkd = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]);\nlet expected_1 = 10;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]);\nlet expected_2 = 25;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\nlet expected_3 = 13;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]);\nlet expected_4 = 11;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = skjkasdkd([0, 81, 12, 3, 1, 21]);\nlet expected_5 = 3;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = skjkasdkd([0, 8, 1, 2, 1, 7]);\nlet expected_6 = 7;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = skjkasdkd([8191]);\nlet expected_7 = 19;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = skjkasdkd([8191, 123456, 127, 7]);\nlet expected_8 = 19;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = skjkasdkd([127, 97, 8192]);\nlet expected_9 = 10;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Vous avez une liste d'entiers.\n    Vous devez trouver la plus grande valeur première et retourner la somme de ses chiffres.\n\n    Exemples:", "entry_point": "skjkasdkd", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/41", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Étant donné un dictionnaire, renvoyer True si toutes les clés sont des chaînes de caractères en minuscules ou toutes les clés sont des chaînes de caractères en majuscules, sinon renvoyer False. La fonction doit renvoyer False si le dictionnaire donné est vide. Exemples :\n * \n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n * \n */\nconst check_dict_case = function (dict: Map<any, string>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [\"b\", \"banana\"]]));\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [\"A\", \"banana\"], [\"B\", \"banana\"]]));\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [5, \"banana\"], [\"a\", \"apple\"]]));\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = check_dict_case(new Map<any, any>([[\"Name\", \"John\"], [\"Age\", \"36\"], [\"City\", \"Houston\"]]));\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = check_dict_case(new Map<any, any>([[\"STATE\", \"NC\"], [\"ZIP\", \"12345\"]]));\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = check_dict_case(new Map<any, any>([[\"fruit\", \"Orange\"], [\"taste\", \"Sweet\"]]));\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = check_dict_case(new Map<any, any>([]));\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné un dictionnaire, renvoyer True si toutes les clés sont des chaînes de caractères en minuscules ou toutes les clés sont des chaînes de caractères en majuscules, sinon renvoyer False. La fonction doit renvoyer False si le dictionnaire donné est vide. Exemples :", "entry_point": "check_dict_case", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/42", "prompt": "import * as math from 'mathjs'\n\n/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Créez une fonction qui prend une valeur (chaîne de caractères) représentant un nombre et renvoie l'entier le plus proche. Si le nombre est à égale distance de deux entiers, arrondissez-le à l'entier le plus éloigné de zéro.\n * \n * Exemples\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n * \n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n * \n */\nconst closest_integer = function (value: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = closest_integer(\"10\");\nlet expected_1 = 10;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = closest_integer(\"14.5\");\nlet expected_2 = 15;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = closest_integer(\"-15.5\");\nlet expected_3 = -16;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = closest_integer(\"15.3\");\nlet expected_4 = 15;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = closest_integer(\"0\");\nlet expected_5 = 0;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Créez une fonction qui prend une valeur (chaîne de caractères) représentant un nombre et renvoie l'entier le plus proche. Si le nombre est à égale distance de deux entiers, arrondissez-le à l'entier le plus éloigné de zéro.\n\nExemples", "entry_point": "closest_integer", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/43", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Étant donné un entier positif n, vous devez faire une pile de n niveaux de pierres.\n *     Le premier niveau a n pierres.\n *     Le nombre de pierres dans le niveau suivant est:\n *         - le prochain nombre impair si n est impair.\n *         - le prochain nombre pair si n est pair.\n *     Retournez le nombre de pierres dans chaque niveau dans une liste, où l'élément à l'indice\n *     i représente le nombre de pierres dans le niveau (i+1).\n * \n *     Exemples:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n * \n */\nconst make_a_pile = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = make_a_pile(3);\nlet expected_1 = [3, 5, 7];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = make_a_pile(4);\nlet expected_2 = [4, 6, 8, 10];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = make_a_pile(5);\nlet expected_3 = [5, 7, 9, 11, 13];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = make_a_pile(6);\nlet expected_4 = [6, 8, 10, 12, 14, 16];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = make_a_pile(8);\nlet expected_5 = [8, 10, 12, 14, 16, 18, 20, 22];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné un entier positif n, vous devez faire une pile de n niveaux de pierres.\n    Le premier niveau a n pierres.\n    Le nombre de pierres dans le niveau suivant est:\n        - le prochain nombre impair si n est impair.\n        - le prochain nombre pair si n est pair.\n    Retournez le nombre de pierres dans chaque niveau dans une liste, où l'élément à l'indice\n    i représente le nombre de pierres dans le niveau (i+1).\n\n    Exemples:", "entry_point": "make_a_pile", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/44", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Vous recevrez une chaîne de mots séparés par des virgules ou des espaces. Votre tâche est de diviser la chaîne en mots et de renvoyer un tableau des mots.\n * \n * Par exemple:\n * \n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n * \n */\nconst words_string = function (s: string) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = words_string(\"Hi, my name is John\");\nlet expected_1 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = words_string(\"One, two, three, four, five, six\");\nlet expected_2 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = words_string(\"Hi, my name\");\nlet expected_3 = [\"Hi\", \"my\", \"name\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = words_string(\"One,, two, three, four, five, six,\");\nlet expected_4 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = words_string(\"\");\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = words_string(\"ahmed     , gamal\");\nlet expected_6 = [\"ahmed\", \"gamal\"];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Vous recevrez une chaîne de mots séparés par des virgules ou des espaces. Votre tâche est de diviser la chaîne en mots et de renvoyer un tableau des mots.\n\nPar exemple:", "entry_point": "words_string", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/45", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Cette fonction prend deux nombres positifs x et y et renvoie le plus grand nombre entier pair qui se trouve dans l'intervalle [x, y] inclus. Si aucun nombre ne répond à cette condition, la fonction doit renvoyer -1.\n * \n * Par exemple :\n * \n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n * \n */\nconst choose_num = function (x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = choose_num(12,15);\nlet expected_1 = 14;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = choose_num(13,12);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = choose_num(33,12354);\nlet expected_3 = 12354;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = choose_num(5234,5233);\nlet expected_4 = -1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = choose_num(6,29);\nlet expected_5 = 28;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = choose_num(27,10);\nlet expected_6 = -1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = choose_num(7,7);\nlet expected_7 = -1;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = choose_num(546,546);\nlet expected_8 = 546;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "Cette fonction prend deux nombres positifs x et y et renvoie le plus grand nombre entier pair qui se trouve dans l'intervalle [x, y] inclus. Si aucun nombre ne répond à cette condition, la fonction doit renvoyer -1.\n\nPar exemple :", "entry_point": "choose_num", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/46", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * On vous donne deux entiers positifs n et m, et votre tâche est de calculer la moyenne des entiers de n à m (y compris n et m). Arrondissez la réponse à l'entier le plus proche et convertissez-le en binaire. Si n est supérieur à m, retournez -1. Exemple:\n * \n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n * \n */\nconst rounded_avg = function (n: number, m: number) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = rounded_avg(1,5);\nlet expected_1 = \"0b11\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = rounded_avg(7,13);\nlet expected_2 = \"0b1010\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = rounded_avg(964,977);\nlet expected_3 = \"0b1111001010\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = rounded_avg(996,997);\nlet expected_4 = \"0b1111100100\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = rounded_avg(560,851);\nlet expected_5 = \"0b1011000010\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = rounded_avg(185,546);\nlet expected_6 = \"0b101101110\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = rounded_avg(362,496);\nlet expected_7 = \"0b110101101\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = rounded_avg(350,902);\nlet expected_8 = \"0b1001110010\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = rounded_avg(197,233);\nlet expected_9 = \"0b11010111\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = rounded_avg(7,5);\nlet expected_10 = -1;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = rounded_avg(5,1);\nlet expected_11 = -1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = rounded_avg(5,5);\nlet expected_12 = \"0b101\";\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\n", "language": "typescript", "description": "On vous donne deux entiers positifs n et m, et votre tâche est de calculer la moyenne des entiers de n à m (y compris n et m). Arrondissez la réponse à l'entier le plus proche et convertissez-le en binaire. Si n est supérieur à m, retournez -1. Exemple:", "entry_point": "rounded_avg", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/47", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Implémentez la fonction f qui prend n en paramètre et renvoie une liste de taille n, telle que la valeur de l'élément à l'index i soit le factoriel de i si i est pair ou la somme des nombres de 1 à i sinon. i commence à 1. Le factoriel de i est la multiplication des nombres de 1 à i (1 * 2 * ... * i). Exemple :\n * \n * f(5) == [1, 2, 6, 24, 15]\n * \n */\nconst f = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = f(5);\nlet expected_1 = [1, 2, 6, 24, 15];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = f(7);\nlet expected_2 = [1, 2, 6, 24, 15, 720, 28];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = f(1);\nlet expected_3 = [1];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = f(3);\nlet expected_4 = [1, 2, 6];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Implémentez la fonction f qui prend n en paramètre et renvoie une liste de taille n, telle que la valeur de l'élément à l'index i soit le factoriel de i si i est pair ou la somme des nombres de 1 à i sinon. i commence à 1. Le factoriel de i est la multiplication des nombres de 1 à i (1 * 2 * ... * i). Exemple :", "entry_point": "f", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/48", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Étant donné un entier positif n, renvoyer un tuple qui contient le nombre de nombres palindromes pairs et impairs qui se trouvent dans la plage (1, n), inclus.\n * \n *     Exemple 1:\n * \n *         Entrée: 3\n *         Sortie: (1, 2)\n *         Explication:\n *         Les nombres palindromes sont 1, 2, 3. Un d'entre eux est pair et deux sont impairs.\n * \n *     Exemple 2:\n * \n *         Entrée: 12\n *         Sortie: (4, 6)\n *         Explication:\n *         Les nombres palindromes sont 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Quatre d'entre eux sont pairs et six sont impairs.\n * \n *     Remarque:\n *         1. 1 <= n <= 10^3\n *         2. Le tuple renvoyé contient respectivement le nombre de nombres palindromes pairs et impairs.\n * \n * \n */\nconst even_odd_palindrome = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = even_odd_palindrome(123);\nlet expected_1 = [8, 13];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = even_odd_palindrome(12);\nlet expected_2 = [4, 6];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = even_odd_palindrome(3);\nlet expected_3 = [1, 2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = even_odd_palindrome(63);\nlet expected_4 = [6, 8];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = even_odd_palindrome(25);\nlet expected_5 = [5, 6];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = even_odd_palindrome(19);\nlet expected_6 = [4, 6];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = even_odd_palindrome(9);\nlet expected_7 = [4, 5];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = even_odd_palindrome(1);\nlet expected_8 = [0, 1];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné un entier positif n, renvoyer un tuple qui contient le nombre de nombres palindromes pairs et impairs qui se trouvent dans la plage (1, n), inclus.\n\n    Exemple 1:\n\n        Entrée: 3\n        Sortie: (1, 2)\n        Explication:\n        Les nombres palindromes sont 1, 2, 3. Un d'entre eux est pair et deux sont impairs.\n\n    Exemple 2:\n\n        Entrée: 12\n        Sortie: (4, 6)\n        Explication:\n        Les nombres palindromes sont 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Quatre d'entre eux sont pairs et six sont impairs.\n\n    Remarque:\n        1. 1 <= n <= 10^3\n        2. Le tuple renvoyé contient respectivement le nombre de nombres palindromes pairs et impairs.", "entry_point": "even_odd_palindrome", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/49", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Nous avons un tableau 'arr' de N entiers arr[1], arr[2], ..., arr[N]. Les nombres dans le tableau seront dans un ordre aléatoire. Votre tâche est de déterminer s'il est possible d'obtenir un tableau trié dans l'ordre non décroissant en effectuant l'opération suivante sur le tableau donné :\n *         Vous êtes autorisé à effectuer une opération de décalage vers la droite un nombre quelconque de fois.\n *     \n *     Une opération de décalage vers la droite signifie décaler tous les éléments du tableau d'une position vers la droite. Le dernier élément du tableau sera déplacé à la position de départ dans le tableau, c'est-à-dire l'indice 0.\n * \n *     Si il est possible d'obtenir le tableau trié en effectuant l'opération ci-dessus, retournez True sinon retournez False.\n *     Si le tableau donné est vide, retournez True.\n * \n *     Remarque : La liste donnée est garantie d'avoir des éléments uniques.\n * \n *     Par exemple :\n *     \n *     move_one_ball([3, 4, 5, 1, 2])==>True\n *     Explication : En effectuant 2 opérations de décalage vers la droite, l'ordre non décroissant peut être obtenu pour le tableau donné.\n *     move_one_ball([3, 5, 4, 1, 2])==>False\n *     Explication : Il n'est pas possible d'obtenir un ordre non décroissant pour le tableau donné en effectuant un nombre quelconque d'opérations de décalage vers la droite.\n * \n * \n * \n */\nconst move_one_ball = function (arr: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = move_one_ball([3, 4, 5, 1, 2]);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = move_one_ball([3, 5, 10, 1, 2]);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = move_one_ball([4, 3, 1, 2]);\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = move_one_ball([3, 5, 4, 1, 2]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = move_one_ball([]);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Nous avons un tableau 'arr' de N entiers arr[1], arr[2], ..., arr[N]. Les nombres dans le tableau seront dans un ordre aléatoire. Votre tâche est de déterminer s'il est possible d'obtenir un tableau trié dans l'ordre non décroissant en effectuant l'opération suivante sur le tableau donné :\n        Vous êtes autorisé à effectuer une opération de décalage vers la droite un nombre quelconque de fois.\n    \n    Une opération de décalage vers la droite signifie décaler tous les éléments du tableau d'une position vers la droite. Le dernier élément du tableau sera déplacé à la position de départ dans le tableau, c'est-à-dire l'indice 0.\n\n    Si il est possible d'obtenir le tableau trié en effectuant l'opération ci-dessus, retournez True sinon retournez False.\n    Si le tableau donné est vide, retournez True.\n\n    Remarque : La liste donnée est garantie d'avoir des éléments uniques.\n\n    Par exemple :\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explication : En effectuant 2 opérations de décalage vers la droite, l'ordre non décroissant peut être obtenu pour le tableau donné.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explication : Il n'est pas possible d'obtenir un ordre non décroissant pour le tableau donné en effectuant un nombre quelconque d'opérations de décalage vers la droite.", "entry_point": "move_one_ball", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/50", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Dans ce problème, vous implémenterez une fonction qui prend deux listes de nombres et détermine s'il est possible d'échanger des éléments entre elles pour faire de lst1 une liste de nombres pairs uniquement. Il n'y a pas de limite sur le nombre d'éléments échangés entre lst1 et lst2. Si il est possible d'échanger des éléments entre lst1 et lst2 pour que tous les éléments de lst1 soient pairs, retournez \"YES\". Sinon, retournez \"NO\". Par exemple: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". On suppose que les listes d'entrée ne seront pas vides.\n * \n * \n */\nconst exchange = function (lst1: Array<number>, lst2: Array<number>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = exchange([1, 2, 3, 4],[1, 2, 3, 4]);\nlet expected_1 = \"YES\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = exchange([1, 2, 3, 4],[1, 5, 3, 4]);\nlet expected_2 = \"NO\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = exchange([1, 2, 3, 4],[2, 1, 4, 3]);\nlet expected_3 = \"YES\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = exchange([5, 7, 3],[2, 6, 4]);\nlet expected_4 = \"YES\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = exchange([5, 7, 3],[2, 6, 3]);\nlet expected_5 = \"NO\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = exchange([3, 2, 6, 1, 8, 9],[3, 5, 5, 1, 1, 1]);\nlet expected_6 = \"NO\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = exchange([100, 200],[200, 200]);\nlet expected_7 = \"YES\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Dans ce problème, vous implémenterez une fonction qui prend deux listes de nombres et détermine s'il est possible d'échanger des éléments entre elles pour faire de lst1 une liste de nombres pairs uniquement. Il n'y a pas de limite sur le nombre d'éléments échangés entre lst1 et lst2. Si il est possible d'échanger des éléments entre lst1 et lst2 pour que tous les éléments de lst1 soient pairs, retournez \"YES\". Sinon, retournez \"NO\". Par exemple: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". On suppose que les listes d'entrée ne seront pas vides.", "entry_point": "exchange", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/51", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Tâche\n *     Nous avons deux chaînes de caractères s et c, vous devez supprimer tous les caractères de s qui sont égaux à n'importe quel caractère de c\n *     puis vérifier si la chaîne résultante est un palindrome.\n *     Une chaîne est appelée palindrome si elle se lit de la même manière de gauche à droite et de droite à gauche.\n *     Vous devez retourner un tuple contenant la chaîne résultante et True/False pour la vérification.\n *     Exemple\n *     Pour s = \"abcde\", c = \"ae\", le résultat devrait être ('bcd',False)\n *     Pour s = \"abcdef\", c = \"b\"  le résultat devrait être ('acdef',False)\n *     Pour s = \"abcdedcba\", c = \"ab\", le résultat devrait être ('cdedc',True)\n * \n * \n */\nconst reverse_delete = function (s: string, c: string) : Array<any>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = reverse_delete(\"abcde\",\"ae\");\nlet expected_1 = [\"bcd\", false];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = reverse_delete(\"abcdef\",\"b\");\nlet expected_2 = [\"acdef\", false];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = reverse_delete(\"abcdedcba\",\"ab\");\nlet expected_3 = [\"cdedc\", true];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = reverse_delete(\"dwik\",\"w\");\nlet expected_4 = [\"dik\", false];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = reverse_delete(\"a\",\"a\");\nlet expected_5 = [\"\", true];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = reverse_delete(\"abcdedcba\",\"\");\nlet expected_6 = [\"abcdedcba\", true];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = reverse_delete(\"abcdedcba\",\"v\");\nlet expected_7 = [\"abcdedcba\", true];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = reverse_delete(\"vabba\",\"v\");\nlet expected_8 = [\"abba\", true];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = reverse_delete(\"mamma\",\"mia\");\nlet expected_9 = [\"\", true];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Tâche\n    Nous avons deux chaînes de caractères s et c, vous devez supprimer tous les caractères de s qui sont égaux à n'importe quel caractère de c\n    puis vérifier si la chaîne résultante est un palindrome.\n    Une chaîne est appelée palindrome si elle se lit de la même manière de gauche à droite et de droite à gauche.\n    Vous devez retourner un tuple contenant la chaîne résultante et True/False pour la vérification.\n    Exemple\n    Pour s = \"abcde\", c = \"ae\", le résultat devrait être ('bcd',False)\n    Pour s = \"abcdef\", c = \"b\"  le résultat devrait être ('acdef',False)\n    Pour s = \"abcdedcba\", c = \"ab\", le résultat devrait être ('cdedc',True)", "entry_point": "reverse_delete", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/52", "prompt": "import * as math from 'mathjs'\n\n/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * On vous donne une grille rectangulaire de puits. Chaque ligne représente un seul puits, et chaque 1 dans une ligne représente une unité d'eau. Chaque puits a un seau correspondant qui peut être utilisé pour extraire de l'eau, et tous les seaux ont la même capacité. Votre tâche est d'utiliser les seaux pour vider les puits. Sortez le nombre de fois que vous devez abaisser les seaux.\n * \n * Exemple 1:\n *     Entrée:\n *         grille : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n *         capacité_du_seau : 1\n *     Sortie: 6\n * \n * Exemple 2:\n *     Entrée:\n *         grille : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n *         capacité_du_seau : 2\n *     Sortie: 5\n * \n * Exemple 3:\n *     Entrée:\n *         grille : [[0,0,0], [0,0,0]]\n *         capacité_du_seau : 5\n *     Sortie: 0\n * \n * Contraintes:\n *     * tous les puits ont la même longueur\n *     * 1 <= grille.longueur <= 10^2\n *     * 1 <= grille[:,1].longueur <= 10^2\n *     * grille[i][j] -> 0 | 1\n *     * 1 <= capacité <= 10\n * \n * \n */\nconst max_fill = function (grid: Array<Array<number>>, capacity: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],1);\nlet expected_1 = 6;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],2);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = max_fill([[0, 0, 0], [0, 0, 0]],5);\nlet expected_3 = 0;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = max_fill([[1, 1, 1, 1], [1, 1, 1, 1]],2);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = max_fill([[1, 1, 1, 1], [1, 1, 1, 1]],9);\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "On vous donne une grille rectangulaire de puits. Chaque ligne représente un seul puits, et chaque 1 dans une ligne représente une unité d'eau. Chaque puits a un seau correspondant qui peut être utilisé pour extraire de l'eau, et tous les seaux ont la même capacité. Votre tâche est d'utiliser les seaux pour vider les puits. Sortez le nombre de fois que vous devez abaisser les seaux.\n\nExemple 1:\n    Entrée:\n        grille : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        capacité_du_seau : 1\n    Sortie: 6\n\nExemple 2:\n    Entrée:\n        grille : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        capacité_du_seau : 2\n    Sortie: 5\n\nExemple 3:\n    Entrée:\n        grille : [[0,0,0], [0,0,0]]\n        capacité_du_seau : 5\n    Sortie: 0\n\nContraintes:\n    * tous les puits ont la même longueur\n    * 1 <= grille.longueur <= 10^2\n    * 1 <= grille[:,1].longueur <= 10^2\n    * grille[i][j] -> 0 | 1\n    * 1 <= capacité <= 10", "entry_point": "max_fill", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/53", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Étant donné une chaîne de caractères s et un nombre naturel n, vous avez été chargé d'implémenter une fonction qui renvoie une liste de tous les mots de la chaîne s qui contiennent exactement n consonnes, dans l'ordre où ces mots apparaissent dans la chaîne s. Si la chaîne s est vide, la fonction doit renvoyer une liste vide. Remarque : vous pouvez supposer que la chaîne d'entrée ne contient que des lettres et des espaces. Exemples :\n * \n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n * \n */\nconst select_words = function (s: string, n: number) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = select_words(\"Mary had a little lamb\",4);\nlet expected_1 = [\"little\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = select_words(\"Mary had a little lamb\",3);\nlet expected_2 = [\"Mary\", \"lamb\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = select_words(\"simple white space\",2);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = select_words(\"Hello world\",4);\nlet expected_4 = [\"world\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = select_words(\"Uncle sam\",3);\nlet expected_5 = [\"Uncle\"];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = select_words(\"\",4);\nlet expected_6 = [];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = select_words(\"a b c d e f\",1);\nlet expected_7 = [\"b\", \"c\", \"d\", \"f\"];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné une chaîne de caractères s et un nombre naturel n, vous avez été chargé d'implémenter une fonction qui renvoie une liste de tous les mots de la chaîne s qui contiennent exactement n consonnes, dans l'ordre où ces mots apparaissent dans la chaîne s. Si la chaîne s est vide, la fonction doit renvoyer une liste vide. Remarque : vous pouvez supposer que la chaîne d'entrée ne contient que des lettres et des espaces. Exemples :", "entry_point": "select_words", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/54", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Étant donné un tableau arr d'entiers et un entier positif k, renvoyer une liste triée de longueur k avec les k nombres maximum dans arr.\n * \n *     Exemple 1:\n * \n *         Input: arr = [-3, -4, 5], k = 3\n *         Output: [-4, -3, 5]\n * \n *     Exemple 2:\n * \n *         Input: arr = [4, -4, 4], k = 2\n *         Output: [4, 4]\n * \n *     Exemple 3:\n * \n *         Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n *         Output: [2]\n * \n *     Note:\n *         1. La longueur du tableau sera dans la plage de [1, 1000].\n *         2. Les éléments du tableau seront dans la plage de [-1000, 1000].\n *         3. 0 <= k <= len(arr)\n * \n * \n */\nconst maximum = function (arr: Array<number>, k: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = maximum([-3, -4, 5],3);\nlet expected_1 = [-4, -3, 5];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = maximum([4, -4, 4],2);\nlet expected_2 = [4, 4];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = maximum([-3, 2, 1, 2, -1, -2, 1],1);\nlet expected_3 = [2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = maximum([123, -123, 20, 0, 1, 2, -3],3);\nlet expected_4 = [2, 20, 123];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = maximum([-123, 20, 0, 1, 2, -3],4);\nlet expected_5 = [0, 1, 2, 20];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = maximum([5, 15, 0, 3, -13, -8, 0],7);\nlet expected_6 = [-13, -8, 0, 0, 3, 5, 15];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = maximum([-1, 0, 2, 5, 3, -10],2);\nlet expected_7 = [3, 5];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = maximum([1, 0, 5, -7],1);\nlet expected_8 = [5];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = maximum([4, -4],2);\nlet expected_9 = [-4, 4];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = maximum([-10, 10],2);\nlet expected_10 = [-10, 10];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = maximum([1, 2, 3, -23, 243, -400, 0],0);\nlet expected_11 = [];\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné un tableau arr d'entiers et un entier positif k, renvoyer une liste triée de longueur k avec les k nombres maximum dans arr.\n\n    Exemple 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Exemple 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Exemple 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. La longueur du tableau sera dans la plage de [1, 1000].\n        2. Les éléments du tableau seront dans la plage de [-1000, 1000].\n        3. 0 <= k <= len(arr)", "entry_point": "maximum", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/55", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Étant donné un tableau non vide d'entiers arr et un entier k, retournez la somme des éléments ayant au plus deux chiffres parmi les k premiers éléments de arr.\n * \n * Exemple :\n * \n *     Entrée : arr = [111,21,3,4000,5,6,7,8,9], k = 4\n *     Sortie : 24 # somme de 21 + 3\n * \n * Contraintes :\n *     1. 1 <= len(arr) <= 100\n *     2. 1 <= k <= len(arr)\n * \n * \n */\nconst add_elements = function (arr: Array<number>, k: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = add_elements([1, -2, -3, 41, 57, 76, 87, 88, 99],3);\nlet expected_1 = -4;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = add_elements([111, 121, 3, 4000, 5, 6],2);\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = add_elements([11, 21, 3, 90, 5, 6, 7, 8, 9],4);\nlet expected_3 = 125;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9],4);\nlet expected_4 = 24;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = add_elements([1],1);\nlet expected_5 = 1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné un tableau non vide d'entiers arr et un entier k, retournez la somme des éléments ayant au plus deux chiffres parmi les k premiers éléments de arr.\n\nExemple :\n\n    Entrée : arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Sortie : 24 # somme de 21 + 3\n\nContraintes :\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)", "entry_point": "add_elements", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/56", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * On vous donne deux intervalles,\n *     où chaque intervalle est une paire d'entiers. Par exemple, intervalle = (début, fin) = (1, 2).\n *     Les intervalles donnés sont fermés, ce qui signifie que l'intervalle (début, fin)\n *     inclut à la fois le début et la fin.\n *     Pour chaque intervalle donné, on suppose que son début est inférieur ou égal à sa fin.\n *     Votre tâche est de déterminer si la longueur de l'intersection de ces deux\n *     intervalles est un nombre premier.\n *     Par exemple, l'intersection des intervalles (1, 3), (2, 4) est (2, 3)\n *     dont la longueur est 1, qui n'est pas un nombre premier.\n *     Si la longueur de l'intersection est un nombre premier, renvoyez \"YES\",\n *     sinon, renvoyez \"NO\".\n *     Si les deux intervalles ne se croisent pas, renvoyez \"NO\".\n * \n * \n *     [entrée/sortie] exemples:\n * \n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n * \n */\nconst intersection = function (interval1: Array<number>, interval2: Array<number>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = intersection([1, 2],[2, 3]);\nlet expected_1 = \"NO\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = intersection([-1, 1],[0, 4]);\nlet expected_2 = \"NO\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = intersection([-3, -1],[-5, 5]);\nlet expected_3 = \"YES\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = intersection([-2, 2],[-4, 0]);\nlet expected_4 = \"YES\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = intersection([-11, 2],[-1, -1]);\nlet expected_5 = \"NO\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = intersection([1, 2],[3, 5]);\nlet expected_6 = \"NO\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = intersection([1, 2],[1, 2]);\nlet expected_7 = \"NO\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = intersection([-2, -2],[-3, -2]);\nlet expected_8 = \"NO\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "On vous donne deux intervalles,\n    où chaque intervalle est une paire d'entiers. Par exemple, intervalle = (début, fin) = (1, 2).\n    Les intervalles donnés sont fermés, ce qui signifie que l'intervalle (début, fin)\n    inclut à la fois le début et la fin.\n    Pour chaque intervalle donné, on suppose que son début est inférieur ou égal à sa fin.\n    Votre tâche est de déterminer si la longueur de l'intersection de ces deux\n    intervalles est un nombre premier.\n    Par exemple, l'intersection des intervalles (1, 3), (2, 4) est (2, 3)\n    dont la longueur est 1, qui n'est pas un nombre premier.\n    Si la longueur de l'intersection est un nombre premier, renvoyez \"YES\",\n    sinon, renvoyez \"NO\".\n    Si les deux intervalles ne se croisent pas, renvoyez \"NO\".\n\n\n    [entrée/sortie] exemples:", "entry_point": "intersection", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/57", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Tout le monde connaît la suite de Fibonacci, qui a été étudiée en profondeur par les mathématiciens au cours des derniers siècles. Cependant, ce que les gens ne savent pas, c'est la suite de Tribonacci. La suite de Tribonacci est définie par la récurrence :\n * tri(1) = 3\n * tri(n) = 1 + n / 2, si n est pair.\n * tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n est impair.\n * Par exemple :\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n * = 2 + 3 + 3 = 8\n * Vous avez un nombre entier non négatif n, vous devez retourner une liste des n + 1 premiers nombres de la suite de Tribonacci.\n * Exemples :\n * tri(3) = [1, 3, 2, 8]\n * \n * \n */\nconst tri = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = tri(3);\nlet expected_1 = [1, 3, 2.0, 8.0];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = tri(4);\nlet expected_2 = [1, 3, 2.0, 8.0, 3.0];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = tri(5);\nlet expected_3 = [1, 3, 2.0, 8.0, 3.0, 15.0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = tri(6);\nlet expected_4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = tri(7);\nlet expected_5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = tri(8);\nlet expected_6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = tri(9);\nlet expected_7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = tri(20);\nlet expected_8 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = tri(0);\nlet expected_9 = [1];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = tri(1);\nlet expected_10 = [1, 3];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Tout le monde connaît la suite de Fibonacci, qui a été étudiée en profondeur par les mathématiciens au cours des derniers siècles. Cependant, ce que les gens ne savent pas, c'est la suite de Tribonacci. La suite de Tribonacci est définie par la récurrence :\ntri(1) = 3\ntri(n) = 1 + n / 2, si n est pair.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n est impair.\nPar exemple :\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nVous avez un nombre entier non négatif n, vous devez retourner une liste des n + 1 premiers nombres de la suite de Tribonacci.\nExemples :\ntri(3) = [1, 3, 2, 8]", "entry_point": "tri", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/58", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Étant donné un entier positif n, renvoyer le produit des chiffres impairs.\n *     Renvoyer 0 si tous les chiffres sont pairs.\n *     Par exemple:\n * \n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n * \n */\nconst digits = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = digits(5);\nlet expected_1 = 5;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = digits(54);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = digits(120);\nlet expected_3 = 1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = digits(5014);\nlet expected_4 = 5;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = digits(98765);\nlet expected_5 = 315;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = digits(5576543);\nlet expected_6 = 2625;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = digits(2468);\nlet expected_7 = 0;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné un entier positif n, renvoyer le produit des chiffres impairs.\n    Renvoyer 0 si tous les chiffres sont pairs.\n    Par exemple:", "entry_point": "digits", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/59", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Créez une fonction qui prend une chaîne de caractères en entrée contenant uniquement des crochets carrés.\n * La fonction doit renvoyer True si et seulement s'il existe une sous-séquence valide de crochets où au moins un crochet dans la sous-séquence est imbriqué.\n * is_nested('[[]]') ➞ True\n * is_nested('[]]]]]]][[[[[]') ➞ False\n * is_nested('[][]') ➞ False\n * is_nested('[]') ➞ False\n * is_nested('[[][]]') ➞ True\n * is_nested('[[]][[') ➞ True\n * \n */\nconst is_nested = function (string0: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_nested(\"[[]]\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_nested(\"[]]]]]]][[[[[]\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_nested(\"[][]\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_nested(\"[]\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_nested(\"[[[[]]]]\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_nested(\"[]]]]]]]]]]\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_nested(\"[][][[]]\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_nested(\"[[]\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_nested(\"[]]\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_nested(\"[[]][[\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = is_nested(\"[[][]]\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = is_nested(\"\");\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = is_nested(\"[[[[[[[[\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = is_nested(\"]]]]]]]]\");\nlet expected_14 = false;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\n", "language": "typescript", "description": "Créez une fonction qui prend une chaîne de caractères en entrée contenant uniquement des crochets carrés.\nLa fonction doit renvoyer True si et seulement s'il existe une sous-séquence valide de crochets où au moins un crochet dans la sous-séquence est imbriqué.", "entry_point": "is_nested", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/60", "prompt": "import * as math from 'mathjs'\n\n/**\n * Vous êtes un programmeur TypeScript expert.\n * Vous avez une liste de nombres.\n * Vous devez retourner la somme des carrés des nombres dans la liste donnée,\n * arrondir chaque élément de la liste à l'entier supérieur (plafond) d'abord.\n * Exemples:\n * Pour lst = [1,2,3], la sortie devrait être 14\n * Pour lst = [1,4,9], la sortie devrait être 98\n * Pour lst = [1,3,5,7], la sortie devrait être 84\n * Pour lst = [1.4,4.2,0], la sortie devrait être 29\n * Pour lst = [-2.4,1,1], la sortie devrait être 6\n * \n * \n * \n * \n */\nconst sum_squares = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_squares([1, 2, 3]);\nlet expected_1 = 14;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_squares([1.0, 2, 3]);\nlet expected_2 = 14;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_squares([1, 3, 5, 7]);\nlet expected_3 = 84;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_squares([1.4, 4.2, 0]);\nlet expected_4 = 29;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_squares([-2.4, 1, 1]);\nlet expected_5 = 6;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = sum_squares([100, 1, 15, 2]);\nlet expected_6 = 10230;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = sum_squares([10000, 10000]);\nlet expected_7 = 200000000;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = sum_squares([-1.4, 4.6, 6.3]);\nlet expected_8 = 75;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = sum_squares([-1.4, 17.9, 18.9, 19.9]);\nlet expected_9 = 1086;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = sum_squares([0]);\nlet expected_10 = 0;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = sum_squares([-1]);\nlet expected_11 = 1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = sum_squares([-1, 1, 0]);\nlet expected_12 = 2;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\n", "language": "typescript", "description": "Vous avez une liste de nombres.\nVous devez retourner la somme des carrés des nombres dans la liste donnée,\narrondir chaque élément de la liste à l'entier supérieur (plafond) d'abord.\nExemples:\nPour lst = [1,2,3], la sortie devrait être 14\nPour lst = [1,4,9], la sortie devrait être 98\nPour lst = [1,3,5,7], la sortie devrait être 84\nPour lst = [1.4,4.2,0], la sortie devrait être 29\nPour lst = [-2.4,1,1], la sortie devrait être 6", "entry_point": "sum_squares", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/61", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Créez une fonction qui renvoie True si le dernier caractère d'une chaîne donnée est un caractère alphabétique et ne fait pas partie d'un mot, et False sinon.\n *     Remarque: un \"mot\" est un groupe de caractères séparés par un espace.\n * \n *     Exemples:\n * \n * check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n * check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n * check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n * check_if_last_char_is_a_letter(\"\") ➞ False \n * \n */\nconst check_if_last_char_is_a_letter = function (txt: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = check_if_last_char_is_a_letter(\"apple\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = check_if_last_char_is_a_letter(\"apple pi e\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = check_if_last_char_is_a_letter(\"eeeee\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = check_if_last_char_is_a_letter(\"A\");\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = check_if_last_char_is_a_letter(\"Pumpkin pie \");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = check_if_last_char_is_a_letter(\"Pumpkin pie 1\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = check_if_last_char_is_a_letter(\"\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = check_if_last_char_is_a_letter(\"eeeee e \");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = check_if_last_char_is_a_letter(\"apple pie\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = check_if_last_char_is_a_letter(\"apple pi e \");\nlet expected_10 = false;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Créez une fonction qui renvoie True si le dernier caractère d'une chaîne donnée est un caractère alphabétique et ne fait pas partie d'un mot, et False sinon.\n    Remarque: un \"mot\" est un groupe de caractères séparés par un espace.\n\n    Exemples:", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/62", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Créez une fonction qui renvoie l'indice le plus grand d'un élément qui n'est pas supérieur ou égal à l'élément immédiatement précédent. Si aucun tel élément n'existe, retournez -1. Le tableau donné ne contiendra pas de valeurs en double.\n * \n * Exemples :\n * \n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n * \n */\nconst can_arrange = function (arr: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = can_arrange([1, 2, 4, 3, 5]);\nlet expected_1 = 3;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = can_arrange([1, 2, 4, 5]);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = can_arrange([1, 4, 2, 5, 6, 7, 8, 9, 10]);\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = can_arrange([4, 8, 5, 7, 3]);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = can_arrange([]);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Créez une fonction qui renvoie l'indice le plus grand d'un élément qui n'est pas supérieur ou égal à l'élément immédiatement précédent. Si aucun tel élément n'existe, retournez -1. Le tableau donné ne contiendra pas de valeurs en double.\n\nExemples :", "entry_point": "can_arrange", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/63", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Créez une fonction qui renvoie un tuple (a, b), où 'a' est le plus grand des entiers négatifs et 'b' est le plus petit des entiers positifs dans une liste. Si aucun entier négatif ou positif n'est présent, renvoyez-les comme None.\n * \n * Exemples :\n * \n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n * \n */\nconst largest_smallest_integers = function (lst: Array<number>) : Array<any>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = largest_smallest_integers([2, 4, 1, 3, 5, 7]);\nlet expected_1 = [undefined, 1];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = largest_smallest_integers([2, 4, 1, 3, 5, 7, 0]);\nlet expected_2 = [undefined, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = largest_smallest_integers([1, 3, 2, 4, 5, 6, -2]);\nlet expected_3 = [-2, 1];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = largest_smallest_integers([4, 5, 3, 6, 2, 7, -7]);\nlet expected_4 = [-7, 2];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = largest_smallest_integers([7, 3, 8, 4, 9, 2, 5, -9]);\nlet expected_5 = [-9, 2];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = largest_smallest_integers([]);\nlet expected_6 = [undefined, undefined];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = largest_smallest_integers([0]);\nlet expected_7 = [undefined, undefined];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = largest_smallest_integers([-1, -3, -5, -6]);\nlet expected_8 = [-1, undefined];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = largest_smallest_integers([-1, -3, -5, -6, 0]);\nlet expected_9 = [-1, undefined];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = largest_smallest_integers([-6, -4, -4, -3, 1]);\nlet expected_10 = [-3, 1];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = largest_smallest_integers([-6, -4, -4, -3, -100, 1]);\nlet expected_11 = [-3, 1];\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "Créez une fonction qui renvoie un tuple (a, b), où 'a' est le plus grand des entiers négatifs et 'b' est le plus petit des entiers positifs dans une liste. Si aucun entier négatif ou positif n'est présent, renvoyez-les comme None.\n\nExemples :", "entry_point": "largest_smallest_integers", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/64", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Le factoriel brésilien est défini comme suit :\n *     factoriel_bresilien(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     où n > 0\n * \n *     Par exemple :\n * >>> special_factorial(4)\n * 288\n * \n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n * \n */\nconst special_factorial = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = special_factorial(4);\nlet expected_1 = 288;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = special_factorial(5);\nlet expected_2 = 34560;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = special_factorial(7);\nlet expected_3 = 125411328000;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = special_factorial(1);\nlet expected_4 = 1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Le factoriel brésilien est défini comme suit :\n    factoriel_bresilien(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    où n > 0\n\n    Par exemple :", "entry_point": "special_factorial", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/65", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * On vous donne une chaîne de caractères représentant une phrase,\n *     la phrase contient des mots séparés par un espace,\n *     et vous devez retourner une chaîne de caractères qui contient les mots de la phrase originale,\n *     dont les longueurs sont des nombres premiers,\n *     l'ordre des mots dans la nouvelle chaîne doit être le même que celui de la phrase originale.\n * \n *     Exemple 1:\n *         Entrée: sentence = \"This is a test\"\n *         Sortie: \"is\"\n * \n *     Exemple 2:\n *         Entrée: sentence = \"lets go for swimming\"\n *         Sortie: \"go for\"\n * \n *     Contraintes:\n *         * 1 <= len(sentence) <= 100\n *         * sentence ne contient que des lettres\n * \n * \n */\nconst words_in_sentence = function (sentence: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = words_in_sentence(\"This is a test\");\nlet expected_1 = \"is\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = words_in_sentence(\"lets go for swimming\");\nlet expected_2 = \"go for\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = words_in_sentence(\"there is no place available here\");\nlet expected_3 = \"there is no place\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = words_in_sentence(\"Hi I am Hussein\");\nlet expected_4 = \"Hi am Hussein\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = words_in_sentence(\"go for it\");\nlet expected_5 = \"go for it\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = words_in_sentence(\"here\");\nlet expected_6 = \"\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = words_in_sentence(\"here is\");\nlet expected_7 = \"is\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "On vous donne une chaîne de caractères représentant une phrase,\n    la phrase contient des mots séparés par un espace,\n    et vous devez retourner une chaîne de caractères qui contient les mots de la phrase originale,\n    dont les longueurs sont des nombres premiers,\n    l'ordre des mots dans la nouvelle chaîne doit être le même que celui de la phrase originale.\n\n    Exemple 1:\n        Entrée: sentence = \"This is a test\"\n        Sortie: \"is\"\n\n    Exemple 2:\n        Entrée: sentence = \"lets go for swimming\"\n        Sortie: \"go for\"\n\n    Contraintes:\n        * 1 <= len(sentence) <= 100\n        * sentence ne contient que des lettres", "entry_point": "words_in_sentence", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/66", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Votre tâche consiste à implémenter une fonction qui simplifiera l'expression x * n. La fonction renvoie True si x * n évalue à un nombre entier et False sinon. Les deux x et n sont des représentations de chaîne d'une fraction et ont le format suivant, <numérateur>/<dénominateur> où le numérateur et le dénominateur sont des nombres entiers positifs.\n * \n * Vous pouvez supposer que x et n sont des fractions valides et n'ont pas zéro comme dénominateur.\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n * \n */\nconst simplify = function (x: string, n: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = simplify(\"1/5\",\"5/1\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = simplify(\"1/6\",\"2/1\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = simplify(\"5/1\",\"3/1\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = simplify(\"7/10\",\"10/2\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = simplify(\"2/10\",\"50/10\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = simplify(\"7/2\",\"4/2\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = simplify(\"11/6\",\"6/1\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = simplify(\"2/3\",\"5/2\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = simplify(\"5/2\",\"3/5\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = simplify(\"2/4\",\"8/4\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = simplify(\"2/4\",\"4/2\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = simplify(\"1/5\",\"5/1\");\nlet expected_12 = true;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = simplify(\"1/5\",\"1/5\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\n", "language": "typescript", "description": "Votre tâche consiste à implémenter une fonction qui simplifiera l'expression x * n. La fonction renvoie True si x * n évalue à un nombre entier et False sinon. Les deux x et n sont des représentations de chaîne d'une fraction et ont le format suivant, <numérateur>/<dénominateur> où le numérateur et le dénominateur sont des nombres entiers positifs.\n\nVous pouvez supposer que x et n sont des fractions valides et n'ont pas zéro comme dénominateur.", "entry_point": "simplify", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/67", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Écrivez une fonction qui trie la liste donnée d'entiers\n *     dans l'ordre croissant en fonction de la somme de leurs chiffres.\n *     Remarque : s'il y a plusieurs éléments avec une somme de chiffres similaire,\n *     les trier en fonction de leur index dans la liste d'origine.\n * \n *     Par exemple:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n * \n */\nconst order_by_points = function (nums: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = order_by_points([1, 11, -1, -11, -12]);\nlet expected_1 = [-1, -11, 1, -12, 11];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = order_by_points([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]);\nlet expected_2 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = order_by_points([]);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = order_by_points([1, -11, -32, 43, 54, -98, 2, -3]);\nlet expected_4 = [-3, -32, -98, -11, 1, 2, 43, 54];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = order_by_points([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\nlet expected_5 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = order_by_points([0, 6, 6, -76, -21, 23, 4]);\nlet expected_6 = [-76, -21, 0, 4, 23, 6, 6];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Écrivez une fonction qui trie la liste donnée d'entiers\n    dans l'ordre croissant en fonction de la somme de leurs chiffres.\n    Remarque : s'il y a plusieurs éléments avec une somme de chiffres similaire,\n    les trier en fonction de leur index dans la liste d'origine.\n\n    Par exemple:", "entry_point": "order_by_points", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/68", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Écrivez une fonction qui prend en entrée un tableau de nombres et renvoie le nombre d'éléments du tableau qui sont supérieurs à 10 et dont les premiers et derniers chiffres d'un nombre sont impairs (1, 3, 5, 7, 9). Par exemple :\n * \n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n * \n */\nconst specialFilter = function (nums: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = specialFilter([5, -2, 1, -5]);\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = specialFilter([15, -73, 14, -15]);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = specialFilter([33, -2, -3, 45, 21, 109]);\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = specialFilter([43, -12, 93, 125, 121, 109]);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = specialFilter([71, -2, -33, 75, 21, 19]);\nlet expected_5 = 3;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = specialFilter([1]);\nlet expected_6 = 0;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = specialFilter([]);\nlet expected_7 = 0;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Écrivez une fonction qui prend en entrée un tableau de nombres et renvoie le nombre d'éléments du tableau qui sont supérieurs à 10 et dont les premiers et derniers chiffres d'un nombre sont impairs (1, 3, 5, 7, 9). Par exemple :", "entry_point": "specialFilter", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/69", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * On vous donne un entier positif n. Vous devez créer un tableau d'entiers a de longueur n.\n *         Pour chaque i (1 ≤ i ≤ n), la valeur de a[i] = i * i - i + 1.\n *         Renvoyez le nombre de triplets (a[i], a[j], a[k]) de a où i < j < k, \n *     et a[i] + a[j] + a[k] est un multiple de 3.\n * \n *     Exemple :\n *         Entrée : n = 5\n *         Sortie : 1\n *         Explication : \n *         a = [1, 3, 7, 13, 21]\n *         Le seul triplet valide est (1, 7, 13).\n * \n * \n */\nconst get_max_triples = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_max_triples(5);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_max_triples(6);\nlet expected_2 = 4;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_max_triples(10);\nlet expected_3 = 36;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_max_triples(100);\nlet expected_4 = 53361;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "On vous donne un entier positif n. Vous devez créer un tableau d'entiers a de longueur n.\n        Pour chaque i (1 ≤ i ≤ n), la valeur de a[i] = i * i - i + 1.\n        Renvoyez le nombre de triplets (a[i], a[j], a[k]) de a où i < j < k, \n    et a[i] + a[j] + a[k] est un multiple de 3.\n\n    Exemple :\n        Entrée : n = 5\n        Sortie : 1\n        Explication : \n        a = [1, 3, 7, 13, 21]\n        Le seul triplet valide est (1, 7, 13).", "entry_point": "get_max_triples", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/70", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Il y a huit planètes dans notre système solaire : la plus proche du Soleil est Mercure, la suivante est Vénus, puis la Terre, Mars, Jupiter, Saturne, Uranus, Neptune. Écrivez une fonction qui prend deux noms de planètes en tant que chaînes de caractères planet1 et planet2. La fonction devrait renvoyer un tuple contenant toutes les planètes dont les orbites sont situées entre l'orbite de planet1 et l'orbite de planet2, triées par proximité avec le soleil. La fonction devrait renvoyer un tuple vide si planet1 ou planet2 ne sont pas des noms de planètes corrects. Exemples.\n * \n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n * \n */\nconst bf = function (planet1: string, planet2: string) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = bf(\"Jupiter\",\"Neptune\");\nlet expected_1 = [\"Saturn\", \"Uranus\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = bf(\"Earth\",\"Mercury\");\nlet expected_2 = [\"Venus\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = bf(\"Mercury\",\"Uranus\");\nlet expected_3 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = bf(\"Neptune\",\"Venus\");\nlet expected_4 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = bf(\"Earth\",\"Earth\");\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = bf(\"Mars\",\"Earth\");\nlet expected_6 = [];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = bf(\"Jupiter\",\"Makemake\");\nlet expected_7 = [];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Il y a huit planètes dans notre système solaire : la plus proche du Soleil est Mercure, la suivante est Vénus, puis la Terre, Mars, Jupiter, Saturne, Uranus, Neptune. Écrivez une fonction qui prend deux noms de planètes en tant que chaînes de caractères planet1 et planet2. La fonction devrait renvoyer un tuple contenant toutes les planètes dont les orbites sont situées entre l'orbite de planet1 et l'orbite de planet2, triées par proximité avec le soleil. La fonction devrait renvoyer un tuple vide si planet1 ou planet2 ne sont pas des noms de planètes corrects. Exemples.", "entry_point": "bf", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/71", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Un programme simple qui devrait renvoyer la valeur de x si n est un nombre premier et devrait renvoyer la valeur de y sinon.\n * \n * Exemples :\n * \n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n * \n */\nconst x_or_y = function (n: number, x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = x_or_y(7,34,12);\nlet expected_1 = 34;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = x_or_y(15,8,5);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = x_or_y(3,33,5212);\nlet expected_3 = 33;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = x_or_y(1259,3,52);\nlet expected_4 = 3;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = x_or_y(7919,-1,12);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = x_or_y(3609,1245,583);\nlet expected_6 = 583;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = x_or_y(91,56,129);\nlet expected_7 = 129;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = x_or_y(6,34,1234);\nlet expected_8 = 1234;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = x_or_y(1,2,0);\nlet expected_9 = 0;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = x_or_y(2,2,0);\nlet expected_10 = 2;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Un programme simple qui devrait renvoyer la valeur de x si n est un nombre premier et devrait renvoyer la valeur de y sinon.\n\nExemples :", "entry_point": "x_or_y", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/72", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Étant donné une liste de nombres, retournez la somme des carrés des nombres de la liste qui sont impairs. Ignorez les nombres négatifs ou non entiers.\n * \n *     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n *     double_the_difference([-1, -2, 0]) == 0\n *     double_the_difference([9, -2]) == 81\n *     double_the_difference([0]) == 0\n *     \n *     Si la liste d'entrée est vide, retournez 0.\n * \n * \n */\nconst double_the_difference = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = double_the_difference([]);\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = double_the_difference([5, 4]);\nlet expected_2 = 25;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = double_the_difference([0.1, 0.2, 0.3]);\nlet expected_3 = 0;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = double_the_difference([-10, -20, -30]);\nlet expected_4 = 0;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = double_the_difference([-1, -2, 8]);\nlet expected_5 = 0;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = double_the_difference([0.2, 3, 5]);\nlet expected_6 = 34;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = double_the_difference([-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]);\nlet expected_7 = 166650;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné une liste de nombres, retournez la somme des carrés des nombres de la liste qui sont impairs. Ignorez les nombres négatifs ou non entiers.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n    \n    Si la liste d'entrée est vide, retournez 0.", "entry_point": "double_the_difference", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/73", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Vous recevrez le nom d'une classe (une chaîne de caractères) et une liste d'extensions. Les extensions doivent être utilisées pour charger des classes supplémentaires dans la classe. La force de l'extension est déterminée comme suit : soit CAP le nombre de lettres majuscules dans le nom de l'extension, et SM le nombre de lettres minuscules dans le nom de l'extension, la force est donnée par la fraction CAP - SM. Vous devez trouver l'extension la plus forte et renvoyer une chaîne de caractères dans ce format : NomDeLaClasse.NomDeLExtensionLaPlusForte. S'il y a deux ou plusieurs extensions avec la même force, vous devez choisir celle qui vient en premier dans la liste. Par exemple, si vous recevez \"Slices\" comme classe et une liste d'extensions : ['SErviNGSliCes', 'Cheese', 'StuFfed'], vous devez renvoyer 'Slices.SErviNGSliCes' car 'SErviNGSliCes' est l'extension la plus forte (sa force est -1). Exemple :\n * \n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n * \n */\nconst Strongest_Extension = function (class_name: string, extensions: Array<string>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = Strongest_Extension(\"Watashi\",[\"tEN\", \"niNE\", \"eIGHt8OKe\"]);\nlet expected_1 = \"Watashi.eIGHt8OKe\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = Strongest_Extension(\"Boku123\",[\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]);\nlet expected_2 = \"Boku123.YEs.WeCaNe\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = Strongest_Extension(\"__YESIMHERE\",[\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]);\nlet expected_3 = \"__YESIMHERE.NuLl__\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = Strongest_Extension(\"K\",[\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]);\nlet expected_4 = \"K.TAR\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = Strongest_Extension(\"__HAHA\",[\"Tab\", \"123\", \"781345\", \"-_-\"]);\nlet expected_5 = \"__HAHA.123\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = Strongest_Extension(\"YameRore\",[\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]);\nlet expected_6 = \"YameRore.okIWILL123\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = Strongest_Extension(\"finNNalLLly\",[\"Die\", \"NowW\", \"Wow\", \"WoW\"]);\nlet expected_7 = \"finNNalLLly.WoW\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = Strongest_Extension(\"_\",[\"Bb\", \"91245\"]);\nlet expected_8 = \"_.Bb\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = Strongest_Extension(\"Sp\",[\"671235\", \"Bb\"]);\nlet expected_9 = \"Sp.671235\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Vous recevrez le nom d'une classe (une chaîne de caractères) et une liste d'extensions. Les extensions doivent être utilisées pour charger des classes supplémentaires dans la classe. La force de l'extension est déterminée comme suit : soit CAP le nombre de lettres majuscules dans le nom de l'extension, et SM le nombre de lettres minuscules dans le nom de l'extension, la force est donnée par la fraction CAP - SM. Vous devez trouver l'extension la plus forte et renvoyer une chaîne de caractères dans ce format : NomDeLaClasse.NomDeLExtensionLaPlusForte. S'il y a deux ou plusieurs extensions avec la même force, vous devez choisir celle qui vient en premier dans la liste. Par exemple, si vous recevez \"Slices\" comme classe et une liste d'extensions : ['SErviNGSliCes', 'Cheese', 'StuFfed'], vous devez renvoyer 'Slices.SErviNGSliCes' car 'SErviNGSliCes' est l'extension la plus forte (sa force est -1). Exemple :", "entry_point": "Strongest_Extension", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/74", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * Vous avez deux mots. Vous devez renvoyer True si le deuxième mot ou l'une de ses rotations est une sous-chaîne dans le premier mot.\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n * \n * \n */\nconst cycpattern_check = function (a: string, b: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = cycpattern_check(\"xyzw\",\"xyw\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = cycpattern_check(\"yello\",\"ell\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = cycpattern_check(\"whattup\",\"ptut\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = cycpattern_check(\"efef\",\"fee\");\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = cycpattern_check(\"abab\",\"aabb\");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = cycpattern_check(\"winemtt\",\"tinem\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Vous avez deux mots. Vous devez renvoyer True si le deuxième mot ou l'une de ses rotations est une sous-chaîne dans le premier mot.", "entry_point": "cycpattern_check", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/75", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Étant donné un entier positif, obtenez son équivalent en chiffres romains sous forme de chaîne de caractères et retournez-le en minuscules.\n * Restrictions : 1 <= num <= 1000\n * \n * Exemples :\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n * \n */\nconst int_to_mini_roman = function (number0: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = int_to_mini_roman(19);\nlet expected_1 = \"xix\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = int_to_mini_roman(152);\nlet expected_2 = \"clii\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = int_to_mini_roman(251);\nlet expected_3 = \"ccli\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = int_to_mini_roman(426);\nlet expected_4 = \"cdxxvi\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = int_to_mini_roman(500);\nlet expected_5 = \"d\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = int_to_mini_roman(1);\nlet expected_6 = \"i\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = int_to_mini_roman(4);\nlet expected_7 = \"iv\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = int_to_mini_roman(43);\nlet expected_8 = \"xliii\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = int_to_mini_roman(90);\nlet expected_9 = \"xc\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = int_to_mini_roman(94);\nlet expected_10 = \"xciv\";\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = int_to_mini_roman(532);\nlet expected_11 = \"dxxxii\";\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = int_to_mini_roman(900);\nlet expected_12 = \"cm\";\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = int_to_mini_roman(994);\nlet expected_13 = \"cmxciv\";\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = int_to_mini_roman(1000);\nlet expected_14 = \"m\";\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné un entier positif, obtenez son équivalent en chiffres romains sous forme de chaîne de caractères et retournez-le en minuscules.\nRestrictions : 1 <= num <= 1000\n\nExemples :", "entry_point": "int_to_mini_roman", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/76", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Étant donné les longueurs des trois côtés d'un triangle. Renvoyer True si les trois côtés forment un triangle rectangle, False sinon. Un triangle rectangle est un triangle dans lequel un angle est un angle droit ou de 90 degrés. Exemple:\n * \n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n * \n */\nconst right_angle_triangle = function (a: number, b: number, c: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = right_angle_triangle(3,4,5);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = right_angle_triangle(1,2,3);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = right_angle_triangle(10,6,8);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = right_angle_triangle(2,2,2);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = right_angle_triangle(7,24,25);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = right_angle_triangle(10,5,7);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = right_angle_triangle(5,12,13);\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = right_angle_triangle(15,8,17);\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = right_angle_triangle(48,55,73);\nlet expected_9 = true;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = right_angle_triangle(1,1,1);\nlet expected_10 = false;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = right_angle_triangle(2,2,10);\nlet expected_11 = false;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné les longueurs des trois côtés d'un triangle. Renvoyer True si les trois côtés forment un triangle rectangle, False sinon. Un triangle rectangle est un triangle dans lequel un angle est un angle droit ou de 90 degrés. Exemple:", "entry_point": "right_angle_triangle", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/77", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * On vous donne une chaîne de caractères s.\n *     Si s[i] est une lettre, inversez sa casse de minuscule à majuscule ou vice versa,\n *     sinon gardez-le tel quel.\n *     Si la chaîne ne contient pas de lettres, inversez la chaîne.\n *     La fonction doit renvoyer la chaîne résultante.\n *     Exemples\n * \n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n * \n */\nconst solve = function (s: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = solve(\"AsDf\");\nlet expected_1 = \"aSdF\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = solve(\"1234\");\nlet expected_2 = \"4321\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = solve(\"ab\");\nlet expected_3 = \"AB\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = solve(\"#a@C\");\nlet expected_4 = \"#A@c\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = solve(\"#AsdfW^45\");\nlet expected_5 = \"#aSDFw^45\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = solve(\"#6@2\");\nlet expected_6 = \"2@6#\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = solve(\"#$a^D\");\nlet expected_7 = \"#$A^d\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = solve(\"#ccc\");\nlet expected_8 = \"#CCC\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "On vous donne une chaîne de caractères s.\n    Si s[i] est une lettre, inversez sa casse de minuscule à majuscule ou vice versa,\n    sinon gardez-le tel quel.\n    Si la chaîne ne contient pas de lettres, inversez la chaîne.\n    La fonction doit renvoyer la chaîne résultante.\n    Exemples", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/78", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Étant donné une chaîne de caractères 'text', retournez sa chaîne équivalente de hachage md5. Si 'text' est une chaîne vide, retournez null.\n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n * \n */\nconst string_to_md5 = function (text: string) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = string_to_md5(\"Hello world\");\nlet expected_1 = \"3e25960a79dbc69b674cd4ec67a72c62\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = string_to_md5(\"\");\nlet expected_2 = undefined;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = string_to_md5(\"A B C\");\nlet expected_3 = \"0ef78513b0cb8cef12743f5aeb35f888\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = string_to_md5(\"password\");\nlet expected_4 = \"5f4dcc3b5aa765d61d8327deb882cf99\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné une chaîne de caractères 'text', retournez sa chaîne équivalente de hachage md5. Si 'text' est une chaîne vide, retournez null.", "entry_point": "string_to_md5", "canonical_solution": NaN, "natural_language": "French"}
{"task_id": "typescript/79", "prompt": "/**\n * Vous êtes un programmeur TypeScript expert.\n * \n * Étant donné deux entiers positifs a et b, renvoyer les chiffres pairs entre a et b, dans l'ordre croissant.\n * \n * Par exemple:\n * \n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n * \n */\nconst generate_integers = function (a: number, b: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = generate_integers(2,10);\nlet expected_1 = [2, 4, 6, 8];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = generate_integers(10,2);\nlet expected_2 = [2, 4, 6, 8];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = generate_integers(132,2);\nlet expected_3 = [2, 4, 6, 8];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = generate_integers(17,89);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Étant donné deux entiers positifs a et b, renvoyer les chiffres pairs entre a et b, dans l'ordre croissant.\n\nPar exemple:", "entry_point": "generate_integers", "canonical_solution": NaN, "natural_language": "French"}
