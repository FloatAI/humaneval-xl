{"task_id": "typescript/0", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Bạn được cung cấp một danh sách các hoạt động gửi và rút tiền trên tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ điểm nào số dư của tài khoản có giảm xuống dưới không và tại điểm đó, hàm sẽ trả về True. Nếu không, nó sẽ trả về False.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n * \n */\nconst below_zero = function (operations: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = below_zero([]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = below_zero([1, 2, -3, 1, 2, -3]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = below_zero([1, 2, -4, 5, 6]);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = below_zero([1, -1, 2, -2, 5, -5, 4, -4]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = below_zero([1, -1, 2, -2, 5, -5, 4, -5]);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = below_zero([1, -2, 2, -2, 5, -5, 4, -4]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cung cấp một danh sách các hoạt động gửi và rút tiền trên tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ điểm nào số dư của tài khoản có giảm xuống dưới không và tại điểm đó, hàm sẽ trả về True. Nếu không, nó sẽ trả về False.", "entry_point": "below_zero", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/1", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Cho một danh sách số nguyên, trả về một tuple bao gồm tổng và tích của tất cả các số nguyên trong danh sách.\n *     Tổng rỗng phải bằng 0 và tích rỗng phải bằng 1.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n * \n */\nconst sum_product = function (numbers: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_product([]);\nlet expected_1 = [0, 1];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_product([1, 1, 1]);\nlet expected_2 = [3, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_product([100, 0]);\nlet expected_3 = [100, 0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_product([3, 5, 7]);\nlet expected_4 = [15, 105];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_product([10]);\nlet expected_5 = [10, 10];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Cho một danh sách số nguyên, trả về một tuple bao gồm tổng và tích của tất cả các số nguyên trong danh sách.\n    Tổng rỗng phải bằng 0 và tích rỗng phải bằng 1.", "entry_point": "sum_product", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/2", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Đầu vào là hai chuỗi a và b chỉ gồm các số 1 và 0.\n *     Thực hiện phép XOR nhị phân trên hai đầu vào này và trả kết quả dưới dạng chuỗi.\n * >>> string_xor('010', '110')\n * '100'\n * \n */\nconst string_xor = function (a: string, b: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = string_xor(\"111000\",\"101010\");\nlet expected_1 = \"010010\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = string_xor(\"1\",\"1\");\nlet expected_2 = \"0\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = string_xor(\"0101\",\"0000\");\nlet expected_3 = \"0101\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "Đầu vào là hai chuỗi a và b chỉ gồm các số 1 và 0.\n    Thực hiện phép XOR nhị phân trên hai đầu vào này và trả kết quả dưới dạng chuỗi.", "entry_point": "string_xor", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/3", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Trong danh sách các chuỗi, trả về chuỗi dài nhất. Trả về chuỗi đầu tiên trong trường hợp có nhiều chuỗi cùng độ dài. Trả về null nếu danh sách đầu vào rỗng.\n * >>> longest([])\n * \n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n * \n */\nconst longest = function (strings: Array<string>) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = longest([]);\nlet expected_1 = undefined;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = longest([\"x\", \"y\", \"z\"]);\nlet expected_2 = \"x\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = longest([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]);\nlet expected_3 = \"zzzz\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "Trong danh sách các chuỗi, trả về chuỗi dài nhất. Trả về chuỗi đầu tiên trong trường hợp có nhiều chuỗi cùng độ dài. Trả về null nếu danh sách đầu vào rỗng.", "entry_point": "longest", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/4", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Trả về ước số chung lớn nhất của hai số nguyên a và b.\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n * \n */\nconst greatest_common_divisor = function (a: number, b: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = greatest_common_divisor(3,7);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = greatest_common_divisor(10,15);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = greatest_common_divisor(49,14);\nlet expected_3 = 7;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = greatest_common_divisor(144,60);\nlet expected_4 = 12;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Trả về ước số chung lớn nhất của hai số nguyên a và b.", "entry_point": "greatest_common_divisor", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/5", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Đầu vào là một chuỗi các số được phân tách bằng khoảng trắng từ 'zero' đến 'nine'.\n *     Các lựa chọn hợp lệ là 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' và 'nine'.\n *     Trả về chuỗi với các số được sắp xếp từ nhỏ đến lớn.\n * >>> sort_numbers('three one five')\n * 'one three five'\n * \n */\nconst sort_numbers = function (numbers: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sort_numbers(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sort_numbers(\"three\");\nlet expected_2 = \"three\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sort_numbers(\"three five nine\");\nlet expected_3 = \"three five nine\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sort_numbers(\"five zero four seven nine eight\");\nlet expected_4 = \"zero four five seven eight nine\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sort_numbers(\"six five four three two one zero\");\nlet expected_5 = \"zero one two three four five six\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Đầu vào là một chuỗi các số được phân tách bằng khoảng trắng từ 'zero' đến 'nine'.\n    Các lựa chọn hợp lệ là 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' và 'nine'.\n    Trả về chuỗi với các số được sắp xếp từ nhỏ đến lớn.", "entry_point": "sort_numbers", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/6", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Cho một danh sách các số (ít nhất hai phần tử), áp dụng một phép biến đổi tuyến tính cho danh sách đó, sao cho số nhỏ nhất sẽ trở thành 0 và số lớn nhất sẽ trở thành 1.\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n * \n */\nconst rescale_to_unit = function (numbers: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = rescale_to_unit([2.0, 49.9]);\nlet expected_1 = [0.0, 1.0];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = rescale_to_unit([100.0, 49.9]);\nlet expected_2 = [1.0, 0.0];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]);\nlet expected_3 = [0.0, 0.25, 0.5, 0.75, 1.0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]);\nlet expected_4 = [0.25, 0.0, 1.0, 0.5, 0.75];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]);\nlet expected_5 = [0.25, 0.0, 1.0, 0.5, 0.75];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Cho một danh sách các số (ít nhất hai phần tử), áp dụng một phép biến đổi tuyến tính cho danh sách đó, sao cho số nhỏ nhất sẽ trở thành 0 và số lớn nhất sẽ trở thành 1.", "entry_point": "rescale_to_unit", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/7", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Đối với một chuỗi đã cho, đảo ngược các ký tự viết thường thành viết hoa và viết hoa thành viết thường.\n * >>> flip_case('Hello')\n * 'hELLO'\n * \n */\nconst flip_case = function (string0: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = flip_case(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = flip_case(\"Hello!\");\nlet expected_2 = \"hELLO!\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = flip_case(\"These violent delights have violent ends\");\nlet expected_3 = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\n", "language": "typescript", "description": "Đối với một chuỗi đã cho, đảo ngược các ký tự viết thường thành viết hoa và viết hoa thành viết thường.", "entry_point": "flip_case", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/8", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Trả về chỉ các số dương trong danh sách.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n * \n */\nconst get_positive = function (l: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_positive([-1, -2, 4, 5, 6]);\nlet expected_1 = [4, 5, 6];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]);\nlet expected_2 = [5, 3, 2, 3, 3, 9, 123, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_positive([-1, -2]);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_positive([]);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Trả về chỉ các số dương trong danh sách.", "entry_point": "get_positive", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/9", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Trả về giá trị đúng nếu một số được cho là số nguyên tố, và sai nếu không phải.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n * \n */\nconst is_prime = function (n: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_prime(6);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_prime(101);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_prime(11);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_prime(13441);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_prime(61);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_prime(4);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_prime(1);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_prime(5);\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_prime(11);\nlet expected_9 = true;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_prime(17);\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = is_prime(85);\nlet expected_11 = false;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = is_prime(77);\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = is_prime(255379);\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\n", "language": "typescript", "description": "Trả về giá trị đúng nếu một số được cho là số nguyên tố, và sai nếu không phải.", "entry_point": "is_prime", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/10", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Trả về các phần tử duy nhất đã được sắp xếp trong một danh sách.\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n * \n */\nconst unique = function (l: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = unique([5, 3, 5, 2, 3, 3, 9, 0, 123]);\nlet expected_1 = [0, 2, 3, 5, 9, 123];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\n", "language": "typescript", "description": "Trả về các phần tử duy nhất đã được sắp xếp trong một danh sách.", "entry_point": "unique", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/11", "prompt": "import * as math from 'mathjs'\n\n/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * prime_fib trả về số thứ n trong dãy Fibonacci và cũng là số nguyên tố.\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n * \n */\nconst prime_fib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = prime_fib(1);\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = prime_fib(2);\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = prime_fib(3);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = prime_fib(4);\nlet expected_4 = 13;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = prime_fib(5);\nlet expected_5 = 89;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = prime_fib(6);\nlet expected_6 = 233;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = prime_fib(7);\nlet expected_7 = 1597;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = prime_fib(8);\nlet expected_8 = 28657;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = prime_fib(9);\nlet expected_9 = 514229;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = prime_fib(10);\nlet expected_10 = 433494437;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "prime_fib trả về số thứ n trong dãy Fibonacci và cũng là số nguyên tố.", "entry_point": "prime_fib", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/12", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Hàm triples_sum_to_zero nhận vào một danh sách số nguyên.\n * Nó trả về True nếu có ba phần tử khác nhau trong danh sách mà tổng của chúng bằng 0, và False trong trường hợp ngược lại.\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n * \n */\nconst triples_sum_to_zero = function (l: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = triples_sum_to_zero([1, 3, 5, 0]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = triples_sum_to_zero([1, 3, 5, -1]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = triples_sum_to_zero([1, 3, -2, 1]);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = triples_sum_to_zero([1, 2, 3, 7]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = triples_sum_to_zero([1, 2, 5, 7]);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = triples_sum_to_zero([2, 4, -5, 3, 9, 7]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = triples_sum_to_zero([1]);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = triples_sum_to_zero([1, 3, 5, -100]);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = triples_sum_to_zero([100, 3, 5, -100]);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Hàm triples_sum_to_zero nhận vào một danh sách số nguyên.\nNó trả về True nếu có ba phần tử khác nhau trong danh sách mà tổng của chúng bằng 0, và False trong trường hợp ngược lại.", "entry_point": "triples_sum_to_zero", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/13", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Hàm pairs_sum_to_zero nhận vào một danh sách các số nguyên.\n * Nó sẽ trả về True nếu có hai phần tử khác nhau trong danh sách có tổng bằng 0, ngược lại trả về False.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n * \n */\nconst pairs_sum_to_zero = function (l: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = pairs_sum_to_zero([1, 3, 5, 0]);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = pairs_sum_to_zero([1, 3, -2, 1]);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = pairs_sum_to_zero([1, 2, 3, 7]);\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = pairs_sum_to_zero([2, 4, -5, 3, 5, 7]);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = pairs_sum_to_zero([1]);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]);\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Hàm pairs_sum_to_zero nhận vào một danh sách các số nguyên.\nNó sẽ trả về True nếu có hai phần tử khác nhau trong danh sách có tổng bằng 0, ngược lại trả về False.", "entry_point": "pairs_sum_to_zero", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/14", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Dãy số Fib4 là một dãy số tương tự như dãy số Fibonacci được định nghĩa như sau:\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n *     Vui lòng viết một hàm để tính toán hiệu quả phần tử thứ n của dãy số Fib4. Không sử dụng đệ quy.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n * \n */\nconst fib4 = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fib4(5);\nlet expected_1 = 4;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fib4(8);\nlet expected_2 = 28;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fib4(10);\nlet expected_3 = 104;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fib4(12);\nlet expected_4 = 386;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Dãy số Fib4 là một dãy số tương tự như dãy số Fibonacci được định nghĩa như sau:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Vui lòng viết một hàm để tính toán hiệu quả phần tử thứ n của dãy số Fib4. Không sử dụng đệ quy.", "entry_point": "fib4", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/15", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Trả về giá trị trung vị của các phần tử trong danh sách l.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n * \n */\nconst median = function (l: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = median([3, 1, 2, 4, 5]);\nlet expected_1 = 3;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = median([-10, 4, 6, 1000, 10, 20]);\nlet expected_2 = 8.0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = median([5]);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = median([6, 5]);\nlet expected_4 = 5.5;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = median([8, 1, 3, 9, 9, 2, 7]);\nlet expected_5 = 7;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Trả về giá trị trung vị của các phần tử trong danh sách l.", "entry_point": "median", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/16", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Kiểm tra xem chuỗi cho trước có phải là chuỗi đối xứng hay không.\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n * \n */\nconst is_palindrome = function (text: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_palindrome(\"\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_palindrome(\"aba\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_palindrome(\"aaaaa\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_palindrome(\"zbcd\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_palindrome(\"xywyx\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_palindrome(\"xywyz\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_palindrome(\"xywzx\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Kiểm tra xem chuỗi cho trước có phải là chuỗi đối xứng hay không.", "entry_point": "is_palindrome", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/17", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * remove_vowels là một hàm nhận vào một chuỗi và trả về chuỗi không có nguyên âm.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n * \n */\nconst remove_vowels = function (text: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = remove_vowels(\"\");\nlet expected_1 = \"\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = remove_vowels(\"abcdef\\nghijklm\");\nlet expected_2 = \"bcdf\\nghjklm\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = remove_vowels(\"fedcba\");\nlet expected_3 = \"fdcb\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = remove_vowels(\"eeeee\");\nlet expected_4 = \"\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = remove_vowels(\"acBAA\");\nlet expected_5 = \"cB\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = remove_vowels(\"EcBOO\");\nlet expected_6 = \"cB\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = remove_vowels(\"ybcd\");\nlet expected_7 = \"ybcd\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "remove_vowels là một hàm nhận vào một chuỗi và trả về chuỗi không có nguyên âm.", "entry_point": "remove_vowels", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/18", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Trả về True nếu tất cả các số trong danh sách l đều nhỏ hơn ngưỡng t.\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n * \n */\nconst below_threshold = function (l: Array<number>, t: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = below_threshold([1, 2, 4, 10],100);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = below_threshold([1, 20, 4, 10],5);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = below_threshold([1, 20, 4, 10],21);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = below_threshold([1, 20, 4, 10],22);\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = below_threshold([1, 8, 4, 10],11);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = below_threshold([1, 8, 4, 10],10);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Trả về True nếu tất cả các số trong danh sách l đều nhỏ hơn ngưỡng t.", "entry_point": "below_threshold", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/19", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Thêm hai số x và y.\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n * \n */\nconst add = function (x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = add(0,1);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = add(1,0);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = add(2,3);\nlet expected_3 = 5;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = add(5,7);\nlet expected_4 = 12;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = add(7,5);\nlet expected_5 = 12;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = add(572,725);\nlet expected_6 = 1297;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = add(51,804);\nlet expected_7 = 855;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = add(645,96);\nlet expected_8 = 741;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = add(712,853);\nlet expected_9 = 1565;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = add(223,101);\nlet expected_10 = 324;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = add(76,29);\nlet expected_11 = 105;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = add(416,149);\nlet expected_12 = 565;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = add(145,409);\nlet expected_13 = 554;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = add(535,430);\nlet expected_14 = 965;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = add(118,303);\nlet expected_15 = 421;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = add(287,94);\nlet expected_16 = 381;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\nlet actual_17 = add(768,257);\nlet expected_17 = 1025;\nassert.deepEqual(actual_17, expected_17, \"Exception --- test case 16 failed to pass\");\n\nlet actual_18 = add(421,677);\nlet expected_18 = 1098;\nassert.deepEqual(actual_18, expected_18, \"Exception --- test case 17 failed to pass\");\n\nlet actual_19 = add(802,814);\nlet expected_19 = 1616;\nassert.deepEqual(actual_19, expected_19, \"Exception --- test case 18 failed to pass\");\n\nlet actual_20 = add(510,922);\nlet expected_20 = 1432;\nassert.deepEqual(actual_20, expected_20, \"Exception --- test case 19 failed to pass\");\n\nlet actual_21 = add(345,819);\nlet expected_21 = 1164;\nassert.deepEqual(actual_21, expected_21, \"Exception --- test case 20 failed to pass\");\n\nlet actual_22 = add(895,436);\nlet expected_22 = 1331;\nassert.deepEqual(actual_22, expected_22, \"Exception --- test case 21 failed to pass\");\n\nlet actual_23 = add(123,424);\nlet expected_23 = 547;\nassert.deepEqual(actual_23, expected_23, \"Exception --- test case 22 failed to pass\");\n\nlet actual_24 = add(923,245);\nlet expected_24 = 1168;\nassert.deepEqual(actual_24, expected_24, \"Exception --- test case 23 failed to pass\");\n\nlet actual_25 = add(23,438);\nlet expected_25 = 461;\nassert.deepEqual(actual_25, expected_25, \"Exception --- test case 24 failed to pass\");\n\nlet actual_26 = add(565,133);\nlet expected_26 = 698;\nassert.deepEqual(actual_26, expected_26, \"Exception --- test case 25 failed to pass\");\n\nlet actual_27 = add(945,925);\nlet expected_27 = 1870;\nassert.deepEqual(actual_27, expected_27, \"Exception --- test case 26 failed to pass\");\n\nlet actual_28 = add(261,983);\nlet expected_28 = 1244;\nassert.deepEqual(actual_28, expected_28, \"Exception --- test case 27 failed to pass\");\n\nlet actual_29 = add(139,577);\nlet expected_29 = 716;\nassert.deepEqual(actual_29, expected_29, \"Exception --- test case 28 failed to pass\");\n\nlet actual_30 = add(763,178);\nlet expected_30 = 941;\nassert.deepEqual(actual_30, expected_30, \"Exception --- test case 29 failed to pass\");\n\nlet actual_31 = add(147,892);\nlet expected_31 = 1039;\nassert.deepEqual(actual_31, expected_31, \"Exception --- test case 30 failed to pass\");\n\nlet actual_32 = add(436,402);\nlet expected_32 = 838;\nassert.deepEqual(actual_32, expected_32, \"Exception --- test case 31 failed to pass\");\n\nlet actual_33 = add(610,581);\nlet expected_33 = 1191;\nassert.deepEqual(actual_33, expected_33, \"Exception --- test case 32 failed to pass\");\n\nlet actual_34 = add(103,416);\nlet expected_34 = 519;\nassert.deepEqual(actual_34, expected_34, \"Exception --- test case 33 failed to pass\");\n\nlet actual_35 = add(339,990);\nlet expected_35 = 1329;\nassert.deepEqual(actual_35, expected_35, \"Exception --- test case 34 failed to pass\");\n\nlet actual_36 = add(130,504);\nlet expected_36 = 634;\nassert.deepEqual(actual_36, expected_36, \"Exception --- test case 35 failed to pass\");\n\nlet actual_37 = add(242,717);\nlet expected_37 = 959;\nassert.deepEqual(actual_37, expected_37, \"Exception --- test case 36 failed to pass\");\n\nlet actual_38 = add(562,110);\nlet expected_38 = 672;\nassert.deepEqual(actual_38, expected_38, \"Exception --- test case 37 failed to pass\");\n\nlet actual_39 = add(396,909);\nlet expected_39 = 1305;\nassert.deepEqual(actual_39, expected_39, \"Exception --- test case 38 failed to pass\");\n\nlet actual_40 = add(887,703);\nlet expected_40 = 1590;\nassert.deepEqual(actual_40, expected_40, \"Exception --- test case 39 failed to pass\");\n\nlet actual_41 = add(870,551);\nlet expected_41 = 1421;\nassert.deepEqual(actual_41, expected_41, \"Exception --- test case 40 failed to pass\");\n\nlet actual_42 = add(422,391);\nlet expected_42 = 813;\nassert.deepEqual(actual_42, expected_42, \"Exception --- test case 41 failed to pass\");\n\nlet actual_43 = add(299,505);\nlet expected_43 = 804;\nassert.deepEqual(actual_43, expected_43, \"Exception --- test case 42 failed to pass\");\n\nlet actual_44 = add(346,56);\nlet expected_44 = 402;\nassert.deepEqual(actual_44, expected_44, \"Exception --- test case 43 failed to pass\");\n\nlet actual_45 = add(36,706);\nlet expected_45 = 742;\nassert.deepEqual(actual_45, expected_45, \"Exception --- test case 44 failed to pass\");\n\nlet actual_46 = add(738,411);\nlet expected_46 = 1149;\nassert.deepEqual(actual_46, expected_46, \"Exception --- test case 45 failed to pass\");\n\nlet actual_47 = add(679,87);\nlet expected_47 = 766;\nassert.deepEqual(actual_47, expected_47, \"Exception --- test case 46 failed to pass\");\n\nlet actual_48 = add(25,303);\nlet expected_48 = 328;\nassert.deepEqual(actual_48, expected_48, \"Exception --- test case 47 failed to pass\");\n\nlet actual_49 = add(161,612);\nlet expected_49 = 773;\nassert.deepEqual(actual_49, expected_49, \"Exception --- test case 48 failed to pass\");\n\nlet actual_50 = add(306,841);\nlet expected_50 = 1147;\nassert.deepEqual(actual_50, expected_50, \"Exception --- test case 49 failed to pass\");\n\nlet actual_51 = add(973,411);\nlet expected_51 = 1384;\nassert.deepEqual(actual_51, expected_51, \"Exception --- test case 50 failed to pass\");\n\nlet actual_52 = add(711,157);\nlet expected_52 = 868;\nassert.deepEqual(actual_52, expected_52, \"Exception --- test case 51 failed to pass\");\n\nlet actual_53 = add(471,27);\nlet expected_53 = 498;\nassert.deepEqual(actual_53, expected_53, \"Exception --- test case 52 failed to pass\");\n\nlet actual_54 = add(714,792);\nlet expected_54 = 1506;\nassert.deepEqual(actual_54, expected_54, \"Exception --- test case 53 failed to pass\");\n\nlet actual_55 = add(38,206);\nlet expected_55 = 244;\nassert.deepEqual(actual_55, expected_55, \"Exception --- test case 54 failed to pass\");\n\nlet actual_56 = add(907,343);\nlet expected_56 = 1250;\nassert.deepEqual(actual_56, expected_56, \"Exception --- test case 55 failed to pass\");\n\nlet actual_57 = add(23,760);\nlet expected_57 = 783;\nassert.deepEqual(actual_57, expected_57, \"Exception --- test case 56 failed to pass\");\n\nlet actual_58 = add(524,859);\nlet expected_58 = 1383;\nassert.deepEqual(actual_58, expected_58, \"Exception --- test case 57 failed to pass\");\n\nlet actual_59 = add(30,529);\nlet expected_59 = 559;\nassert.deepEqual(actual_59, expected_59, \"Exception --- test case 58 failed to pass\");\n\nlet actual_60 = add(341,691);\nlet expected_60 = 1032;\nassert.deepEqual(actual_60, expected_60, \"Exception --- test case 59 failed to pass\");\n\nlet actual_61 = add(167,729);\nlet expected_61 = 896;\nassert.deepEqual(actual_61, expected_61, \"Exception --- test case 60 failed to pass\");\n\nlet actual_62 = add(636,289);\nlet expected_62 = 925;\nassert.deepEqual(actual_62, expected_62, \"Exception --- test case 61 failed to pass\");\n\nlet actual_63 = add(503,144);\nlet expected_63 = 647;\nassert.deepEqual(actual_63, expected_63, \"Exception --- test case 62 failed to pass\");\n\nlet actual_64 = add(51,985);\nlet expected_64 = 1036;\nassert.deepEqual(actual_64, expected_64, \"Exception --- test case 63 failed to pass\");\n\nlet actual_65 = add(287,149);\nlet expected_65 = 436;\nassert.deepEqual(actual_65, expected_65, \"Exception --- test case 64 failed to pass\");\n\nlet actual_66 = add(659,75);\nlet expected_66 = 734;\nassert.deepEqual(actual_66, expected_66, \"Exception --- test case 65 failed to pass\");\n\nlet actual_67 = add(462,797);\nlet expected_67 = 1259;\nassert.deepEqual(actual_67, expected_67, \"Exception --- test case 66 failed to pass\");\n\nlet actual_68 = add(406,141);\nlet expected_68 = 547;\nassert.deepEqual(actual_68, expected_68, \"Exception --- test case 67 failed to pass\");\n\nlet actual_69 = add(106,44);\nlet expected_69 = 150;\nassert.deepEqual(actual_69, expected_69, \"Exception --- test case 68 failed to pass\");\n\nlet actual_70 = add(300,934);\nlet expected_70 = 1234;\nassert.deepEqual(actual_70, expected_70, \"Exception --- test case 69 failed to pass\");\n\nlet actual_71 = add(471,524);\nlet expected_71 = 995;\nassert.deepEqual(actual_71, expected_71, \"Exception --- test case 70 failed to pass\");\n\nlet actual_72 = add(122,429);\nlet expected_72 = 551;\nassert.deepEqual(actual_72, expected_72, \"Exception --- test case 71 failed to pass\");\n\nlet actual_73 = add(735,195);\nlet expected_73 = 930;\nassert.deepEqual(actual_73, expected_73, \"Exception --- test case 72 failed to pass\");\n\nlet actual_74 = add(335,484);\nlet expected_74 = 819;\nassert.deepEqual(actual_74, expected_74, \"Exception --- test case 73 failed to pass\");\n\nlet actual_75 = add(28,809);\nlet expected_75 = 837;\nassert.deepEqual(actual_75, expected_75, \"Exception --- test case 74 failed to pass\");\n\nlet actual_76 = add(430,20);\nlet expected_76 = 450;\nassert.deepEqual(actual_76, expected_76, \"Exception --- test case 75 failed to pass\");\n\nlet actual_77 = add(916,635);\nlet expected_77 = 1551;\nassert.deepEqual(actual_77, expected_77, \"Exception --- test case 76 failed to pass\");\n\nlet actual_78 = add(301,999);\nlet expected_78 = 1300;\nassert.deepEqual(actual_78, expected_78, \"Exception --- test case 77 failed to pass\");\n\nlet actual_79 = add(454,466);\nlet expected_79 = 920;\nassert.deepEqual(actual_79, expected_79, \"Exception --- test case 78 failed to pass\");\n\nlet actual_80 = add(905,259);\nlet expected_80 = 1164;\nassert.deepEqual(actual_80, expected_80, \"Exception --- test case 79 failed to pass\");\n\nlet actual_81 = add(168,205);\nlet expected_81 = 373;\nassert.deepEqual(actual_81, expected_81, \"Exception --- test case 80 failed to pass\");\n\nlet actual_82 = add(570,434);\nlet expected_82 = 1004;\nassert.deepEqual(actual_82, expected_82, \"Exception --- test case 81 failed to pass\");\n\nlet actual_83 = add(64,959);\nlet expected_83 = 1023;\nassert.deepEqual(actual_83, expected_83, \"Exception --- test case 82 failed to pass\");\n\nlet actual_84 = add(957,510);\nlet expected_84 = 1467;\nassert.deepEqual(actual_84, expected_84, \"Exception --- test case 83 failed to pass\");\n\nlet actual_85 = add(722,598);\nlet expected_85 = 1320;\nassert.deepEqual(actual_85, expected_85, \"Exception --- test case 84 failed to pass\");\n\nlet actual_86 = add(770,226);\nlet expected_86 = 996;\nassert.deepEqual(actual_86, expected_86, \"Exception --- test case 85 failed to pass\");\n\nlet actual_87 = add(579,66);\nlet expected_87 = 645;\nassert.deepEqual(actual_87, expected_87, \"Exception --- test case 86 failed to pass\");\n\nlet actual_88 = add(117,674);\nlet expected_88 = 791;\nassert.deepEqual(actual_88, expected_88, \"Exception --- test case 87 failed to pass\");\n\nlet actual_89 = add(530,30);\nlet expected_89 = 560;\nassert.deepEqual(actual_89, expected_89, \"Exception --- test case 88 failed to pass\");\n\nlet actual_90 = add(776,345);\nlet expected_90 = 1121;\nassert.deepEqual(actual_90, expected_90, \"Exception --- test case 89 failed to pass\");\n\nlet actual_91 = add(327,389);\nlet expected_91 = 716;\nassert.deepEqual(actual_91, expected_91, \"Exception --- test case 90 failed to pass\");\n\nlet actual_92 = add(596,12);\nlet expected_92 = 608;\nassert.deepEqual(actual_92, expected_92, \"Exception --- test case 91 failed to pass\");\n\nlet actual_93 = add(599,511);\nlet expected_93 = 1110;\nassert.deepEqual(actual_93, expected_93, \"Exception --- test case 92 failed to pass\");\n\nlet actual_94 = add(936,476);\nlet expected_94 = 1412;\nassert.deepEqual(actual_94, expected_94, \"Exception --- test case 93 failed to pass\");\n\nlet actual_95 = add(461,14);\nlet expected_95 = 475;\nassert.deepEqual(actual_95, expected_95, \"Exception --- test case 94 failed to pass\");\n\nlet actual_96 = add(966,157);\nlet expected_96 = 1123;\nassert.deepEqual(actual_96, expected_96, \"Exception --- test case 95 failed to pass\");\n\nlet actual_97 = add(326,91);\nlet expected_97 = 417;\nassert.deepEqual(actual_97, expected_97, \"Exception --- test case 96 failed to pass\");\n\nlet actual_98 = add(392,455);\nlet expected_98 = 847;\nassert.deepEqual(actual_98, expected_98, \"Exception --- test case 97 failed to pass\");\n\nlet actual_99 = add(446,477);\nlet expected_99 = 923;\nassert.deepEqual(actual_99, expected_99, \"Exception --- test case 98 failed to pass\");\n\nlet actual_100 = add(324,860);\nlet expected_100 = 1184;\nassert.deepEqual(actual_100, expected_100, \"Exception --- test case 99 failed to pass\");\n\nlet actual_101 = add(945,85);\nlet expected_101 = 1030;\nassert.deepEqual(actual_101, expected_101, \"Exception --- test case 100 failed to pass\");\n\nlet actual_102 = add(886,582);\nlet expected_102 = 1468;\nassert.deepEqual(actual_102, expected_102, \"Exception --- test case 101 failed to pass\");\n\nlet actual_103 = add(886,712);\nlet expected_103 = 1598;\nassert.deepEqual(actual_103, expected_103, \"Exception --- test case 102 failed to pass\");\n\nlet actual_104 = add(842,953);\nlet expected_104 = 1795;\nassert.deepEqual(actual_104, expected_104, \"Exception --- test case 103 failed to pass\");\n\n", "language": "typescript", "description": "Thêm hai số x và y.", "entry_point": "add", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/20", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Kiểm tra xem hai từ có cùng các ký tự hay không.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n * \n */\nconst same_chars = function (s0: string, s1: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = same_chars(\"eabcdzzzz\",\"dddzzzzzzzddeddabc\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = same_chars(\"abcd\",\"dddddddabc\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = same_chars(\"dddddddabc\",\"abcd\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = same_chars(\"eabcd\",\"dddddddabc\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = same_chars(\"abcd\",\"dddddddabcf\");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = same_chars(\"eabcdzzzz\",\"dddzzzzzzzddddabc\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = same_chars(\"aabb\",\"aaccc\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Kiểm tra xem hai từ có cùng các ký tự hay không.", "entry_point": "same_chars", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/21", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Trả về số Fibonacci thứ n.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n * \n */\nconst fib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fib(10);\nlet expected_1 = 55;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fib(1);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fib(8);\nlet expected_3 = 21;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fib(11);\nlet expected_4 = 89;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = fib(12);\nlet expected_5 = 144;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Trả về số Fibonacci thứ n.", "entry_point": "fib", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/22", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Trả về các phần tử chung duy nhất đã được sắp xếp cho hai danh sách.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n * \n * \n */\nconst common = function (l1: Array<number>, l2: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = common([1, 4, 3, 34, 653, 2, 5],[5, 7, 1, 5, 9, 653, 121]);\nlet expected_1 = [1, 5, 653];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = common([5, 3, 2, 8],[3, 2]);\nlet expected_2 = [2, 3];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = common([4, 3, 2, 8],[3, 2, 4]);\nlet expected_3 = [2, 3, 4];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = common([4, 3, 2, 8],[]);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Trả về các phần tử chung duy nhất đã được sắp xếp cho hai danh sách.", "entry_point": "common", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/23", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Trả về ước số nguyên tố lớn nhất của n. Giả sử n > 1 và không phải là số nguyên tố.\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n * \n */\nconst largest_prime_factor = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = largest_prime_factor(15);\nlet expected_1 = 5;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = largest_prime_factor(27);\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = largest_prime_factor(63);\nlet expected_3 = 7;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = largest_prime_factor(330);\nlet expected_4 = 11;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = largest_prime_factor(13195);\nlet expected_5 = 29;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Trả về ước số nguyên tố lớn nhất của n. Giả sử n > 1 và không phải là số nguyên tố.", "entry_point": "largest_prime_factor", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/24", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * sum_to_n là một hàm tính tổng các số từ 1 đến n.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n * \n */\nconst sum_to_n = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_to_n(1);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_to_n(6);\nlet expected_2 = 21;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_to_n(11);\nlet expected_3 = 66;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_to_n(30);\nlet expected_4 = 465;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_to_n(100);\nlet expected_5 = 5050;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "sum_to_n là một hàm tính tổng các số từ 1 đến n.", "entry_point": "sum_to_n", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/25", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * xs đại diện cho các hệ số của một đa thức.\n *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n *     Trả về đạo hàm của đa thức này dưới cùng dạng.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n * \n */\nconst derivative = function (xs: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = derivative([3, 1, 2, 4, 5]);\nlet expected_1 = [1, 4, 12, 20];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = derivative([1, 2, 3]);\nlet expected_2 = [2, 6];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = derivative([3, 2, 1]);\nlet expected_3 = [2, 2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = derivative([3, 2, 1, 0, 4]);\nlet expected_4 = [2, 2, 0, 16];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = derivative([1]);\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "xs đại diện cho các hệ số của một đa thức.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Trả về đạo hàm của đa thức này dưới cùng dạng.", "entry_point": "derivative", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/26", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Dãy số FibFib là một dãy số tương tự như dãy số Fibonacci được định nghĩa như sau:\n *     fibfib(0) == 0\n *     fibfib(1) == 0\n *     fibfib(2) == 1\n *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n *     Vui lòng viết một hàm để tính toán hiệu quả phần tử thứ n của dãy số FibFib.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n * \n */\nconst fibfib = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = fibfib(2);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = fibfib(1);\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = fibfib(5);\nlet expected_3 = 4;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = fibfib(8);\nlet expected_4 = 24;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = fibfib(10);\nlet expected_5 = 81;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = fibfib(12);\nlet expected_6 = 274;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = fibfib(14);\nlet expected_7 = 927;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Dãy số FibFib là một dãy số tương tự như dãy số Fibonacci được định nghĩa như sau:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Vui lòng viết một hàm để tính toán hiệu quả phần tử thứ n của dãy số FibFib.", "entry_point": "fibfib", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/27", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Viết một hàm vowels_count nhận vào một chuỗi đại diện cho một từ và trả về số lượng nguyên âm trong chuỗi. Nguyên âm trong trường hợp này là 'a', 'e', 'i', 'o', 'u'. Ở đây, 'y' cũng là một nguyên âm, nhưng chỉ khi nó ở cuối từ đã cho.\n * \n * Ví dụ:\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n * \n */\nconst vowels_count = function (s: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = vowels_count(\"abcde\");\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = vowels_count(\"Alone\");\nlet expected_2 = 3;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = vowels_count(\"key\");\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = vowels_count(\"bye\");\nlet expected_4 = 1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = vowels_count(\"keY\");\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = vowels_count(\"bYe\");\nlet expected_6 = 1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = vowels_count(\"ACEDY\");\nlet expected_7 = 3;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Viết một hàm vowels_count nhận vào một chuỗi đại diện cho một từ và trả về số lượng nguyên âm trong chuỗi. Nguyên âm trong trường hợp này là 'a', 'e', 'i', 'o', 'u'. Ở đây, 'y' cũng là một nguyên âm, nhưng chỉ khi nó ở cuối từ đã cho.\n\nVí dụ:", "entry_point": "vowels_count", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/28", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Bạn được cho một danh sách không rỗng các số nguyên dương. Trả về số nguyên lớn nhất mà lớn hơn 0 và có tần suất xuất hiện lớn hơn hoặc bằng giá trị của số đó. Tần suất của một số nguyên là số lần nó xuất hiện trong danh sách. Nếu không có giá trị như vậy tồn tại, trả về -1. Ví dụ:\n * \n * search([4, 1, 2, 2, 3, 1]) == 2\n * search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n * search([5, 5, 4, 4, 4]) == -1\n * \n */\nconst search = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = search([5, 5, 5, 5, 1]);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = search([4, 1, 4, 1, 4, 4]);\nlet expected_2 = 4;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = search([3, 3]);\nlet expected_3 = -1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = search([8, 8, 8, 8, 8, 8, 8, 8]);\nlet expected_4 = 8;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = search([2, 3, 3, 2, 2]);\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = search([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]);\nlet expected_6 = 1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = search([3, 2, 8, 2]);\nlet expected_7 = 2;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]);\nlet expected_8 = 1;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = search([8, 8, 3, 6, 5, 6, 4]);\nlet expected_9 = -1;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = search([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]);\nlet expected_10 = 1;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = search([1, 9, 10, 1, 3]);\nlet expected_11 = 1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = search([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]);\nlet expected_12 = 5;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = search([1]);\nlet expected_13 = 1;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = search([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]);\nlet expected_14 = 4;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]);\nlet expected_15 = 2;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]);\nlet expected_16 = 1;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\nlet actual_17 = search([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]);\nlet expected_17 = 4;\nassert.deepEqual(actual_17, expected_17, \"Exception --- test case 16 failed to pass\");\n\nlet actual_18 = search([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]);\nlet expected_18 = 4;\nassert.deepEqual(actual_18, expected_18, \"Exception --- test case 17 failed to pass\");\n\nlet actual_19 = search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]);\nlet expected_19 = 2;\nassert.deepEqual(actual_19, expected_19, \"Exception --- test case 18 failed to pass\");\n\nlet actual_20 = search([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]);\nlet expected_20 = -1;\nassert.deepEqual(actual_20, expected_20, \"Exception --- test case 19 failed to pass\");\n\nlet actual_21 = search([10]);\nlet expected_21 = -1;\nassert.deepEqual(actual_21, expected_21, \"Exception --- test case 20 failed to pass\");\n\nlet actual_22 = search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]);\nlet expected_22 = 2;\nassert.deepEqual(actual_22, expected_22, \"Exception --- test case 21 failed to pass\");\n\nlet actual_23 = search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]);\nlet expected_23 = 1;\nassert.deepEqual(actual_23, expected_23, \"Exception --- test case 22 failed to pass\");\n\nlet actual_24 = search([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]);\nlet expected_24 = 1;\nassert.deepEqual(actual_24, expected_24, \"Exception --- test case 23 failed to pass\");\n\nlet actual_25 = search([3, 10, 10, 9, 2]);\nlet expected_25 = -1;\nassert.deepEqual(actual_25, expected_25, \"Exception --- test case 24 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cho một danh sách không rỗng các số nguyên dương. Trả về số nguyên lớn nhất mà lớn hơn 0 và có tần suất xuất hiện lớn hơn hoặc bằng giá trị của số đó. Tần suất của một số nguyên là số lần nó xuất hiện trong danh sách. Nếu không có giá trị như vậy tồn tại, trả về -1. Ví dụ:", "entry_point": "search", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/29", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Cho độ dài của ba cạnh của một tam giác. Trả về diện tích của tam giác được làm tròn đến 2 chữ số thập phân nếu ba cạnh tạo thành một tam giác hợp lệ. Nếu không, trả về -1. Ba cạnh tạo thành một tam giác hợp lệ khi tổng của hai cạnh bất kỳ lớn hơn cạnh thứ ba. Ví dụ:\n * \n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n * \n */\nconst triangle_area = function (a: number, b: number, c: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = triangle_area(3,4,5);\nlet expected_1 = 6.0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = triangle_area(1,2,10);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = triangle_area(4,8,5);\nlet expected_3 = 8.18;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = triangle_area(2,2,2);\nlet expected_4 = 1.73;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = triangle_area(1,2,3);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = triangle_area(10,5,7);\nlet expected_6 = 16.25;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = triangle_area(2,6,3);\nlet expected_7 = -1;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = triangle_area(1,1,1);\nlet expected_8 = 0.43;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = triangle_area(2,2,10);\nlet expected_9 = -1;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Cho độ dài của ba cạnh của một tam giác. Trả về diện tích của tam giác được làm tròn đến 2 chữ số thập phân nếu ba cạnh tạo thành một tam giác hợp lệ. Nếu không, trả về -1. Ba cạnh tạo thành một tam giác hợp lệ khi tổng của hai cạnh bất kỳ lớn hơn cạnh thứ ba. Ví dụ:", "entry_point": "triangle_area", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/30", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Viết một hàm trả về True nếu đối tượng q có thể bay, và False nếu không thể bay.\n *     Đối tượng q có thể bay nếu nó cân bằng (là một danh sách đối xứng) và tổng các phần tử của nó nhỏ hơn hoặc bằng trọng lượng tối đa có thể.\n * \n *     Ví dụ:\n *     will_it_fly([1, 2], 5) ➞ False \n *     # 1+2 nhỏ hơn trọng lượng tối đa có thể, nhưng không cân bằng.\n * \n *     will_it_fly([3, 2, 3], 1) ➞ False\n *     # nó cân bằng, nhưng 3+2+3 lớn hơn trọng lượng tối đa có thể.\n * \n *     will_it_fly([3, 2, 3], 9) ➞ True\n *     # 3+2+3 nhỏ hơn trọng lượng tối đa có thể, và nó cân bằng.\n * \n *     will_it_fly([3], 5) ➞ True\n *     # 3 nhỏ hơn trọng lượng tối đa có thể, và nó cân bằng.\n * \n * \n */\nconst will_it_fly = function (q: Array<number>, w: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = will_it_fly([3, 2, 3],9);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = will_it_fly([1, 2],5);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = will_it_fly([3],5);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = will_it_fly([3, 2, 3],1);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = will_it_fly([1, 2, 3],6);\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = will_it_fly([5],5);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Viết một hàm trả về True nếu đối tượng q có thể bay, và False nếu không thể bay.\n    Đối tượng q có thể bay nếu nó cân bằng (là một danh sách đối xứng) và tổng các phần tử của nó nhỏ hơn hoặc bằng trọng lượng tối đa có thể.\n\n    Ví dụ:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 nhỏ hơn trọng lượng tối đa có thể, nhưng không cân bằng.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # nó cân bằng, nhưng 3+2+3 lớn hơn trọng lượng tối đa có thể.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 nhỏ hơn trọng lượng tối đa có thể, và nó cân bằng.\n\n    will_it_fly([3], 5) ➞ True\n    # 3 nhỏ hơn trọng lượng tối đa có thể, và nó cân bằng.", "entry_point": "will_it_fly", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/31", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Viết một hàm trả về giá trị true nếu số được cho là tích của 3 số nguyên tố và false trong trường hợp ngược lại. Biết rằng (a) nhỏ hơn 100. Ví dụ:\n * \n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n * \n */\nconst is_multiply_prime = function (a: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_multiply_prime(5);\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_multiply_prime(30);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_multiply_prime(8);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_multiply_prime(10);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_multiply_prime(125);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_multiply_prime(105);\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_multiply_prime(126);\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_multiply_prime(729);\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_multiply_prime(891);\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_multiply_prime(1001);\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Viết một hàm trả về giá trị true nếu số được cho là tích của 3 số nguyên tố và false trong trường hợp ngược lại. Biết rằng (a) nhỏ hơn 100. Ví dụ:", "entry_point": "is_multiply_prime", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/32", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Bạn sẽ được cung cấp một số dưới dạng thập phân và nhiệm vụ của bạn là chuyển đổi nó sang định dạng nhị phân. Hàm sẽ trả về một chuỗi, với mỗi ký tự đại diện cho một số nhị phân. Mỗi ký tự trong chuỗi sẽ là '0' hoặc '1'.\n * \n * Sẽ có một vài ký tự bổ sung 'db' ở đầu và cuối chuỗi. Các ký tự bổ sung này được sử dụng để giúp định dạng.\n * \n * Ví dụ:\n * \n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n * \n */\nconst decimal_to_binary = function (decimal: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = decimal_to_binary(0);\nlet expected_1 = \"db0db\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = decimal_to_binary(32);\nlet expected_2 = \"db100000db\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = decimal_to_binary(103);\nlet expected_3 = \"db1100111db\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = decimal_to_binary(15);\nlet expected_4 = \"db1111db\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Bạn sẽ được cung cấp một số dưới dạng thập phân và nhiệm vụ của bạn là chuyển đổi nó sang định dạng nhị phân. Hàm sẽ trả về một chuỗi, với mỗi ký tự đại diện cho một số nhị phân. Mỗi ký tự trong chuỗi sẽ là '0' hoặc '1'.\n\nSẽ có một vài ký tự bổ sung 'db' ở đầu và cuối chuỗi. Các ký tự bổ sung này được sử dụng để giúp định dạng.\n\nVí dụ:", "entry_point": "decimal_to_binary", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/33", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Bạn được cho một chuỗi s.\n * Nhiệm vụ của bạn là kiểm tra xem chuỗi đó có hạnh phúc hay không.\n * Một chuỗi được coi là hạnh phúc nếu độ dài của nó ít nhất là 3 và mỗi 3 chữ cái liên tiếp đều khác nhau.\n * Ví dụ:\n * \n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n * \n */\nconst is_happy = function (s: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_happy(\"a\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_happy(\"aa\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_happy(\"abcd\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_happy(\"aabb\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_happy(\"adb\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_happy(\"xyy\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_happy(\"iopaxpoi\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_happy(\"iopaxioi\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cho một chuỗi s.\nNhiệm vụ của bạn là kiểm tra xem chuỗi đó có hạnh phúc hay không.\nMột chuỗi được coi là hạnh phúc nếu độ dài của nó ít nhất là 3 và mỗi 3 chữ cái liên tiếp đều khác nhau.\nVí dụ:", "entry_point": "is_happy", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/34", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Đó là tuần cuối cùng của kỳ học và giáo viên phải đưa điểm cho học sinh. Giáo viên đã tạo thuật toán riêng của mình để đánh giá điểm. Vấn đề duy nhất là cô ấy đã mất mã mà cô ấy đã sử dụng để đánh giá điểm. Cô ấy đã cung cấp cho bạn một danh sách GPA của một số học sinh và bạn phải viết một chức năng có thể đưa ra một danh sách các điểm chữ sử dụng bảng sau:\n *              GPA       |    Điểm chữ\n *               4.0                A+\n *             > 3.7                A \n *             > 3.3                A- \n *             > 3.0                B+\n *             > 2.7                B \n *             > 2.3                B-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                E\n *     \n * \n *     Ví dụ:\n * \n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n * \n */\nconst numerical_letter_grade = function (grades: Array<number>) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]);\nlet expected_1 = [\"A+\", \"B\", \"C-\", \"C\", \"A-\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = numerical_letter_grade([1.2]);\nlet expected_2 = [\"D+\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = numerical_letter_grade([0.5]);\nlet expected_3 = [\"D-\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = numerical_letter_grade([0.0]);\nlet expected_4 = [\"E\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = numerical_letter_grade([1, 0.3, 1.5, 2.8, 3.3]);\nlet expected_5 = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = numerical_letter_grade([0, 0.7]);\nlet expected_6 = [\"E\", \"D-\"];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Đó là tuần cuối cùng của kỳ học và giáo viên phải đưa điểm cho học sinh. Giáo viên đã tạo thuật toán riêng của mình để đánh giá điểm. Vấn đề duy nhất là cô ấy đã mất mã mà cô ấy đã sử dụng để đánh giá điểm. Cô ấy đã cung cấp cho bạn một danh sách GPA của một số học sinh và bạn phải viết một chức năng có thể đưa ra một danh sách các điểm chữ sử dụng bảng sau:\n             GPA       |    Điểm chữ\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Ví dụ:", "entry_point": "numerical_letter_grade", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/35", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Viết một hàm nhận vào một chuỗi và trả về True nếu độ dài của chuỗi là số nguyên tố hoặc False nếu không phải. Ví dụ:\n * \n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n * \n */\nconst prime_length = function (string0: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = prime_length(\"Hello\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = prime_length(\"abcdcba\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = prime_length(\"kittens\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = prime_length(\"orange\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = prime_length(\"wow\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = prime_length(\"world\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = prime_length(\"MadaM\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = prime_length(\"Wow\");\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = prime_length(\"\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = prime_length(\"HI\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = prime_length(\"go\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = prime_length(\"gogo\");\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = prime_length(\"aaaaaaaaaaaaaaa\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = prime_length(\"Madam\");\nlet expected_14 = true;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\nlet actual_15 = prime_length(\"M\");\nlet expected_15 = false;\nassert.deepEqual(actual_15, expected_15, \"Exception --- test case 14 failed to pass\");\n\nlet actual_16 = prime_length(\"0\");\nlet expected_16 = false;\nassert.deepEqual(actual_16, expected_16, \"Exception --- test case 15 failed to pass\");\n\n", "language": "typescript", "description": "Viết một hàm nhận vào một chuỗi và trả về True nếu độ dài của chuỗi là số nguyên tố hoặc False nếu không phải. Ví dụ:", "entry_point": "prime_length", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/36", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Cho một số nguyên dương N, trả về tổng các chữ số của N ở hệ nhị phân.\n * \n *     Ví dụ\n *         Với N = 1000, tổng các chữ số sẽ là 1, đầu ra sẽ là \"1\".\n *         Với N = 150, tổng các chữ số sẽ là 6, đầu ra sẽ là \"110\".\n *         Với N = 147, tổng các chữ số sẽ là 12, đầu ra sẽ là \"1100\".\n *     \n *     Biến:\n *         @N số nguyên\n *              Ràng buộc: 0 ≤ N ≤ 10000.\n *     Đầu ra:\n *          một chuỗi số nhị phân.\n * \n * \n */\nconst solve = function (N: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = solve(1000);\nlet expected_1 = \"1\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = solve(150);\nlet expected_2 = \"110\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = solve(147);\nlet expected_3 = \"1100\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = solve(333);\nlet expected_4 = \"1001\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = solve(963);\nlet expected_5 = \"10010\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Cho một số nguyên dương N, trả về tổng các chữ số của N ở hệ nhị phân.\n\n    Ví dụ\n        Với N = 1000, tổng các chữ số sẽ là 1, đầu ra sẽ là \"1\".\n        Với N = 150, tổng các chữ số sẽ là 6, đầu ra sẽ là \"110\".\n        Với N = 147, tổng các chữ số sẽ là 12, đầu ra sẽ là \"1100\".\n    \n    Biến:\n        @N số nguyên\n             Ràng buộc: 0 ≤ N ≤ 10000.\n    Đầu ra:\n         một chuỗi số nhị phân.", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/37", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Bạn được cung cấp một dữ liệu 2 chiều dưới dạng danh sách lồng nhau, tương tự như ma trận, tuy nhiên, khác với ma trận, mỗi hàng có thể chứa một số lượng cột khác nhau. Cho lst và số nguyên x, tìm các số nguyên x trong danh sách và trả về danh sách các bộ, [(x1, y1), (x2, y2) ...] sao cho mỗi bộ là một tọa độ - (hàng, cột), bắt đầu từ 0. Sắp xếp các tọa độ ban đầu theo hàng theo thứ tự tăng dần. Ngoài ra, sắp xếp các tọa độ của hàng theo cột theo thứ tự giảm dần.\n * \n * Ví dụ:\n * \n * get_row([\n * [1,2,3,4,5,6],\n * [1,2,3,4,1,6],\n * [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n * \n */\nconst get_row = function (lst: Array<Array<number>>, x: number) : Array<Array<number>>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],1);\nlet expected_1 = [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],2);\nlet expected_2 = [[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],1);\nlet expected_3 = [[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_row([],1);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = get_row([[1]],2);\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = get_row([[], [1], [1, 2, 3]],3);\nlet expected_6 = [[2, 2]];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cung cấp một dữ liệu 2 chiều dưới dạng danh sách lồng nhau, tương tự như ma trận, tuy nhiên, khác với ma trận, mỗi hàng có thể chứa một số lượng cột khác nhau. Cho lst và số nguyên x, tìm các số nguyên x trong danh sách và trả về danh sách các bộ, [(x1, y1), (x2, y2) ...] sao cho mỗi bộ là một tọa độ - (hàng, cột), bắt đầu từ 0. Sắp xếp các tọa độ ban đầu theo hàng theo thứ tự tăng dần. Ngoài ra, sắp xếp các tọa độ của hàng theo cột theo thứ tự giảm dần.\n\nVí dụ:", "entry_point": "get_row", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/38", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Bạn được cung cấp một danh sách các số nguyên.\n * Viết một hàm next_smallest() trả về phần tử thứ hai nhỏ nhất của danh sách.\n * Trả về null nếu không có phần tử như vậy.\n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n * \n */\nconst next_smallest = function (lst: Array<number>) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = next_smallest([1, 2, 3, 4, 5]);\nlet expected_1 = 2;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = next_smallest([5, 1, 4, 3, 2]);\nlet expected_2 = 2;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = next_smallest([]);\nlet expected_3 = undefined;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = next_smallest([1, 1]);\nlet expected_4 = undefined;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = next_smallest([1, 1, 1, 1, 0]);\nlet expected_5 = 1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = next_smallest([1, 1]);\nlet expected_6 = undefined;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = next_smallest([-35, 34, 12, -45]);\nlet expected_7 = -35;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cung cấp một danh sách các số nguyên.\nViết một hàm next_smallest() trả về phần tử thứ hai nhỏ nhất của danh sách.\nTrả về null nếu không có phần tử như vậy.", "entry_point": "next_smallest", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/39", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Bạn sẽ được cung cấp một chuỗi các từ, và nhiệm vụ của bạn là đếm số lần chán nản. Một câu chán nản là một câu bắt đầu bằng từ \"I\". Các câu được phân cách bởi dấu '.', '?' hoặc '!'.\n * \n * Ví dụ:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n * \n */\nconst is_bored = function (S: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_bored(\"Hello world\");\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_bored(\"Is the sky blue?\");\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_bored(\"I love It !\");\nlet expected_3 = 1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_bored(\"bIt\");\nlet expected_4 = 0;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_bored(\"I feel good today. I will be productive. will kill It\");\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_bored(\"You and I are going for a walk\");\nlet expected_6 = 0;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Bạn sẽ được cung cấp một chuỗi các từ, và nhiệm vụ của bạn là đếm số lần chán nản. Một câu chán nản là một câu bắt đầu bằng từ \"I\". Các câu được phân cách bởi dấu '.', '?' hoặc '!'.\n\nVí dụ:", "entry_point": "is_bored", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/40", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Bạn được cho một danh sách các số nguyên.\n *     Bạn cần tìm giá trị nguyên tố lớn nhất và trả về tổng các chữ số của nó.\n * \n *     Ví dụ:\n * \n * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n * For lst = [0,81,12,3,1,21] the output should be 3\n * For lst = [0,8,1,2,1,7] the output should be 7\n * \n */\nconst skjkasdkd = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]);\nlet expected_1 = 10;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]);\nlet expected_2 = 25;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\nlet expected_3 = 13;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]);\nlet expected_4 = 11;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = skjkasdkd([0, 81, 12, 3, 1, 21]);\nlet expected_5 = 3;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = skjkasdkd([0, 8, 1, 2, 1, 7]);\nlet expected_6 = 7;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = skjkasdkd([8191]);\nlet expected_7 = 19;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = skjkasdkd([8191, 123456, 127, 7]);\nlet expected_8 = 19;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = skjkasdkd([127, 97, 8192]);\nlet expected_9 = 10;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cho một danh sách các số nguyên.\n    Bạn cần tìm giá trị nguyên tố lớn nhất và trả về tổng các chữ số của nó.\n\n    Ví dụ:", "entry_point": "skjkasdkd", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/41", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Cho một từ điển, trả về True nếu tất cả các khóa là chuỗi in thường hoặc tất cả các khóa là chuỗi in hoa, ngược lại trả về False. Hàm sẽ trả về False nếu từ điển trống. Ví dụ:\n * \n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n * \n */\nconst check_dict_case = function (dict: Map<any, string>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [\"b\", \"banana\"]]));\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [\"A\", \"banana\"], [\"B\", \"banana\"]]));\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = check_dict_case(new Map<any, any>([[\"p\", \"pineapple\"], [5, \"banana\"], [\"a\", \"apple\"]]));\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = check_dict_case(new Map<any, any>([[\"Name\", \"John\"], [\"Age\", \"36\"], [\"City\", \"Houston\"]]));\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = check_dict_case(new Map<any, any>([[\"STATE\", \"NC\"], [\"ZIP\", \"12345\"]]));\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = check_dict_case(new Map<any, any>([[\"fruit\", \"Orange\"], [\"taste\", \"Sweet\"]]));\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = check_dict_case(new Map<any, any>([]));\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Cho một từ điển, trả về True nếu tất cả các khóa là chuỗi in thường hoặc tất cả các khóa là chuỗi in hoa, ngược lại trả về False. Hàm sẽ trả về False nếu từ điển trống. Ví dụ:", "entry_point": "check_dict_case", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/42", "prompt": "import * as math from 'mathjs'\n\n/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Tạo một hàm nhận giá trị (chuỗi) đại diện cho một số và trả về số nguyên gần nhất. Nếu số đó cách đều hai số nguyên, làm tròn nó ra khỏi số 0.\n * \n *     Ví dụ:\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n * \n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n * \n */\nconst closest_integer = function (value: string) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = closest_integer(\"10\");\nlet expected_1 = 10;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = closest_integer(\"14.5\");\nlet expected_2 = 15;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = closest_integer(\"-15.5\");\nlet expected_3 = -16;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = closest_integer(\"15.3\");\nlet expected_4 = 15;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = closest_integer(\"0\");\nlet expected_5 = 0;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Tạo một hàm nhận giá trị (chuỗi) đại diện cho một số và trả về số nguyên gần nhất. Nếu số đó cách đều hai số nguyên, làm tròn nó ra khỏi số 0.\n\n    Ví dụ:", "entry_point": "closest_integer", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/43", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Cho một số nguyên dương n, bạn phải xếp một đống đá có n tầng.\n *     Tầng đầu tiên có n viên đá.\n *     Số lượng đá trong tầng tiếp theo là:\n *         - số lẻ tiếp theo nếu n là số lẻ.\n *         - số chẵn tiếp theo nếu n là số chẵn.\n *     Trả về số lượng đá trong mỗi tầng dưới dạng danh sách, trong đó phần tử tại chỉ số\n *     i đại diện cho số lượng đá trong tầng (i+1).\n * \n *     Ví dụ:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n * \n */\nconst make_a_pile = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = make_a_pile(3);\nlet expected_1 = [3, 5, 7];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = make_a_pile(4);\nlet expected_2 = [4, 6, 8, 10];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = make_a_pile(5);\nlet expected_3 = [5, 7, 9, 11, 13];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = make_a_pile(6);\nlet expected_4 = [6, 8, 10, 12, 14, 16];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = make_a_pile(8);\nlet expected_5 = [8, 10, 12, 14, 16, 18, 20, 22];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Cho một số nguyên dương n, bạn phải xếp một đống đá có n tầng.\n    Tầng đầu tiên có n viên đá.\n    Số lượng đá trong tầng tiếp theo là:\n        - số lẻ tiếp theo nếu n là số lẻ.\n        - số chẵn tiếp theo nếu n là số chẵn.\n    Trả về số lượng đá trong mỗi tầng dưới dạng danh sách, trong đó phần tử tại chỉ số\n    i đại diện cho số lượng đá trong tầng (i+1).\n\n    Ví dụ:", "entry_point": "make_a_pile", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/44", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Bạn sẽ được cung cấp một chuỗi các từ được phân tách bằng dấu phẩy hoặc khoảng trắng. Nhiệm vụ của bạn là tách chuỗi thành các từ và trả về một mảng các từ.\n * \n * Ví dụ:\n * \n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n * \n */\nconst words_string = function (s: string) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = words_string(\"Hi, my name is John\");\nlet expected_1 = [\"Hi\", \"my\", \"name\", \"is\", \"John\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = words_string(\"One, two, three, four, five, six\");\nlet expected_2 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = words_string(\"Hi, my name\");\nlet expected_3 = [\"Hi\", \"my\", \"name\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = words_string(\"One,, two, three, four, five, six,\");\nlet expected_4 = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = words_string(\"\");\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = words_string(\"ahmed     , gamal\");\nlet expected_6 = [\"ahmed\", \"gamal\"];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Bạn sẽ được cung cấp một chuỗi các từ được phân tách bằng dấu phẩy hoặc khoảng trắng. Nhiệm vụ của bạn là tách chuỗi thành các từ và trả về một mảng các từ.\n\nVí dụ:", "entry_point": "words_string", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/45", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Hàm này nhận hai số dương x và y và trả về số nguyên chẵn lớn nhất trong khoảng [x, y] bao gồm cả x và y. Nếu không có số như vậy, thì hàm sẽ trả về -1.\n * \n * Ví dụ:\n * \n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n * \n */\nconst choose_num = function (x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = choose_num(12,15);\nlet expected_1 = 14;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = choose_num(13,12);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = choose_num(33,12354);\nlet expected_3 = 12354;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = choose_num(5234,5233);\nlet expected_4 = -1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = choose_num(6,29);\nlet expected_5 = 28;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = choose_num(27,10);\nlet expected_6 = -1;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = choose_num(7,7);\nlet expected_7 = -1;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = choose_num(546,546);\nlet expected_8 = 546;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "Hàm này nhận hai số dương x và y và trả về số nguyên chẵn lớn nhất trong khoảng [x, y] bao gồm cả x và y. Nếu không có số như vậy, thì hàm sẽ trả về -1.\n\nVí dụ:", "entry_point": "choose_num", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/46", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Bạn được cho hai số nguyên dương n và m, và nhiệm vụ của bạn là tính trung bình cộng của các số nguyên từ n đến m (bao gồm cả n và m). Làm tròn kết quả đến số nguyên gần nhất và chuyển đổi thành số nhị phân. Nếu n lớn hơn m, trả về -1. Ví dụ:\n * \n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n * \n */\nconst rounded_avg = function (n: number, m: number) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = rounded_avg(1,5);\nlet expected_1 = \"0b11\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = rounded_avg(7,13);\nlet expected_2 = \"0b1010\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = rounded_avg(964,977);\nlet expected_3 = \"0b1111001010\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = rounded_avg(996,997);\nlet expected_4 = \"0b1111100100\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = rounded_avg(560,851);\nlet expected_5 = \"0b1011000010\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = rounded_avg(185,546);\nlet expected_6 = \"0b101101110\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = rounded_avg(362,496);\nlet expected_7 = \"0b110101101\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = rounded_avg(350,902);\nlet expected_8 = \"0b1001110010\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = rounded_avg(197,233);\nlet expected_9 = \"0b11010111\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = rounded_avg(7,5);\nlet expected_10 = -1;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = rounded_avg(5,1);\nlet expected_11 = -1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = rounded_avg(5,5);\nlet expected_12 = \"0b101\";\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cho hai số nguyên dương n và m, và nhiệm vụ của bạn là tính trung bình cộng của các số nguyên từ n đến m (bao gồm cả n và m). Làm tròn kết quả đến số nguyên gần nhất và chuyển đổi thành số nhị phân. Nếu n lớn hơn m, trả về -1. Ví dụ:", "entry_point": "rounded_avg", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/47", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Thực hiện hàm f nhận tham số n,\n *     và trả về một danh sách có kích thước n, sao cho giá trị của phần tử tại chỉ số i là giai thừa của i nếu i là số chẵn\n *     hoặc tổng của các số từ 1 đến i nếu không phải.\n *     i bắt đầu từ 1.\n *     Giai thừa của i là tích của các số từ 1 đến i (1 * 2 * ... * i).\n *     Ví dụ:\n * \n * f(5) == [1, 2, 6, 24, 15]\n * \n */\nconst f = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = f(5);\nlet expected_1 = [1, 2, 6, 24, 15];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = f(7);\nlet expected_2 = [1, 2, 6, 24, 15, 720, 28];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = f(1);\nlet expected_3 = [1];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = f(3);\nlet expected_4 = [1, 2, 6];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Thực hiện hàm f nhận tham số n,\n    và trả về một danh sách có kích thước n, sao cho giá trị của phần tử tại chỉ số i là giai thừa của i nếu i là số chẵn\n    hoặc tổng của các số từ 1 đến i nếu không phải.\n    i bắt đầu từ 1.\n    Giai thừa của i là tích của các số từ 1 đến i (1 * 2 * ... * i).\n    Ví dụ:", "entry_point": "f", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/48", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Cho một số nguyên dương n, trả về một tuple chứa số lượng số đối xứng chẵn và lẻ trong khoảng từ 1 đến n, bao gồm cả n.\n * \n *     Ví dụ 1:\n * \n *         Input: 3\n *         Output: (1, 2)\n *         Giải thích:\n *         Các số đối xứng là 1, 2, 3. Một số chẵn và hai số lẻ.\n * \n *     Ví dụ 2:\n * \n *         Input: 12\n *         Output: (4, 6)\n *         Giải thích:\n *         Các số đối xứng là 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Bốn số chẵn và sáu số lẻ.\n * \n *     Chú ý:\n *         1. 1 <= n <= 10^3\n *         2. Tuple trả về chứa số lượng số đối xứng chẵn và lẻ tương ứng.\n * \n * \n */\nconst even_odd_palindrome = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = even_odd_palindrome(123);\nlet expected_1 = [8, 13];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = even_odd_palindrome(12);\nlet expected_2 = [4, 6];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = even_odd_palindrome(3);\nlet expected_3 = [1, 2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = even_odd_palindrome(63);\nlet expected_4 = [6, 8];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = even_odd_palindrome(25);\nlet expected_5 = [5, 6];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = even_odd_palindrome(19);\nlet expected_6 = [4, 6];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = even_odd_palindrome(9);\nlet expected_7 = [4, 5];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = even_odd_palindrome(1);\nlet expected_8 = [0, 1];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "Cho một số nguyên dương n, trả về một tuple chứa số lượng số đối xứng chẵn và lẻ trong khoảng từ 1 đến n, bao gồm cả n.\n\n    Ví dụ 1:\n\n        Input: 3\n        Output: (1, 2)\n        Giải thích:\n        Các số đối xứng là 1, 2, 3. Một số chẵn và hai số lẻ.\n\n    Ví dụ 2:\n\n        Input: 12\n        Output: (4, 6)\n        Giải thích:\n        Các số đối xứng là 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Bốn số chẵn và sáu số lẻ.\n\n    Chú ý:\n        1. 1 <= n <= 10^3\n        2. Tuple trả về chứa số lượng số đối xứng chẵn và lẻ tương ứng.", "entry_point": "even_odd_palindrome", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/49", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Chúng ta có một mảng 'arr' gồm N số nguyên arr[1], arr[2], ..., arr[N]. Các số trong mảng sẽ được sắp xếp ngẫu nhiên. Nhiệm vụ của bạn là xác định xem có thể có được một mảng được sắp xếp theo thứ tự không giảm bằng cách thực hiện thao tác sau trên mảng đã cho:\n *     Bạn được phép thực hiện thao tác dịch phải bất kỳ số lần nào.\n *     \n *     Một thao tác dịch phải có nghĩa là dịch tất cả các phần tử của mảng sang phải một vị trí. Phần tử cuối cùng của mảng sẽ được di chuyển đến vị trí bắt đầu trong mảng, tức là vị trí 0.\n * \n *     Nếu có thể thu được mảng được sắp xếp bằng cách thực hiện thao tác trên thì trả về True, ngược lại trả về False.\n *     Nếu mảng đã cho là trống thì trả về True.\n * \n *     Lưu ý: Danh sách đã cho được đảm bảo có các phần tử duy nhất.\n * \n *     Ví dụ:\n * \n *     move_one_ball([3, 4, 5, 1, 2])==>True\n *     Giải thích: Bằng cách thực hiện 2 thao tác dịch phải, ta có thể đạt được thứ tự không giảm cho mảng đã cho.\n *     move_one_ball([3, 5, 4, 1, 2])==>False\n *     Giải thích: Không thể thu được thứ tự không giảm cho mảng đã cho bằng cách thực hiện bất kỳ số lần dịch phải nào.\n * \n * \n * \n */\nconst move_one_ball = function (arr: Array<number>) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = move_one_ball([3, 4, 5, 1, 2]);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = move_one_ball([3, 5, 10, 1, 2]);\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = move_one_ball([4, 3, 1, 2]);\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = move_one_ball([3, 5, 4, 1, 2]);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = move_one_ball([]);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Chúng ta có một mảng 'arr' gồm N số nguyên arr[1], arr[2], ..., arr[N]. Các số trong mảng sẽ được sắp xếp ngẫu nhiên. Nhiệm vụ của bạn là xác định xem có thể có được một mảng được sắp xếp theo thứ tự không giảm bằng cách thực hiện thao tác sau trên mảng đã cho:\n    Bạn được phép thực hiện thao tác dịch phải bất kỳ số lần nào.\n    \n    Một thao tác dịch phải có nghĩa là dịch tất cả các phần tử của mảng sang phải một vị trí. Phần tử cuối cùng của mảng sẽ được di chuyển đến vị trí bắt đầu trong mảng, tức là vị trí 0.\n\n    Nếu có thể thu được mảng được sắp xếp bằng cách thực hiện thao tác trên thì trả về True, ngược lại trả về False.\n    Nếu mảng đã cho là trống thì trả về True.\n\n    Lưu ý: Danh sách đã cho được đảm bảo có các phần tử duy nhất.\n\n    Ví dụ:\n\n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Giải thích: Bằng cách thực hiện 2 thao tác dịch phải, ta có thể đạt được thứ tự không giảm cho mảng đã cho.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Giải thích: Không thể thu được thứ tự không giảm cho mảng đã cho bằng cách thực hiện bất kỳ số lần dịch phải nào.", "entry_point": "move_one_ball", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/50", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Trong bài toán này, bạn sẽ thực hiện một hàm nhận vào hai danh sách số và xác định liệu có thể thực hiện một trao đổi các phần tử giữa chúng để biến lst1 thành một danh sách chỉ chứa các số chẵn hay không. Không có giới hạn về số lượng các phần tử được trao đổi giữa lst1 và lst2. Nếu có thể trao đổi các phần tử giữa lst1 và lst2 để biến tất cả các phần tử của lst1 thành số chẵn, trả về \"YES\". Ngược lại, trả về \"NO\". Ví dụ: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Được cho rằng danh sách đầu vào sẽ không rỗng.\n * \n * \n */\nconst exchange = function (lst1: Array<number>, lst2: Array<number>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = exchange([1, 2, 3, 4],[1, 2, 3, 4]);\nlet expected_1 = \"YES\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = exchange([1, 2, 3, 4],[1, 5, 3, 4]);\nlet expected_2 = \"NO\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = exchange([1, 2, 3, 4],[2, 1, 4, 3]);\nlet expected_3 = \"YES\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = exchange([5, 7, 3],[2, 6, 4]);\nlet expected_4 = \"YES\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = exchange([5, 7, 3],[2, 6, 3]);\nlet expected_5 = \"NO\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = exchange([3, 2, 6, 1, 8, 9],[3, 5, 5, 1, 1, 1]);\nlet expected_6 = \"NO\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = exchange([100, 200],[200, 200]);\nlet expected_7 = \"YES\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Trong bài toán này, bạn sẽ thực hiện một hàm nhận vào hai danh sách số và xác định liệu có thể thực hiện một trao đổi các phần tử giữa chúng để biến lst1 thành một danh sách chỉ chứa các số chẵn hay không. Không có giới hạn về số lượng các phần tử được trao đổi giữa lst1 và lst2. Nếu có thể trao đổi các phần tử giữa lst1 và lst2 để biến tất cả các phần tử của lst1 thành số chẵn, trả về \"YES\". Ngược lại, trả về \"NO\". Ví dụ: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Được cho rằng danh sách đầu vào sẽ không rỗng.", "entry_point": "exchange", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/51", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Nhiệm vụ\n *     Chúng ta được cho hai chuỗi s và c, bạn phải xóa tất cả các ký tự trong s mà bằng với bất kỳ ký tự nào trong c\n *     sau đó kiểm tra xem chuỗi kết quả có phải là chuỗi đối xứng hay không.\n *     Một chuỗi được gọi là đối xứng nếu nó đọc ngược lại giống như đọc xuôi.\n *     Bạn nên trả về một bộ chứa chuỗi kết quả và True/False cho kiểm tra.\n *     Ví dụ\n *     Với s = \"abcde\", c = \"ae\", kết quả sẽ là ('bcd',False)\n *     Với s = \"abcdef\", c = \"b\" kết quả sẽ là ('acdef',False)\n *     Với s = \"abcdedcba\", c = \"ab\", kết quả sẽ là ('cdedc',True)\n * \n * \n */\nconst reverse_delete = function (s: string, c: string) : Array<any>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = reverse_delete(\"abcde\",\"ae\");\nlet expected_1 = [\"bcd\", false];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = reverse_delete(\"abcdef\",\"b\");\nlet expected_2 = [\"acdef\", false];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = reverse_delete(\"abcdedcba\",\"ab\");\nlet expected_3 = [\"cdedc\", true];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = reverse_delete(\"dwik\",\"w\");\nlet expected_4 = [\"dik\", false];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = reverse_delete(\"a\",\"a\");\nlet expected_5 = [\"\", true];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = reverse_delete(\"abcdedcba\",\"\");\nlet expected_6 = [\"abcdedcba\", true];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = reverse_delete(\"abcdedcba\",\"v\");\nlet expected_7 = [\"abcdedcba\", true];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = reverse_delete(\"vabba\",\"v\");\nlet expected_8 = [\"abba\", true];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = reverse_delete(\"mamma\",\"mia\");\nlet expected_9 = [\"\", true];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Nhiệm vụ\n    Chúng ta được cho hai chuỗi s và c, bạn phải xóa tất cả các ký tự trong s mà bằng với bất kỳ ký tự nào trong c\n    sau đó kiểm tra xem chuỗi kết quả có phải là chuỗi đối xứng hay không.\n    Một chuỗi được gọi là đối xứng nếu nó đọc ngược lại giống như đọc xuôi.\n    Bạn nên trả về một bộ chứa chuỗi kết quả và True/False cho kiểm tra.\n    Ví dụ\n    Với s = \"abcde\", c = \"ae\", kết quả sẽ là ('bcd',False)\n    Với s = \"abcdef\", c = \"b\" kết quả sẽ là ('acdef',False)\n    Với s = \"abcdedcba\", c = \"ab\", kết quả sẽ là ('cdedc',True)", "entry_point": "reverse_delete", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/52", "prompt": "import * as math from 'mathjs'\n\n/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Bạn được cho một lưới hình chữ nhật các giếng. Mỗi hàng đại diện cho một giếng đơn, và mỗi số 1 trong một hàng đại diện cho một đơn vị nước. Mỗi giếng có một thùng tương ứng có thể được sử dụng để rút nước từ đó, và tất cả các thùng đều có cùng dung tích. Nhiệm vụ của bạn là sử dụng các thùng để rút hết nước từ các giếng. Đưa ra số lần bạn cần hạ thùng.\n * \n *     Ví dụ 1:\n *         Input: \n *             grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n *             bucket_capacity : 1\n *         Output: 6\n * \n *     Ví dụ 2:\n *         Input: \n *             grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n *             bucket_capacity : 2\n *         Output: 5\n *     \n *     Ví dụ 3:\n *         Input: \n *             grid : [[0,0,0], [0,0,0]]\n *             bucket_capacity : 5\n *         Output: 0\n * \n *     Ràng buộc:\n *         * tất cả các giếng có cùng độ dài\n *         * 1 <= độ dài của grid <= 10^2\n *         * 1 <= độ dài của grid[:,1] <= 10^2\n *         * grid[i][j] -> 0 | 1\n *         * 1 <= dung tích <= 10\n * \n * \n */\nconst max_fill = function (grid: Array<Array<number>>, capacity: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],1);\nlet expected_1 = 6;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],2);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = max_fill([[0, 0, 0], [0, 0, 0]],5);\nlet expected_3 = 0;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = max_fill([[1, 1, 1, 1], [1, 1, 1, 1]],2);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = max_fill([[1, 1, 1, 1], [1, 1, 1, 1]],9);\nlet expected_5 = 2;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cho một lưới hình chữ nhật các giếng. Mỗi hàng đại diện cho một giếng đơn, và mỗi số 1 trong một hàng đại diện cho một đơn vị nước. Mỗi giếng có một thùng tương ứng có thể được sử dụng để rút nước từ đó, và tất cả các thùng đều có cùng dung tích. Nhiệm vụ của bạn là sử dụng các thùng để rút hết nước từ các giếng. Đưa ra số lần bạn cần hạ thùng.\n\n    Ví dụ 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Ví dụ 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Ví dụ 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Ràng buộc:\n        * tất cả các giếng có cùng độ dài\n        * 1 <= độ dài của grid <= 10^2\n        * 1 <= độ dài của grid[:,1] <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= dung tích <= 10", "entry_point": "max_fill", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/53", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Cho một chuỗi s và một số tự nhiên n, bạn được giao nhiệm vụ thực hiện một hàm trả về một danh sách các từ từ chuỗi s chứa chính xác n phụ âm, theo thứ tự các từ xuất hiện trong chuỗi s. Nếu chuỗi s rỗng thì hàm sẽ trả về một danh sách rỗng. Lưu ý: bạn có thể giả định chuỗi đầu vào chỉ chứa chữ cái và khoảng trắng.\n *     Ví dụ:\n * \n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n * \n */\nconst select_words = function (s: string, n: number) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = select_words(\"Mary had a little lamb\",4);\nlet expected_1 = [\"little\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = select_words(\"Mary had a little lamb\",3);\nlet expected_2 = [\"Mary\", \"lamb\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = select_words(\"simple white space\",2);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = select_words(\"Hello world\",4);\nlet expected_4 = [\"world\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = select_words(\"Uncle sam\",3);\nlet expected_5 = [\"Uncle\"];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = select_words(\"\",4);\nlet expected_6 = [];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = select_words(\"a b c d e f\",1);\nlet expected_7 = [\"b\", \"c\", \"d\", \"f\"];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Cho một chuỗi s và một số tự nhiên n, bạn được giao nhiệm vụ thực hiện một hàm trả về một danh sách các từ từ chuỗi s chứa chính xác n phụ âm, theo thứ tự các từ xuất hiện trong chuỗi s. Nếu chuỗi s rỗng thì hàm sẽ trả về một danh sách rỗng. Lưu ý: bạn có thể giả định chuỗi đầu vào chỉ chứa chữ cái và khoảng trắng.\n    Ví dụ:", "entry_point": "select_words", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/54", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Cho một mảng arr gồm các số nguyên và một số nguyên dương k, trả về một danh sách đã sắp xếp có độ dài k với k số lớn nhất trong arr.\n * \n *     Ví dụ 1:\n * \n *         Input: arr = [-3, -4, 5], k = 3\n *         Output: [-4, -3, 5]\n * \n *     Ví dụ 2:\n * \n *         Input: arr = [4, -4, 4], k = 2\n *         Output: [4, 4]\n * \n *     Ví dụ 3:\n * \n *         Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n *         Output: [2]\n * \n *     Lưu ý:\n *         1. Độ dài của mảng sẽ nằm trong khoảng [1, 1000].\n *         2. Các phần tử trong mảng sẽ nằm trong khoảng [-1000, 1000].\n *         3. 0 <= k <= độ dài của arr.\n * \n * \n */\nconst maximum = function (arr: Array<number>, k: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = maximum([-3, -4, 5],3);\nlet expected_1 = [-4, -3, 5];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = maximum([4, -4, 4],2);\nlet expected_2 = [4, 4];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = maximum([-3, 2, 1, 2, -1, -2, 1],1);\nlet expected_3 = [2];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = maximum([123, -123, 20, 0, 1, 2, -3],3);\nlet expected_4 = [2, 20, 123];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = maximum([-123, 20, 0, 1, 2, -3],4);\nlet expected_5 = [0, 1, 2, 20];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = maximum([5, 15, 0, 3, -13, -8, 0],7);\nlet expected_6 = [-13, -8, 0, 0, 3, 5, 15];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = maximum([-1, 0, 2, 5, 3, -10],2);\nlet expected_7 = [3, 5];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = maximum([1, 0, 5, -7],1);\nlet expected_8 = [5];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = maximum([4, -4],2);\nlet expected_9 = [-4, 4];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = maximum([-10, 10],2);\nlet expected_10 = [-10, 10];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = maximum([1, 2, 3, -23, 243, -400, 0],0);\nlet expected_11 = [];\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "Cho một mảng arr gồm các số nguyên và một số nguyên dương k, trả về một danh sách đã sắp xếp có độ dài k với k số lớn nhất trong arr.\n\n    Ví dụ 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Ví dụ 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Ví dụ 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Lưu ý:\n        1. Độ dài của mảng sẽ nằm trong khoảng [1, 1000].\n        2. Các phần tử trong mảng sẽ nằm trong khoảng [-1000, 1000].\n        3. 0 <= k <= độ dài của arr.", "entry_point": "maximum", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/55", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Cho một mảng số nguyên không rỗng arr và một số nguyên k, trả về tổng các phần tử có tối đa hai chữ số từ k phần tử đầu tiên của arr.\n * \n *     Ví dụ:\n * \n *         Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n *         Output: 24 # tổng của 21 + 3\n * \n *     Ràng buộc:\n *         1. 1 <= len(arr) <= 100\n *         2. 1 <= k <= len(arr)\n * \n * \n */\nconst add_elements = function (arr: Array<number>, k: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = add_elements([1, -2, -3, 41, 57, 76, 87, 88, 99],3);\nlet expected_1 = -4;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = add_elements([111, 121, 3, 4000, 5, 6],2);\nlet expected_2 = 0;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = add_elements([11, 21, 3, 90, 5, 6, 7, 8, 9],4);\nlet expected_3 = 125;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9],4);\nlet expected_4 = 24;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = add_elements([1],1);\nlet expected_5 = 1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Cho một mảng số nguyên không rỗng arr và một số nguyên k, trả về tổng các phần tử có tối đa hai chữ số từ k phần tử đầu tiên của arr.\n\n    Ví dụ:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # tổng của 21 + 3\n\n    Ràng buộc:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)", "entry_point": "add_elements", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/56", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Bạn được cho hai khoảng,\n *     trong đó mỗi khoảng là một cặp số nguyên. Ví dụ, khoảng = (bắt đầu, kết thúc) = (1, 2).\n *     Các khoảng được cho là đóng nghĩa là khoảng (bắt đầu, kết thúc)\n *     bao gồm cả bắt đầu và kết thúc.\n *     Đối với mỗi khoảng được cho, giả định rằng bắt đầu của nó nhỏ hơn hoặc bằng kết thúc của nó.\n *     Nhiệm vụ của bạn là xác định xem độ dài giao của hai khoảng này\n *     có phải là một số nguyên tố hay không.\n *     Ví dụ, giao của các khoảng (1, 3), (2, 4) là (2, 3)\n *     có độ dài là 1, không phải là số nguyên tố.\n *     Nếu độ dài của giao là một số nguyên tố, trả về \"YES\",\n *     nếu không, trả về \"NO\".\n *     Nếu hai khoảng không giao nhau, trả về \"NO\".\n * \n * \n *     [input/output] samples:\n * \n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n * \n */\nconst intersection = function (interval1: Array<number>, interval2: Array<number>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = intersection([1, 2],[2, 3]);\nlet expected_1 = \"NO\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = intersection([-1, 1],[0, 4]);\nlet expected_2 = \"NO\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = intersection([-3, -1],[-5, 5]);\nlet expected_3 = \"YES\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = intersection([-2, 2],[-4, 0]);\nlet expected_4 = \"YES\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = intersection([-11, 2],[-1, -1]);\nlet expected_5 = \"NO\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = intersection([1, 2],[3, 5]);\nlet expected_6 = \"NO\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = intersection([1, 2],[1, 2]);\nlet expected_7 = \"NO\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = intersection([-2, -2],[-3, -2]);\nlet expected_8 = \"NO\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cho hai khoảng,\n    trong đó mỗi khoảng là một cặp số nguyên. Ví dụ, khoảng = (bắt đầu, kết thúc) = (1, 2).\n    Các khoảng được cho là đóng nghĩa là khoảng (bắt đầu, kết thúc)\n    bao gồm cả bắt đầu và kết thúc.\n    Đối với mỗi khoảng được cho, giả định rằng bắt đầu của nó nhỏ hơn hoặc bằng kết thúc của nó.\n    Nhiệm vụ của bạn là xác định xem độ dài giao của hai khoảng này\n    có phải là một số nguyên tố hay không.\n    Ví dụ, giao của các khoảng (1, 3), (2, 4) là (2, 3)\n    có độ dài là 1, không phải là số nguyên tố.\n    Nếu độ dài của giao là một số nguyên tố, trả về \"YES\",\n    nếu không, trả về \"NO\".\n    Nếu hai khoảng không giao nhau, trả về \"NO\".\n\n\n    [input/output] samples:", "entry_point": "intersection", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/57", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Mọi người đều biết dãy Fibonacci, nó đã được nghiên cứu sâu rộng bởi các nhà toán học trong vài thế kỷ qua. Tuy nhiên, điều mà mọi người không biết là dãy Tribonacci. Dãy Tribonacci được định nghĩa bởi sự lặp lại:\n * tri(1) = 3\n * tri(n) = 1 + n / 2, nếu n là số chẵn.\n * tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), nếu n là số lẻ.\n * Ví dụ:\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n * = 2 + 3 + 3 = 8\n * Bạn được cho một số nguyên không âm n, bạn phải trả về một danh sách gồm n + 1 số đầu tiên của dãy Tribonacci.\n * Ví dụ:\n * tri(3) = [1, 3, 2, 8]\n * \n * \n */\nconst tri = function (n: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = tri(3);\nlet expected_1 = [1, 3, 2.0, 8.0];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = tri(4);\nlet expected_2 = [1, 3, 2.0, 8.0, 3.0];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = tri(5);\nlet expected_3 = [1, 3, 2.0, 8.0, 3.0, 15.0];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = tri(6);\nlet expected_4 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = tri(7);\nlet expected_5 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = tri(8);\nlet expected_6 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = tri(9);\nlet expected_7 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = tri(20);\nlet expected_8 = [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = tri(0);\nlet expected_9 = [1];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = tri(1);\nlet expected_10 = [1, 3];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Mọi người đều biết dãy Fibonacci, nó đã được nghiên cứu sâu rộng bởi các nhà toán học trong vài thế kỷ qua. Tuy nhiên, điều mà mọi người không biết là dãy Tribonacci. Dãy Tribonacci được định nghĩa bởi sự lặp lại:\ntri(1) = 3\ntri(n) = 1 + n / 2, nếu n là số chẵn.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), nếu n là số lẻ.\nVí dụ:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nBạn được cho một số nguyên không âm n, bạn phải trả về một danh sách gồm n + 1 số đầu tiên của dãy Tribonacci.\nVí dụ:\ntri(3) = [1, 3, 2, 8]", "entry_point": "tri", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/58", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Cho một số nguyên dương n, trả về tích của các chữ số lẻ.\n *     Trả về 0 nếu tất cả các chữ số đều là chẵn.\n *     Ví dụ:\n * \n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n * \n */\nconst digits = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = digits(5);\nlet expected_1 = 5;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = digits(54);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = digits(120);\nlet expected_3 = 1;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = digits(5014);\nlet expected_4 = 5;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = digits(98765);\nlet expected_5 = 315;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = digits(5576543);\nlet expected_6 = 2625;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = digits(2468);\nlet expected_7 = 0;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Cho một số nguyên dương n, trả về tích của các chữ số lẻ.\n    Trả về 0 nếu tất cả các chữ số đều là chẵn.\n    Ví dụ:", "entry_point": "digits", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/59", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Tạo một hàm nhận một chuỗi làm đầu vào chỉ chứa các dấu ngoặc vuông.\n * Hàm nên trả về True nếu và chỉ nếu có một chuỗi con hợp lệ của các dấu ngoặc vuông, trong đó ít nhất một dấu ngoặc trong chuỗi con được lồng vào.\n * is_nested('[[]]') ➞ True\n * is_nested('[]]]]]]][[[[[]') ➞ False\n * is_nested('[][]') ➞ False\n * is_nested('[]') ➞ False\n * is_nested('[[][]]') ➞ True\n * is_nested('[[]][[') ➞ True\n * \n */\nconst is_nested = function (string0: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = is_nested(\"[[]]\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = is_nested(\"[]]]]]]][[[[[]\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = is_nested(\"[][]\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = is_nested(\"[]\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = is_nested(\"[[[[]]]]\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = is_nested(\"[]]]]]]]]]]\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = is_nested(\"[][][[]]\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = is_nested(\"[[]\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = is_nested(\"[]]\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = is_nested(\"[[]][[\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = is_nested(\"[[][]]\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = is_nested(\"\");\nlet expected_12 = false;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = is_nested(\"[[[[[[[[\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = is_nested(\"]]]]]]]]\");\nlet expected_14 = false;\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\n", "language": "typescript", "description": "Tạo một hàm nhận một chuỗi làm đầu vào chỉ chứa các dấu ngoặc vuông.\nHàm nên trả về True nếu và chỉ nếu có một chuỗi con hợp lệ của các dấu ngoặc vuông, trong đó ít nhất một dấu ngoặc trong chuỗi con được lồng vào.", "entry_point": "is_nested", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/60", "prompt": "import * as math from 'mathjs'\n\n/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Bạn được cho một danh sách các số.\n *     Bạn cần trả về tổng các số bình phương trong danh sách đã cho,\n *     làm tròn mỗi phần tử trong danh sách lên đến số nguyên trên (Ceiling) trước.\n *     Ví dụ:\n *     Với lst = [1,2,3], đầu ra sẽ là 14\n *     Với lst = [1,4,9], đầu ra sẽ là 98\n *     Với lst = [1,3,5,7], đầu ra sẽ là 84\n *     Với lst = [1.4,4.2,0], đầu ra sẽ là 29\n *     Với lst = [-2.4,1,1], đầu ra sẽ là 6\n * \n * \n * \n * \n */\nconst sum_squares = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = sum_squares([1, 2, 3]);\nlet expected_1 = 14;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = sum_squares([1.0, 2, 3]);\nlet expected_2 = 14;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = sum_squares([1, 3, 5, 7]);\nlet expected_3 = 84;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = sum_squares([1.4, 4.2, 0]);\nlet expected_4 = 29;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = sum_squares([-2.4, 1, 1]);\nlet expected_5 = 6;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = sum_squares([100, 1, 15, 2]);\nlet expected_6 = 10230;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = sum_squares([10000, 10000]);\nlet expected_7 = 200000000;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = sum_squares([-1.4, 4.6, 6.3]);\nlet expected_8 = 75;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = sum_squares([-1.4, 17.9, 18.9, 19.9]);\nlet expected_9 = 1086;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = sum_squares([0]);\nlet expected_10 = 0;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = sum_squares([-1]);\nlet expected_11 = 1;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = sum_squares([-1, 1, 0]);\nlet expected_12 = 2;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cho một danh sách các số.\n    Bạn cần trả về tổng các số bình phương trong danh sách đã cho,\n    làm tròn mỗi phần tử trong danh sách lên đến số nguyên trên (Ceiling) trước.\n    Ví dụ:\n    Với lst = [1,2,3], đầu ra sẽ là 14\n    Với lst = [1,4,9], đầu ra sẽ là 98\n    Với lst = [1,3,5,7], đầu ra sẽ là 84\n    Với lst = [1.4,4.2,0], đầu ra sẽ là 29\n    Với lst = [-2.4,1,1], đầu ra sẽ là 6", "entry_point": "sum_squares", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/61", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Tạo một hàm trả về True nếu ký tự cuối cùng của chuỗi đã cho là một ký tự chữ cái và không phải là một phần của một từ, và False trong trường hợp khác. Lưu ý: \"từ\" là một nhóm ký tự được tách ra bằng khoảng trắng.\n * \n *     Ví dụ:\n * \n * check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n * check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n * check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n * check_if_last_char_is_a_letter(\"\") ➞ False \n * \n */\nconst check_if_last_char_is_a_letter = function (txt: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = check_if_last_char_is_a_letter(\"apple\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = check_if_last_char_is_a_letter(\"apple pi e\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = check_if_last_char_is_a_letter(\"eeeee\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = check_if_last_char_is_a_letter(\"A\");\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = check_if_last_char_is_a_letter(\"Pumpkin pie \");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = check_if_last_char_is_a_letter(\"Pumpkin pie 1\");\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = check_if_last_char_is_a_letter(\"\");\nlet expected_7 = false;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = check_if_last_char_is_a_letter(\"eeeee e \");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = check_if_last_char_is_a_letter(\"apple pie\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = check_if_last_char_is_a_letter(\"apple pi e \");\nlet expected_10 = false;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Tạo một hàm trả về True nếu ký tự cuối cùng của chuỗi đã cho là một ký tự chữ cái và không phải là một phần của một từ, và False trong trường hợp khác. Lưu ý: \"từ\" là một nhóm ký tự được tách ra bằng khoảng trắng.\n\n    Ví dụ:", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/62", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Tạo một hàm trả về chỉ số lớn nhất của một phần tử không lớn hơn hoặc bằng phần tử ngay trước nó. Nếu không có phần tử như vậy thì trả về -1. Mảng được cung cấp sẽ không chứa các giá trị trùng lặp.\n * \n * Ví dụ:\n * \n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n * \n */\nconst can_arrange = function (arr: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = can_arrange([1, 2, 4, 3, 5]);\nlet expected_1 = 3;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = can_arrange([1, 2, 4, 5]);\nlet expected_2 = -1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = can_arrange([1, 4, 2, 5, 6, 7, 8, 9, 10]);\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = can_arrange([4, 8, 5, 7, 3]);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = can_arrange([]);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\n", "language": "typescript", "description": "Tạo một hàm trả về chỉ số lớn nhất của một phần tử không lớn hơn hoặc bằng phần tử ngay trước nó. Nếu không có phần tử như vậy thì trả về -1. Mảng được cung cấp sẽ không chứa các giá trị trùng lặp.\n\nVí dụ:", "entry_point": "can_arrange", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/63", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Tạo một hàm trả về một tuple (a, b), trong đó 'a' là số nguyên âm lớn nhất và 'b' là số nguyên dương nhỏ nhất trong danh sách. Nếu không có số nguyên âm hoặc dương, trả về chúng là None.\n * \n * Ví dụ:\n * \n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n * \n */\nconst largest_smallest_integers = function (lst: Array<number>) : Array<any>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = largest_smallest_integers([2, 4, 1, 3, 5, 7]);\nlet expected_1 = [undefined, 1];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = largest_smallest_integers([2, 4, 1, 3, 5, 7, 0]);\nlet expected_2 = [undefined, 1];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = largest_smallest_integers([1, 3, 2, 4, 5, 6, -2]);\nlet expected_3 = [-2, 1];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = largest_smallest_integers([4, 5, 3, 6, 2, 7, -7]);\nlet expected_4 = [-7, 2];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = largest_smallest_integers([7, 3, 8, 4, 9, 2, 5, -9]);\nlet expected_5 = [-9, 2];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = largest_smallest_integers([]);\nlet expected_6 = [undefined, undefined];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = largest_smallest_integers([0]);\nlet expected_7 = [undefined, undefined];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = largest_smallest_integers([-1, -3, -5, -6]);\nlet expected_8 = [-1, undefined];\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = largest_smallest_integers([-1, -3, -5, -6, 0]);\nlet expected_9 = [-1, undefined];\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = largest_smallest_integers([-6, -4, -4, -3, 1]);\nlet expected_10 = [-3, 1];\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = largest_smallest_integers([-6, -4, -4, -3, -100, 1]);\nlet expected_11 = [-3, 1];\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "Tạo một hàm trả về một tuple (a, b), trong đó 'a' là số nguyên âm lớn nhất và 'b' là số nguyên dương nhỏ nhất trong danh sách. Nếu không có số nguyên âm hoặc dương, trả về chúng là None.\n\nVí dụ:", "entry_point": "largest_smallest_integers", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/64", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Phép tính giai thừa Brazil được định nghĩa như sau:\n *     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     với n > 0\n * \n *     Ví dụ:\n * >>> special_factorial(4)\n * 288\n * \n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n * \n */\nconst special_factorial = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = special_factorial(4);\nlet expected_1 = 288;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = special_factorial(5);\nlet expected_2 = 34560;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = special_factorial(7);\nlet expected_3 = 125411328000;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = special_factorial(1);\nlet expected_4 = 1;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Phép tính giai thừa Brazil được định nghĩa như sau:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    với n > 0\n\n    Ví dụ:", "entry_point": "special_factorial", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/65", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Bạn được cho một chuỗi đại diện cho một câu,\n *     câu đó chứa một số từ được phân tách bởi khoảng trắng,\n *     và bạn phải trả về một chuỗi chứa các từ từ câu ban đầu,\n *     có độ dài là số nguyên tố,\n *     thứ tự các từ trong chuỗi mới phải giống như ban đầu.\n * \n *     Ví dụ 1:\n *         Input: sentence = \"This is a test\"\n *         Output: \"is\"\n * \n *     Ví dụ 2:\n *         Input: sentence = \"lets go for swimming\"\n *         Output: \"go for\"\n * \n *     Ràng buộc:\n *         * 1 <= len(sentence) <= 100\n *         * sentence chỉ chứa các chữ cái.\n * \n * \n */\nconst words_in_sentence = function (sentence: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = words_in_sentence(\"This is a test\");\nlet expected_1 = \"is\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = words_in_sentence(\"lets go for swimming\");\nlet expected_2 = \"go for\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = words_in_sentence(\"there is no place available here\");\nlet expected_3 = \"there is no place\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = words_in_sentence(\"Hi I am Hussein\");\nlet expected_4 = \"Hi am Hussein\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = words_in_sentence(\"go for it\");\nlet expected_5 = \"go for it\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = words_in_sentence(\"here\");\nlet expected_6 = \"\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = words_in_sentence(\"here is\");\nlet expected_7 = \"is\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cho một chuỗi đại diện cho một câu,\n    câu đó chứa một số từ được phân tách bởi khoảng trắng,\n    và bạn phải trả về một chuỗi chứa các từ từ câu ban đầu,\n    có độ dài là số nguyên tố,\n    thứ tự các từ trong chuỗi mới phải giống như ban đầu.\n\n    Ví dụ 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Ví dụ 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Ràng buộc:\n        * 1 <= len(sentence) <= 100\n        * sentence chỉ chứa các chữ cái.", "entry_point": "words_in_sentence", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/66", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Nhiệm vụ của bạn là triển khai một hàm để đơn giản hóa biểu thức x * n. Hàm trả về True nếu x * n đánh giá thành một số nguyên và False nếu không phải. Cả x và n đều là biểu diễn chuỗi của một phân số và có định dạng sau đây, <tử số>/<mẫu số> trong đó cả tử số và mẫu số đều là số nguyên dương.\n * \n * Bạn có thể giả định rằng x và n là các phân số hợp lệ và không có số 0 làm mẫu số.\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n * \n */\nconst simplify = function (x: string, n: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = simplify(\"1/5\",\"5/1\");\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = simplify(\"1/6\",\"2/1\");\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = simplify(\"5/1\",\"3/1\");\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = simplify(\"7/10\",\"10/2\");\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = simplify(\"2/10\",\"50/10\");\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = simplify(\"7/2\",\"4/2\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = simplify(\"11/6\",\"6/1\");\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = simplify(\"2/3\",\"5/2\");\nlet expected_8 = false;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = simplify(\"5/2\",\"3/5\");\nlet expected_9 = false;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = simplify(\"2/4\",\"8/4\");\nlet expected_10 = true;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = simplify(\"2/4\",\"4/2\");\nlet expected_11 = true;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = simplify(\"1/5\",\"5/1\");\nlet expected_12 = true;\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = simplify(\"1/5\",\"1/5\");\nlet expected_13 = false;\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\n", "language": "typescript", "description": "Nhiệm vụ của bạn là triển khai một hàm để đơn giản hóa biểu thức x * n. Hàm trả về True nếu x * n đánh giá thành một số nguyên và False nếu không phải. Cả x và n đều là biểu diễn chuỗi của một phân số và có định dạng sau đây, <tử số>/<mẫu số> trong đó cả tử số và mẫu số đều là số nguyên dương.\n\nBạn có thể giả định rằng x và n là các phân số hợp lệ và không có số 0 làm mẫu số.", "entry_point": "simplify", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/67", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Viết một hàm sắp xếp danh sách số nguyên được cung cấp theo thứ tự tăng dần dựa trên tổng các chữ số của chúng. Lưu ý: nếu có nhiều mục có tổng số chữ số tương tự, sắp xếp chúng dựa trên chỉ số trong danh sách gốc.\n * \n * Ví dụ:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n * \n */\nconst order_by_points = function (nums: Array<number>) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = order_by_points([1, 11, -1, -11, -12]);\nlet expected_1 = [-1, -11, 1, -12, 11];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = order_by_points([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]);\nlet expected_2 = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = order_by_points([]);\nlet expected_3 = [];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = order_by_points([1, -11, -32, 43, 54, -98, 2, -3]);\nlet expected_4 = [-3, -32, -98, -11, 1, 2, 43, 54];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = order_by_points([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\nlet expected_5 = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = order_by_points([0, 6, 6, -76, -21, 23, 4]);\nlet expected_6 = [-76, -21, 0, 4, 23, 6, 6];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Viết một hàm sắp xếp danh sách số nguyên được cung cấp theo thứ tự tăng dần dựa trên tổng các chữ số của chúng. Lưu ý: nếu có nhiều mục có tổng số chữ số tương tự, sắp xếp chúng dựa trên chỉ số trong danh sách gốc.\n\nVí dụ:", "entry_point": "order_by_points", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/68", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Viết một hàm nhận một mảng số làm đầu vào và trả về số lượng phần tử trong mảng lớn hơn 10 và cả hai chữ số đầu và cuối của một số đều là số lẻ (1, 3, 5, 7, 9). Ví dụ:\n * \n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n * \n */\nconst specialFilter = function (nums: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = specialFilter([5, -2, 1, -5]);\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = specialFilter([15, -73, 14, -15]);\nlet expected_2 = 1;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = specialFilter([33, -2, -3, 45, 21, 109]);\nlet expected_3 = 2;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = specialFilter([43, -12, 93, 125, 121, 109]);\nlet expected_4 = 4;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = specialFilter([71, -2, -33, 75, 21, 19]);\nlet expected_5 = 3;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = specialFilter([1]);\nlet expected_6 = 0;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = specialFilter([]);\nlet expected_7 = 0;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Viết một hàm nhận một mảng số làm đầu vào và trả về số lượng phần tử trong mảng lớn hơn 10 và cả hai chữ số đầu và cuối của một số đều là số lẻ (1, 3, 5, 7, 9). Ví dụ:", "entry_point": "specialFilter", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/69", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Bạn được cho một số nguyên dương n. Bạn phải tạo ra một mảng số nguyên a có độ dài n.\n *         Đối với mỗi i (1 ≤ i ≤ n), giá trị của a[i] = i * i - i + 1.\n *         Trả về số lượng bộ ba (a[i], a[j], a[k]) của a trong đó i < j < k, \n *     và a[i] + a[j] + a[k] là bội số của 3.\n * \n *     Ví dụ :\n *         Input: n = 5\n *         Output: 1\n *         Giải thích: \n *         a = [1, 3, 7, 13, 21]\n *         Chỉ có một bộ ba hợp lệ là (1, 7, 13).\n * \n * \n */\nconst get_max_triples = function (n: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = get_max_triples(5);\nlet expected_1 = 1;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = get_max_triples(6);\nlet expected_2 = 4;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = get_max_triples(10);\nlet expected_3 = 36;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = get_max_triples(100);\nlet expected_4 = 53361;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cho một số nguyên dương n. Bạn phải tạo ra một mảng số nguyên a có độ dài n.\n        Đối với mỗi i (1 ≤ i ≤ n), giá trị của a[i] = i * i - i + 1.\n        Trả về số lượng bộ ba (a[i], a[j], a[k]) của a trong đó i < j < k, \n    và a[i] + a[j] + a[k] là bội số của 3.\n\n    Ví dụ :\n        Input: n = 5\n        Output: 1\n        Giải thích: \n        a = [1, 3, 7, 13, 21]\n        Chỉ có một bộ ba hợp lệ là (1, 7, 13).", "entry_point": "get_max_triples", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/70", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Trong hệ mặt trời của chúng ta có tám hành tinh: hành tinh gần nhất với Mặt Trời là Sao Thủy, tiếp theo là Sao Kim, sau đó là Trái đất, Sao Hỏa, Sao Mộc, Sao Thổ, Sao Thiên Vương và Sao Hải Vương. Viết một hàm nhận hai tên hành tinh dưới dạng chuỗi planet1 và planet2. Hàm này sẽ trả về một tuple chứa tất cả các hành tinh có quỹ đạo nằm giữa quỹ đạo của planet1 và planet2, được sắp xếp theo khoảng cách đến Mặt Trời. Hàm sẽ trả về một tuple rỗng nếu planet1 hoặc planet2 không phải là tên hành tinh đúng. Ví dụ.\n * \n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n * \n */\nconst bf = function (planet1: string, planet2: string) : Array<string>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = bf(\"Jupiter\",\"Neptune\");\nlet expected_1 = [\"Saturn\", \"Uranus\"];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = bf(\"Earth\",\"Mercury\");\nlet expected_2 = [\"Venus\"];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = bf(\"Mercury\",\"Uranus\");\nlet expected_3 = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = bf(\"Neptune\",\"Venus\");\nlet expected_4 = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = bf(\"Earth\",\"Earth\");\nlet expected_5 = [];\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = bf(\"Mars\",\"Earth\");\nlet expected_6 = [];\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = bf(\"Jupiter\",\"Makemake\");\nlet expected_7 = [];\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Trong hệ mặt trời của chúng ta có tám hành tinh: hành tinh gần nhất với Mặt Trời là Sao Thủy, tiếp theo là Sao Kim, sau đó là Trái đất, Sao Hỏa, Sao Mộc, Sao Thổ, Sao Thiên Vương và Sao Hải Vương. Viết một hàm nhận hai tên hành tinh dưới dạng chuỗi planet1 và planet2. Hàm này sẽ trả về một tuple chứa tất cả các hành tinh có quỹ đạo nằm giữa quỹ đạo của planet1 và planet2, được sắp xếp theo khoảng cách đến Mặt Trời. Hàm sẽ trả về một tuple rỗng nếu planet1 hoặc planet2 không phải là tên hành tinh đúng. Ví dụ.", "entry_point": "bf", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/71", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Một chương trình đơn giản sẽ trả về giá trị của x nếu n là số nguyên tố và sẽ trả về giá trị của y trong trường hợp khác.\n * \n * Ví dụ:\n * \n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n * \n */\nconst x_or_y = function (n: number, x: number, y: number) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = x_or_y(7,34,12);\nlet expected_1 = 34;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = x_or_y(15,8,5);\nlet expected_2 = 5;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = x_or_y(3,33,5212);\nlet expected_3 = 33;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = x_or_y(1259,3,52);\nlet expected_4 = 3;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = x_or_y(7919,-1,12);\nlet expected_5 = -1;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = x_or_y(3609,1245,583);\nlet expected_6 = 583;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = x_or_y(91,56,129);\nlet expected_7 = 129;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = x_or_y(6,34,1234);\nlet expected_8 = 1234;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = x_or_y(1,2,0);\nlet expected_9 = 0;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = x_or_y(2,2,0);\nlet expected_10 = 2;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\n", "language": "typescript", "description": "Một chương trình đơn giản sẽ trả về giá trị của x nếu n là số nguyên tố và sẽ trả về giá trị của y trong trường hợp khác.\n\nVí dụ:", "entry_point": "x_or_y", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/72", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Cho một danh sách các số, trả về tổng bình phương của các số trong danh sách là số lẻ. Bỏ qua các số âm hoặc không phải số nguyên.\n * \n *     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n *     double_the_difference([-1, -2, 0]) == 0\n *     double_the_difference([9, -2]) == 81\n *     double_the_difference([0]) == 0\n * \n * Nếu danh sách đầu vào là rỗng, trả về 0.\n * \n * \n */\nconst double_the_difference = function (lst: Array<number>) : number  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = double_the_difference([]);\nlet expected_1 = 0;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = double_the_difference([5, 4]);\nlet expected_2 = 25;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = double_the_difference([0.1, 0.2, 0.3]);\nlet expected_3 = 0;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = double_the_difference([-10, -20, -30]);\nlet expected_4 = 0;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = double_the_difference([-1, -2, 8]);\nlet expected_5 = 0;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = double_the_difference([0.2, 3, 5]);\nlet expected_6 = 34;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = double_the_difference([-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]);\nlet expected_7 = 166650;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\n", "language": "typescript", "description": "Cho một danh sách các số, trả về tổng bình phương của các số trong danh sách là số lẻ. Bỏ qua các số âm hoặc không phải số nguyên.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\nNếu danh sách đầu vào là rỗng, trả về 0.", "entry_point": "double_the_difference", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/73", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Bạn sẽ được cung cấp tên của một lớp (một chuỗi) và một danh sách các phần mở rộng. Các phần mở rộng được sử dụng để tải thêm các lớp vào lớp. Sức mạnh của phần mở rộng được tính như sau: Cho CAP là số chữ cái in hoa trong tên phần mở rộng và cho SM là số chữ cái thường trong tên phần mở rộng, sức mạnh được cho bởi phân số CAP - SM. Bạn nên tìm phần mở rộng mạnh nhất và trả về một chuỗi theo định dạng sau: ClassName.StrongestExtensionName. Nếu có hai hoặc nhiều phần mở rộng có cùng sức mạnh, bạn nên chọn phần mở rộng đầu tiên trong danh sách. Ví dụ, nếu bạn được cung cấp \"Slices\" làm lớp và một danh sách các phần mở rộng: ['SErviNGSliCes', 'Cheese', 'StuFfed'] thì bạn nên trả về 'Slices.SErviNGSliCes' vì 'SErviNGSliCes' là phần mở rộng mạnh nhất (sức mạnh của nó là -1). Ví dụ:\n * \n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n * \n */\nconst Strongest_Extension = function (class_name: string, extensions: Array<string>) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = Strongest_Extension(\"Watashi\",[\"tEN\", \"niNE\", \"eIGHt8OKe\"]);\nlet expected_1 = \"Watashi.eIGHt8OKe\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = Strongest_Extension(\"Boku123\",[\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]);\nlet expected_2 = \"Boku123.YEs.WeCaNe\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = Strongest_Extension(\"__YESIMHERE\",[\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]);\nlet expected_3 = \"__YESIMHERE.NuLl__\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = Strongest_Extension(\"K\",[\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]);\nlet expected_4 = \"K.TAR\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = Strongest_Extension(\"__HAHA\",[\"Tab\", \"123\", \"781345\", \"-_-\"]);\nlet expected_5 = \"__HAHA.123\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = Strongest_Extension(\"YameRore\",[\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]);\nlet expected_6 = \"YameRore.okIWILL123\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = Strongest_Extension(\"finNNalLLly\",[\"Die\", \"NowW\", \"Wow\", \"WoW\"]);\nlet expected_7 = \"finNNalLLly.WoW\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = Strongest_Extension(\"_\",[\"Bb\", \"91245\"]);\nlet expected_8 = \"_.Bb\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = Strongest_Extension(\"Sp\",[\"671235\", \"Bb\"]);\nlet expected_9 = \"Sp.671235\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\n", "language": "typescript", "description": "Bạn sẽ được cung cấp tên của một lớp (một chuỗi) và một danh sách các phần mở rộng. Các phần mở rộng được sử dụng để tải thêm các lớp vào lớp. Sức mạnh của phần mở rộng được tính như sau: Cho CAP là số chữ cái in hoa trong tên phần mở rộng và cho SM là số chữ cái thường trong tên phần mở rộng, sức mạnh được cho bởi phân số CAP - SM. Bạn nên tìm phần mở rộng mạnh nhất và trả về một chuỗi theo định dạng sau: ClassName.StrongestExtensionName. Nếu có hai hoặc nhiều phần mở rộng có cùng sức mạnh, bạn nên chọn phần mở rộng đầu tiên trong danh sách. Ví dụ, nếu bạn được cung cấp \"Slices\" làm lớp và một danh sách các phần mở rộng: ['SErviNGSliCes', 'Cheese', 'StuFfed'] thì bạn nên trả về 'Slices.SErviNGSliCes' vì 'SErviNGSliCes' là phần mở rộng mạnh nhất (sức mạnh của nó là -1). Ví dụ:", "entry_point": "Strongest_Extension", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/74", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Bạn được cho 2 từ. Bạn cần trả về True nếu từ thứ hai hoặc bất kỳ phép xoay nào của nó là một chuỗi con trong từ đầu tiên.\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n * \n * \n */\nconst cycpattern_check = function (a: string, b: string) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = cycpattern_check(\"xyzw\",\"xyw\");\nlet expected_1 = false;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = cycpattern_check(\"yello\",\"ell\");\nlet expected_2 = true;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = cycpattern_check(\"whattup\",\"ptut\");\nlet expected_3 = false;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = cycpattern_check(\"efef\",\"fee\");\nlet expected_4 = true;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = cycpattern_check(\"abab\",\"aabb\");\nlet expected_5 = false;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = cycpattern_check(\"winemtt\",\"tinem\");\nlet expected_6 = true;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cho 2 từ. Bạn cần trả về True nếu từ thứ hai hoặc bất kỳ phép xoay nào của nó là một chuỗi con trong từ đầu tiên.", "entry_point": "cycpattern_check", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/75", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Cho một số nguyên dương, tìm số La Mã tương ứng và trả về dưới dạng chuỗi viết thường.\n *     Giới hạn: 1 <= num <= 1000\n * \n *     Ví dụ:\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n * \n */\nconst int_to_mini_roman = function (number0: number) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = int_to_mini_roman(19);\nlet expected_1 = \"xix\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = int_to_mini_roman(152);\nlet expected_2 = \"clii\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = int_to_mini_roman(251);\nlet expected_3 = \"ccli\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = int_to_mini_roman(426);\nlet expected_4 = \"cdxxvi\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = int_to_mini_roman(500);\nlet expected_5 = \"d\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = int_to_mini_roman(1);\nlet expected_6 = \"i\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = int_to_mini_roman(4);\nlet expected_7 = \"iv\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = int_to_mini_roman(43);\nlet expected_8 = \"xliii\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = int_to_mini_roman(90);\nlet expected_9 = \"xc\";\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = int_to_mini_roman(94);\nlet expected_10 = \"xciv\";\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = int_to_mini_roman(532);\nlet expected_11 = \"dxxxii\";\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\nlet actual_12 = int_to_mini_roman(900);\nlet expected_12 = \"cm\";\nassert.deepEqual(actual_12, expected_12, \"Exception --- test case 11 failed to pass\");\n\nlet actual_13 = int_to_mini_roman(994);\nlet expected_13 = \"cmxciv\";\nassert.deepEqual(actual_13, expected_13, \"Exception --- test case 12 failed to pass\");\n\nlet actual_14 = int_to_mini_roman(1000);\nlet expected_14 = \"m\";\nassert.deepEqual(actual_14, expected_14, \"Exception --- test case 13 failed to pass\");\n\n", "language": "typescript", "description": "Cho một số nguyên dương, tìm số La Mã tương ứng và trả về dưới dạng chuỗi viết thường.\n    Giới hạn: 1 <= num <= 1000\n\n    Ví dụ:", "entry_point": "int_to_mini_roman", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/76", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Cho độ dài của ba cạnh của một tam giác. Trả về True nếu ba cạnh tạo thành một tam giác vuông, False nếu không phải. Một tam giác vuông là một tam giác có một góc vuông hoặc 90 độ. Ví dụ:\n * \n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n * \n */\nconst right_angle_triangle = function (a: number, b: number, c: number) : boolean  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = right_angle_triangle(3,4,5);\nlet expected_1 = true;\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = right_angle_triangle(1,2,3);\nlet expected_2 = false;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = right_angle_triangle(10,6,8);\nlet expected_3 = true;\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = right_angle_triangle(2,2,2);\nlet expected_4 = false;\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = right_angle_triangle(7,24,25);\nlet expected_5 = true;\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = right_angle_triangle(10,5,7);\nlet expected_6 = false;\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = right_angle_triangle(5,12,13);\nlet expected_7 = true;\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = right_angle_triangle(15,8,17);\nlet expected_8 = true;\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\nlet actual_9 = right_angle_triangle(48,55,73);\nlet expected_9 = true;\nassert.deepEqual(actual_9, expected_9, \"Exception --- test case 8 failed to pass\");\n\nlet actual_10 = right_angle_triangle(1,1,1);\nlet expected_10 = false;\nassert.deepEqual(actual_10, expected_10, \"Exception --- test case 9 failed to pass\");\n\nlet actual_11 = right_angle_triangle(2,2,10);\nlet expected_11 = false;\nassert.deepEqual(actual_11, expected_11, \"Exception --- test case 10 failed to pass\");\n\n", "language": "typescript", "description": "Cho độ dài của ba cạnh của một tam giác. Trả về True nếu ba cạnh tạo thành một tam giác vuông, False nếu không phải. Một tam giác vuông là một tam giác có một góc vuông hoặc 90 độ. Ví dụ:", "entry_point": "right_angle_triangle", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/77", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * Bạn được cho một chuỗi s.\n *     Nếu s[i] là một chữ cái, đảo ngược trường hợp của nó từ chữ thường thành chữ hoa hoặc ngược lại,\n *     nếu không giữ nguyên như vậy.\n *     Nếu chuỗi không chứa chữ cái, đảo ngược chuỗi.\n *     Hàm nên trả về chuỗi kết quả.\n *     Ví dụ\n * \n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n * \n */\nconst solve = function (s: string) : string  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = solve(\"AsDf\");\nlet expected_1 = \"aSdF\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = solve(\"1234\");\nlet expected_2 = \"4321\";\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = solve(\"ab\");\nlet expected_3 = \"AB\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = solve(\"#a@C\");\nlet expected_4 = \"#A@c\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\nlet actual_5 = solve(\"#AsdfW^45\");\nlet expected_5 = \"#aSDFw^45\";\nassert.deepEqual(actual_5, expected_5, \"Exception --- test case 4 failed to pass\");\n\nlet actual_6 = solve(\"#6@2\");\nlet expected_6 = \"2@6#\";\nassert.deepEqual(actual_6, expected_6, \"Exception --- test case 5 failed to pass\");\n\nlet actual_7 = solve(\"#$a^D\");\nlet expected_7 = \"#$A^d\";\nassert.deepEqual(actual_7, expected_7, \"Exception --- test case 6 failed to pass\");\n\nlet actual_8 = solve(\"#ccc\");\nlet expected_8 = \"#CCC\";\nassert.deepEqual(actual_8, expected_8, \"Exception --- test case 7 failed to pass\");\n\n", "language": "typescript", "description": "Bạn được cho một chuỗi s.\n    Nếu s[i] là một chữ cái, đảo ngược trường hợp của nó từ chữ thường thành chữ hoa hoặc ngược lại,\n    nếu không giữ nguyên như vậy.\n    Nếu chuỗi không chứa chữ cái, đảo ngược chuỗi.\n    Hàm nên trả về chuỗi kết quả.\n    Ví dụ", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/78", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Cho một chuỗi 'text', trả về chuỗi tương đương với băm md5 của nó.\n *     Nếu 'text' là một chuỗi rỗng, trả về null.\n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n * \n */\nconst string_to_md5 = function (text: string) : any  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = string_to_md5(\"Hello world\");\nlet expected_1 = \"3e25960a79dbc69b674cd4ec67a72c62\";\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = string_to_md5(\"\");\nlet expected_2 = undefined;\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = string_to_md5(\"A B C\");\nlet expected_3 = \"0ef78513b0cb8cef12743f5aeb35f888\";\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = string_to_md5(\"password\");\nlet expected_4 = \"5f4dcc3b5aa765d61d8327deb882cf99\";\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Cho một chuỗi 'text', trả về chuỗi tương đương với băm md5 của nó.\n    Nếu 'text' là một chuỗi rỗng, trả về null.", "entry_point": "string_to_md5", "canonical_solution": NaN, "natural_language": "Vietnamese"}
{"task_id": "typescript/79", "prompt": "/**\n * Bạn là một lập trình viên TypeScript chuyên nghiệp.\n * \n * Cho hai số nguyên dương a và b, trả về các chữ số chẵn giữa a và b, theo thứ tự tăng dần.\n * \n * Ví dụ:\n * \n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n * \n */\nconst generate_integers = function (a: number, b: number) : Array<number>  {\n", "test": "\nimport * as assert from 'assert'\n\nlet actual_1 = generate_integers(2,10);\nlet expected_1 = [2, 4, 6, 8];\nassert.deepEqual(actual_1, expected_1, \"Exception --- test case 0 failed to pass\");\n\nlet actual_2 = generate_integers(10,2);\nlet expected_2 = [2, 4, 6, 8];\nassert.deepEqual(actual_2, expected_2, \"Exception --- test case 1 failed to pass\");\n\nlet actual_3 = generate_integers(132,2);\nlet expected_3 = [2, 4, 6, 8];\nassert.deepEqual(actual_3, expected_3, \"Exception --- test case 2 failed to pass\");\n\nlet actual_4 = generate_integers(17,89);\nlet expected_4 = [];\nassert.deepEqual(actual_4, expected_4, \"Exception --- test case 3 failed to pass\");\n\n", "language": "typescript", "description": "Cho hai số nguyên dương a và b, trả về các chữ số chẵn giữa a và b, theo thứ tự tăng dần.\n\nVí dụ:", "entry_point": "generate_integers", "canonical_solution": NaN, "natural_language": "Vietnamese"}
