{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Egy banki számla befizetéseinek és kivételeinek listáját kapod, amely nulláról indul. A feladatod az, hogy észleld, ha a számla egy adott pontján a mérleg nulla alá esik, és ebben az esetben a függvény True értéket kell, hogy adjon vissza. Ellenkező esetben False értéket kell visszaadnia.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Egy banki számla befizetéseinek és kivételeinek listáját kapod, amely nulláról indul. A feladatod az, hogy észleld, ha a számla egy adott pontján a mérleg nulla alá esik, és ebben az esetben a függvény True értéket kell, hogy adjon vissza. Ellenkező esetben False értéket kell visszaadnia.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Adott egy egész számok listája, adjon vissza egy tuple-t, amely egy összeget és egy szorzatot tartalmaz a listában található összes egész számról.\nAz üres összegnek 0-nak kell lennie, az üres szorzatnak pedig 1-nek kell lennie.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Adott egy egész számok listája, adjon vissza egy tuple-t, amely egy összeget és egy szorzatot tartalmaz a listában található összes egész számról.\nAz üres összegnek 0-nak kell lennie, az üres szorzatnak pedig 1-nek kell lennie.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" A bemenet két, csak 1-ekből és 0-ákból álló karakterlánc, a és b.\nVégezzen bináris XOR műveletet ezeken a bemeneteken, majd adja vissza az eredményt szintén karakterlánc formájában.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "A bemenet két, csak 1-ekből és 0-ákból álló karakterlánc, a és b.\nVégezzen bináris XOR műveletet ezeken a bemeneteken, majd adja vissza az eredményt szintén karakterlánc formájában.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" A stringek listájából adja vissza a leghosszabbat. Több azonos hosszúságú string esetén az elsőt adja vissza. Üres bemeneti lista esetén null-t ad vissza.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "A stringek listájából adja vissza a leghosszabbat. Több azonos hosszúságú string esetén az elsőt adja vissza. Üres bemeneti lista esetén null-t ad vissza.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Adjon vissza két egész szám, a és b legnagyobb közös osztóját.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Adjon vissza két egész szám, a és b legnagyobb közös osztóját.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" A bemenet egy szóközzel elválasztott számjegyekből álló karakterlánc, amely tartalmazza a \"zero\" és \"nine\" közötti számjegyeket. A helyes választások a következők: \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\" és \"nine\". A program a számokat a legkisebbtől a legnagyobbig rendezve adja vissza.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "A bemenet egy szóközzel elválasztott számjegyekből álló karakterlánc, amely tartalmazza a \"zero\" és \"nine\" közötti számjegyeket. A helyes választások a következők: \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\" és \"nine\". A program a számokat a legkisebbtől a legnagyobbig rendezve adja vissza.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Adott egy számok listája (legalább két elemű), alkalmazzunk egy lineáris transzformációt erre a listára, úgy hogy a legkisebb szám 0, a legnagyobb pedig 1 lesz.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Adott egy számok listája (legalább két elemű), alkalmazzunk egy lineáris transzformációt erre a listára, úgy hogy a legkisebb szám 0, a legnagyobb pedig 1 lesz.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Adott karakterlánc esetén fordítsa meg a kisbetűket nagybetűkre és a nagybetűket kisbetűkre.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Adott karakterlánc esetén fordítsa meg a kisbetűket nagybetűkre és a nagybetűket kisbetűkre.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Csak pozitív számokat adjon vissza a listában.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Csak pozitív számokat adjon vissza a listában.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Ha a megadott szám prím, akkor igazat ad vissza, különben hamisat.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Ha a megadott szám prím, akkor igazat ad vissza, különben hamisat.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Visszaadja a rendezett egyedi elemeket egy listában.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Visszaadja a rendezett egyedi elemeket egy listában.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib visszaadja az n-edik számot, ami Fibonacci-szám és egyben prím is.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib visszaadja az n-edik számot, ami Fibonacci-szám és egyben prím is.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    A \"triples_sum_to_zero\" egy egész számok listáját veszi bemenetként.\n    Igazat ad vissza, ha a listában három különböző elem összege nulla,\n    és hamisat, ha nem.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "A \"triples_sum_to_zero\" egy egész számok listáját veszi bemenetként.\n    Igazat ad vissza, ha a listában három különböző elem összege nulla,\n    és hamisat, ha nem.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    A pairs_sum_to_zero egy egész számok listáját veszi bemenetként.\n    Igazat ad vissza, ha a listában két különböző elem összege nulla,\n    és hamisat, ha nem.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "A pairs_sum_to_zero egy egész számok listáját veszi bemenetként.\n    Igazat ad vissza, ha a listában két különböző elem összege nulla,\n    és hamisat, ha nem.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"A Fib4 szám sorozat egy olyan sorozat, amely hasonló a Fibonacci sorozathoz, és a következőképpen van definiálva:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Kérjük, írjon egy függvényt a fib4 szám sorozat n-edik elemének hatékony kiszámításához. Ne használjon rekurziót.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "A Fib4 szám sorozat egy olyan sorozat, amely hasonló a Fibonacci sorozathoz, és a következőképpen van definiálva:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Kérjük, írjon egy függvényt a fib4 szám sorozat n-edik elemének hatékony kiszámításához. Ne használjon rekurziót.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Adja vissza a lista l elemeinek mediánját.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Adja vissza a lista l elemeinek mediánját.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Ellenőrzi, hogy a megadott karakterlánc palindróma-e.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Ellenőrzi, hogy a megadott karakterlánc palindróma-e.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels egy olyan függvény, amely egy karakterláncot vesz át, és visszaadja azt a karakterláncot, amelyben nincsenek magánhangzók.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels egy olyan függvény, amely egy karakterláncot vesz át, és visszaadja azt a karakterláncot, amelyben nincsenek magánhangzók.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Ha az l lista összes száma kisebb, mint a küszöbérték t, akkor igazat ad vissza.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Ha az l lista összes száma kisebb, mint a küszöbérték t, akkor igazat ad vissza.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Adj hozzá két számot, x-et és y-t.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Adj hozzá két számot, x-et és y-t.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Ellenőrizze, hogy két szó azonos karaktereket tartalmaz-e.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Ellenőrizze, hogy két szó azonos karaktereket tartalmaz-e.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Adja vissza az n-edik Fibonacci számot.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Adja vissza az n-edik Fibonacci számot.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Adja vissza a két lista rendezett, egyedi közös elemeit.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Adja vissza a két lista rendezett, egyedi közös elemeit.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Adja vissza n legnagyobb prímosztóját. Feltételezzük, hogy n > 1 és nem prím.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Adja vissza n legnagyobb prímosztóját. Feltételezzük, hogy n > 1 és nem prím.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n egy olyan függvény, amely összeadja az 1-től n-ig terjedő számokat.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n egy olyan függvény, amely összeadja az 1-től n-ig terjedő számokat.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" Az xs egy polinom együtthatóit jelöli.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    A polinom deriváltját ugyanebben a formában kell visszaadni.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "Az xs egy polinom együtthatóit jelöli.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    A polinom deriváltját ugyanebben a formában kell visszaadni.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"A FibFib szám sorozat egy olyan sorozat, amely hasonló a Fibonacci sorozathoz, és a következőképpen van definiálva:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Kérjük, írjon egy függvényt a fibfib szám sorozat n-edik elemének hatékony kiszámításához.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "A FibFib szám sorozat egy olyan sorozat, amely hasonló a Fibonacci sorozathoz, és a következőképpen van definiálva:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Kérjük, írjon egy függvényt a fibfib szám sorozat n-edik elemének hatékony kiszámításához.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Írj egy vowels_count függvényt, amely egy szót reprezentáló stringet vesz bemenetként, és visszaadja a stringben található magánhangzók számát. Magánhangzók ebben az esetben az 'a', 'e', 'i', 'o', 'u'. Itt a 'y' is magánhangzó, de csak akkor, ha a megadott szó végén van.\n\n    Példa:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Írj egy vowels_count függvényt, amely egy szót reprezentáló stringet vesz bemenetként, és visszaadja a stringben található magánhangzók számát. Magánhangzók ebben az esetben az 'a', 'e', 'i', 'o', 'u'. Itt a 'y' is magánhangzó, de csak akkor, ha a megadott szó végén van.\n\n    Példa:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Adott egy nem üres lista pozitív egész számokkal. Adjuk vissza a legnagyobb egész számot, ami nagyobb, mint nulla, és gyakorisága nagyobb vagy egyenlő az egész szám értékével. Az egész szám gyakorisága az, hogy hányszor szerepel a listában. Ha nincs ilyen érték, akkor -1-et adjunk vissza. Példák:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Adott egy nem üres lista pozitív egész számokkal. Adjuk vissza a legnagyobb egész számot, ami nagyobb, mint nulla, és gyakorisága nagyobb vagy egyenlő az egész szám értékével. Az egész szám gyakorisága az, hogy hányszor szerepel a listában. Ha nincs ilyen érték, akkor -1-et adjunk vissza. Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Adott egy háromszög három oldalának hossza. Ha a három oldal alkot egy érvényes háromszöget, akkor térjen vissza a háromszög területével, két tizedesjegyre kerekítve. Ellenkező esetben térjen vissza -1-gyel. Három oldal akkor alkot érvényes háromszöget, ha bármely két oldal összege nagyobb, mint a harmadik oldal. Példa:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Adott egy háromszög három oldalának hossza. Ha a három oldal alkot egy érvényes háromszöget, akkor térjen vissza a háromszög területével, két tizedesjegyre kerekítve. Ellenkező esetben térjen vissza -1-gyel. Három oldal akkor alkot érvényes háromszöget, ha bármely két oldal összege nagyobb, mint a harmadik oldal. Példa:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Írj egy függvényt, amely igazat ad vissza, ha a q objektum repül, és hamisat, ha nem.\n    Az q objektum akkor repül, ha kiegyensúlyozott (palindróm lista), és az elemeinek összege kisebb vagy egyenlő a maximális lehetséges súllyal w.\n\n        Példa:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 kisebb, mint a maximális lehetséges súly, de kiegyensúlyozatlan.\n\n        will_it_fly([3, 2, 3], 1) ➞ False\n    # kiegyensúlyozott, de 3+2+3 több, mint a maximális lehetséges súly.\n\n        will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 kisebb, mint a maximális lehetséges súly, és kiegyensúlyozott.\n\n        will_it_fly([3], 5) ➞ True\n    # 3 kisebb, mint a maximális lehetséges súly, és kiegyensúlyozott.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Írj egy függvényt, amely igazat ad vissza, ha a q objektum repül, és hamisat, ha nem.\n    Az q objektum akkor repül, ha kiegyensúlyozott (palindróm lista), és az elemeinek összege kisebb vagy egyenlő a maximális lehetséges súllyal w.\n\n        Példa:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 kisebb, mint a maximális lehetséges súly, de kiegyensúlyozatlan.\n\n        will_it_fly([3, 2, 3], 1) ➞ False\n    # kiegyensúlyozott, de 3+2+3 több, mint a maximális lehetséges súly.\n\n        will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 kisebb, mint a maximális lehetséges súly, és kiegyensúlyozott.\n\n        will_it_fly([3], 5) ➞ True\n    # 3 kisebb, mint a maximális lehetséges súly, és kiegyensúlyozott.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Írj egy függvényt, amely igazat ad vissza, ha a megadott szám három prímszám szorzata, és hamisat, ha nem. Tudva, hogy (a) kisebb, mint 100. Példa:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Írj egy függvényt, amely igazat ad vissza, ha a megadott szám három prímszám szorzata, és hamisat, ha nem. Tudva, hogy (a) kisebb, mint 100. Példa:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Kapni fogsz egy számot decimális formában, és a feladatod az, hogy átalakítsd bináris formátumra. A függvénynek egy karakterláncot kell visszaadnia, ahol minden karakter egy bináris számot képvisel. A karakterláncban minden karakter '0' vagy '1' lesz.\n\n    Az elején és a végén is lesz néhány extra karakter 'db' formájában. Az extra karakterek a formázáshoz szükségesek.\n\n    Példák:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Kapni fogsz egy számot decimális formában, és a feladatod az, hogy átalakítsd bináris formátumra. A függvénynek egy karakterláncot kell visszaadnia, ahol minden karakter egy bináris számot képvisel. A karakterláncban minden karakter '0' vagy '1' lesz.\n\n    Az elején és a végén is lesz néhány extra karakter 'db' formájában. Az extra karakterek a formázáshoz szükségesek.\n\n    Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Adott egy s karakterlánc.\n    A feladatod az, hogy ellenőrizd, boldog-e a karakterlánc.\n    Egy karakterlánc boldog, ha legalább 3 karakter hosszú, és minden 3 egymást követő karakter különböző.\n    Például:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Adott egy s karakterlánc.\n    A feladatod az, hogy ellenőrizd, boldog-e a karakterlánc.\n    Egy karakterlánc boldog, ha legalább 3 karakter hosszú, és minden 3 egymást követő karakter különböző.\n    Például:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"A félév utolsó hete van, és a tanárnőnek osztályzatokat kell adnia a diákoknak. A tanárnő saját algoritmust készített az osztályzásra. Az egyetlen probléma az, hogy elvesztette az osztályzásához használt kódot. Adott neked néhány diák GPA-jának listáját, és írnod kell egy függvényt, amely a következő táblázatot használva ki tudja írni az osztályzatok listáját:\n\n                 GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Példa:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "A félév utolsó hete van, és a tanárnőnek osztályzatokat kell adnia a diákoknak. A tanárnő saját algoritmust készített az osztályzásra. Az egyetlen probléma az, hogy elvesztette az osztályzásához használt kódot. Adott neked néhány diák GPA-jának listáját, és írnod kell egy függvényt, amely a következő táblázatot használva ki tudja írni az osztályzatok listáját:\n\n                 GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Példa:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Írj egy függvényt, amely egy karakterláncot vesz át, és igazat ad vissza, ha a karakterlánc hossza prímszám, egyébként hamisat. Példák:\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Írj egy függvényt, amely egy karakterláncot vesz át, és igazat ad vissza, ha a karakterlánc hossza prímszám, egyébként hamisat. Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Adott egy pozitív egész szám N, térj vissza a számjegyeinek összegével binárisan.\n\n        Példa:\n        Ha N = 1000, akkor a számjegyek összege 1 lesz, az eredmény \"1\" kell legyen.\n        Ha N = 150, akkor a számjegyek összege 6 lesz, az eredmény \"110\" kell legyen.\n        Ha N = 147, akkor a számjegyek összege 12 lesz, az eredmény \"1100\" kell legyen.\n    \n    Változók:\n        @N egész szám\n             Korlátok: 0 ≤ N ≤ 10000.\n    Kimenet:\n         egy bináris szám string formájában.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Adott egy pozitív egész szám N, térj vissza a számjegyeinek összegével binárisan.\n\n        Példa:\n        Ha N = 1000, akkor a számjegyek összege 1 lesz, az eredmény \"1\" kell legyen.\n        Ha N = 150, akkor a számjegyek összege 6 lesz, az eredmény \"110\" kell legyen.\n        Ha N = 147, akkor a számjegyek összege 12 lesz, az eredmény \"1100\" kell legyen.\n    \n    Változók:\n        @N egész szám\n             Korlátok: 0 ≤ N ≤ 10000.\n    Kimenet:\n         egy bináris szám string formájában.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Adott egy 2 dimenziós adat, mint egy beágyazott lista, amely hasonló a mátrixhoz, azonban, ellentétben a mátrixokkal, minden sorban lehet különböző számú oszlop. Adott lst és x egész szám, keressük meg az x egész számokat a listában, majd térjünk vissza egy [(x1, y1), (x2, y2) ...] tuple listával, amelyek mindegyike egy koordináta - (sor, oszlop), kezdve 0-tól. A koordinátákat kezdetben soronként növekvő sorrendben rendezzük. Emellett a sor koordinátáit oszlopok szerint csökkenő sorrendben rendezzük.\n\n    Példák:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Adott egy 2 dimenziós adat, mint egy beágyazott lista, amely hasonló a mátrixhoz, azonban, ellentétben a mátrixokkal, minden sorban lehet különböző számú oszlop. Adott lst és x egész szám, keressük meg az x egész számokat a listában, majd térjünk vissza egy [(x1, y1), (x2, y2) ...] tuple listával, amelyek mindegyike egy koordináta - (sor, oszlop), kezdve 0-tól. A koordinátákat kezdetben soronként növekvő sorrendben rendezzük. Emellett a sor koordinátáit oszlopok szerint csökkenő sorrendben rendezzük.\n\n    Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Adott egy egész számok listája.\nÍrj egy next_smallest() függvényt, amely visszaadja a lista második legkisebb elemét.\nHa nincs ilyen elem, akkor null-t adjon vissza.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Adott egy egész számok listája.\nÍrj egy next_smallest() függvényt, amely visszaadja a lista második legkisebb elemét.\nHa nincs ilyen elem, akkor null-t adjon vissza.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Adott egy szósztring, és a feladatod az unalomok számának megszámlálása. Az unalom olyan mondat, amely az \"I\" szóval kezdődik. A mondatokat '.' vagy '?' vagy '!' határolja.\n\n    Például:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Adott egy szósztring, és a feladatod az unalomok számának megszámlálása. Az unalom olyan mondat, amely az \"I\" szóval kezdődik. A mondatokat '.' vagy '?' vagy '!' határolja.\n\n    Például:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Adott egy egész számok listája.\n    Meg kell találnod a legnagyobb prímszámot és vissza kell adnod annak számjegyeinek összegét.\n\n        Példák:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Adott egy egész számok listája.\n    Meg kell találnod a legnagyobb prímszámot és vissza kell adnod annak számjegyeinek összegét.\n\n        Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Adott egy szótár, térjen vissza igazzal, ha az összes kulcs kisbetűs string vagy az összes kulcs nagybetűs string, különben térjen vissza hamissal. A függvény hamissal térjen vissza, ha a megadott szótár üres. Példák:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Adott egy szótár, térjen vissza igazzal, ha az összes kulcs kisbetűs string vagy az összes kulcs nagybetűs string, különben térjen vissza hamissal. A függvény hamissal térjen vissza, ha a megadott szótár üres. Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Hozz létre egy függvényt, amely egy számot reprezentáló értéket (string) vesz át, és visszaadja a legközelebbi egész számot. Ha a szám két egész szám között egyenlő távolságra van, akkor kerekítse azt távolabb a zérótól.\n\n        Példák\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Hozz létre egy függvényt, amely egy számot reprezentáló értéket (string) vesz át, és visszaadja a legközelebbi egész számot. Ha a szám két egész szám között egyenlő távolságra van, akkor kerekítse azt távolabb a zérótól.\n\n        Példák\n    ", "natural_language": "Hungarian"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Adott egy pozitív egész szám n, és egy n szintű kőhalomot kell létrehoznod.\nAz első szinten n darab kő van.\nA következő szinten a következő számú kövek vannak:\n- a következő páratlan szám, ha n páratlan.\n- a következő páros szám, ha n páros.\nEgy listában vissza kell adni a szintenkénti kövek számát, ahol az i. indexű elem a (i+1). szinten lévő kövek számát jelenti.\n\n    Példák:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Adott egy pozitív egész szám n, és egy n szintű kőhalomot kell létrehoznod.\nAz első szinten n darab kő van.\nA következő szinten a következő számú kövek vannak:\n- a következő páratlan szám, ha n páratlan.\n- a következő páros szám, ha n páros.\nEgy listában vissza kell adni a szintenkénti kövek számát, ahol az i. indexű elem a (i+1). szinten lévő kövek számát jelenti.\n\n    Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Adott lesz egy szóközökkel vagy vesszőkkel elválasztott szavakból álló karakterlánc. A feladatod az, hogy szétválaszd a karakterláncot szavakra, majd visszatérj egy tömbbel, amely a szavakat tartalmazza.\n\n    Példa:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Adott lesz egy szóközökkel vagy vesszőkkel elválasztott szavakból álló karakterlánc. A feladatod az, hogy szétválaszd a karakterláncot szavakra, majd visszatérj egy tömbbel, amely a szavakat tartalmazza.\n\n    Példa:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Ez a függvény két pozitív számot, x-et és y-t vesz át, majd visszaadja a legnagyobb páros egész számot, amely az [x, y] tartományba esik. Ha nincs ilyen szám, akkor a függvény -1-et ad vissza.\n\n    Példa:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Ez a függvény két pozitív számot, x-et és y-t vesz át, majd visszaadja a legnagyobb páros egész számot, amely az [x, y] tartományba esik. Ha nincs ilyen szám, akkor a függvény -1-et ad vissza.\n\n    Példa:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Két pozitív egész számot, n-et és m-et adnak meg neked, és a feladatod az, hogy kiszámold az egész számok átlagát n-től m-ig (beleértve n-et és m-et). Kerekítsd az eredményt a legközelebbi egészre, majd konvertáld azt binárisra. Ha n nagyobb, mint m, térj vissza -1-gyel. Példa:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Két pozitív egész számot, n-et és m-et adnak meg neked, és a feladatod az, hogy kiszámold az egész számok átlagát n-től m-ig (beleértve n-et és m-et). Kerekítsd az eredményt a legközelebbi egészre, majd konvertáld azt binárisra. Ha n nagyobb, mint m, térj vissza -1-gyel. Példa:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Valósítsa meg a függvényt, amely n paramétert vesz át,\n    és visszaad egy n méretű listát, úgy hogy az i indexű elem értéke az i faktoriálisa, ha i páros,\n    vagy az 1-től i-ig terjedő számok összege, ha i páratlan.\n    Az i 1-től indul.\n    Az i faktoriálisa az 1-től i-ig terjedő számok szorzata (1 * 2 * ... * i).\n    Példa:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Valósítsa meg a függvényt, amely n paramétert vesz át,\n    és visszaad egy n méretű listát, úgy hogy az i indexű elem értéke az i faktoriálisa, ha i páros,\n    vagy az 1-től i-ig terjedő számok összege, ha i páratlan.\n    Az i 1-től indul.\n    Az i faktoriálisa az 1-től i-ig terjedő számok szorzata (1 * 2 * ... * i).\n    Példa:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Adjon meg egy pozitív egész számot n, és térjen vissza egy tuple-el, amely tartalmazza a páros és páratlan egész szám palindrómok számát a (1, n) tartományban, beleértve a határokat.\n\n        Példa 1:\n\n            Bemenet: 3\n        Kimenet: (1, 2)\n        Magyarázat:\n        Az egész szám palindrómok 1, 2, 3. Egyikük páros, és kettőjük páratlan.\n\n        Példa 2:\n\n            Bemenet: 12\n        Kimenet: (4, 6)\n        Magyarázat:\n        Az egész szám palindrómok 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Négy páros és hat páratlan.\n\n        Megjegyzés:\n        1. 1 <= n <= 10^3\n        2. A visszatérő tuple a páros és páratlan egész szám palindrómok számát tartalmazza.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Adjon meg egy pozitív egész számot n, és térjen vissza egy tuple-el, amely tartalmazza a páros és páratlan egész szám palindrómok számát a (1, n) tartományban, beleértve a határokat.\n\n        Példa 1:\n\n            Bemenet: 3\n        Kimenet: (1, 2)\n        Magyarázat:\n        Az egész szám palindrómok 1, 2, 3. Egyikük páros, és kettőjük páratlan.\n\n        Példa 2:\n\n            Bemenet: 12\n        Kimenet: (4, 6)\n        Magyarázat:\n        Az egész szám palindrómok 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Négy páros és hat páratlan.\n\n        Megjegyzés:\n        1. 1 <= n <= 10^3\n        2. A visszatérő tuple a páros és páratlan egész szám palindrómok számát tartalmazza.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Van egy N elemű 'arr' tömbünk, melynek elemei arr[1], arr[2], ..., arr[N] véletlenszerűen rendezettek. A feladatod az, hogy eldöntsd, lehetséges-e egy nem-csökkenő sorrendbe rendezett tömböt kapni a következő művelettel:\n        Lehetőséged van bármennyi jobbra tolás műveletet végrehajtani.\n    \n    Egy jobbra tolás művelet azt jelenti, hogy az összes tömb elemet egy pozícióval jobbra tolod. A tömb utolsó eleme a tömb kezdő pozíciójába kerül, azaz az 0. indexre.\n\n        Ha a fenti művelettel lehetséges a rendezett tömb megszerzése, akkor igaz értéket kell visszaadni, különben hamisat. Ha a megadott tömb üres, akkor igazat kell visszaadni.\n\n        Megjegyzés: A megadott lista garantáltan egyedi elemeket tartalmaz.\n\n        Példa:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Magyarázat: 2 jobbra tolás művelettel elérhető a nem-csökkenő sorrend a megadott tömbben.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Magyarázat: Nem lehetséges bármennyi jobbra tolás művelettel a nem-csökkenő sorrend elérése a megadott tömbben.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Van egy N elemű 'arr' tömbünk, melynek elemei arr[1], arr[2], ..., arr[N] véletlenszerűen rendezettek. A feladatod az, hogy eldöntsd, lehetséges-e egy nem-csökkenő sorrendbe rendezett tömböt kapni a következő művelettel:\n        Lehetőséged van bármennyi jobbra tolás műveletet végrehajtani.\n    \n    Egy jobbra tolás művelet azt jelenti, hogy az összes tömb elemet egy pozícióval jobbra tolod. A tömb utolsó eleme a tömb kezdő pozíciójába kerül, azaz az 0. indexre.\n\n        Ha a fenti művelettel lehetséges a rendezett tömb megszerzése, akkor igaz értéket kell visszaadni, különben hamisat. Ha a megadott tömb üres, akkor igazat kell visszaadni.\n\n        Megjegyzés: A megadott lista garantáltan egyedi elemeket tartalmaz.\n\n        Példa:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Magyarázat: 2 jobbra tolás művelettel elérhető a nem-csökkenő sorrend a megadott tömbben.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Magyarázat: Nem lehetséges bármennyi jobbra tolás művelettel a nem-csökkenő sorrend elérése a megadott tömbben.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Ebben a feladatban egy olyan függvényt kell megvalósítania, amely két számok listáját veszi,\n    és meghatározza, hogy lehetséges-e elemek cseréje\n    közöttük, hogy lst1 csak páros számok listája legyen.\n    Nincs korlátozás a lst1 és lst2 közötti cserélt elemek számára.\n    Ha lehetséges elemeket cserélni a lst1 és lst2 között, hogy\n    lst1 összes eleme páros legyen, akkor \"YES\"-t adjon vissza.\n    Ellenkező esetben \"NO\"-t adjon vissza.\n    Például:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    Feltételezhető, hogy a bemeneti listák nem üresek.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "Ebben a feladatban egy olyan függvényt kell megvalósítania, amely két számok listáját veszi,\n    és meghatározza, hogy lehetséges-e elemek cseréje\n    közöttük, hogy lst1 csak páros számok listája legyen.\n    Nincs korlátozás a lst1 és lst2 közötti cserélt elemek számára.\n    Ha lehetséges elemeket cserélni a lst1 és lst2 között, hogy\n    lst1 összes eleme páros legyen, akkor \"YES\"-t adjon vissza.\n    Ellenkező esetben \"NO\"-t adjon vissza.\n    Például:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    Feltételezhető, hogy a bemeneti listák nem üresek.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Feladat\n    Két karakterláncot kapunk, s és c. Törölni kell az összes s karakterláncban található karaktert, amely megegyezik bármely karakterrel c-ben,\n    majd ellenőrizni kell, hogy az eredmény karakterlánc palindrom-e.\n    Egy karakterlánc akkor nevezhető palindromnak, ha ugyanazt olvassuk előre és visszafelé.\n    Egy tuple-t kell visszaadni, amely tartalmazza az eredmény karakterláncot és az igaz/hamis értéket az ellenőrzéshez.\n    Példa\n    Ha s = \"abcde\", c = \"ae\", akkor az eredmény ('bcd',False) kell legyen.\n    Ha s = \"abcdef\", c = \"b\", akkor az eredmény ('acdef',False) kell legyen.\n    Ha s = \"abcdedcba\", c = \"ab\", akkor az eredmény ('cdedc',True) kell legyen.\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Feladat\n    Két karakterláncot kapunk, s és c. Törölni kell az összes s karakterláncban található karaktert, amely megegyezik bármely karakterrel c-ben,\n    majd ellenőrizni kell, hogy az eredmény karakterlánc palindrom-e.\n    Egy karakterlánc akkor nevezhető palindromnak, ha ugyanazt olvassuk előre és visszafelé.\n    Egy tuple-t kell visszaadni, amely tartalmazza az eredmény karakterláncot és az igaz/hamis értéket az ellenőrzéshez.\n    Példa\n    Ha s = \"abcde\", c = \"ae\", akkor az eredmény ('bcd',False) kell legyen.\n    Ha s = \"abcdef\", c = \"b\", akkor az eredmény ('acdef',False) kell legyen.\n    Ha s = \"abcdedcba\", c = \"ab\", akkor az eredmény ('cdedc',True) kell legyen.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Egy téglalap alakú kút rácsot kapsz. Minden sor egy kút, és minden 1 a sorban egy egység vizet jelent. Minden kútnak van egy megfelelő vödör, amelyet használhatsz a víz kivonására, és minden vödörnek azonos kapacitása van. A feladatod az, hogy a vödröket használva kiürítsd a kutakat. Azt kell kimenetként megadni, hogy hányszor kell leengedni a vödröket.\n\n    Példa 1:\n    Bemenet:\n        rács : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        vödör kapacitása : 1\n    Kimenet: 6\n\n    Példa 2:\n    Bemenet:\n        rács : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        vödör kapacitása : 2\n    Kimenet: 5\n\n    Példa 3:\n    Bemenet:\n        rács : [[0,0,0], [0,0,0]]\n        vödör kapacitása : 5\n    Kimenet: 0\n\n    Korlátok:\n    * minden kútnak azonos hossza van\n    * 1 <= rács.hossza <= 10^2\n    * 1 <= rács[:,1].hossza <= 10^2\n    * rács[i][j] -> 0 | 1\n    * 1 <= kapacitás <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Egy téglalap alakú kút rácsot kapsz. Minden sor egy kút, és minden 1 a sorban egy egység vizet jelent. Minden kútnak van egy megfelelő vödör, amelyet használhatsz a víz kivonására, és minden vödörnek azonos kapacitása van. A feladatod az, hogy a vödröket használva kiürítsd a kutakat. Azt kell kimenetként megadni, hogy hányszor kell leengedni a vödröket.\n\n    Példa 1:\n    Bemenet:\n        rács : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        vödör kapacitása : 1\n    Kimenet: 6\n\n    Példa 2:\n    Bemenet:\n        rács : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        vödör kapacitása : 2\n    Kimenet: 5\n\n    Példa 3:\n    Bemenet:\n        rács : [[0,0,0], [0,0,0]]\n        vödör kapacitása : 5\n    Kimenet: 0\n\n    Korlátok:\n    * minden kútnak azonos hossza van\n    * 1 <= rács.hossza <= 10^2\n    * 1 <= rács[:,1].hossza <= 10^2\n    * rács[i][j] -> 0 | 1\n    * 1 <= kapacitás <= 10\n    ", "natural_language": "Hungarian"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Adott egy s karakterlánc és egy természetes szám n, feladatod egy olyan függvény megvalósítása, amely visszaad egy listát az összes olyan szóról a s karakterláncból, amely pontosan n mássalhangzót tartalmaz, azok sorrendjében, ahogy azok a s karakterláncban megjelennek. Ha az s karakterlánc üres, akkor a függvény üres listát kell visszaadjon. Megjegyzés: feltételezheted, hogy a bemeneti karakterlánc csak betűket és szóközöket tartalmaz. Példák:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Adott egy s karakterlánc és egy természetes szám n, feladatod egy olyan függvény megvalósítása, amely visszaad egy listát az összes olyan szóról a s karakterláncból, amely pontosan n mássalhangzót tartalmaz, azok sorrendjében, ahogy azok a s karakterláncban megjelennek. Ha az s karakterlánc üres, akkor a függvény üres listát kell visszaadjon. Megjegyzés: feltételezheted, hogy a bemeneti karakterlánc csak betűket és szóközöket tartalmaz. Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Adott egy arr nevű egész számokat tartalmazó tömb és egy pozitív egész szám k. Adj vissza egy rendezett listát, amelynek hossza k és amely az arr tömb k legnagyobb számát tartalmazza.\n\n    Példa 1:\n\n        Bemenet: arr = [-3, -4, 5], k = 3\n    Kimenet: [-4, -3, 5]\n\n    Példa 2:\n\n        Bemenet: arr = [4, -4, 4], k = 2\n    Kimenet: [4, 4]\n\n    Példa 3:\n\n        Bemenet: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Kimenet: [2]\n\n    Megjegyzés:\n    1. A tömb hossza [1, 1000] tartományban lesz.\n    2. A tömb elemei [-1000, 1000] tartományban lesznek.\n    3. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Adott egy arr nevű egész számokat tartalmazó tömb és egy pozitív egész szám k. Adj vissza egy rendezett listát, amelynek hossza k és amely az arr tömb k legnagyobb számát tartalmazza.\n\n    Példa 1:\n\n        Bemenet: arr = [-3, -4, 5], k = 3\n    Kimenet: [-4, -3, 5]\n\n    Példa 2:\n\n        Bemenet: arr = [4, -4, 4], k = 2\n    Kimenet: [4, 4]\n\n    Példa 3:\n\n        Bemenet: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Kimenet: [2]\n\n    Megjegyzés:\n    1. A tömb hossza [1, 1000] tartományban lesz.\n    2. A tömb elemei [-1000, 1000] tartományban lesznek.\n    3. 0 <= k <= len(arr)\n    ", "natural_language": "Hungarian"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Adott egy nem üres egész számok tömbje (arr) és egy egész szám (k). Adjuk vissza azoknak az elemeknek az összegét, amelyeknek legfeljebb két számjegyük van az arr első k eleme között.\n\n        Példa:\n\n            Bemenet: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Kimenet: 24 # 21 + 3 összege\n\n        Megkötések:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Adott egy nem üres egész számok tömbje (arr) és egy egész szám (k). Adjuk vissza azoknak az elemeknek az összegét, amelyeknek legfeljebb két számjegyük van az arr első k eleme között.\n\n        Példa:\n\n            Bemenet: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Kimenet: 24 # 21 + 3 összege\n\n        Megkötések:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    ", "natural_language": "Hungarian"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Két intervallumot kapsz,\n    ahol minden intervallum egy egész számpárból áll. Például, intervallum = (kezdő, vég) = (1, 2).\n    A megadott intervallumok zártak, ami azt jelenti, hogy az intervallum (kezdő, vég)\n    mindkét végpontját tartalmazza.\n    Minden intervallum esetében feltételezzük, hogy a kezdő értéke kisebb vagy egyenlő a végével.\n    A feladatod az, hogy meghatározd, az adott két intervallum metszetének hossza prímszám-e.\n    Például, az intervallumok (1, 3), (2, 4) metszete (2, 3) és annak hossza 1, ami nem prímszám.\n    Ha a metszet hossza prímszám, térj vissza \"YES\"-sel,\n    különben térj vissza \"NO\"-val.\n    Ha a két intervallum nem metszi egymást, térj vissza \"NO\"-val.\n\n    \n    [bemenet/kimenet] példák:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Két intervallumot kapsz,\n    ahol minden intervallum egy egész számpárból áll. Például, intervallum = (kezdő, vég) = (1, 2).\n    A megadott intervallumok zártak, ami azt jelenti, hogy az intervallum (kezdő, vég)\n    mindkét végpontját tartalmazza.\n    Minden intervallum esetében feltételezzük, hogy a kezdő értéke kisebb vagy egyenlő a végével.\n    A feladatod az, hogy meghatározd, az adott két intervallum metszetének hossza prímszám-e.\n    Például, az intervallumok (1, 3), (2, 4) metszete (2, 3) és annak hossza 1, ami nem prímszám.\n    Ha a metszet hossza prímszám, térj vissza \"YES\"-sel,\n    különben térj vissza \"NO\"-val.\n    Ha a két intervallum nem metszi egymást, térj vissza \"NO\"-val.\n\n    \n    [bemenet/kimenet] példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Mindenki ismeri a Fibonacci sorozatot, amelyet az elmúlt évszázadokban mélyen tanulmányoztak a matematikusok. Azonban amit az emberek nem tudnak, az a Tribonacci sorozat. A Tribonacci sorozatot a következő visszatérő érték határozza meg: tri(1) = 3, tri(n) = 1 + n / 2, ha n páros, tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ha n páratlan. Például: tri(2) = 1 + (2 / 2) = 2, tri(4) = 3, tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8. Adott egy nem-negatív egész szám n, és vissza kell adnia a Tribonacci sorozat első n + 1 számát tartalmazó listát. Példák: tri(3) = [1, 3, 2, 8].\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Mindenki ismeri a Fibonacci sorozatot, amelyet az elmúlt évszázadokban mélyen tanulmányoztak a matematikusok. Azonban amit az emberek nem tudnak, az a Tribonacci sorozat. A Tribonacci sorozatot a következő visszatérő érték határozza meg: tri(1) = 3, tri(n) = 1 + n / 2, ha n páros, tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ha n páratlan. Például: tri(2) = 1 + (2 / 2) = 2, tri(4) = 3, tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8. Adott egy nem-negatív egész szám n, és vissza kell adnia a Tribonacci sorozat első n + 1 számát tartalmazó listát. Példák: tri(3) = [1, 3, 2, 8].\n    ", "natural_language": "Hungarian"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Adott egy pozitív egész szám n, térjen vissza az páratlan számjegyek szorzatával.\nHa az összes számjegy páros, akkor térjen vissza 0-val.\nPélda:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Adott egy pozitív egész szám n, térjen vissza az páratlan számjegyek szorzatával.\nHa az összes számjegy páros, akkor térjen vissza 0-val.\nPélda:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Hozzon létre egy függvényt, amely egy olyan karakterláncot vesz bemenetként, amely csak szögletes zárójeleket tartalmaz.\n    A függvény akkor kell, hogy igazat adjon vissza, ha és csak ha van egy érvényes zárójel-alminta, \n    ahol legalább egy zárójel beágyazott.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Hozzon létre egy függvényt, amely egy olyan karakterláncot vesz bemenetként, amely csak szögletes zárójeleket tartalmaz.\n    A függvény akkor kell, hogy igazat adjon vissza, ha és csak ha van egy érvényes zárójel-alminta, \n    ahol legalább egy zárójel beágyazott.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Adott egy számok listája.\n    Vissza kell adnod a lista négyzetes elemeinek összegét,\n    minden elemet a listában felfelé kell kerekíteni az egész számok felé.\n    Példák:\n    Ha lst = [1,2,3], akkor a kimenet 14 legyen\n    Ha lst = [1,4,9], akkor a kimenet 98 legyen\n    Ha lst = [1,3,5,7], akkor a kimenet 84 legyen\n    Ha lst = [1.4,4.2,0], akkor a kimenet 29 legyen\n    Ha lst = [-2.4,1,1], akkor a kimenet 6 legyen\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Adott egy számok listája.\n    Vissza kell adnod a lista négyzetes elemeinek összegét,\n    minden elemet a listában felfelé kell kerekíteni az egész számok felé.\n    Példák:\n    Ha lst = [1,2,3], akkor a kimenet 14 legyen\n    Ha lst = [1,4,9], akkor a kimenet 98 legyen\n    Ha lst = [1,3,5,7], akkor a kimenet 84 legyen\n    Ha lst = [1.4,4.2,0], akkor a kimenet 29 legyen\n    Ha lst = [-2.4,1,1], akkor a kimenet 6 legyen\n    ", "natural_language": "Hungarian"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Hozzon létre egy függvényt, amely igazat ad vissza, ha a megadott karakterlánc utolsó karaktere betű és nem része egy szónak, és hamisat ad vissza egyébként.\nMegjegyzés: \"szó\" egy karakterek csoportja, amelyek szóközzel vannak elválasztva.\n\n    Példák:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Hozzon létre egy függvényt, amely igazat ad vissza, ha a megadott karakterlánc utolsó karaktere betű és nem része egy szónak, és hamisat ad vissza egyébként.\nMegjegyzés: \"szó\" egy karakterek csoportja, amelyek szóközzel vannak elválasztva.\n\n    Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Hozzon létre egy függvényt, amely visszaadja a legnagyobb indexet azon elemnek, amely nem nagyobb vagy egyenlő az előtte álló elemmel. Ha nincs ilyen elem, akkor -1-et adjon vissza. A megadott tömb nem tartalmaz ismétlődő értékeket.\n\n    Példák:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Hozzon létre egy függvényt, amely visszaadja a legnagyobb indexet azon elemnek, amely nem nagyobb vagy egyenlő az előtte álló elemmel. Ha nincs ilyen elem, akkor -1-et adjon vissza. A megadott tömb nem tartalmaz ismétlődő értékeket.\n\n    Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Hozzon létre egy függvényt, amely egy tuple-t (a, b) ad vissza, ahol 'a' a negatív egész számok legnagyobbika, és 'b' a pozitív egész számok legkisebbike egy listában. Ha nincs negatív vagy pozitív egész szám, akkor None-ként térjen vissza.\n\n    Példák:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Hozzon létre egy függvényt, amely egy tuple-t (a, b) ad vissza, ahol 'a' a negatív egész számok legnagyobbika, és 'b' a pozitív egész számok legkisebbike egy listában. Ha nincs negatív vagy pozitív egész szám, akkor None-ként térjen vissza.\n\n    Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"A brazil faktoriális a következőképpen van definiálva:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    ahol n > 0\n\n        Például:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "A brazil faktoriális a következőképpen van definiálva:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    ahol n > 0\n\n        Például:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Kap egy karakterláncot, amely egy mondatot reprezentál,\n    a mondat néhány szót tartalmaz, amelyek szóközzel vannak elválasztva,\n    és vissza kell adnia egy karakterláncot, amely tartalmazza az eredeti mondat szavait,\n    amelyek hosszai prím számok,\n    az új karakterláncban a szavak sorrendje ugyanaz kell legyen, mint az eredeti mondatban.\n\n        Példa 1:\n        Bemenet: sentence = \"This is a test\"\n        Kimenet: \"is\"\n\n        Példa 2:\n        Bemenet: sentence = \"lets go for swimming\"\n        Kimenet: \"go for\"\n\n        Korlátok:\n        * 1 <= len(sentence) <= 100\n        * a mondat csak betűket tartalmaz\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Kap egy karakterláncot, amely egy mondatot reprezentál,\n    a mondat néhány szót tartalmaz, amelyek szóközzel vannak elválasztva,\n    és vissza kell adnia egy karakterláncot, amely tartalmazza az eredeti mondat szavait,\n    amelyek hosszai prím számok,\n    az új karakterláncban a szavak sorrendje ugyanaz kell legyen, mint az eredeti mondatban.\n\n        Példa 1:\n        Bemenet: sentence = \"This is a test\"\n        Kimenet: \"is\"\n\n        Példa 2:\n        Bemenet: sentence = \"lets go for swimming\"\n        Kimenet: \"go for\"\n\n        Korlátok:\n        * 1 <= len(sentence) <= 100\n        * a mondat csak betűket tartalmaz\n    ", "natural_language": "Hungarian"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"A feladatod az, hogy megvalósíts egy függvényt, amely egyszerűsíti a kifejezést\n    x * n. A függvény True értéket ad vissza, ha x * n egész számra értékelődik ki, és False-t\n    egyébként. Mind x, mind n egy tört sztring reprezentációja, és a következő formátumot követik,\n    <számláló>/<nevező>, ahol mind a számláló, mind a nevező pozitív egész számok.\n\n        Feltételezheted, hogy x és n érvényes törtek, és nem rendelkeznek nullával nevezőként.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "A feladatod az, hogy megvalósíts egy függvényt, amely egyszerűsíti a kifejezést\n    x * n. A függvény True értéket ad vissza, ha x * n egész számra értékelődik ki, és False-t\n    egyébként. Mind x, mind n egy tört sztring reprezentációja, és a következő formátumot követik,\n    <számláló>/<nevező>, ahol mind a számláló, mind a nevező pozitív egész számok.\n\n        Feltételezheted, hogy x és n érvényes törtek, és nem rendelkeznek nullával nevezőként.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Írj egy függvényt, amely rendezni tudja a megadott egész számok listáját növekvő sorrendben a számjegyeik összege alapján. Megjegyzés: ha több elemnek van hasonló számjegyek összege, rendezd őket az eredeti lista indexe szerint. \n\n    Példa:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Írj egy függvényt, amely rendezni tudja a megadott egész számok listáját növekvő sorrendben a számjegyeik összege alapján. Megjegyzés: ha több elemnek van hasonló számjegyek összege, rendezd őket az eredeti lista indexe szerint. \n\n    Példa:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Írj egy függvényt, amely egy számokból álló tömböt vesz bemenetként, és visszaadja a tömbben található olyan elemek számát, amelyek nagyobbak, mint 10, és az adott szám első és utolsó számjegye is páratlan (1, 3, 5, 7, 9). Például:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Írj egy függvényt, amely egy számokból álló tömböt vesz bemenetként, és visszaadja a tömbben található olyan elemek számát, amelyek nagyobbak, mint 10, és az adott szám első és utolsó számjegye is páratlan (1, 3, 5, 7, 9). Például:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Adott egy pozitív egész szám n. Létre kell hoznod egy n hosszú egész tömböt, a.\n        Minden i-re (1 ≤ i ≤ n), a[i] értéke legyen i * i - i + 1.\n        Add vissza az a tömbben található olyan hármasok (a[i], a[j], a[k]) számát, ahol i < j < k, \n    és a[i] + a[j] + a[k] hárommal osztható.\n\n        Példa :\n        Bemenet: n = 5\n        Kimenet: 1\n        Magyarázat: \n        a = [1, 3, 7, 13, 21]\n        Az egyetlen érvényes hármas (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Adott egy pozitív egész szám n. Létre kell hoznod egy n hosszú egész tömböt, a.\n        Minden i-re (1 ≤ i ≤ n), a[i] értéke legyen i * i - i + 1.\n        Add vissza az a tömbben található olyan hármasok (a[i], a[j], a[k]) számát, ahol i < j < k, \n    és a[i] + a[j] + a[k] hárommal osztható.\n\n        Példa :\n        Bemenet: n = 5\n        Kimenet: 1\n        Magyarázat: \n        a = [1, 3, 7, 13, 21]\n        Az egyetlen érvényes hármas (1, 7, 13).\n    ", "natural_language": "Hungarian"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    A Naprendszerünkben nyolc bolygó van: a legközelebbi a Naphoz a Merkúr, \n    utána jön a Vénusz, majd a Föld, a Mars, a Jupiter, a Szaturnusz, \n    az Uránusz és a Neptunusz.\n    Írj egy függvényt, amely két bolygó nevét tartalmazza stringként, planet1 és planet2. \n    A függvénynek egy tuple-t kell visszaadnia, amely tartalmazza az összes bolygót, \n    amelyeknek az orbitája planet1 és planet2 orbitája között található, a Nap közeléhez \n    rendezve. \n    A függvény egy üres tuple-t kell visszaadjon, ha planet1 vagy planet2 nem megfelelő bolygónevek. \n    Példák\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "A Naprendszerünkben nyolc bolygó van: a legközelebbi a Naphoz a Merkúr, \n    utána jön a Vénusz, majd a Föld, a Mars, a Jupiter, a Szaturnusz, \n    az Uránusz és a Neptunusz.\n    Írj egy függvényt, amely két bolygó nevét tartalmazza stringként, planet1 és planet2. \n    A függvénynek egy tuple-t kell visszaadnia, amely tartalmazza az összes bolygót, \n    amelyeknek az orbitája planet1 és planet2 orbitája között található, a Nap közeléhez \n    rendezve. \n    A függvény egy üres tuple-t kell visszaadjon, ha planet1 vagy planet2 nem megfelelő bolygónevek. \n    Példák\n    ", "natural_language": "Hungarian"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Egy egyszerű program, amely visszaadja az x értékét, ha n prímszám, és az y értékét, ha nem.\n\n    Példák:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Egy egyszerű program, amely visszaadja az x értékét, ha n prímszám, és az y értékét, ha nem.\n\n    Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Adott egy számok listája, térj vissza a listában található páratlan számok négyzetösszegével. Figyelmen kívül hagyja a negatív vagy nem egész számokat.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    Ha a bemeneti lista üres, térjen vissza 0-val.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Adott egy számok listája, térj vissza a listában található páratlan számok négyzetösszegével. Figyelmen kívül hagyja a negatív vagy nem egész számokat.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    Ha a bemeneti lista üres, térjen vissza 0-val.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Adjon meg egy osztály nevet (string) és egy kiterjesztés listát.\n    A kiterjesztéseket az osztályhoz való további osztályok betöltésére kell használni. A\n    kiterjesztés ereje a következő: Legyen CAP a kiterjesztés nevében található nagybetűk száma, és legyen SM a kisbetűk száma\n    a kiterjesztés nevében, az erő a CAP - SM törttel van meghatározva. \n    Meg kell találnod a legerősebb kiterjesztést, és vissza kell adnod egy stringet ebben a\n    formátumban: ClassName.StrongestExtensionName.\n    Ha két vagy több kiterjesztésnek azonos az ereje, akkor azt kell választani, amelyik először szerepel a listában.\n    Például, ha \"Slices\"-t kapja meg az osztálynak és egy kiterjesztés listát: ['SErviNGSliCes', 'Cheese', 'StuFfed'], akkor\n    vissza kell adnia 'Slices.SErviNGSliCes'-t, mivel 'SErviNGSliCes' a legerősebb kiterjesztés (az ereje -1).\n    Példa:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Adjon meg egy osztály nevet (string) és egy kiterjesztés listát.\n    A kiterjesztéseket az osztályhoz való további osztályok betöltésére kell használni. A\n    kiterjesztés ereje a következő: Legyen CAP a kiterjesztés nevében található nagybetűk száma, és legyen SM a kisbetűk száma\n    a kiterjesztés nevében, az erő a CAP - SM törttel van meghatározva. \n    Meg kell találnod a legerősebb kiterjesztést, és vissza kell adnod egy stringet ebben a\n    formátumban: ClassName.StrongestExtensionName.\n    Ha két vagy több kiterjesztésnek azonos az ereje, akkor azt kell választani, amelyik először szerepel a listában.\n    Például, ha \"Slices\"-t kapja meg az osztálynak és egy kiterjesztés listát: ['SErviNGSliCes', 'Cheese', 'StuFfed'], akkor\n    vissza kell adnia 'Slices.SErviNGSliCes'-t, mivel 'SErviNGSliCes' a legerősebb kiterjesztés (az ereje -1).\n    Példa:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Két szót kapsz. Ha a második szó vagy bármelyik forgatása részsztring a első szóban, akkor igazat kell visszaadni.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Két szót kapsz. Ha a második szó vagy bármelyik forgatása részsztring a első szóban, akkor igazat kell visszaadni.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Adott egy pozitív egész szám, állapítsa meg a római számjegyekkel való ekvivalensét string formában, és térjen vissza kisbetűkkel.\nKorlátozások: 1 <= num <= 1000\n\n    Példák:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Adott egy pozitív egész szám, állapítsa meg a római számjegyekkel való ekvivalensét string formában, és térjen vissza kisbetűkkel.\nKorlátozások: 1 <= num <= 1000\n\n    Példák:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Adott egy háromszög oldalainak hossza. Ha a három oldal alkot egy derékszögű háromszöget, akkor igazat, egyébként hamisat adjon vissza. Egy derékszögű háromszög az a háromszög, amelyben egy szög derékszögű, vagyis 90 fokos. Példa:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Adott egy háromszög oldalainak hossza. Ha a három oldal alkot egy derékszögű háromszöget, akkor igazat, egyébként hamisat adjon vissza. Egy derékszögű háromszög az a háromszög, amelyben egy szög derékszögű, vagyis 90 fokos. Példa:\n    ", "natural_language": "Hungarian"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Adott egy s karakterlánc.\n    Ha s[i] egy betű, fordítsa meg az esetét kisbetűről nagybetűre vagy fordítva,\n    különben hagyja változatlanul.\n    Ha a karakterlánc nem tartalmaz betűket, fordítsa meg a karakterláncot.\n    A függvény visszaadja az eredményezett karakterláncot.\n    Példák\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Adott egy s karakterlánc.\n    Ha s[i] egy betű, fordítsa meg az esetét kisbetűről nagybetűre vagy fordítva,\n    különben hagyja változatlanul.\n    Ha a karakterlánc nem tartalmaz betűket, fordítsa meg a karakterláncot.\n    A függvény visszaadja az eredményezett karakterláncot.\n    Példák\n    ", "natural_language": "Hungarian"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Adott egy 'szöveg' karakterlánc, térj vissza az md5 hash ekvivalens karakterláncával.\nHa a 'szöveg' üres karakterlánc, térj vissza null értékkel.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Adott egy 'szöveg' karakterlánc, térj vissza az md5 hash ekvivalens karakterláncával.\nHa a 'szöveg' üres karakterlánc, térj vissza null értékkel.\n    ", "natural_language": "Hungarian"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Adott két pozitív egész szám, a és b, térjen vissza az a és b közötti páros számjegyekkel növekvő sorrendben.\n\n    Például:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Adott két pozitív egész szám, a és b, térjen vissza az a és b közötti páros számjegyekkel növekvő sorrendben.\n\n    Például:\n    ", "natural_language": "Hungarian"}
