{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" شما یک لیست از عملیات واریز و برداشت در یک حساب بانکی با موجودی صفر داده شده است. وظیفه شما این است که در صورتی که در هر نقطه موجودی حساب کمتر از صفر شود، تشخیص دهید و در آن نقطه تابع باید True را برگرداند. در غیر این صورت باید False را برگرداند.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "شما یک لیست از عملیات واریز و برداشت در یک حساب بانکی با موجودی صفر داده شده است. وظیفه شما این است که در صورتی که در هر نقطه موجودی حساب کمتر از صفر شود، تشخیص دهید و در آن نقطه تابع باید True را برگرداند. در غیر این صورت باید False را برگرداند.\n    ", "natural_language": "Persian"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" برای یک لیست داده شده از اعداد صحیح، یک تاپل شامل جمع و ضرب تمام اعداد در لیست برگردانید.\nجمع خالی باید برابر با 0 و ضرب خالی باید برابر با 1 باشد.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "برای یک لیست داده شده از اعداد صحیح، یک تاپل شامل جمع و ضرب تمام اعداد در لیست برگردانید.\nجمع خالی باید برابر با 0 و ضرب خالی باید برابر با 1 باشد.\n    ", "natural_language": "Persian"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" ورودی دو رشته a و b هستند که فقط شامل اعداد ۱ و ۰ هستند.\n    عملگر XOR دودویی را روی این ورودی ها انجام داده و نتیجه را نیز به صورت یک رشته برگردانید.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "ورودی دو رشته a و b هستند که فقط شامل اعداد ۱ و ۰ هستند.\n    عملگر XOR دودویی را روی این ورودی ها انجام داده و نتیجه را نیز به صورت یک رشته برگردانید.\n    ", "natural_language": "Persian"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" از لیستی از رشته‌ها، بزرگترین رشته را بازگردانید. در صورت وجود چند رشته با طول یکسان، اولین رشته را بازگردانید. در صورت خالی بودن لیست ورودی، null بازگردانید.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "از لیستی از رشته‌ها، بزرگترین رشته را بازگردانید. در صورت وجود چند رشته با طول یکسان، اولین رشته را بازگردانید. در صورت خالی بودن لیست ورودی، null بازگردانید.\n    ", "natural_language": "Persian"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" بازگشت بزرگترین مقسوم علیه مشترک دو عدد a و b\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "بازگشت بزرگترین مقسوم علیه مشترک دو عدد a و b\n    ", "natural_language": "Persian"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" ورودی یک رشته با فاصله جدا شده از اعداد از 'صفر' تا 'نه' است.\n    انتخاب های معتبر عبارتند از 'صفر'، 'یک'، 'دو'، 'سه'، 'چهار'، 'پنج'، 'شش'، 'هفت'، 'هشت' و 'نه'.\n    رشته را با اعداد مرتب شده از کوچکترین تا بزرگترین برگردانید.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "ورودی یک رشته با فاصله جدا شده از اعداد از 'صفر' تا 'نه' است.\n    انتخاب های معتبر عبارتند از 'صفر'، 'یک'، 'دو'، 'سه'، 'چهار'، 'پنج'، 'شش'، 'هفت'، 'هشت' و 'نه'.\n    رشته را با اعداد مرتب شده از کوچکترین تا بزرگترین برگردانید.\n    ", "natural_language": "Persian"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" در لیستی از اعداد (حداقل دو عنصر)، یک تبدیل خطی به این لیست اعمال شود، به گونه‌ای که کوچکترین عدد برابر با ۰ و بزرگترین عدد برابر با ۱ شود.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "در لیستی از اعداد (حداقل دو عنصر)، یک تبدیل خطی به این لیست اعمال شود، به گونه‌ای که کوچکترین عدد برابر با ۰ و بزرگترین عدد برابر با ۱ شود.\n    ", "natural_language": "Persian"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" برای یک رشته داده شده، حروف کوچک را به حروف بزرگ و حروف بزرگ را به حروف کوچک تبدیل کنید.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "برای یک رشته داده شده، حروف کوچک را به حروف بزرگ و حروف بزرگ را به حروف کوچک تبدیل کنید.\n    ", "natural_language": "Persian"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"تنها اعداد مثبت در لیست را بازگردانید.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "تنها اعداد مثبت در لیست را بازگردانید.\n    ", "natural_language": "Persian"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"اگر یک عدد داده شده اول باشد، true برگردانید و در غیر این صورت false.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "اگر یک عدد داده شده اول باشد، true برگردانید و در غیر این صورت false.\n    ", "natural_language": "Persian"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"بازگشت عناصر منحصر به فرد مرتب شده در یک لیست\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "بازگشت عناصر منحصر به فرد مرتب شده در یک لیست\n    ", "natural_language": "Persian"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib عدد n ام را برمیگرداند که یک عدد فیبوناچی است و همچنین اول است.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib عدد n ام را برمیگرداند که یک عدد فیبوناچی است و همچنین اول است.\n    ", "natural_language": "Persian"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    تابع triples_sum_to_zero یک لیست اعداد صحیح را به عنوان ورودی دریافت می‌کند.\n    اگر در لیست سه عنصر متمایز وجود داشته باشد که مجموع آن‌ها صفر باشد، True برمی‌گرداند و در غیر این صورت False.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "تابع triples_sum_to_zero یک لیست اعداد صحیح را به عنوان ورودی دریافت می‌کند.\n    اگر در لیست سه عنصر متمایز وجود داشته باشد که مجموع آن‌ها صفر باشد، True برمی‌گرداند و در غیر این صورت False.\n    ", "natural_language": "Persian"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero یک لیست اعداد صحیح را به عنوان ورودی می‌گیرد.\n    اگر دو عنصر متمایز در لیست وجود داشته باشند که مجموع آن‌ها صفر باشد، True برمی‌گرداند و در غیر این صورت False.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "pairs_sum_to_zero یک لیست اعداد صحیح را به عنوان ورودی می‌گیرد.\n    اگر دو عنصر متمایز در لیست وجود داشته باشند که مجموع آن‌ها صفر باشد، True برمی‌گرداند و در غیر این صورت False.\n    ", "natural_language": "Persian"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"دنباله اعداد فیبوناچی 4 یک دنباله مشابه دنباله فیبوناچی است که به شرح زیر تعریف می‌شود:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    لطفا یک تابع برای محاسبه بهینه عنصر n ام از دنباله اعداد فیبوناچی 4 بنویسید. از بازگشتی استفاده نکنید.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "دنباله اعداد فیبوناچی 4 یک دنباله مشابه دنباله فیبوناچی است که به شرح زیر تعریف می‌شود:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    لطفا یک تابع برای محاسبه بهینه عنصر n ام از دنباله اعداد فیبوناچی 4 بنویسید. از بازگشتی استفاده نکنید.\n    ", "natural_language": "Persian"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"بازگشت میانگین عناصر لیست l.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "بازگشت میانگین عناصر لیست l.\n    ", "natural_language": "Persian"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    بررسی می‌کند که رشته داده شده یک پالیندروم است یا خیر.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "بررسی می‌کند که رشته داده شده یک پالیندروم است یا خیر.\n    ", "natural_language": "Persian"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels یک تابع است که یک رشته را دریافت کرده و رشته‌ای بدون حروف صدادار برمی‌گرداند.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels یک تابع است که یک رشته را دریافت کرده و رشته‌ای بدون حروف صدادار برمی‌گرداند.\n    ", "natural_language": "Persian"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"اگر همه اعداد در لیست l کمتر از آستانه t باشند، True برگردانید.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "اگر همه اعداد در لیست l کمتر از آستانه t باشند، True برگردانید.\n    ", "natural_language": "Persian"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"افزودن دو عدد x و y\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "افزودن دو عدد x و y\n    ", "natural_language": "Persian"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    بررسی کنید که دو کلمه دارای کاراکترهای یکسان هستند یا خیر.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "بررسی کنید که دو کلمه دارای کاراکترهای یکسان هستند یا خیر.\n    ", "natural_language": "Persian"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"بازگشت عدد فیبوناچی n ام.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "بازگشت عدد فیبوناچی n ام.\n    ", "natural_language": "Persian"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"بازگشت عناصر مشترک منحصر به فرد مرتب شده برای دو لیست.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "بازگشت عناصر مشترک منحصر به فرد مرتب شده برای دو لیست.\n    ", "natural_language": "Persian"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"بزرگترین عامل اول n را بازگردانید. فرض کنید n> 1 و اول نیست.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "بزرگترین عامل اول n را بازگردانید. فرض کنید n> 1 و اول نیست.\n    ", "natural_language": "Persian"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"تابع sum_to_n مجموع اعداد از ۱ تا n را محاسبه می‌کند.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "تابع sum_to_n مجموع اعداد از ۱ تا n را محاسبه می‌کند.\n    ", "natural_language": "Persian"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs ضرایب یک چندجمله‌ای را نشان می‌دهد.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\nمشتق این چندجمله‌ای را با همان فرم برگردانید.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs ضرایب یک چندجمله‌ای را نشان می‌دهد.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\nمشتق این چندجمله‌ای را با همان فرم برگردانید.\n    ", "natural_language": "Persian"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"دنباله اعداد فیبفیب یک دنباله مشابه دنباله فیبوناچی است که به شرح زیر تعریف می‌شود:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    لطفا یک تابع برای محاسبه بهینه عنصر nام دنباله اعداد فیبفیب بنویسید.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "دنباله اعداد فیبفیب یک دنباله مشابه دنباله فیبوناچی است که به شرح زیر تعریف می‌شود:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    لطفا یک تابع برای محاسبه بهینه عنصر nام دنباله اعداد فیبفیب بنویسید.\n    ", "natural_language": "Persian"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"تابع vowels_count را بنویسید که یک رشته که یک کلمه را نشان می دهد را به عنوان ورودی می گیرد و تعداد حروف صدادار در رشته را برمی گرداند. حروف صدادار در اینجا 'a'، 'e'، 'i'، 'o'، 'u' هستند. در اینجا، 'y' نیز یک حرف صدادار است، اما فقط زمانی که در انتهای کلمه داده شده باشد.\n\n        مثال:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "تابع vowels_count را بنویسید که یک رشته که یک کلمه را نشان می دهد را به عنوان ورودی می گیرد و تعداد حروف صدادار در رشته را برمی گرداند. حروف صدادار در اینجا 'a'، 'e'، 'i'، 'o'، 'u' هستند. در اینجا، 'y' نیز یک حرف صدادار است، اما فقط زمانی که در انتهای کلمه داده شده باشد.\n\n        مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    شما یک لیست غیر خالی از اعداد صحیح مثبت دارید. بزرگترین عدد صحیحی را که بزرگتر از صفر است و فرکانس آن بیشتر یا مساوی با مقدار خود عدد است، برگردانید. فرکانس یک عدد، تعداد بارهایی است که در لیست ظاهر می‌شود. اگر چنین مقداری وجود نداشته باشد، -1 را برگردانید. نمونه‌ها:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "شما یک لیست غیر خالی از اعداد صحیح مثبت دارید. بزرگترین عدد صحیحی را که بزرگتر از صفر است و فرکانس آن بیشتر یا مساوی با مقدار خود عدد است، برگردانید. فرکانس یک عدد، تعداد بارهایی است که در لیست ظاهر می‌شود. اگر چنین مقداری وجود نداشته باشد، -1 را برگردانید. نمونه‌ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    با دریافت طول سه ضلع مثلث، مساحت مثلث را با دو رقم اعشار گرد کرده و در صورتی که سه ضلع یک مثلث معتبر را تشکیل دهند، آن را برگردانید. در غیر این صورت، -1 را برگردانید. سه ضلع یک مثلث معتبر را زمانی تشکیل می دهند که مجموع هر دو ضلع بزرگتر از ضلع سوم باشد. مثال:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "با دریافت طول سه ضلع مثلث، مساحت مثلث را با دو رقم اعشار گرد کرده و در صورتی که سه ضلع یک مثلث معتبر را تشکیل دهند، آن را برگردانید. در غیر این صورت، -1 را برگردانید. سه ضلع یک مثلث معتبر را زمانی تشکیل می دهند که مجموع هر دو ضلع بزرگتر از ضلع سوم باشد. مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    تابعی بنویسید که در صورتی که شیء q پرواز کند، True برمی گرداند و در غیر این صورت False.\nشیء q در صورتی پرواز می کند که متعادل باشد (یک لیست پالیندرومیک است) و مجموع عناصر آن کمتر یا مساوی حداکثر وزن ممکن w باشد.\n\n    مثال:\nwill_it_fly([1، 2]، 5) ➞ False\n# 1 + 2 کمتر از حداکثر وزن ممکن است، اما متعادل نیست.\n\n    will_it_fly([3، 2، 3]، 1) ➞ False\n# متعادل است، اما 3 + 2 + 3 بیشتر از حداکثر وزن ممکن است.\n\n    will_it_fly([3، 2، 3]، 9) ➞ True\n# 3 + 2 + 3 کمتر از حداکثر وزن ممکن است و متعادل است.\n\n    will_it_fly([3]، 5) ➞ True\n# 3 کمتر از حداکثر وزن ممکن است و متعادل است.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "تابعی بنویسید که در صورتی که شیء q پرواز کند، True برمی گرداند و در غیر این صورت False.\nشیء q در صورتی پرواز می کند که متعادل باشد (یک لیست پالیندرومیک است) و مجموع عناصر آن کمتر یا مساوی حداکثر وزن ممکن w باشد.\n\n    مثال:\nwill_it_fly([1، 2]، 5) ➞ False\n# 1 + 2 کمتر از حداکثر وزن ممکن است، اما متعادل نیست.\n\n    will_it_fly([3، 2، 3]، 1) ➞ False\n# متعادل است، اما 3 + 2 + 3 بیشتر از حداکثر وزن ممکن است.\n\n    will_it_fly([3، 2، 3]، 9) ➞ True\n# 3 + 2 + 3 کمتر از حداکثر وزن ممکن است و متعادل است.\n\n    will_it_fly([3]، 5) ➞ True\n# 3 کمتر از حداکثر وزن ممکن است و متعادل است.\n    ", "natural_language": "Persian"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"یک تابع بنویسید که در صورتی که عدد داده شده حاصلضرب 3 عدد اول باشد، مقدار درست را برگرداند و در غیر این صورت، مقدار نادرست را برگرداند.\n    با دانستن اینکه (a) کمتر از 100 است.\n    مثال:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "یک تابع بنویسید که در صورتی که عدد داده شده حاصلضرب 3 عدد اول باشد، مقدار درست را برگرداند و در غیر این صورت، مقدار نادرست را برگرداند.\n    با دانستن اینکه (a) کمتر از 100 است.\n    مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"شما یک عدد به صورت دهدهی دریافت خواهید کرد و وظیفه شما تبدیل آن به فرمت دودویی است. تابع باید یک رشته بازگرداند که هر کاراکتر آن یک عدد دودویی را نشان می‌دهد. هر کاراکتر در رشته '0' یا '1' خواهد بود.\n\n    در ابتدا و انتهای رشته، چند کاراکتر اضافی 'db' وجود دارد. این کاراکترهای اضافی برای کمک به فرمت‌بندی است.\n\n    مثال‌ها:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "شما یک عدد به صورت دهدهی دریافت خواهید کرد و وظیفه شما تبدیل آن به فرمت دودویی است. تابع باید یک رشته بازگرداند که هر کاراکتر آن یک عدد دودویی را نشان می‌دهد. هر کاراکتر در رشته '0' یا '1' خواهد بود.\n\n    در ابتدا و انتهای رشته، چند کاراکتر اضافی 'db' وجود دارد. این کاراکترهای اضافی برای کمک به فرمت‌بندی است.\n\n    مثال‌ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"شما یک رشته s دریافت می کنید.\n    وظیفه شما بررسی این است که رشته خوشحال است یا خیر.\n    یک رشته خوشحال است اگر طول آن حداقل 3 باشد و هر 3 حرف متوالی آن متفاوت باشد.\n    به عنوان مثال:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "شما یک رشته s دریافت می کنید.\n    وظیفه شما بررسی این است که رشته خوشحال است یا خیر.\n    یک رشته خوشحال است اگر طول آن حداقل 3 باشد و هر 3 حرف متوالی آن متفاوت باشد.\n    به عنوان مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"در هفته آخر ترم، معلم باید نمرات را به دانش آموزان بدهد. معلم الگوریتم خود را برای نمره دادن ارائه داده است. تنها مشکل این است که او کدی که برای نمره دادن استفاده کرده است را از دست داده است. او لیستی از معدل های برخی از دانش آموزان به شما داده است و شما باید یک تابع بنویسید که با استفاده از جدول زیر، لیستی از نمرات حروفی را خروجی دهد:\n\n                 GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        مثال:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "در هفته آخر ترم، معلم باید نمرات را به دانش آموزان بدهد. معلم الگوریتم خود را برای نمره دادن ارائه داده است. تنها مشکل این است که او کدی که برای نمره دادن استفاده کرده است را از دست داده است. او لیستی از معدل های برخی از دانش آموزان به شما داده است و شما باید یک تابع بنویسید که با استفاده از جدول زیر، لیستی از نمرات حروفی را خروجی دهد:\n\n                 GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"یک تابع بنویسید که یک رشته را دریافت کرده و در صورتی که طول رشته یک عدد اول باشد، True و در غیر این صورت False برگرداند.\nمثال ها:\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "یک تابع بنویسید که یک رشته را دریافت کرده و در صورتی که طول رشته یک عدد اول باشد، True و در غیر این صورت False برگرداند.\nمثال ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"با دادن یک عدد صحیح مثبت N، مجموع کل رقم های آن در سیستم دو برگردانده می شود.\n\n        مثال:\n        برای N = 1000، مجموع ارقام برابر با 1 خواهد بود و خروجی \"1\" خواهد بود.\n        برای N = 150، مجموع ارقام برابر با 6 خواهد بود و خروجی \"110\" خواهد بود.\n        برای N = 147، مجموع ارقام برابر با 12 خواهد بود و خروجی \"1100\" خواهد بود.\n    \n    متغیرها:\n        @N عدد صحیح\n             محدودیت ها: 0 ≤ N ≤ 10000.\n    خروجی:\n         یک رشته از عدد دودویی.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "با دادن یک عدد صحیح مثبت N، مجموع کل رقم های آن در سیستم دو برگردانده می شود.\n\n        مثال:\n        برای N = 1000، مجموع ارقام برابر با 1 خواهد بود و خروجی \"1\" خواهد بود.\n        برای N = 150، مجموع ارقام برابر با 6 خواهد بود و خروجی \"110\" خواهد بود.\n        برای N = 147، مجموع ارقام برابر با 12 خواهد بود و خروجی \"1100\" خواهد بود.\n    \n    متغیرها:\n        @N عدد صحیح\n             محدودیت ها: 0 ≤ N ≤ 10000.\n    خروجی:\n         یک رشته از عدد دودویی.\n    ", "natural_language": "Persian"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    شما یک داده دو بعدی به عنوان لیست های تو در تو دریافت می کنید که شبیه به ماتریس است، با این حال، برخلاف ماتریس ها، هر ردیف ممکن است شامل تعداد مختلفی ستون باشد. با دادن lst و عدد صحیح x، اعداد صحیح x را در لیست پیدا کرده و لیستی از تاپل ها، [(x1، y1)، (x2، y2) ...] را برگردانید که هر تاپل یک مختصات - (ردیف، ستون)، با شروع از 0 است. مختصات را در ابتدا بر اساس ردیف ها به ترتیب صعودی مرتب کنید. همچنین، مختصات ردیف را بر اساس ستون ها به ترتیب نزولی مرتب کنید.\n\n    مثال ها:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "شما یک داده دو بعدی به عنوان لیست های تو در تو دریافت می کنید که شبیه به ماتریس است، با این حال، برخلاف ماتریس ها، هر ردیف ممکن است شامل تعداد مختلفی ستون باشد. با دادن lst و عدد صحیح x، اعداد صحیح x را در لیست پیدا کرده و لیستی از تاپل ها، [(x1، y1)، (x2، y2) ...] را برگردانید که هر تاپل یک مختصات - (ردیف، ستون)، با شروع از 0 است. مختصات را در ابتدا بر اساس ردیف ها به ترتیب صعودی مرتب کنید. همچنین، مختصات ردیف را بر اساس ستون ها به ترتیب نزولی مرتب کنید.\n\n    مثال ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    شما یک لیست اعداد صحیح دارید.\nتابع next_smallest() را بنویسید که دومین کوچکترین عنصر لیست را برمی‌گرداند.\nاگر چنین عنصری وجود نداشته باشد، null برگردانید.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "شما یک لیست اعداد صحیح دارید.\nتابع next_smallest() را بنویسید که دومین کوچکترین عنصر لیست را برمی‌گرداند.\nاگر چنین عنصری وجود نداشته باشد، null برگردانید.\n    ", "natural_language": "Persian"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    شما یک رشته از کلمات دریافت خواهید کرد و وظیفه شما شمارش تعداد خستگی ها است. خستگی یک جمله است که با کلمه \"من\" شروع می شود. جملات با '.'، '?' یا '!' محدود می شوند.\n\n        به عنوان مثال:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "شما یک رشته از کلمات دریافت خواهید کرد و وظیفه شما شمارش تعداد خستگی ها است. خستگی یک جمله است که با کلمه \"من\" شروع می شود. جملات با '.'، '?' یا '!' محدود می شوند.\n\n        به عنوان مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"شما یک لیست اعداد صحیح دارید.\nشما باید بزرگترین مقدار اولیه را پیدا کرده و مجموع ارقام آن را برگردانید.\n\n    مثال ها:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "شما یک لیست اعداد صحیح دارید.\nشما باید بزرگترین مقدار اولیه را پیدا کرده و مجموع ارقام آن را برگردانید.\n\n    مثال ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    با توجه به یک فرهنگ لغت، در صورتی که همه کلیدها رشته‌هایی با حروف کوچک باشند یا همه کلیدها رشته‌هایی با حروف بزرگ باشند، True را برگردانید. در غیر این صورت، False را برگردانید. اگر فرهنگ لغت داده شده خالی باشد، تابع باید False را برگرداند. مثال‌ها:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "با توجه به یک فرهنگ لغت، در صورتی که همه کلیدها رشته‌هایی با حروف کوچک باشند یا همه کلیدها رشته‌هایی با حروف بزرگ باشند، True را برگردانید. در غیر این صورت، False را برگردانید. اگر فرهنگ لغت داده شده خالی باشد، تابع باید False را برگرداند. مثال‌ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    تابعی بسازید که یک مقدار (رشته) که یک عدد را نشان می‌دهد را بگیرد و نزدیک‌ترین عدد صحیح به آن را برگرداند. اگر عدد از دو عدد صحیح به یک فاصله باشد، آن را به سمت دور از صفر گرد کنید.\n\n        مثال‌ها\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "تابعی بسازید که یک مقدار (رشته) که یک عدد را نشان می‌دهد را بگیرد و نزدیک‌ترین عدد صحیح به آن را برگرداند. اگر عدد از دو عدد صحیح به یک فاصله باشد، آن را به سمت دور از صفر گرد کنید.\n\n        مثال‌ها\n    ", "natural_language": "Persian"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    با دریافت یک عدد صحیح مثبت n، باید یک توده از n سطح سنگ بسازید.\n    سطح اول دارای n سنگ است.\n    تعداد سنگ در سطح بعدی به شرح زیر است:\n        - اگر n فرد باشد، تعداد سنگ بعدی برابر با بعد بعدی فرد خواهد بود.\n        - اگر n زوج باشد، تعداد سنگ بعدی برابر با بعد بعدی زوج خواهد بود.\n    تعداد سنگ در هر سطح را در یک لیست بازگردانید، به طوری که المان در اندیس\n    i تعداد سنگ در سطح (i+1) را نشان می دهد.\n\n        مثال ها:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "با دریافت یک عدد صحیح مثبت n، باید یک توده از n سطح سنگ بسازید.\n    سطح اول دارای n سنگ است.\n    تعداد سنگ در سطح بعدی به شرح زیر است:\n        - اگر n فرد باشد، تعداد سنگ بعدی برابر با بعد بعدی فرد خواهد بود.\n        - اگر n زوج باشد، تعداد سنگ بعدی برابر با بعد بعدی زوج خواهد بود.\n    تعداد سنگ در هر سطح را در یک لیست بازگردانید، به طوری که المان در اندیس\n    i تعداد سنگ در سطح (i+1) را نشان می دهد.\n\n        مثال ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    شما یک رشته از کلمات جدا شده توسط کاما یا فاصله دریافت خواهید کرد. وظیفه شما این است که رشته را به کلمات تقسیم کرده و یک آرایه از کلمات برگردانید.\n\n        به عنوان مثال:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "شما یک رشته از کلمات جدا شده توسط کاما یا فاصله دریافت خواهید کرد. وظیفه شما این است که رشته را به کلمات تقسیم کرده و یک آرایه از کلمات برگردانید.\n\n        به عنوان مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"این تابع دو عدد مثبت x و y را می‌گیرد و بزرگترین عدد صحیح زوجی را که در بازه [x، y] قرار دارد، برمی‌گرداند. اگر چنین عددی وجود نداشته باشد، تابع باید -1 را برگرداند.\n\n        به عنوان مثال:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "این تابع دو عدد مثبت x و y را می‌گیرد و بزرگترین عدد صحیح زوجی را که در بازه [x، y] قرار دارد، برمی‌گرداند. اگر چنین عددی وجود نداشته باشد، تابع باید -1 را برگرداند.\n\n        به عنوان مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"شما دو عدد صحیح مثبت n و m را دریافت می‌کنید و وظیفه شما محاسبه میانگین اعداد صحیح از n تا m (شامل n و m) است. پاسخ را به نزدیک‌ترین عدد صحیح گرد کرده و آن را به دودویی تبدیل کنید. اگر n بزرگتر از m باشد، -1 را برگردانید.\nمثال:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "شما دو عدد صحیح مثبت n و m را دریافت می‌کنید و وظیفه شما محاسبه میانگین اعداد صحیح از n تا m (شامل n و m) است. پاسخ را به نزدیک‌ترین عدد صحیح گرد کرده و آن را به دودویی تبدیل کنید. اگر n بزرگتر از m باشد، -1 را برگردانید.\nمثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" تابع f را پیاده سازی کنید که n را به عنوان پارامتر دریافت می کند،\nو یک لیست به اندازه n برمی گرداند، به گونه ای که مقدار المان در اندیس i برابر با فاکتوریل i است اگر i زوج باشد\nو در غیر این صورت مجموع اعداد از 1 تا i است.\ni از 1 شروع می شود.\nفاکتوریل i ضرب اعداد از 1 تا i است (1 * 2 * ... * i).\nمثال:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "تابع f را پیاده سازی کنید که n را به عنوان پارامتر دریافت می کند،\nو یک لیست به اندازه n برمی گرداند، به گونه ای که مقدار المان در اندیس i برابر با فاکتوریل i است اگر i زوج باشد\nو در غیر این صورت مجموع اعداد از 1 تا i است.\ni از 1 شروع می شود.\nفاکتوریل i ضرب اعداد از 1 تا i است (1 * 2 * ... * i).\nمثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    با توجه به یک عدد صحیح مثبت n، یک tuple را برگردانید که شامل تعداد اعداد پالیندروم زوج و فردی است که در بازه (1، n)، شامل هستند.\n\n        مثال 1:\n\n            ورودی: 3\n        خروجی: (1، 2)\n        توضیحات:\n        اعداد پالیندروم شامل 1، 2، 3 هستند. یکی از آن‌ها زوج و دوتای دیگر فرد هستند.\n\n        مثال 2:\n\n            ورودی: 12\n        خروجی: (4، 6)\n        توضیحات:\n        اعداد پالیندروم شامل 1، 2، 3، 4، 5، 6، 7، 8، 9، 11 هستند. چهارتای آن‌ها زوج و 6 تای دیگر فرد هستند.\n\n        توجه:\n        1. 1 <= n <= 10^3\n        2. توپل برگشتی تعداد اعداد پالیندروم زوج و فردی را به ترتیب دارد.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "با توجه به یک عدد صحیح مثبت n، یک tuple را برگردانید که شامل تعداد اعداد پالیندروم زوج و فردی است که در بازه (1، n)، شامل هستند.\n\n        مثال 1:\n\n            ورودی: 3\n        خروجی: (1، 2)\n        توضیحات:\n        اعداد پالیندروم شامل 1، 2، 3 هستند. یکی از آن‌ها زوج و دوتای دیگر فرد هستند.\n\n        مثال 2:\n\n            ورودی: 12\n        خروجی: (4، 6)\n        توضیحات:\n        اعداد پالیندروم شامل 1، 2، 3، 4، 5، 6، 7، 8، 9، 11 هستند. چهارتای آن‌ها زوج و 6 تای دیگر فرد هستند.\n\n        توجه:\n        1. 1 <= n <= 10^3\n        2. توپل برگشتی تعداد اعداد پالیندروم زوج و فردی را به ترتیب دارد.\n    ", "natural_language": "Persian"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"ما یک آرایه به نام 'arr' از N عدد صحیح arr [1]، arr [2]، ...، arr [N] داریم. اعداد در آرایه به صورت تصادفی مرتب شده اند. وظیفه شما تعیین این است که آیا می توان با انجام عملیات shift به راست بر روی آرایه داده شده آرایه ای را در ترتیب صعودی غیر صعودی بدست آورد یا خیر:\n\n        شما مجاز به انجام عملیات shift به راست به تعداد دلخواه هستید.\n    \n    یک عملیات shift به راست به معنی جابجایی تمام عناصر آرایه به یک موقعیت به سمت راست است. آخرین عنصر آرایه به موقعیت شروع آرایه یعنی فهرست 0 اندیس منتقل می شود.\n\n        اگر با انجام عملیات فوق می توان آرایه مرتب شده را بدست آورد ، آنگاه True را برگردانید در غیر این صورت False را برگردانید.\n    اگر آرایه داده شده خالی باشد ، True را برگردانید.\n\n        توجه: لیست داده شده تضمین می کند که عناصر منحصر به فردی دارد.\n\n        به عنوان مثال:\n\n        move_one_ball([3، 4، 5، 1، 2]) ==> True\n    توضیح: با انجام 2 عملیات shift به راست ، می توان برای آرایه داده شده ترتیب صعودی غیر صعودی را بدست آورد.\n    move_one_ball([3، 5، 4، 1، 2]) ==> False\n    توضیح: با انجام هر تعداد عملیات shift به راست ، نمی توان برای آرایه داده شده ترتیب صعودی غیر صعودی را بدست آورد.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "ما یک آرایه به نام 'arr' از N عدد صحیح arr [1]، arr [2]، ...، arr [N] داریم. اعداد در آرایه به صورت تصادفی مرتب شده اند. وظیفه شما تعیین این است که آیا می توان با انجام عملیات shift به راست بر روی آرایه داده شده آرایه ای را در ترتیب صعودی غیر صعودی بدست آورد یا خیر:\n\n        شما مجاز به انجام عملیات shift به راست به تعداد دلخواه هستید.\n    \n    یک عملیات shift به راست به معنی جابجایی تمام عناصر آرایه به یک موقعیت به سمت راست است. آخرین عنصر آرایه به موقعیت شروع آرایه یعنی فهرست 0 اندیس منتقل می شود.\n\n        اگر با انجام عملیات فوق می توان آرایه مرتب شده را بدست آورد ، آنگاه True را برگردانید در غیر این صورت False را برگردانید.\n    اگر آرایه داده شده خالی باشد ، True را برگردانید.\n\n        توجه: لیست داده شده تضمین می کند که عناصر منحصر به فردی دارد.\n\n        به عنوان مثال:\n\n        move_one_ball([3، 4، 5، 1، 2]) ==> True\n    توضیح: با انجام 2 عملیات shift به راست ، می توان برای آرایه داده شده ترتیب صعودی غیر صعودی را بدست آورد.\n    move_one_ball([3، 5، 4، 1، 2]) ==> False\n    توضیح: با انجام هر تعداد عملیات shift به راست ، نمی توان برای آرایه داده شده ترتیب صعودی غیر صعودی را بدست آورد.\n    ", "natural_language": "Persian"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"در این مسئله، شما باید یک تابع پیاده سازی کنید که دو لیست از اعداد را دریافت کرده، تعیین می کند که آیا امکان تعویض عناصر بین آنها وجود دارد تا lst1 یک لیست از اعداد زوج باشد یا خیر. هیچ محدودیتی برای تعویض عناصر بین lst1 و lst2 وجود ندارد. اگر امکان تعویض عناصر بین lst1 و lst2 برای تبدیل تمام عناصر lst1 به اعداد زوج وجود داشت، \"YES\" را برگردانید. در غیر این صورت، \"NO\" را برگردانید. به عنوان مثال: exchange([1، 2، 3، 4]، [1، 2، 3، 4]) => \"YES\" exchange([1، 2، 3، 4]، [1، 5، 3، 4]) => \"NO\" فرض می شود که لیست های ورودی خالی نخواهند بود.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "در این مسئله، شما باید یک تابع پیاده سازی کنید که دو لیست از اعداد را دریافت کرده، تعیین می کند که آیا امکان تعویض عناصر بین آنها وجود دارد تا lst1 یک لیست از اعداد زوج باشد یا خیر. هیچ محدودیتی برای تعویض عناصر بین lst1 و lst2 وجود ندارد. اگر امکان تعویض عناصر بین lst1 و lst2 برای تبدیل تمام عناصر lst1 به اعداد زوج وجود داشت، \"YES\" را برگردانید. در غیر این صورت، \"NO\" را برگردانید. به عنوان مثال: exchange([1، 2، 3، 4]، [1، 2، 3، 4]) => \"YES\" exchange([1، 2، 3، 4]، [1، 5، 3، 4]) => \"NO\" فرض می شود که لیست های ورودی خالی نخواهند بود.\n    ", "natural_language": "Persian"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"وظیفه\n    دو رشته s و c داده شده است، شما باید تمامی حروفی را که در s با هر حرفی در c برابر است، حذف کنید\n    سپس بررسی کنید که رشته نتیجه شده یک پالیندروم است یا خیر.\n    یک رشته پالیندروم نامیده می شود اگر به صورت معکوس با خودش برابر باشد.\n    شما باید یک تاپل شامل رشته نتیجه و True/False برای بررسی برگردانید.\n    مثال\n    برای s = \"abcde\"، c = \"ae\"، نتیجه باید ('bcd'،False) باشد\n    برای s = \"abcdef\"، c = \"b\"، نتیجه باید ('acdef'،False) باشد\n    برای s = \"abcdedcba\"، c = \"ab\"، نتیجه باید ('cdedc'،True) باشد\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "وظیفه\n    دو رشته s و c داده شده است، شما باید تمامی حروفی را که در s با هر حرفی در c برابر است، حذف کنید\n    سپس بررسی کنید که رشته نتیجه شده یک پالیندروم است یا خیر.\n    یک رشته پالیندروم نامیده می شود اگر به صورت معکوس با خودش برابر باشد.\n    شما باید یک تاپل شامل رشته نتیجه و True/False برای بررسی برگردانید.\n    مثال\n    برای s = \"abcde\"، c = \"ae\"، نتیجه باید ('bcd'،False) باشد\n    برای s = \"abcdef\"، c = \"b\"، نتیجه باید ('acdef'،False) باشد\n    برای s = \"abcdedcba\"، c = \"ab\"، نتیجه باید ('cdedc'،True) باشد\n    ", "natural_language": "Persian"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    شما یک شبکه مستطیلی از چاه ها دارید. هر ردیف یک چاه را نشان می دهد و هر 1 در یک ردیف یک واحد آب را نشان می دهد. هر چاه دارای یک سطل متناظر است که می توان از آن برای استخراج آب استفاده کرد و تمام سطل ها دارای ظرفیت یکسان هستند. وظیفه شما استفاده از سطل ها برای خالی کردن چاه ها است. تعداد بارهایی که باید سطل ها را پایین بیاورید را خروجی دهید.\n\n    مثال ۱:\n    ورودی:\n        شبکه: [[0،0،1،0]، [0،1،0،0]، [1،1،1،1]]\n        ظرفیت سطل: ۱\n    خروجی: ۶\n\n    مثال ۲:\n    ورودی:\n        شبکه: [[0،0،1،1]، [0،0،0،0]، [1،1،1،1]، [0،1،1،1]]\n        ظرفیت سطل: ۲\n    خروجی: ۵\n\n    مثال ۳:\n    ورودی:\n        شبکه: [[0،0،0]، [0،0،0]]\n        ظرفیت سطل: ۵\n    خروجی: ۰\n\n    محدودیت ها:\n    * تمام چاه ها طول یکسانی دارند\n    * ۱ <= طول شبکه <= ۱۰^۲\n    * ۱ <= طول grid [:، ۱] <= ۱۰^۲\n    * grid [i] [j] -> ۰ | ۱\n    * ۱ <= ظرفیت <= ۱۰\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "شما یک شبکه مستطیلی از چاه ها دارید. هر ردیف یک چاه را نشان می دهد و هر 1 در یک ردیف یک واحد آب را نشان می دهد. هر چاه دارای یک سطل متناظر است که می توان از آن برای استخراج آب استفاده کرد و تمام سطل ها دارای ظرفیت یکسان هستند. وظیفه شما استفاده از سطل ها برای خالی کردن چاه ها است. تعداد بارهایی که باید سطل ها را پایین بیاورید را خروجی دهید.\n\n    مثال ۱:\n    ورودی:\n        شبکه: [[0،0،1،0]، [0،1،0،0]، [1،1،1،1]]\n        ظرفیت سطل: ۱\n    خروجی: ۶\n\n    مثال ۲:\n    ورودی:\n        شبکه: [[0،0،1،1]، [0،0،0،0]، [1،1،1،1]، [0،1،1،1]]\n        ظرفیت سطل: ۲\n    خروجی: ۵\n\n    مثال ۳:\n    ورودی:\n        شبکه: [[0،0،0]، [0،0،0]]\n        ظرفیت سطل: ۵\n    خروجی: ۰\n\n    محدودیت ها:\n    * تمام چاه ها طول یکسانی دارند\n    * ۱ <= طول شبکه <= ۱۰^۲\n    * ۱ <= طول grid [:، ۱] <= ۱۰^۲\n    * grid [i] [j] -> ۰ | ۱\n    * ۱ <= ظرفیت <= ۱۰\n    ", "natural_language": "Persian"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"با دادن یک رشته s و یک عدد طبیعی n، شما مسئولیت پیاده سازی یک تابع را دارید که لیستی از تمام کلمات رشته s را که دقیقاً n حرف بی صدا دارند، به ترتیبی که این کلمات در رشته s ظاهر می شوند، برمی گرداند. اگر رشته s خالی باشد، تابع باید یک لیست خالی برگرداند. توجه: شما می توانید فرض کنید رشته ورودی فقط شامل حروف و فضاها است.\n    مثال ها:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "با دادن یک رشته s و یک عدد طبیعی n، شما مسئولیت پیاده سازی یک تابع را دارید که لیستی از تمام کلمات رشته s را که دقیقاً n حرف بی صدا دارند، به ترتیبی که این کلمات در رشته s ظاهر می شوند، برمی گرداند. اگر رشته s خالی باشد، تابع باید یک لیست خالی برگرداند. توجه: شما می توانید فرض کنید رشته ورودی فقط شامل حروف و فضاها است.\n    مثال ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    با دادن یک آرایه از اعداد صحیح و یک عدد صحیح مثبت k، یک لیست مرتب شده با طول k حاوی بزرگترین k عدد در آرایه برگردانید.\n\n    مثال ۱:\n\n    ورودی: arr = [-3، -4، 5]، k = 3\nخروجی: [-4، -3، 5]\n\n    مثال ۲:\n\n    ورودی: arr = [4، -4، 4]، k = 2\nخروجی: [4، 4]\n\n    مثال ۳:\n\n    ورودی: arr = [-3، 2، 1، 2، -1، -2، 1]، k = 1\nخروجی: [2]\n\n    توجه:\n۱. طول آرایه در محدوده [1، 1000] خواهد بود.\n۲. عناصر آرایه در محدوده [-1000، 1000] خواهند بود.\n۳. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "با دادن یک آرایه از اعداد صحیح و یک عدد صحیح مثبت k، یک لیست مرتب شده با طول k حاوی بزرگترین k عدد در آرایه برگردانید.\n\n    مثال ۱:\n\n    ورودی: arr = [-3، -4، 5]، k = 3\nخروجی: [-4، -3، 5]\n\n    مثال ۲:\n\n    ورودی: arr = [4، -4، 4]، k = 2\nخروجی: [4، 4]\n\n    مثال ۳:\n\n    ورودی: arr = [-3، 2، 1، 2، -1، -2، 1]، k = 1\nخروجی: [2]\n\n    توجه:\n۱. طول آرایه در محدوده [1، 1000] خواهد بود.\n۲. عناصر آرایه در محدوده [-1000، 1000] خواهند بود.\n۳. 0 <= k <= len(arr)\n    ", "natural_language": "Persian"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    با دریافت یک آرایه غیر خالی از اعداد صحیح arr و یک عدد صحیح k، مجموع عناصر با حداکثر دو رقم از اولین k عنصر از arr را برگردانید.\n\n    مثال:\n\n        ورودی: arr = [111، 21، 3، 4000، 5، 6، 7، 8، 9]، k = 4\n    خروجی: 24 # مجموع 21 + 3\n\n    محدودیت ها:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "با دریافت یک آرایه غیر خالی از اعداد صحیح arr و یک عدد صحیح k، مجموع عناصر با حداکثر دو رقم از اولین k عنصر از arr را برگردانید.\n\n    مثال:\n\n        ورودی: arr = [111، 21، 3، 4000، 5، 6، 7، 8، 9]، k = 4\n    خروجی: 24 # مجموع 21 + 3\n\n    محدودیت ها:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    ", "natural_language": "Persian"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"شما دو بازه داده شده دارید،\n    که هر بازه شامل یک جفت عدد صحیح است. به عنوان مثال، بازه = (شروع، پایان) = (1، 2).\n    بازه های داده شده بسته هستند که به این معنی است که بازه (شروع، پایان)\n    شامل هر دو شروع و پایان است.\n    برای هر بازه داده شده، فرض می شود که شروع آن کمتر یا مساوی پایان آن است.\n    وظیفه شما تعیین این است که طول تقاطع این دو بازه\n    یک عدد اول است یا خیر.\n    به عنوان مثال، تقاطع بازه ها (1، 3)، (2، 4) (2، 3) است\n    که طول آن 1 است، که یک عدد اول نیست.\n    اگر طول تقاطع یک عدد اول باشد، \"YES\" را برگردانید،\n    در غیر این صورت، \"NO\" را برگردانید.\n    اگر دو بازه با هم تداخل ندارند، \"NO\" را برگردانید.\n\n    \n    [ورودی / خروجی] نمونه:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "شما دو بازه داده شده دارید،\n    که هر بازه شامل یک جفت عدد صحیح است. به عنوان مثال، بازه = (شروع، پایان) = (1، 2).\n    بازه های داده شده بسته هستند که به این معنی است که بازه (شروع، پایان)\n    شامل هر دو شروع و پایان است.\n    برای هر بازه داده شده، فرض می شود که شروع آن کمتر یا مساوی پایان آن است.\n    وظیفه شما تعیین این است که طول تقاطع این دو بازه\n    یک عدد اول است یا خیر.\n    به عنوان مثال، تقاطع بازه ها (1، 3)، (2، 4) (2، 3) است\n    که طول آن 1 است، که یک عدد اول نیست.\n    اگر طول تقاطع یک عدد اول باشد، \"YES\" را برگردانید،\n    در غیر این صورت، \"NO\" را برگردانید.\n    اگر دو بازه با هم تداخل ندارند، \"NO\" را برگردانید.\n\n    \n    [ورودی / خروجی] نمونه:\n    ", "natural_language": "Persian"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"همه می‌دانند دنباله فیبوناچی، که در چند قرن گذشته توسط ریاضی‌دانان عمیقاً مورد بررسی قرار گرفته است. با این حال، آنچه مردم نمی‌دانند دنباله تریبوناچی است. دنباله تریبوناچی توسط بازگشتی تعریف می‌شود:\n    tri(1) = 3\n    tri(n) = 1 + n / 2، اگر n زوج باشد.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، اگر n فرد باشد.\n    به عنوان مثال:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    شما یک عدد صحیح غیر منفی n را دریافت می‌کنید، شما باید یک لیست از اولین n + 1 عدد دنباله تریبوناچی را برگردانید.\n    مثال:\n    tri(3) = [1، 3، 2، 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "همه می‌دانند دنباله فیبوناچی، که در چند قرن گذشته توسط ریاضی‌دانان عمیقاً مورد بررسی قرار گرفته است. با این حال، آنچه مردم نمی‌دانند دنباله تریبوناچی است. دنباله تریبوناچی توسط بازگشتی تعریف می‌شود:\n    tri(1) = 3\n    tri(n) = 1 + n / 2، اگر n زوج باشد.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، اگر n فرد باشد.\n    به عنوان مثال:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    شما یک عدد صحیح غیر منفی n را دریافت می‌کنید، شما باید یک لیست از اولین n + 1 عدد دنباله تریبوناچی را برگردانید.\n    مثال:\n    tri(3) = [1، 3، 2، 8]\n    ", "natural_language": "Persian"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"با دادن یک عدد صحیح مثبت n، حاصلضرب ارقام فرد را برگردانید.\n    اگر همه ارقام زوج باشند، 0 را برگردانید.\n    به عنوان مثال:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "با دادن یک عدد صحیح مثبت n، حاصلضرب ارقام فرد را برگردانید.\n    اگر همه ارقام زوج باشند، 0 را برگردانید.\n    به عنوان مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    یک تابع ایجاد کنید که یک رشته را به عنوان ورودی دریافت می کند که فقط شامل براکت های مربعی است.\nاین تابع باید در صورت وجود زیردنباله معتبری از براکت ها که حداقل یک براکت درونی در آن وجود دارد، True را برگرداند.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "یک تابع ایجاد کنید که یک رشته را به عنوان ورودی دریافت می کند که فقط شامل براکت های مربعی است.\nاین تابع باید در صورت وجود زیردنباله معتبری از براکت ها که حداقل یک براکت درونی در آن وجود دارد، True را برگرداند.\n    ", "natural_language": "Persian"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"شما یک لیست اعداد دارید.\nشما باید مجموع اعداد مربع شده در لیست داده شده را برگردانید،\nهر عنصر در لیست را ابتدا به بالاترین عدد صحیح (سقف) گرد کنید.\nمثال:\nبرای lst = [1،2،3] خروجی باید 14 باشد\nبرای lst = [1،4،9] خروجی باید 98 باشد\nبرای lst = [1،3،5،7] خروجی باید 84 باشد\nبرای lst = [1.4،4.2،0] خروجی باید 29 باشد\nبرای lst = [-2.4،1،1] خروجی باید 6 باشد\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "شما یک لیست اعداد دارید.\nشما باید مجموع اعداد مربع شده در لیست داده شده را برگردانید،\nهر عنصر در لیست را ابتدا به بالاترین عدد صحیح (سقف) گرد کنید.\nمثال:\nبرای lst = [1،2،3] خروجی باید 14 باشد\nبرای lst = [1،4،9] خروجی باید 98 باشد\nبرای lst = [1،3،5،7] خروجی باید 84 باشد\nبرای lst = [1.4،4.2،0] خروجی باید 29 باشد\nبرای lst = [-2.4،1،1] خروجی باید 6 باشد\n    ", "natural_language": "Persian"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    تابعی بسازید که در صورتی که آخرین حرف رشته داده شده یک حرف الفبایی باشد و بخشی از یک کلمه نباشد، True برگرداند و در غیر این صورت False.\nتوجه: \"کلمه\" یک گروه از حروف جدا شده توسط فاصله است.\n\n    مثال ها:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "تابعی بسازید که در صورتی که آخرین حرف رشته داده شده یک حرف الفبایی باشد و بخشی از یک کلمه نباشد، True برگرداند و در غیر این صورت False.\nتوجه: \"کلمه\" یک گروه از حروف جدا شده توسط فاصله است.\n\n    مثال ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"تابعی بسازید که بزرگترین شاخص یک عنصر را که بزرگتر یا مساوی عنصر قبلی آن نیست، برگرداند. اگر چنین عنصری وجود نداشته باشد، -1 را برگردانید. آرایه داده شده شامل مقادیر تکراری نخواهد بود.\n\n    مثال ها:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "تابعی بسازید که بزرگترین شاخص یک عنصر را که بزرگتر یا مساوی عنصر قبلی آن نیست، برگرداند. اگر چنین عنصری وجود نداشته باشد، -1 را برگردانید. آرایه داده شده شامل مقادیر تکراری نخواهد بود.\n\n    مثال ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    تابعی بسازید که یک تاپل (a، b) را برمی گرداند، جایی که 'a' بزرگترین اعداد منفی و 'b' کوچکترین اعداد مثبت در یک لیست است. اگر هیچ عدد منفی یا مثبتی وجود نداشته باشد، آنها را به عنوان None برگردانید.\n\n    مثال ها:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "تابعی بسازید که یک تاپل (a، b) را برمی گرداند، جایی که 'a' بزرگترین اعداد منفی و 'b' کوچکترین اعداد مثبت در یک لیست است. اگر هیچ عدد منفی یا مثبتی وجود نداشته باشد، آنها را به عنوان None برگردانید.\n\n    مثال ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"فاکتوریل برزیلی به شکل زیر تعریف می‌شود:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    که در آن n > 0\n\n        به عنوان مثال:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "فاکتوریل برزیلی به شکل زیر تعریف می‌شود:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    که در آن n > 0\n\n        به عنوان مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    شما یک رشته به عنوان جمله دریافت می‌کنید،\n    جمله شامل برخی کلمات جدا شده با یک فضا است،\n    و شما باید یک رشته برگردانید که شامل کلمات از جمله اصلی باشد،\n    که طول آن‌ها اعداد اول هستند،\n    ترتیب کلمات در رشته جدید باید همانند اصلی باشد.\n\n        مثال ۱:\n        ورودی: جمله = \"This is a test\"\n        خروجی: \"is\"\n\n        مثال ۲:\n        ورودی: جمله = \"lets go for swimming\"\n        خروجی: \"go for\"\n\n        محدودیت‌ها:\n        * ۱ <= len(sentence) <= ۱۰۰\n        * جمله فقط شامل حروف است.\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "شما یک رشته به عنوان جمله دریافت می‌کنید،\n    جمله شامل برخی کلمات جدا شده با یک فضا است،\n    و شما باید یک رشته برگردانید که شامل کلمات از جمله اصلی باشد،\n    که طول آن‌ها اعداد اول هستند،\n    ترتیب کلمات در رشته جدید باید همانند اصلی باشد.\n\n        مثال ۱:\n        ورودی: جمله = \"This is a test\"\n        خروجی: \"is\"\n\n        مثال ۲:\n        ورودی: جمله = \"lets go for swimming\"\n        خروجی: \"go for\"\n\n        محدودیت‌ها:\n        * ۱ <= len(sentence) <= ۱۰۰\n        * جمله فقط شامل حروف است.\n    ", "natural_language": "Persian"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"وظیفه شما پیاده سازی یک تابع است که عبارت x * n را ساده سازی می کند. اگر x * n به یک عدد صحیح تبدیل شود، تابع True را برمی گرداند و در غیر این صورت False. هر دو x و n، نمایش رشته ای یک کسر هستند و فرمت آنها به شرح زیر است، <شمارنده>/<مخرج> که هر دو شمارنده و مخرج اعداد صحیح مثبت هستند.\n\n    می توانید فرض کنید که x و n کسرهای معتبری هستند و صفر به عنوان مخرج ندارند.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "وظیفه شما پیاده سازی یک تابع است که عبارت x * n را ساده سازی می کند. اگر x * n به یک عدد صحیح تبدیل شود، تابع True را برمی گرداند و در غیر این صورت False. هر دو x و n، نمایش رشته ای یک کسر هستند و فرمت آنها به شرح زیر است، <شمارنده>/<مخرج> که هر دو شمارنده و مخرج اعداد صحیح مثبت هستند.\n\n    می توانید فرض کنید که x و n کسرهای معتبری هستند و صفر به عنوان مخرج ندارند.\n    ", "natural_language": "Persian"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    یک تابع بنویسید که لیست داده شده از اعداد صحیح را بر اساس مجموع ارقام آنها به ترتیب صعودی مرتب کند. توجه: اگر چند مورد با مجموع مشابه از ارقام آنها وجود داشته باشد، آنها را بر اساس شاخص آنها در لیست اصلی مرتب کنید.\n\n        به عنوان مثال:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "یک تابع بنویسید که لیست داده شده از اعداد صحیح را بر اساس مجموع ارقام آنها به ترتیب صعودی مرتب کند. توجه: اگر چند مورد با مجموع مشابه از ارقام آنها وجود داشته باشد، آنها را بر اساس شاخص آنها در لیست اصلی مرتب کنید.\n\n        به عنوان مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"یک تابع بنویسید که یک آرایه از اعداد را به عنوان ورودی دریافت کرده و تعداد عناصر آرایه را که بزرگتر از 10 هستند و هر دو رقم اول و آخر یک عدد فرد هستند (1، 3، 5، 7، 9) برمی گرداند. به عنوان مثال:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "یک تابع بنویسید که یک آرایه از اعداد را به عنوان ورودی دریافت کرده و تعداد عناصر آرایه را که بزرگتر از 10 هستند و هر دو رقم اول و آخر یک عدد فرد هستند (1، 3، 5، 7، 9) برمی گرداند. به عنوان مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    شما یک عدد صحیح مثبت n داده شده است. شما باید یک آرایه صحیح a با طول n ایجاد کنید.\n        برای هر i (1 ≤ i ≤ n)، مقدار a[i] = i * i - i + 1 است.\n        تعداد سه تایی (a[i]، a[j]، a[k]) از a را که i < j < k و a[i] + a[j] + a[k] بخشی از 3 است، برگردانید.\n\n        مثال:\n        ورودی: n = 5\n        خروجی: 1\n        توضیحات:\n        a = [1، 3، 7، 13، 21]\n        تنها سه تایی معتبر (1، 7، 13) است.\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "شما یک عدد صحیح مثبت n داده شده است. شما باید یک آرایه صحیح a با طول n ایجاد کنید.\n        برای هر i (1 ≤ i ≤ n)، مقدار a[i] = i * i - i + 1 است.\n        تعداد سه تایی (a[i]، a[j]، a[k]) از a را که i < j < k و a[i] + a[j] + a[k] بخشی از 3 است، برگردانید.\n\n        مثال:\n        ورودی: n = 5\n        خروجی: 1\n        توضیحات:\n        a = [1، 3، 7، 13، 21]\n        تنها سه تایی معتبر (1، 7، 13) است.\n    ", "natural_language": "Persian"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    در سیستم شمسی ما هشت سیاره وجود دارد: نزدیک‌ترین سیاره به خورشید \n    مریخ است، سپس ونوس، زمین، مریخ، مشتری، زحل، \n    اورانوس و نپتون.\n    یک تابع بنویسید که دو نام سیاره به عنوان رشته‌های planet1 و planet2 را دریافت کند. \n    تابع باید یک تاپل حاوی تمام سیاره‌هایی که مدار آن‌ها بین مدار سیاره 1 و مدار سیاره 2 قرار دارد را برگرداند، مرتب شده بر اساس نزدیکی به خورشید. \n    اگر planet1 یا planet2 نام سیاره صحیح نباشد، تابع باید یک تاپل خالی برگرداند. \n    مثال‌ها:\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "در سیستم شمسی ما هشت سیاره وجود دارد: نزدیک‌ترین سیاره به خورشید \n    مریخ است، سپس ونوس، زمین، مریخ، مشتری، زحل، \n    اورانوس و نپتون.\n    یک تابع بنویسید که دو نام سیاره به عنوان رشته‌های planet1 و planet2 را دریافت کند. \n    تابع باید یک تاپل حاوی تمام سیاره‌هایی که مدار آن‌ها بین مدار سیاره 1 و مدار سیاره 2 قرار دارد را برگرداند، مرتب شده بر اساس نزدیکی به خورشید. \n    اگر planet1 یا planet2 نام سیاره صحیح نباشد، تابع باید یک تاپل خالی برگرداند. \n    مثال‌ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"یک برنامه ساده که باید مقدار x را برگرداند اگر n یک عدد اول باشد و در غیر این صورت باید مقدار y را برگرداند.\n\n        مثال ها:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "یک برنامه ساده که باید مقدار x را برگرداند اگر n یک عدد اول باشد و در غیر این صورت باید مقدار y را برگرداند.\n\n        مثال ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    با دادن یک لیست از اعداد، مجموع مربعات اعداد فرد در لیست را برگردانید. اعداد منفی یا غیرصحیح را نادیده بگیرید.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0\n\n    اگر لیست ورودی خالی باشد، 0 را برگردانید.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "با دادن یک لیست از اعداد، مجموع مربعات اعداد فرد در لیست را برگردانید. اعداد منفی یا غیرصحیح را نادیده بگیرید.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0\n\n    اگر لیست ورودی خالی باشد، 0 را برگردانید.\n    ", "natural_language": "Persian"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"شما نام یک کلاس (رشته ای) و یک لیست از افزونه ها را دریافت خواهید کرد.\n    افزونه ها برای بارگذاری کلاس های اضافی به کلاس استفاده می شوند. قدرت افزونه به شرح زیر است: CAP شماره حروف بزرگ در نام افزونه باشد و SM شماره حروف کوچک در نام افزونه باشد، قدرت با کسر CAP - SM داده می شود.\n    شما باید قوی ترین افزونه را پیدا کرده و یک رشته در این بازه برگردانید: ClassName.StrongestExtensionName.\n    اگر دو یا بیشتر از دو افزونه با قدرت یکسان وجود داشته باشد، باید آن را انتخاب کنید که اولین در لیست باشد.\n    به عنوان مثال، اگر به عنوان کلاس \"Slices\" و لیستی از افزونه ها را به شما داده شود: ['SErviNGSliCes', 'Cheese', 'StuFfed'] ، باید 'Slices.SErviNGSliCes' را برگردانید زیرا 'SErviNGSliCes' قوی ترین افزونه است (قدرت آن -1 است).\n    مثال:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "شما نام یک کلاس (رشته ای) و یک لیست از افزونه ها را دریافت خواهید کرد.\n    افزونه ها برای بارگذاری کلاس های اضافی به کلاس استفاده می شوند. قدرت افزونه به شرح زیر است: CAP شماره حروف بزرگ در نام افزونه باشد و SM شماره حروف کوچک در نام افزونه باشد، قدرت با کسر CAP - SM داده می شود.\n    شما باید قوی ترین افزونه را پیدا کرده و یک رشته در این بازه برگردانید: ClassName.StrongestExtensionName.\n    اگر دو یا بیشتر از دو افزونه با قدرت یکسان وجود داشته باشد، باید آن را انتخاب کنید که اولین در لیست باشد.\n    به عنوان مثال، اگر به عنوان کلاس \"Slices\" و لیستی از افزونه ها را به شما داده شود: ['SErviNGSliCes', 'Cheese', 'StuFfed'] ، باید 'Slices.SErviNGSliCes' را برگردانید زیرا 'SErviNGSliCes' قوی ترین افزونه است (قدرت آن -1 است).\n    مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"شما دو کلمه داده شده است. شما باید در صورتی که کلمه دوم یا هر یک از چرخش های آن به عنوان زیررشته در کلمه اول وجود داشته باشد، True را برگردانید.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "شما دو کلمه داده شده است. شما باید در صورتی که کلمه دوم یا هر یک از چرخش های آن به عنوان زیررشته در کلمه اول وجود داشته باشد، True را برگردانید.\n    ", "natural_language": "Persian"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    با دریافت یک عدد مثبت، معادل عدد رومی آن را به صورت رشته‌ای بدست آورده، و آن را به حروف کوچک برگردانید.\nمحدودیت‌ها: 1 <= num <= 1000\n\n    مثال‌ها:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "با دریافت یک عدد مثبت، معادل عدد رومی آن را به صورت رشته‌ای بدست آورده، و آن را به حروف کوچک برگردانید.\nمحدودیت‌ها: 1 <= num <= 1000\n\n    مثال‌ها:\n    ", "natural_language": "Persian"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    با توجه به طول سه ضلع مثلث، اگر سه ضلع یک مثلث قائم‌الزاویه را تشکیل دهند، True برگردانده شود و در غیر این صورت False. یک مثلث قائم‌الزاویه، مثلثی است که یکی از زوایای آن زاویه قائمه یا ۹۰ درجه است. مثال:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "با توجه به طول سه ضلع مثلث، اگر سه ضلع یک مثلث قائم‌الزاویه را تشکیل دهند، True برگردانده شود و در غیر این صورت False. یک مثلث قائم‌الزاویه، مثلثی است که یکی از زوایای آن زاویه قائمه یا ۹۰ درجه است. مثال:\n    ", "natural_language": "Persian"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"شما یک رشته s دریافت می‌کنید.\n    اگر s[i] یک حرف باشد، حالت آن را از کوچک به بزرگ یا برعکس تغییر دهید،\n    در غیر این صورت آن را به عنوان آن باقی بگذارید.\n    اگر رشته حاوی هیچ حرفی نباشد، رشته را برعکس کنید.\n    تابع باید رشته حاصل را برگرداند.\n    مثالها\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "شما یک رشته s دریافت می‌کنید.\n    اگر s[i] یک حرف باشد، حالت آن را از کوچک به بزرگ یا برعکس تغییر دهید،\n    در غیر این صورت آن را به عنوان آن باقی بگذارید.\n    اگر رشته حاوی هیچ حرفی نباشد، رشته را برعکس کنید.\n    تابع باید رشته حاصل را برگرداند.\n    مثالها\n    ", "natural_language": "Persian"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    با دادن یک رشته 'text'، رشته معادل هش md5 آن را برگردانید. اگر 'text' یک رشته خالی است، null را برگردانید.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "با دادن یک رشته 'text'، رشته معادل هش md5 آن را برگردانید. اگر 'text' یک رشته خالی است، null را برگردانید.\n    ", "natural_language": "Persian"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    با داشتن دو عدد مثبت a و b، ارقام زوج بین a و b را به ترتیب صعودی برگردانید.\n\n        به عنوان مثال:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "با داشتن دو عدد مثبت a و b، ارقام زوج بین a و b را به ترتیب صعودی برگردانید.\n\n        به عنوان مثال:\n    ", "natural_language": "Persian"}
