{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con un saldo de cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y en ese punto la función debe devolver Verdadero. De lo contrario, debe devolver Falso.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con un saldo de cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y en ese punto la función debe devolver Verdadero. De lo contrario, debe devolver Falso.\n    ", "natural_language": "Spanish"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Para una lista dada de enteros, devuelve una tupla que consiste en la suma y el producto de todos los enteros en la lista.\n    La suma vacía debe ser igual a 0 y el producto vacío debe ser igual a 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Para una lista dada de enteros, devuelve una tupla que consiste en la suma y el producto de todos los enteros en la lista.\n    La suma vacía debe ser igual a 0 y el producto vacío debe ser igual a 1.\n    ", "natural_language": "Spanish"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" La entrada son dos cadenas a y b que consisten solo en 1s y 0s.\nRealice una operación XOR binaria en estas entradas y devuelva el resultado también como una cadena.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "La entrada son dos cadenas a y b que consisten solo en 1s y 0s.\nRealice una operación XOR binaria en estas entradas y devuelva el resultado también como una cadena.\n    ", "natural_language": "Spanish"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" De una lista de cadenas, devuelve la más larga. Devuelve la primera en caso de múltiples cadenas de la misma longitud. Devuelve nulo en caso de que la lista de entrada esté vacía.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "De una lista de cadenas, devuelve la más larga. Devuelve la primera en caso de múltiples cadenas de la misma longitud. Devuelve nulo en caso de que la lista de entrada esté vacía.\n    ", "natural_language": "Spanish"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Devuelve el máximo común divisor de dos enteros a y b.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Devuelve el máximo común divisor de dos enteros a y b.\n    ", "natural_language": "Spanish"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" La entrada es una cadena de números separados por espacios que van desde 'cero' hasta 'nueve'.\nLas opciones válidas son 'cero', 'uno', 'dos', 'tres', 'cuatro', 'cinco', 'seis', 'siete', 'ocho' y 'nueve'.\nDevuelve la cadena con los números ordenados de menor a mayor.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "La entrada es una cadena de números separados por espacios que van desde 'cero' hasta 'nueve'.\nLas opciones válidas son 'cero', 'uno', 'dos', 'tres', 'cuatro', 'cinco', 'seis', 'siete', 'ocho' y 'nueve'.\nDevuelve la cadena con los números ordenados de menor a mayor.\n    ", "natural_language": "Spanish"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Dada una lista de números (de al menos dos elementos), aplicar una transformación lineal a esa lista, de tal manera que el número más pequeño se convierta en 0 y el más grande en 1.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Dada una lista de números (de al menos dos elementos), aplicar una transformación lineal a esa lista, de tal manera que el número más pequeño se convierta en 0 y el más grande en 1.\n    ", "natural_language": "Spanish"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Para una cadena dada, invertir los caracteres en minúscula a mayúscula y los caracteres en mayúscula a minúscula.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Para una cadena dada, invertir los caracteres en minúscula a mayúscula y los caracteres en mayúscula a minúscula.\n    ", "natural_language": "Spanish"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Devolver solo números positivos en la lista.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Devolver solo números positivos en la lista.\n    ", "natural_language": "Spanish"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Devuelve verdadero si un número dado es primo, y falso en caso contrario.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Devuelve verdadero si un número dado es primo, y falso en caso contrario.\n    ", "natural_language": "Spanish"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Devolver los elementos únicos ordenados de una lista.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Devolver los elementos únicos ordenados de una lista.\n    ", "natural_language": "Spanish"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib devuelve el número n-ésimo que es un número de Fibonacci y también es primo.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib devuelve el número n-ésimo que es un número de Fibonacci y también es primo.\n    ", "natural_language": "Spanish"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero toma una lista de enteros como entrada. Devuelve True si hay tres elementos distintos en la lista que suman cero, y False en caso contrario.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "triples_sum_to_zero toma una lista de enteros como entrada. Devuelve True si hay tres elementos distintos en la lista que suman cero, y False en caso contrario.\n    ", "natural_language": "Spanish"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    La función pairs_sum_to_zero toma una lista de enteros como entrada. Devuelve True si hay dos elementos distintos en la lista que suman cero, y False en caso contrario.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "La función pairs_sum_to_zero toma una lista de enteros como entrada. Devuelve True si hay dos elementos distintos en la lista que suman cero, y False en caso contrario.\n    ", "natural_language": "Spanish"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"La secuencia de números Fib4 es una secuencia similar a la secuencia de Fibonacci que se define de la siguiente manera:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Por favor, escriba una función para calcular eficientemente el n-ésimo elemento de la secuencia de números fib4. No utilice la recursión.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "La secuencia de números Fib4 es una secuencia similar a la secuencia de Fibonacci que se define de la siguiente manera:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Por favor, escriba una función para calcular eficientemente el n-ésimo elemento de la secuencia de números fib4. No utilice la recursión.\n    ", "natural_language": "Spanish"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Devuelve la mediana de los elementos en la lista l.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Devuelve la mediana de los elementos en la lista l.\n    ", "natural_language": "Spanish"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Verifica si la cadena dada es un palíndromo.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Verifica si la cadena dada es un palíndromo.\n    ", "natural_language": "Spanish"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels es una función que toma una cadena y devuelve una cadena sin vocales.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels es una función que toma una cadena y devuelve una cadena sin vocales.\n    ", "natural_language": "Spanish"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Devuelve Verdadero si todos los números en la lista l están por debajo del umbral t.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Devuelve Verdadero si todos los números en la lista l están por debajo del umbral t.\n    ", "natural_language": "Spanish"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Sumar dos números x e y.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Sumar dos números x e y.\n    ", "natural_language": "Spanish"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Comprueba si dos palabras tienen los mismos caracteres.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Comprueba si dos palabras tienen los mismos caracteres.\n    ", "natural_language": "Spanish"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Devolver el n-ésimo número de Fibonacci.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Devolver el n-ésimo número de Fibonacci.\n    ", "natural_language": "Spanish"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Devolver los elementos comunes únicos ordenados para dos listas.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Devolver los elementos comunes únicos ordenados para dos listas.\n    ", "natural_language": "Spanish"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Devuelve el factor primo más grande de n. Suponga que n > 1 y no es un número primo.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Devuelve el factor primo más grande de n. Suponga que n > 1 y no es un número primo.\n    ", "natural_language": "Spanish"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n es una función que suma números del 1 al n.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n es una función que suma números del 1 al n.\n    ", "natural_language": "Spanish"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs representa los coeficientes de un polinomio.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Devuelve la derivada de este polinomio en la misma forma.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs representa los coeficientes de un polinomio.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Devuelve la derivada de este polinomio en la misma forma.\n    ", "natural_language": "Spanish"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"La secuencia de números FibFib es una secuencia similar a la secuencia de Fibonacci que se define de la siguiente manera:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Por favor, escriba una función para calcular eficientemente el n-ésimo elemento de la secuencia de números FibFib.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "La secuencia de números FibFib es una secuencia similar a la secuencia de Fibonacci que se define de la siguiente manera:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Por favor, escriba una función para calcular eficientemente el n-ésimo elemento de la secuencia de números FibFib.\n    ", "natural_language": "Spanish"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Escriba una función vowels_count que tome como entrada una cadena que representa una palabra y devuelva el número de vocales en la cadena. Las vocales en este caso son 'a', 'e', 'i', 'o', 'u'. Aquí, 'y' también es una vocal, pero solo cuando está al final de la palabra dada.\n\n    Ejemplo:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Escriba una función vowels_count que tome como entrada una cadena que representa una palabra y devuelva el número de vocales en la cadena. Las vocales en este caso son 'a', 'e', 'i', 'o', 'u'. Aquí, 'y' también es una vocal, pero solo cuando está al final de la palabra dada.\n\n    Ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Se te da una lista no vacía de enteros positivos. Devuelve el entero más grande que sea mayor que cero y tenga una frecuencia mayor o igual al valor del propio entero. La frecuencia de un entero es el número de veces que aparece en la lista. Si no existe tal valor, devuelve -1. Ejemplos:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Se te da una lista no vacía de enteros positivos. Devuelve el entero más grande que sea mayor que cero y tenga una frecuencia mayor o igual al valor del propio entero. La frecuencia de un entero es el número de veces que aparece en la lista. Si no existe tal valor, devuelve -1. Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Dado las longitudes de los tres lados de un triángulo. Devuelve el área del triángulo redondeada a 2 decimales si los tres lados forman un triángulo válido. De lo contrario, devuelve -1. Tres lados forman un triángulo válido cuando la suma de cualquier par de lados es mayor que el tercer lado. Ejemplo:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Dado las longitudes de los tres lados de un triángulo. Devuelve el área del triángulo redondeada a 2 decimales si los tres lados forman un triángulo válido. De lo contrario, devuelve -1. Tres lados forman un triángulo válido cuando la suma de cualquier par de lados es mayor que el tercer lado. Ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Escriba una función que devuelva True si el objeto q volará, y False de lo contrario.\nEl objeto q volará si está equilibrado (es una lista palindrómica) y la suma de sus elementos es menor o igual al peso máximo posible w.\n\n    Ejemplo:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 es menor que el peso máximo posible, pero está desequilibrado.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# está equilibrado, pero 3+2+3 es más que el peso máximo posible.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 es menor que el peso máximo posible, y está equilibrado.\n\n    will_it_fly([3], 5) ➞ True\n# 3 es menor que el peso máximo posible, y está equilibrado.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Escriba una función que devuelva True si el objeto q volará, y False de lo contrario.\nEl objeto q volará si está equilibrado (es una lista palindrómica) y la suma de sus elementos es menor o igual al peso máximo posible w.\n\n    Ejemplo:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 es menor que el peso máximo posible, pero está desequilibrado.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# está equilibrado, pero 3+2+3 es más que el peso máximo posible.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 es menor que el peso máximo posible, y está equilibrado.\n\n    will_it_fly([3], 5) ➞ True\n# 3 es menor que el peso máximo posible, y está equilibrado.\n    ", "natural_language": "Spanish"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Escriba una función que devuelva verdadero si el número dado es la multiplicación de 3 números primos y falso en caso contrario. Sabiendo que (a) es menor que 100. Ejemplo:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Escriba una función que devuelva verdadero si el número dado es la multiplicación de 3 números primos y falso en caso contrario. Sabiendo que (a) es menor que 100. Ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Se le dará un número en forma decimal y su tarea es convertirlo a formato binario. La función debe devolver una cadena, donde cada carácter representa un número binario. Cada carácter en la cadena será '0' o '1'.\n\n    Habrá un par de caracteres adicionales 'db' al principio y al final de la cadena. Los caracteres adicionales están ahí para ayudar con el formato.\n\n    Ejemplos:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Se le dará un número en forma decimal y su tarea es convertirlo a formato binario. La función debe devolver una cadena, donde cada carácter representa un número binario. Cada carácter en la cadena será '0' o '1'.\n\n    Habrá un par de caracteres adicionales 'db' al principio y al final de la cadena. Los caracteres adicionales están ahí para ayudar con el formato.\n\n    Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Se te da una cadena s.\n    Tu tarea es verificar si la cadena es feliz o no.\n    Una cadena es feliz si su longitud es al menos 3 y cada 3 letras consecutivas son distintas.\n    Por ejemplo:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Se te da una cadena s.\n    Tu tarea es verificar si la cadena es feliz o no.\n    Una cadena es feliz si su longitud es al menos 3 y cada 3 letras consecutivas son distintas.\n    Por ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Es la última semana del semestre y el profesor tiene que dar las calificaciones a los estudiantes. El profesor ha estado creando su propio algoritmo para calificar. El único problema es que ha perdido el código que usó para calificar. Te ha dado una lista de GPAs de algunos estudiantes y tienes que escribir una función que pueda producir una lista de calificaciones de letras utilizando la siguiente tabla:\n\n                 GPA       |    Calificación de letra\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Ejemplo:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "Es la última semana del semestre y el profesor tiene que dar las calificaciones a los estudiantes. El profesor ha estado creando su propio algoritmo para calificar. El único problema es que ha perdido el código que usó para calificar. Te ha dado una lista de GPAs de algunos estudiantes y tienes que escribir una función que pueda producir una lista de calificaciones de letras utilizando la siguiente tabla:\n\n                 GPA       |    Calificación de letra\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Escriba una función que tome una cadena y devuelva True si la longitud de la cadena es un número primo o False de lo contrario.\nEjemplos\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Escriba una función que tome una cadena y devuelva True si la longitud de la cadena es un número primo o False de lo contrario.\nEjemplos\n    ", "natural_language": "Spanish"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Dado un número entero positivo N, devuelve la suma total de sus dígitos en binario.\n\n    Ejemplo:\n    Para N = 1000, la suma de los dígitos será 1 y la salida debería ser \"1\".\n    Para N = 150, la suma de los dígitos será 6 y la salida debería ser \"110\".\n    Para N = 147, la suma de los dígitos será 12 y la salida debería ser \"1100\".\n\n    Variables:\n    @N entero\n         Restricciones: 0 ≤ N ≤ 10000.\nSalida:\n     una cadena de número binario.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Dado un número entero positivo N, devuelve la suma total de sus dígitos en binario.\n\n    Ejemplo:\n    Para N = 1000, la suma de los dígitos será 1 y la salida debería ser \"1\".\n    Para N = 150, la suma de los dígitos será 6 y la salida debería ser \"110\".\n    Para N = 147, la suma de los dígitos será 12 y la salida debería ser \"1100\".\n\n    Variables:\n    @N entero\n         Restricciones: 0 ≤ N ≤ 10000.\nSalida:\n     una cadena de número binario.\n    ", "natural_language": "Spanish"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Se le proporciona un conjunto de datos bidimensional, como listas anidadas, que es similar a una matriz, sin embargo, a diferencia de las matrices, cada fila puede contener un número diferente de columnas. Dado lst y un entero x, encuentre enteros x en la lista y devuelva una lista de tuplas, [(x1, y1), (x2, y2) ...] de tal manera que cada tupla sea una coordenada - (fila, columnas), comenzando con 0. Ordene las coordenadas inicialmente por filas en orden ascendente. Además, ordene las coordenadas de la fila por columnas en orden descendente.\n\n    Ejemplos:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Se le proporciona un conjunto de datos bidimensional, como listas anidadas, que es similar a una matriz, sin embargo, a diferencia de las matrices, cada fila puede contener un número diferente de columnas. Dado lst y un entero x, encuentre enteros x en la lista y devuelva una lista de tuplas, [(x1, y1), (x2, y2) ...] de tal manera que cada tupla sea una coordenada - (fila, columnas), comenzando con 0. Ordene las coordenadas inicialmente por filas en orden ascendente. Además, ordene las coordenadas de la fila por columnas en orden descendente.\n\n    Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Se te da una lista de enteros.\nEscribe una función next_smallest() que devuelva el segundo elemento más pequeño de la lista.\nDevuelve null si no hay tal elemento.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Se te da una lista de enteros.\nEscribe una función next_smallest() que devuelva el segundo elemento más pequeño de la lista.\nDevuelve null si no hay tal elemento.\n    ", "natural_language": "Spanish"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Se te dará una cadena de palabras y tu tarea es contar el número de aburrimientos. Un aburrimiento es una oración que comienza con la palabra \"Yo\". Las oraciones están delimitadas por '.', '?' o '!'.\n\n    Por ejemplo:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Se te dará una cadena de palabras y tu tarea es contar el número de aburrimientos. Un aburrimiento es una oración que comienza con la palabra \"Yo\". Las oraciones están delimitadas por '.', '?' o '!'.\n\n    Por ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Se te da una lista de enteros.\n    Necesitas encontrar el valor primo más grande y devolver la suma de sus dígitos.\n\n        Ejemplos:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Se te da una lista de enteros.\n    Necesitas encontrar el valor primo más grande y devolver la suma de sus dígitos.\n\n        Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Dado un diccionario, devuelve True si todas las claves son cadenas en minúsculas o todas las claves son cadenas en mayúsculas, de lo contrario devuelve False. La función debe devolver False si el diccionario dado está vacío. Ejemplos:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Dado un diccionario, devuelve True si todas las claves son cadenas en minúsculas o todas las claves son cadenas en mayúsculas, de lo contrario devuelve False. La función debe devolver False si el diccionario dado está vacío. Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Crea una función que tome un valor (cadena) que representa un número y devuelva el entero más cercano. Si el número está equidistante de dos enteros, redondea hacia arriba.\n\n    Ejemplos:\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Crea una función que tome un valor (cadena) que representa un número y devuelva el entero más cercano. Si el número está equidistante de dos enteros, redondea hacia arriba.\n\n    Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Dado un número entero positivo n, debes hacer una pila de n niveles de piedras.\n    El primer nivel tiene n piedras.\n    El número de piedras en el siguiente nivel es:\n        - el siguiente número impar si n es impar.\n        - el siguiente número par si n es par.\n    Devuelve el número de piedras en cada nivel en una lista, donde el elemento en el índice\n    i representa el número de piedras en el nivel (i+1).\n\n        Ejemplos:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Dado un número entero positivo n, debes hacer una pila de n niveles de piedras.\n    El primer nivel tiene n piedras.\n    El número de piedras en el siguiente nivel es:\n        - el siguiente número impar si n es impar.\n        - el siguiente número par si n es par.\n    Devuelve el número de piedras en cada nivel en una lista, donde el elemento en el índice\n    i representa el número de piedras en el nivel (i+1).\n\n        Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Se le dará una cadena de palabras separadas por comas o espacios. Su tarea es dividir la cadena en palabras y devolver un arreglo de las palabras.\n\n    Por ejemplo:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Se le dará una cadena de palabras separadas por comas o espacios. Su tarea es dividir la cadena en palabras y devolver un arreglo de las palabras.\n\n    Por ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Esta función toma dos números positivos x e y y devuelve el número entero par más grande que se encuentra en el rango [x, y] inclusive. Si no hay tal número, entonces la función debe devolver -1.\n\n    Por ejemplo:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Esta función toma dos números positivos x e y y devuelve el número entero par más grande que se encuentra en el rango [x, y] inclusive. Si no hay tal número, entonces la función debe devolver -1.\n\n    Por ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Se te dan dos enteros positivos n y m, y tu tarea es calcular el promedio de los enteros desde n hasta m (incluyendo n y m). Redondea la respuesta al entero más cercano y conviértelo a binario. Si n es mayor que m, devuelve -1. Ejemplo:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Se te dan dos enteros positivos n y m, y tu tarea es calcular el promedio de los enteros desde n hasta m (incluyendo n y m). Redondea la respuesta al entero más cercano y conviértelo a binario. Si n es mayor que m, devuelve -1. Ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Implemente la función f que toma n como parámetro y devuelve una lista de tamaño n, tal que el valor del elemento en el índice i es el factorial de i si i es par o la suma de los números del 1 al i en caso contrario. i comienza en 1. El factorial de i es la multiplicación de los números del 1 al i (1 * 2 * ... * i). Ejemplo:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Implemente la función f que toma n como parámetro y devuelve una lista de tamaño n, tal que el valor del elemento en el índice i es el factorial de i si i es par o la suma de los números del 1 al i en caso contrario. i comienza en 1. El factorial de i es la multiplicación de los números del 1 al i (1 * 2 * ... * i). Ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Dado un número entero positivo n, devuelve una tupla que tiene el número de palíndromos enteros pares e impares que caen dentro del rango (1, n), inclusive.\n\n        Ejemplo 1:\n\n            Entrada: 3\n        Salida: (1, 2)\n        Explicación:\n        Los palíndromos enteros son 1, 2, 3. Uno de ellos es par y dos son impares.\n\n        Ejemplo 2:\n\n            Entrada: 12\n        Salida: (4, 6)\n        Explicación:\n        Los palíndromos enteros son 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Cuatro de ellos son pares y seis son impares.\n\n        Nota:\n        1. 1 <= n <= 10^3\n        2. La tupla devuelta tiene el número de palíndromos enteros pares e impares respectivamente.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Dado un número entero positivo n, devuelve una tupla que tiene el número de palíndromos enteros pares e impares que caen dentro del rango (1, n), inclusive.\n\n        Ejemplo 1:\n\n            Entrada: 3\n        Salida: (1, 2)\n        Explicación:\n        Los palíndromos enteros son 1, 2, 3. Uno de ellos es par y dos son impares.\n\n        Ejemplo 2:\n\n            Entrada: 12\n        Salida: (4, 6)\n        Explicación:\n        Los palíndromos enteros son 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Cuatro de ellos son pares y seis son impares.\n\n        Nota:\n        1. 1 <= n <= 10^3\n        2. La tupla devuelta tiene el número de palíndromos enteros pares e impares respectivamente.\n    ", "natural_language": "Spanish"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Tenemos un arreglo 'arr' de N enteros arr[1], arr[2], ..., arr[N]. Los números en el arreglo estarán ordenados al azar. Su tarea es determinar si es posible obtener un arreglo ordenado en orden no decreciente realizando la siguiente operación en el arreglo dado:\n        Se permite realizar la operación de desplazamiento hacia la derecha cualquier número de veces.\n    \n    Una operación de desplazamiento hacia la derecha significa desplazar todos los elementos del arreglo una posición hacia la derecha. El último elemento del arreglo se moverá a la posición de inicio en el arreglo, es decir, el índice 0.\n\n        Si es posible obtener el arreglo ordenado realizando la operación anterior, devuelva True, de lo contrario, devuelva False.\n    Si el arreglo dado está vacío, devuelva True.\n\n        Nota: Se garantiza que la lista dada tiene elementos únicos.\n\n        Por ejemplo:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explicación: Al realizar 2 operaciones de desplazamiento hacia la derecha, se puede lograr un orden no decreciente para el arreglo dado.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explicación: No es posible obtener un orden no decreciente para el arreglo dado realizando cualquier número de operaciones de desplazamiento hacia la derecha.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Tenemos un arreglo 'arr' de N enteros arr[1], arr[2], ..., arr[N]. Los números en el arreglo estarán ordenados al azar. Su tarea es determinar si es posible obtener un arreglo ordenado en orden no decreciente realizando la siguiente operación en el arreglo dado:\n        Se permite realizar la operación de desplazamiento hacia la derecha cualquier número de veces.\n    \n    Una operación de desplazamiento hacia la derecha significa desplazar todos los elementos del arreglo una posición hacia la derecha. El último elemento del arreglo se moverá a la posición de inicio en el arreglo, es decir, el índice 0.\n\n        Si es posible obtener el arreglo ordenado realizando la operación anterior, devuelva True, de lo contrario, devuelva False.\n    Si el arreglo dado está vacío, devuelva True.\n\n        Nota: Se garantiza que la lista dada tiene elementos únicos.\n\n        Por ejemplo:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explicación: Al realizar 2 operaciones de desplazamiento hacia la derecha, se puede lograr un orden no decreciente para el arreglo dado.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explicación: No es posible obtener un orden no decreciente para el arreglo dado realizando cualquier número de operaciones de desplazamiento hacia la derecha.\n    ", "natural_language": "Spanish"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"En este problema, implementarás una función que tome dos listas de números y determine si es posible realizar un intercambio de elementos entre ellas para hacer que lst1 sea una lista de solo números pares. No hay límite en el número de elementos intercambiados entre lst1 y lst2. Si es posible intercambiar elementos entre lst1 y lst2 para hacer que todos los elementos de lst1 sean pares, devuelve \"SI\". De lo contrario, devuelve \"NO\". Por ejemplo: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"SI\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Se asume que las listas de entrada no estarán vacías.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "En este problema, implementarás una función que tome dos listas de números y determine si es posible realizar un intercambio de elementos entre ellas para hacer que lst1 sea una lista de solo números pares. No hay límite en el número de elementos intercambiados entre lst1 y lst2. Si es posible intercambiar elementos entre lst1 y lst2 para hacer que todos los elementos de lst1 sean pares, devuelve \"SI\". De lo contrario, devuelve \"NO\". Por ejemplo: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"SI\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Se asume que las listas de entrada no estarán vacías.\n    ", "natural_language": "Spanish"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Tarea\n    Se nos dan dos cadenas s y c, debes eliminar todos los caracteres en s que sean iguales a cualquier carácter en c\n    luego verificar si la cadena resultante es un palíndromo.\n    Una cadena se llama palíndromo si se lee igual de atrás hacia adelante.\n    Debes devolver una tupla que contenga la cadena resultante y True/False para la verificación.\n    Ejemplo\n    Para s = \"abcde\", c = \"ae\", el resultado debería ser ('bcd',False)\n    Para s = \"abcdef\", c = \"b\"  el resultado debería ser ('acdef',False)\n    Para s = \"abcdedcba\", c = \"ab\", el resultado debería ser ('cdedc',True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Tarea\n    Se nos dan dos cadenas s y c, debes eliminar todos los caracteres en s que sean iguales a cualquier carácter en c\n    luego verificar si la cadena resultante es un palíndromo.\n    Una cadena se llama palíndromo si se lee igual de atrás hacia adelante.\n    Debes devolver una tupla que contenga la cadena resultante y True/False para la verificación.\n    Ejemplo\n    Para s = \"abcde\", c = \"ae\", el resultado debería ser ('bcd',False)\n    Para s = \"abcdef\", c = \"b\"  el resultado debería ser ('acdef',False)\n    Para s = \"abcdedcba\", c = \"ab\", el resultado debería ser ('cdedc',True)\n    ", "natural_language": "Spanish"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Se te da una cuadrícula rectangular de pozos. Cada fila representa un solo pozo, y cada 1 en una fila representa una unidad de agua. Cada pozo tiene un cubo correspondiente que se puede usar para extraer agua de él, y todos los cubos tienen la misma capacidad. Tu tarea es usar los cubos para vaciar los pozos. Imprime el número de veces que necesitas bajar los cubos.\n\n    Ejemplo 1:\n    Entrada:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        capacidad_cubo: 1\n    Salida: 6\n\n    Ejemplo 2:\n    Entrada:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        capacidad_cubo: 2\n    Salida: 5\n\n    Ejemplo 3:\n    Entrada:\n        grid: [[0,0,0], [0,0,0]]\n        capacidad_cubo: 5\n    Salida: 0\n\n    Restricciones:\n    * todos los pozos tienen la misma longitud\n    * 1 <= longitud de grid <= 10^2\n    * 1 <= longitud de grid[:,1] <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= capacidad <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Se te da una cuadrícula rectangular de pozos. Cada fila representa un solo pozo, y cada 1 en una fila representa una unidad de agua. Cada pozo tiene un cubo correspondiente que se puede usar para extraer agua de él, y todos los cubos tienen la misma capacidad. Tu tarea es usar los cubos para vaciar los pozos. Imprime el número de veces que necesitas bajar los cubos.\n\n    Ejemplo 1:\n    Entrada:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        capacidad_cubo: 1\n    Salida: 6\n\n    Ejemplo 2:\n    Entrada:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        capacidad_cubo: 2\n    Salida: 5\n\n    Ejemplo 3:\n    Entrada:\n        grid: [[0,0,0], [0,0,0]]\n        capacidad_cubo: 5\n    Salida: 0\n\n    Restricciones:\n    * todos los pozos tienen la misma longitud\n    * 1 <= longitud de grid <= 10^2\n    * 1 <= longitud de grid[:,1] <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= capacidad <= 10\n    ", "natural_language": "Spanish"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Dada una cadena s y un número natural n, se le ha asignado la tarea de implementar una función que devuelva una lista de todas las palabras de la cadena s que contengan exactamente n consonantes, en el orden en que aparecen estas palabras en la cadena s. Si la cadena s está vacía, la función debe devolver una lista vacía. Nota: puede suponer que la cadena de entrada contiene solo letras y espacios. Ejemplos:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Dada una cadena s y un número natural n, se le ha asignado la tarea de implementar una función que devuelva una lista de todas las palabras de la cadena s que contengan exactamente n consonantes, en el orden en que aparecen estas palabras en la cadena s. Si la cadena s está vacía, la función debe devolver una lista vacía. Nota: puede suponer que la cadena de entrada contiene solo letras y espacios. Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Dado un arreglo arr de enteros y un entero positivo k, devuelve una lista ordenada de longitud k con los k números máximos en arr.\n\n        Ejemplo 1:\n\n            Entrada: arr = [-3, -4, 5], k = 3\n        Salida: [-4, -3, 5]\n\n        Ejemplo 2:\n\n            Entrada: arr = [4, -4, 4], k = 2\n        Salida: [4, 4]\n\n        Ejemplo 3:\n\n            Entrada: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Salida: [2]\n\n        Nota:\n        1. La longitud del arreglo estará en el rango de [1, 1000].\n        2. Los elementos en el arreglo estarán en el rango de [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Dado un arreglo arr de enteros y un entero positivo k, devuelve una lista ordenada de longitud k con los k números máximos en arr.\n\n        Ejemplo 1:\n\n            Entrada: arr = [-3, -4, 5], k = 3\n        Salida: [-4, -3, 5]\n\n        Ejemplo 2:\n\n            Entrada: arr = [4, -4, 4], k = 2\n        Salida: [4, 4]\n\n        Ejemplo 3:\n\n            Entrada: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Salida: [2]\n\n        Nota:\n        1. La longitud del arreglo estará en el rango de [1, 1000].\n        2. Los elementos en el arreglo estarán en el rango de [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    ", "natural_language": "Spanish"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Dado un arreglo no vacío de enteros arr y un entero k, devuelve la suma de los elementos con a lo sumo dos dígitos de los primeros k elementos de arr.\n\n        Ejemplo:\n\n            Entrada: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Salida: 24 # suma de 21 + 3\n\n        Restricciones:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Dado un arreglo no vacío de enteros arr y un entero k, devuelve la suma de los elementos con a lo sumo dos dígitos de los primeros k elementos de arr.\n\n        Ejemplo:\n\n            Entrada: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Salida: 24 # suma de 21 + 3\n\n        Restricciones:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    ", "natural_language": "Spanish"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Se te dan dos intervalos,\n    donde cada intervalo es un par de enteros. Por ejemplo, intervalo = (inicio, fin) = (1, 2).\n    Los intervalos dados son cerrados, lo que significa que el intervalo (inicio, fin)\n    incluye tanto el inicio como el fin.\n    Para cada intervalo dado, se asume que su inicio es menor o igual a su fin.\n    Tu tarea es determinar si la longitud de la intersección de estos dos\n    intervalos es un número primo.\n    Por ejemplo, la intersección de los intervalos (1, 3), (2, 4) es (2, 3)\n    cuya longitud es 1, que no es un número primo.\n    Si la longitud de la intersección es un número primo, devuelve \"YES\",\n    de lo contrario, devuelve \"NO\".\n    Si los dos intervalos no se intersectan, devuelve \"NO\".\n\n    \n    Ejemplo de entrada/salida:\n\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Se te dan dos intervalos,\n    donde cada intervalo es un par de enteros. Por ejemplo, intervalo = (inicio, fin) = (1, 2).\n    Los intervalos dados son cerrados, lo que significa que el intervalo (inicio, fin)\n    incluye tanto el inicio como el fin.\n    Para cada intervalo dado, se asume que su inicio es menor o igual a su fin.\n    Tu tarea es determinar si la longitud de la intersección de estos dos\n    intervalos es un número primo.\n    Por ejemplo, la intersección de los intervalos (1, 3), (2, 4) es (2, 3)\n    cuya longitud es 1, que no es un número primo.\n    Si la longitud de la intersección es un número primo, devuelve \"YES\",\n    de lo contrario, devuelve \"NO\".\n    Si los dos intervalos no se intersectan, devuelve \"NO\".\n\n    \n    Ejemplo de entrada/salida:\n\n    ", "natural_language": "Spanish"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Todos conocen la secuencia de Fibonacci, que fue estudiada profundamente por matemáticos en los últimos siglos. Sin embargo, lo que la gente no sabe es la secuencia de Tribonacci. La secuencia de Tribonacci se define por la recurrencia:\ntri(1) = 3\ntri(n) = 1 + n / 2, si n es par.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n es impar.\nPor ejemplo:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nSe te da un número entero no negativo n, debes devolver una lista de los primeros n + 1 números de la secuencia de Tribonacci.\nEjemplos:\ntri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Todos conocen la secuencia de Fibonacci, que fue estudiada profundamente por matemáticos en los últimos siglos. Sin embargo, lo que la gente no sabe es la secuencia de Tribonacci. La secuencia de Tribonacci se define por la recurrencia:\ntri(1) = 3\ntri(n) = 1 + n / 2, si n es par.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n es impar.\nPor ejemplo:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nSe te da un número entero no negativo n, debes devolver una lista de los primeros n + 1 números de la secuencia de Tribonacci.\nEjemplos:\ntri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Spanish"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Dado un número entero positivo n, devuelve el producto de los dígitos impares.\n    Devuelve 0 si todos los dígitos son pares.\n    Por ejemplo:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Dado un número entero positivo n, devuelve el producto de los dígitos impares.\n    Devuelve 0 si todos los dígitos son pares.\n    Por ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Crear una función que tome una cadena como entrada que contenga solo corchetes.\nLa función debe devolver Verdadero solo si hay una subsecuencia válida de corchetes donde al menos un corchete en la subsecuencia está anidado.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Crear una función que tome una cadena como entrada que contenga solo corchetes.\nLa función debe devolver Verdadero solo si hay una subsecuencia válida de corchetes donde al menos un corchete en la subsecuencia está anidado.\n    ", "natural_language": "Spanish"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Se te da una lista de números.\n    Necesitas devolver la suma de los números al cuadrado en la lista dada,\n    redondea cada elemento en la lista al entero superior (Ceiling) primero.\n    Ejemplos:\n    Para lst = [1,2,3] la salida debería ser 14\n    Para lst = [1,4,9] la salida debería ser 98\n    Para lst = [1,3,5,7] la salida debería ser 84\n    Para lst = [1.4,4.2,0] la salida debería ser 29\n    Para lst = [-2.4,1,1] la salida debería ser 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Se te da una lista de números.\n    Necesitas devolver la suma de los números al cuadrado en la lista dada,\n    redondea cada elemento en la lista al entero superior (Ceiling) primero.\n    Ejemplos:\n    Para lst = [1,2,3] la salida debería ser 14\n    Para lst = [1,4,9] la salida debería ser 98\n    Para lst = [1,3,5,7] la salida debería ser 84\n    Para lst = [1.4,4.2,0] la salida debería ser 29\n    Para lst = [-2.4,1,1] la salida debería ser 6\n    ", "natural_language": "Spanish"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Crea una función que devuelva True si el último carácter de una cadena dada es un carácter alfabético y no es parte de una palabra, y False en caso contrario. Nota: \"palabra\" es un grupo de caracteres separados por espacio.\n\n    Ejemplos:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Crea una función que devuelva True si el último carácter de una cadena dada es un carácter alfabético y no es parte de una palabra, y False en caso contrario. Nota: \"palabra\" es un grupo de caracteres separados por espacio.\n\n    Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Crea una función que devuelva el índice más grande de un elemento que no sea mayor o igual al elemento inmediatamente anterior. Si no existe tal elemento, devuelve -1. El array dado no contendrá valores duplicados.\n\n    Ejemplos:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Crea una función que devuelva el índice más grande de un elemento que no sea mayor o igual al elemento inmediatamente anterior. Si no existe tal elemento, devuelve -1. El array dado no contendrá valores duplicados.\n\n    Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Crea una función que devuelva una tupla (a, b), donde 'a' es el número entero negativo más grande y 'b' es el número entero positivo más pequeño en una lista. Si no hay números enteros negativos o positivos, devuélvelos como None.\n\n    Ejemplos:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Crea una función que devuelva una tupla (a, b), donde 'a' es el número entero negativo más grande y 'b' es el número entero positivo más pequeño en una lista. Si no hay números enteros negativos o positivos, devuélvelos como None.\n\n    Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"La factorial brasileña se define como:\n    factorial_brasileña(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    donde n > 0\n\n        Por ejemplo:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "La factorial brasileña se define como:\n    factorial_brasileña(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    donde n > 0\n\n        Por ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Se te da una cadena que representa una oración,\n    la oración contiene algunas palabras separadas por un espacio,\n    y debes devolver una cadena que contenga las palabras de la oración original,\n    cuyas longitudes son números primos,\n    el orden de las palabras en la nueva cadena debe ser el mismo que el original.\n\n        Ejemplo 1:\n        Entrada: sentence = \"This is a test\"\n        Salida: \"is\"\n\n        Ejemplo 2:\n        Entrada: sentence = \"lets go for swimming\"\n        Salida: \"go for\"\n\n        Restricciones:\n        * 1 <= len(sentence) <= 100\n        * sentence contiene solo letras\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Se te da una cadena que representa una oración,\n    la oración contiene algunas palabras separadas por un espacio,\n    y debes devolver una cadena que contenga las palabras de la oración original,\n    cuyas longitudes son números primos,\n    el orden de las palabras en la nueva cadena debe ser el mismo que el original.\n\n        Ejemplo 1:\n        Entrada: sentence = \"This is a test\"\n        Salida: \"is\"\n\n        Ejemplo 2:\n        Entrada: sentence = \"lets go for swimming\"\n        Salida: \"go for\"\n\n        Restricciones:\n        * 1 <= len(sentence) <= 100\n        * sentence contiene solo letras\n    ", "natural_language": "Spanish"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Su tarea es implementar una función que simplifique la expresión x * n. La función devuelve True si x * n se evalúa como un número entero y False en caso contrario. Tanto x como n son representaciones de cadena de una fracción y tienen el siguiente formato: <numerador>/<denominador> donde tanto el numerador como el denominador son números enteros positivos.\n\n    Se puede asumir que x y n son fracciones válidas y no tienen cero como denominador.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Su tarea es implementar una función que simplifique la expresión x * n. La función devuelve True si x * n se evalúa como un número entero y False en caso contrario. Tanto x como n son representaciones de cadena de una fracción y tienen el siguiente formato: <numerador>/<denominador> donde tanto el numerador como el denominador son números enteros positivos.\n\n    Se puede asumir que x y n son fracciones válidas y no tienen cero como denominador.\n    ", "natural_language": "Spanish"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Escriba una función que ordene la lista dada de enteros en orden ascendente según la suma de sus dígitos. Nota: si hay varios elementos con una suma similar de sus dígitos, ordénelos según su índice en la lista original.\n\n    Por ejemplo:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Escriba una función que ordene la lista dada de enteros en orden ascendente según la suma de sus dígitos. Nota: si hay varios elementos con una suma similar de sus dígitos, ordénelos según su índice en la lista original.\n\n    Por ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Escriba una función que tome como entrada una matriz de números y devuelva el número de elementos en la matriz que son mayores que 10 y ambos el primer y último dígito de un número son impares (1, 3, 5, 7, 9). Por ejemplo:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Escriba una función que tome como entrada una matriz de números y devuelva el número de elementos en la matriz que son mayores que 10 y ambos el primer y último dígito de un número son impares (1, 3, 5, 7, 9). Por ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Se te da un entero positivo n. Debes crear un arreglo de enteros a de longitud n.\n        Para cada i (1 ≤ i ≤ n), el valor de a[i] = i * i - i + 1.\n        Devuelve el número de triples (a[i], a[j], a[k]) de a donde i < j < k, \n    y a[i] + a[j] + a[k] es múltiplo de 3.\n\n        Ejemplo:\n        Entrada: n = 5\n        Salida: 1\n        Explicación:\n        a = [1, 3, 7, 13, 21]\n        El único triple válido es (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Se te da un entero positivo n. Debes crear un arreglo de enteros a de longitud n.\n        Para cada i (1 ≤ i ≤ n), el valor de a[i] = i * i - i + 1.\n        Devuelve el número de triples (a[i], a[j], a[k]) de a donde i < j < k, \n    y a[i] + a[j] + a[k] es múltiplo de 3.\n\n        Ejemplo:\n        Entrada: n = 5\n        Salida: 1\n        Explicación:\n        a = [1, 3, 7, 13, 21]\n        El único triple válido es (1, 7, 13).\n    ", "natural_language": "Spanish"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    Hay ocho planetas en nuestro sistema solar: el más cercano al Sol es Mercurio, el siguiente es Venus, luego la Tierra, Marte, Júpiter, Saturno, Urano, Neptuno. \nEscribe una función que tome dos nombres de planetas como cadenas de texto planet1 y planet2. La función debe devolver una tupla que contenga todos los planetas cuyas órbitas se encuentran entre la órbita de planet1 y la órbita de planet2, ordenados por proximidad al sol. La función debe devolver una tupla vacía si planet1 o planet2 no son nombres de planetas correctos. \nEjemplos:\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "Hay ocho planetas en nuestro sistema solar: el más cercano al Sol es Mercurio, el siguiente es Venus, luego la Tierra, Marte, Júpiter, Saturno, Urano, Neptuno. \nEscribe una función que tome dos nombres de planetas como cadenas de texto planet1 y planet2. La función debe devolver una tupla que contenga todos los planetas cuyas órbitas se encuentran entre la órbita de planet1 y la órbita de planet2, ordenados por proximidad al sol. La función debe devolver una tupla vacía si planet1 o planet2 no son nombres de planetas correctos. \nEjemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Un programa simple que debería devolver el valor de x si n es un número primo y debería devolver el valor de y en caso contrario.\n\n    Ejemplos:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Un programa simple que debería devolver el valor de x si n es un número primo y debería devolver el valor de y en caso contrario.\n\n    Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Dada una lista de números, devuelve la suma de los cuadrados de los números en la lista que son impares. Ignora los números que son negativos o no enteros.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    Si la lista de entrada está vacía, devuelve 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Dada una lista de números, devuelve la suma de los cuadrados de los números en la lista que son impares. Ignora los números que son negativos o no enteros.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    Si la lista de entrada está vacía, devuelve 0.\n    ", "natural_language": "Spanish"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Se le dará el nombre de una clase (una cadena) y una lista de extensiones.\n    Las extensiones se utilizarán para cargar clases adicionales a la clase. La\n    fuerza de la extensión es la siguiente: sea CAP el número de letras mayúsculas\n    en el nombre de la extensión, y sea SM el número de letras minúsculas\n    en el nombre de la extensión, la fuerza se da por la fracción CAP - SM.\n    Debe encontrar la extensión más fuerte y devolver una cadena en este\n    formato: NombreDeClase.NombreDeExtensionMásFuerte.\n    Si hay dos o más extensiones con la misma fuerza, debe\n    elegir el que aparece primero en la lista.\n    Por ejemplo, si se le da \"Slices\" como clase y una lista de\n    extensiones: ['SErviNGSliCes', 'Cheese', 'StuFfed'] entonces debería\n    devolver 'Slices.SErviNGSliCes' ya que 'SErviNGSliCes' es la extensión más fuerte\n    (su fuerza es -1).\n    Ejemplo:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Se le dará el nombre de una clase (una cadena) y una lista de extensiones.\n    Las extensiones se utilizarán para cargar clases adicionales a la clase. La\n    fuerza de la extensión es la siguiente: sea CAP el número de letras mayúsculas\n    en el nombre de la extensión, y sea SM el número de letras minúsculas\n    en el nombre de la extensión, la fuerza se da por la fracción CAP - SM.\n    Debe encontrar la extensión más fuerte y devolver una cadena en este\n    formato: NombreDeClase.NombreDeExtensionMásFuerte.\n    Si hay dos o más extensiones con la misma fuerza, debe\n    elegir el que aparece primero en la lista.\n    Por ejemplo, si se le da \"Slices\" como clase y una lista de\n    extensiones: ['SErviNGSliCes', 'Cheese', 'StuFfed'] entonces debería\n    devolver 'Slices.SErviNGSliCes' ya que 'SErviNGSliCes' es la extensión más fuerte\n    (su fuerza es -1).\n    Ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Se te dan 2 palabras. Necesitas devolver True si la segunda palabra o cualquiera de sus rotaciones es una subcadena en la primera palabra.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Se te dan 2 palabras. Necesitas devolver True si la segunda palabra o cualquiera de sus rotaciones es una subcadena en la primera palabra.\n    ", "natural_language": "Spanish"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Dado un número entero positivo, obtén su equivalente en numeral romano como una cadena y devuélvelo en minúsculas.\n    Restricciones: 1 <= num <= 1000\n\n        Ejemplos:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Dado un número entero positivo, obtén su equivalente en numeral romano como una cadena y devuélvelo en minúsculas.\n    Restricciones: 1 <= num <= 1000\n\n        Ejemplos:\n    ", "natural_language": "Spanish"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Dado las longitudes de los tres lados de un triángulo. Devuelve True si los tres lados forman un triángulo rectángulo, False en caso contrario. Un triángulo rectángulo es un triángulo en el que uno de los ángulos es un ángulo recto o de 90 grados. Ejemplo:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Dado las longitudes de los tres lados de un triángulo. Devuelve True si los tres lados forman un triángulo rectángulo, False en caso contrario. Un triángulo rectángulo es un triángulo en el que uno de los ángulos es un ángulo recto o de 90 grados. Ejemplo:\n    ", "natural_language": "Spanish"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Se te da una cadena s.\n    Si s[i] es una letra, invierte su caso de minúscula a mayúscula o viceversa,\n    de lo contrario, mantenlo como está.\n    Si la cadena no contiene letras, invierte la cadena.\n    La función debe devolver la cadena resultante.\n    Ejemplos\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Se te da una cadena s.\n    Si s[i] es una letra, invierte su caso de minúscula a mayúscula o viceversa,\n    de lo contrario, mantenlo como está.\n    Si la cadena no contiene letras, invierte la cadena.\n    La función debe devolver la cadena resultante.\n    Ejemplos\n    ", "natural_language": "Spanish"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Dado un string 'texto', devuelve su equivalente string de hash md5. Si 'texto' es un string vacío, devuelve null.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Dado un string 'texto', devuelve su equivalente string de hash md5. Si 'texto' es un string vacío, devuelve null.\n    ", "natural_language": "Spanish"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Dado dos enteros positivos a y b, devuelve los dígitos pares entre a y b, en orden ascendente.\n\n    Por ejemplo:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Dado dos enteros positivos a y b, devuelve los dígitos pares entre a y b, en orden ascendente.\n\n    Por ejemplo:\n    ", "natural_language": "Spanish"}
