{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Даден ви е списък с операции за депозит и теглене на банкова сметка, която започва с нулев баланс. Вашата задача е да откриете дали на някаква точка балансът на сметката пада под нула и в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Даден ви е списък с операции за депозит и теглене на банкова сметка, която започва с нулев баланс. Вашата задача е да откриете дали на някаква точка балансът на сметката пада под нула и в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" За даден списък от цели числа върнете кортеж, състоящ се от сума и произведение на всички цели числа в списъка. Празната сума трябва да бъде равна на 0, а празното произведение трябва да бъде равно на 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "За даден списък от цели числа върнете кортеж, състоящ се от сума и произведение на всички цели числа в списъка. Празната сума трябва да бъде равна на 0, а празното произведение трябва да бъде равно на 1.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Входът са две низа a и b, съставени само от 1 и 0.\nИзвършете двоично XOR върху тези входове и върнете резултата също като низ.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "Входът са две низа a и b, съставени само от 1 и 0.\nИзвършете двоично XOR върху тези входове и върнете резултата също като низ.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" От списък от низове, върни най-дългия. Върни първия в случай на множество низове с еднаква дължина. Върни null, ако входният списък е празен.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "От списък от низове, върни най-дългия. Върни първия в случай на множество низове с еднаква дължина. Върни null, ако входният списък е празен.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Върни най-големия общ делител на две цели числа a и b.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Върни най-големия общ делител на две цели числа a и b.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Входът е низ от числени думи, разделени с интервал, от 'нула' до 'девет'.\n    Валидни избори са 'нула', 'едно', 'две', 'три', 'четири', 'пет', 'шест', 'седем', 'осем' и 'девет'.\n    Върнете низа с числата, сортирани от най-малкото към най-голямото.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "Входът е низ от числени думи, разделени с интервал, от 'нула' до 'девет'.\n    Валидни избори са 'нула', 'едно', 'две', 'три', 'четири', 'пет', 'шест', 'седем', 'осем' и 'девет'.\n    Върнете низа с числата, сортирани от най-малкото към най-голямото.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Даден е списък от числа (с поне два елемента), приложете линейно преобразуване върху този списък, така че най-малкото число да стане 0, а най-голямото да стане 1.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Даден е списък от числа (с поне два елемента), приложете линейно преобразуване върху този списък, така че най-малкото число да стане 0, а най-голямото да стане 1.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" За даден низ, обърнете малки букви на големи и големи на малки.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "За даден низ, обърнете малки букви на големи и големи на малки.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Върни само положителни числа в списъка.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Върни само положителни числа в списъка.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Върни истина, ако дадено число е просто, и лъжа в противен случай.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Върни истина, ако дадено число е просто, и лъжа в противен случай.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Върни сортирани уникални елементи в списък.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Върни сортирани уникални елементи в списък.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib връща n-тото число, което е Фибоначи число и е също просто.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib връща n-тото число, което е Фибоначи число и е също просто.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero приема списък от цели числа като вход.\n    Връща True, ако има три различни елемента в списъка, които\n    се сумират до нула, и False в противен случай.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "triples_sum_to_zero приема списък от цели числа като вход.\n    Връща True, ако има три различни елемента в списъка, които\n    се сумират до нула, и False в противен случай.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero приема списък от цели числа като вход.\n    Връща True, ако има два различни елемента в списъка, които\n    се сумират до нула, и False в противен случай.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "pairs_sum_to_zero приема списък от цели числа като вход.\n    Връща True, ако има два различни елемента в списъка, които\n    се сумират до нула, и False в противен случай.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Редицата от числа Fib4 е подобна на редицата на Фибоначи и е дефинирана по следния начин:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Моля, напишете функция за ефективно изчисляване на n-тия елемент на редицата от числа Fib4. Не използвайте рекурсия.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "Редицата от числа Fib4 е подобна на редицата на Фибоначи и е дефинирана по следния начин:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Моля, напишете функция за ефективно изчисляване на n-тия елемент на редицата от числа Fib4. Не използвайте рекурсия.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Върни медианата на елементите в списъка l.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Върни медианата на елементите в списъка l.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Проверява дали даден низ е палиндром.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Проверява дали даден низ е палиндром.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels е функция, която приема низ и връща низ без гласни букви.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels е функция, която приема низ и връща низ без гласни букви.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Върни Истина, ако всички числа в списъка l са под прага t.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Върни Истина, ако всички числа в списъка l са под прага t.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Добавете две числа x и y.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Добавете две числа x и y.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Проверете дали две думи имат еднакви символи.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Проверете дали две думи имат еднакви символи.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Върни n-тото число на Фибоначи.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Върни n-тото число на Фибоначи.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Върни сортирани уникални общи елементи за два списъка.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Върни сортирани уникални общи елементи за два списъка.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Върни най-големия прост множител на n. Предполага се, че n > 1 и не е просто число.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Върни най-големия прост множител на n. Предполага се, че n > 1 и не е просто число.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n е функция, която сумира числата от 1 до n.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n е функция, която сумира числата от 1 до n.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs представляват коефициентите на полином.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Върни производната на този полином в същия формат.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs представляват коефициентите на полином.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Върни производната на този полином в същия формат.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"Последователността от числа FibFib е подобна на редицата на Фибоначи и се дефинира по следния начин:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Моля, напишете функция, която ефективно изчислява n-тия елемент на последователността от числа FibFib.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "Последователността от числа FibFib е подобна на редицата на Фибоначи и се дефинира по следния начин:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Моля, напишете функция, която ефективно изчислява n-тия елемент на последователността от числа FibFib.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Напишете функция vowels_count, която приема като входен параметър низ, представляващ дума, и връща броя на гласните букви в низа. Гласните букви в този случай са 'a', 'e', 'i', 'o', 'u'. Тук 'y' също е гласна буква, но само когато е в края на дадената дума.\n\n    Пример:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Напишете функция vowels_count, която приема като входен параметър низ, представляващ дума, и връща броя на гласните букви в низа. Гласните букви в този случай са 'a', 'e', 'i', 'o', 'u'. Тук 'y' също е гласна буква, но само когато е в края на дадената дума.\n\n    Пример:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Даден ви е непразен списък от положителни цели числа. Върнете най-голямото цяло число, което е по-голямо от нула и има честота, по-голяма или равна на стойността на самото число. Честотата на едно число е броят пъти, в които се появява в списъка. Ако не съществува такава стойност, върнете -1. Примери:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Даден ви е непразен списък от положителни цели числа. Върнете най-голямото цяло число, което е по-голямо от нула и има честота, по-голяма или равна на стойността на самото число. Честотата на едно число е броят пъти, в които се появява в списъка. Ако не съществува такава стойност, върнете -1. Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Дадени са дължините на трите страни на триъгълник. Върни лицето на триъгълника закръглено до 2 десетични знака, ако трите страни образуват валиден триъгълник. В противен случай върни -1. Три страни образуват валиден триъгълник, когато сумата на всяка две страни е по-голяма от третата страна. Пример:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Дадени са дължините на трите страни на триъгълник. Върни лицето на триъгълника закръглено до 2 десетични знака, ако трите страни образуват валиден триъгълник. В противен случай върни -1. Три страни образуват валиден триъгълник, когато сумата на всяка две страни е по-голяма от третата страна. Пример:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Напишете функция, която връща True, ако обектът q ще лети, и False в противен случай.\nОбектът q ще лети, ако е балансиран (е палиндромен списък) и сумата на неговите елементи е по-малка или равна на максималното възможно тегло w.\n\n    Пример:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 е по-малко от максималното възможно тегло, но е небалансиран.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# е балансиран, но 3+2+3 е повече от максималното възможно тегло.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 е по-малко от максималното възможно тегло и е балансиран.\n\n    will_it_fly([3], 5) ➞ True\n# 3 е по-малко от максималното възможно тегло и е балансиран.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Напишете функция, която връща True, ако обектът q ще лети, и False в противен случай.\nОбектът q ще лети, ако е балансиран (е палиндромен списък) и сумата на неговите елементи е по-малка или равна на максималното възможно тегло w.\n\n    Пример:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 е по-малко от максималното възможно тегло, но е небалансиран.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# е балансиран, но 3+2+3 е повече от максималното възможно тегло.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 е по-малко от максималното възможно тегло и е балансиран.\n\n    will_it_fly([3], 5) ➞ True\n# 3 е по-малко от максималното възможно тегло и е балансиран.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Напишете функция, която връща истина, ако даденото число е произведение на 3 прости числа и лъжа в противен случай. Знаейки, че (а) е по-малко от 100. Пример:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Напишете функция, която връща истина, ако даденото число е произведение на 3 прости числа и лъжа в противен случай. Знаейки, че (а) е по-малко от 100. Пример:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Ще получите число в десетичен формат и вашата задача е да го преобразувате в двоичен формат. Функцията трябва да върне низ, като всеки символ представлява двоично число. Всеки символ в низа ще бъде '0' или '1'.\n\n        В началото и в края на низа ще има допълнителни два символа 'db'. Допълнителните символи са там, за да помогнат за формата.\n\n        Примери:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Ще получите число в десетичен формат и вашата задача е да го преобразувате в двоичен формат. Функцията трябва да върне низ, като всеки символ представлява двоично число. Всеки символ в низа ще бъде '0' или '1'.\n\n        В началото и в края на низа ще има допълнителни два символа 'db'. Допълнителните символи са там, за да помогнат за формата.\n\n        Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Даден ви е низ s.\n    Вашата задача е да проверите дали низът е щастлив или не.\n    Низът е щастлив, ако дължината му е поне 3 и всеки 3 последователни букви са различни.\n    Например:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Даден ви е низ s.\n    Вашата задача е да проверите дали низът е щастлив или не.\n    Низът е щастлив, ако дължината му е поне 3 и всеки 3 последователни букви са различни.\n    Например:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Последната седмица от семестъра е и учителят трябва да даде оценки на учениците. Учителят е създал свой алгоритъм за оценяване. Единствената проблем е, че е загубил кода, който е използвал за оценяване. Той ви е дал списък с GPAs на някои ученици и вие трябва да напишете функция, която може да изведе списък с буквени оценки, използвайки следната таблица:\n\n                 GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Пример:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "Последната седмица от семестъра е и учителят трябва да даде оценки на учениците. Учителят е създал свой алгоритъм за оценяване. Единствената проблем е, че е загубил кода, който е използвал за оценяване. Той ви е дал списък с GPAs на някои ученици и вие трябва да напишете функция, която може да изведе списък с буквени оценки, използвайки следната таблица:\n\n                 GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Пример:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Напишете функция, която приема низ и връща True, ако дължината на низа е просто число, или False в противен случай.\nПримери:\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Напишете функция, която приема низ и връща True, ако дължината на низа е просто число, или False в противен случай.\nПримери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Дадено е положително цяло число N, върнете общата сума на неговите цифри в двоичен вид.\n\n        Пример\n        За N = 1000, сумата на цифрите ще бъде 1, изходът трябва да бъде \"1\".\n        За N = 150, сумата на цифрите ще бъде 6, изходът трябва да бъде \"110\".\n        За N = 147, сумата на цифрите ще бъде 12, изходът трябва да бъде \"1100\".\n    \n    Променливи:\n        @N цяло число\n             Ограничения: 0 ≤ N ≤ 10000.\n    Изход:\n         низ от двоично число\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Дадено е положително цяло число N, върнете общата сума на неговите цифри в двоичен вид.\n\n        Пример\n        За N = 1000, сумата на цифрите ще бъде 1, изходът трябва да бъде \"1\".\n        За N = 150, сумата на цифрите ще бъде 6, изходът трябва да бъде \"110\".\n        За N = 147, сумата на цифрите ще бъде 12, изходът трябва да бъде \"1100\".\n    \n    Променливи:\n        @N цяло число\n             Ограничения: 0 ≤ N ≤ 10000.\n    Изход:\n         низ от двоично число\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Даден ви е двумерен данни, като вложени списъци, които са подобни на матрица, но за разлика от матриците, всяка редица може да съдържа различен брой колони. Даден е списък lst и цяло число x, намерете целите числа x в списъка и върнете списък от наредени двойки [(x1, y1), (x2, y2) ...], като всяка двойка е координата - (ред, колони), започващи от 0. Сортирайте координатите първоначално по редове във възходящ ред. Също така, сортирайте координатите на реда по колони в низходящ ред.\n\n    Примери:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Даден ви е двумерен данни, като вложени списъци, които са подобни на матрица, но за разлика от матриците, всяка редица може да съдържа различен брой колони. Даден е списък lst и цяло число x, намерете целите числа x в списъка и върнете списък от наредени двойки [(x1, y1), (x2, y2) ...], като всяка двойка е координата - (ред, колони), започващи от 0. Сортирайте координатите първоначално по редове във възходящ ред. Също така, сортирайте координатите на реда по колони в низходящ ред.\n\n    Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Даден ви е списък от цели числа.\nНапишете функция next_smallest(), която връща втория по големина елемент от списъка.\nАко няма такъв елемент, върнете null.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Даден ви е списък от цели числа.\nНапишете функция next_smallest(), която връща втория по големина елемент от списъка.\nАко няма такъв елемент, върнете null.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Ще получите низ от думи и вашата задача е да броите броя на скучните моменти. Скучен момент е изречение, което започва с думата \"Аз\". Изреченията са разделени с '.', '?' или '!'. \n\n    Например:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Ще получите низ от думи и вашата задача е да броите броя на скучните моменти. Скучен момент е изречение, което започва с думата \"Аз\". Изреченията са разделени с '.', '?' или '!'. \n\n    Например:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Даден ви е списък от цели числа.\nТрябва да намерите най-голямата проста стойност и да върнете сумата на нейните цифри.\n\n    Примери:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Даден ви е списък от цели числа.\nТрябва да намерите най-голямата проста стойност и да върнете сумата на нейните цифри.\n\n    Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Даден е речник, върнете True, ако всички ключове са низове в малки букви или всички ключове са низове в големи букви, в противен случай върнете False. Функцията трябва да върне False, ако даденият речник е празен. Примери:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Даден е речник, върнете True, ако всички ключове са низове в малки букви или всички ключове са низове в големи букви, в противен случай върнете False. Функцията трябва да върне False, ако даденият речник е празен. Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Създайте функция, която приема стойност (низ), представляващ число и връща най-близкото цяло число до него. Ако числото е на равно разстояние от две цели числа, закръглете го надолу.\n\n    Примери:\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Създайте функция, която приема стойност (низ), представляващ число и връща най-близкото цяло число до него. Ако числото е на равно разстояние от две цели числа, закръглете го надолу.\n\n    Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Дадено е положително цяло число n, трябва да направите купчина от n нива от камъни.\n    Първото ниво има n камъка.\n    Броят на камъните в следващото ниво е:\n        - следващото нечетно число, ако n е нечетно.\n        - следващото четно число, ако n е четно.\n    Върнете броя на камъните във всяко ниво в списък, където елементът на индекс\n    i представлява броя на камъните в нивото (i+1).\n\n        Примери:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Дадено е положително цяло число n, трябва да направите купчина от n нива от камъни.\n    Първото ниво има n камъка.\n    Броят на камъните в следващото ниво е:\n        - следващото нечетно число, ако n е нечетно.\n        - следващото четно число, ако n е четно.\n    Върнете броя на камъните във всяко ниво в списък, където елементът на индекс\n    i представлява броя на камъните в нивото (i+1).\n\n        Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Ще получите низ от думи, разделени със запетая или интервал. Вашата задача е да разделяте низа на думи и да връщате масив от думите.\n\n    Например:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Ще получите низ от думи, разделени със запетая или интервал. Вашата задача е да разделяте низа на думи и да връщате масив от думите.\n\n    Например:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Тази функция приема две положителни числа x и y и връща най-голямото четно цяло число, което е в интервала [x, y] включително. Ако няма такова число, функцията трябва да върне -1.\n\n    Например:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Тази функция приема две положителни числа x и y и връща най-голямото четно цяло число, което е в интервала [x, y] включително. Ако няма такова число, функцията трябва да върне -1.\n\n    Например:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Дадени са ви две положителни цели числа n и m, а вашата задача е да изчислите\n    средното аритметично на целите числа от n до m (включително n и m). \n    Закръглете отговора до най-близкото цяло число и го превърнете в двоична бройна система.\n    Ако n е по-голямо от m, върнете -1.\n    Пример:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Дадени са ви две положителни цели числа n и m, а вашата задача е да изчислите\n    средното аритметично на целите числа от n до m (включително n и m). \n    Закръглете отговора до най-близкото цяло число и го превърнете в двоична бройна система.\n    Ако n е по-голямо от m, върнете -1.\n    Пример:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Реализирайте функцията f, която приема n като параметър и връща списък с размер n, като стойността на елемента на индекс i е факториелът на i, ако i е четно число, или сумата на числата от 1 до i в противен случай. i започва от 1. Факториелът на i е умножението на числата от 1 до i (1 * 2 * ... * i). Пример:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Реализирайте функцията f, която приема n като параметър и връща списък с размер n, като стойността на елемента на индекс i е факториелът на i, ако i е четно число, или сумата на числата от 1 до i в противен случай. i започва от 1. Факториелът на i е умножението на числата от 1 до i (1 * 2 * ... * i). Пример:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Дадено е положително цяло число n, върнете кортеж, който има броя на четните и нечетните цели палиндроми, които попадат в диапазона (1, n), включително.\n\n        Пример 1:\n\n            Вход: 3\n        Изход: (1, 2)\n        Обяснение:\n        Целите палиндроми са 1, 2, 3. Един от тях е четен, а двама са нечетни.\n\n        Пример 2:\n\n            Вход: 12\n        Изход: (4, 6)\n        Обяснение:\n        Целите палиндроми са 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Четири от тях са четни, а шест са нечетни.\n\n        Бележка:\n        1. 1 <= n <= 10^3\n        2. върнатият кортеж има броя на четните и нечетните цели палиндроми, съответно.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Дадено е положително цяло число n, върнете кортеж, който има броя на четните и нечетните цели палиндроми, които попадат в диапазона (1, n), включително.\n\n        Пример 1:\n\n            Вход: 3\n        Изход: (1, 2)\n        Обяснение:\n        Целите палиндроми са 1, 2, 3. Един от тях е четен, а двама са нечетни.\n\n        Пример 2:\n\n            Вход: 12\n        Изход: (4, 6)\n        Обяснение:\n        Целите палиндроми са 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Четири от тях са четни, а шест са нечетни.\n\n        Бележка:\n        1. 1 <= n <= 10^3\n        2. върнатият кортеж има броя на четните и нечетните цели палиндроми, съответно.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Имаме масив 'arr' от N цели числа arr[1], arr[2], ..., arr[N]. Числата в масива ще бъдат произволно подредени. Вашата задача е да определите дали е възможно да се получи масив, подреден в ненамаляващ ред, като извършите следната операция върху дадения масив:\n        Имате право да извършвате операцията за дясно изместване на произволен брой пъти.\n    \n    Една операция за дясно изместване означава изместване на всички елементи на масива с една позиция в дясната посока. Последният елемент на масива ще бъде преместен на началната позиция в масива, т.е. на индекс 0. \n\n        Ако е възможно да се получи подредения масив, като се извърши горната операция, върнете True, в противен случай върнете False.\n    Ако даденият масив е празен, върнете True.\n\n        Забележка: Даденият списък е гарантирано да има уникални елементи.\n\n        Например:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Обяснение: С извършване на 2 операции за дясно изместване може да се постигне ненамаляващ ред за дадения масив.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Обяснение: Не е възможно да се получи ненамаляващ ред за дадения масив, като се извършат произволен брой операции за дясно изместване.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Имаме масив 'arr' от N цели числа arr[1], arr[2], ..., arr[N]. Числата в масива ще бъдат произволно подредени. Вашата задача е да определите дали е възможно да се получи масив, подреден в ненамаляващ ред, като извършите следната операция върху дадения масив:\n        Имате право да извършвате операцията за дясно изместване на произволен брой пъти.\n    \n    Една операция за дясно изместване означава изместване на всички елементи на масива с една позиция в дясната посока. Последният елемент на масива ще бъде преместен на началната позиция в масива, т.е. на индекс 0. \n\n        Ако е възможно да се получи подредения масив, като се извърши горната операция, върнете True, в противен случай върнете False.\n    Ако даденият масив е празен, върнете True.\n\n        Забележка: Даденият списък е гарантирано да има уникални елементи.\n\n        Например:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Обяснение: С извършване на 2 операции за дясно изместване може да се постигне ненамаляващ ред за дадения масив.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Обяснение: Не е възможно да се получи ненамаляващ ред за дадения масив, като се извършат произволен брой операции за дясно изместване.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"В тази задача ще реализирате функция, която приема два списъка от числа и определя дали е възможно да се извърши размяна на елементи между тях, за да се направи lst1 списък само от четни числа. Няма ограничение за броя на разменените елементи между lst1 и lst2. Ако е възможно да се разменят елементи между lst1 и lst2, за да се направят всички елементи на lst1 четни, върнете \"YES\". В противен случай върнете \"NO\". Например: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Предполага се, че входните списъци ще бъдат непразни.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "В тази задача ще реализирате функция, която приема два списъка от числа и определя дали е възможно да се извърши размяна на елементи между тях, за да се направи lst1 списък само от четни числа. Няма ограничение за броя на разменените елементи между lst1 и lst2. Ако е възможно да се разменят елементи между lst1 и lst2, за да се направят всички елементи на lst1 четни, върнете \"YES\". В противен случай върнете \"NO\". Например: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Предполага се, че входните списъци ще бъдат непразни.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Задача\n    Дадени са ни две низа s и c, трябва да изтриете всички символи в s, които са равни на някой символ в c,\n    след което да проверите дали резултатният низ е палиндром.\n    Низ се нарича палиндром, ако се чете еднакво отпред назад и отзад напред.\n    Трябва да върнете кортеж, който съдържа резултатния низ и True/False за проверката.\n    Пример\n    За s = \"abcde\", c = \"ae\", резултатът трябва да бъде ('bcd',False)\n    За s = \"abcdef\", c = \"b\"  резултатът трябва да бъде ('acdef',False)\n    За s = \"abcdedcba\", c = \"ab\", резултатът трябва да бъде ('cdedc',True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Задача\n    Дадени са ни две низа s и c, трябва да изтриете всички символи в s, които са равни на някой символ в c,\n    след което да проверите дали резултатният низ е палиндром.\n    Низ се нарича палиндром, ако се чете еднакво отпред назад и отзад напред.\n    Трябва да върнете кортеж, който съдържа резултатния низ и True/False за проверката.\n    Пример\n    За s = \"abcde\", c = \"ae\", резултатът трябва да бъде ('bcd',False)\n    За s = \"abcdef\", c = \"b\"  резултатът трябва да бъде ('acdef',False)\n    За s = \"abcdedcba\", c = \"ab\", резултатът трябва да бъде ('cdedc',True)\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Дадена ви е правоъгълен решетъчен граф от кладенци. Всяка редица представлява един кладенец, а всяко 1 в редицата представлява единица вода. Всеки кладенец има съответен ведро, което може да се използва за изваждане на вода от него, и всички ведра имат еднакъв капацитет. Вашата задача е да използвате ведрата, за да изпразните кладенците. Изведете броя на пътищата, които трябва да намалите ведрата.\n\n    Пример 1:\n    Вход:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        bucket_capacity: 1\n    Изход: 6\n\n    Пример 2:\n    Вход:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        bucket_capacity: 2\n    Изход: 5\n\n    Пример 3:\n    Вход:\n        grid: [[0,0,0], [0,0,0]]\n        bucket_capacity: 5\n    Изход: 0\n\n    Ограничения:\n    * всички кладенци имат еднаква дължина\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid[:,1].length <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= capacity <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Дадена ви е правоъгълен решетъчен граф от кладенци. Всяка редица представлява един кладенец, а всяко 1 в редицата представлява единица вода. Всеки кладенец има съответен ведро, което може да се използва за изваждане на вода от него, и всички ведра имат еднакъв капацитет. Вашата задача е да използвате ведрата, за да изпразните кладенците. Изведете броя на пътищата, които трябва да намалите ведрата.\n\n    Пример 1:\n    Вход:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        bucket_capacity: 1\n    Изход: 6\n\n    Пример 2:\n    Вход:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        bucket_capacity: 2\n    Изход: 5\n\n    Пример 3:\n    Вход:\n        grid: [[0,0,0], [0,0,0]]\n        bucket_capacity: 5\n    Изход: 0\n\n    Ограничения:\n    * всички кладенци имат еднаква дължина\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid[:,1].length <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= capacity <= 10\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Даден е низ s и естествено число n. Вашата задача е да реализирате функция, която връща списък от всички думи от низа s, които съдържат точно n съгласни звука, в реда, в който тези думи се появяват в низа s. Ако низът s е празен, функцията трябва да върне празен списък. Забележка: можете да предположите, че входният низ съдържа само букви и интервали. Примери:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Даден е низ s и естествено число n. Вашата задача е да реализирате функция, която връща списък от всички думи от низа s, които съдържат точно n съгласни звука, в реда, в който тези думи се появяват в низа s. Ако низът s е празен, функцията трябва да върне празен списък. Забележка: можете да предположите, че входният низ съдържа само букви и интервали. Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Даден е масив arr от цели числа и положително цяло число k. Върни сортиран списък с дължина k, който съдържа максималните k числа в arr.\n\n    Пример 1:\n\n        Вход: arr = [-3, -4, 5], k = 3\n    Изход: [-4, -3, 5]\n\n    Пример 2:\n\n        Вход: arr = [4, -4, 4], k = 2\n    Изход: [4, 4]\n\n    Пример 3:\n\n        Вход: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Изход: [2]\n\n    Забележка:\n    1. Дължината на масива ще бъде в интервала [1, 1000].\n    2. Елементите в масива ще бъдат в интервала [-1000, 1000].\n    3. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Даден е масив arr от цели числа и положително цяло число k. Върни сортиран списък с дължина k, който съдържа максималните k числа в arr.\n\n    Пример 1:\n\n        Вход: arr = [-3, -4, 5], k = 3\n    Изход: [-4, -3, 5]\n\n    Пример 2:\n\n        Вход: arr = [4, -4, 4], k = 2\n    Изход: [4, 4]\n\n    Пример 3:\n\n        Вход: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Изход: [2]\n\n    Забележка:\n    1. Дължината на масива ще бъде в интервала [1, 1000].\n    2. Елементите в масива ще бъдат в интервала [-1000, 1000].\n    3. 0 <= k <= len(arr)\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Даден е непразен масив от цели числа arr и цяло число k. Върни сумата на елементите с най-много две цифри от първите k елемента на arr.\n\n    Пример:\n\n        Вход: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Изход: 24 # сумата на 21 + 3\n\n    Ограничения:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Даден е непразен масив от цели числа arr и цяло число k. Върни сумата на елементите с най-много две цифри от първите k елемента на arr.\n\n    Пример:\n\n        Вход: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Изход: 24 # сумата на 21 + 3\n\n    Ограничения:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Дадени са ви два интервала, където всеки интервал е двойка от цели числа. Например, интервал = (начало, край) = (1, 2). Дадените интервали са затворени, което означава, че интервалът (начало, край) включва и началото, и края. За всеки даден интервал се предполага, че началото му е по-малко или равно на края му. Вашата задача е да определите дали дължината на пресичането на тези два интервала е просто число. Например, пресичането на интервалите (1, 3), (2, 4) е (2, 3), която има дължина 1, която не е просто число. Ако дължината на пресичането е просто число, върнете \"YES\", в противен случай върнете \"NO\". Ако двете интервала не се пресичат, върнете \"NO\".\n\n    [вход/изход] примери:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Дадени са ви два интервала, където всеки интервал е двойка от цели числа. Например, интервал = (начало, край) = (1, 2). Дадените интервали са затворени, което означава, че интервалът (начало, край) включва и началото, и края. За всеки даден интервал се предполага, че началото му е по-малко или равно на края му. Вашата задача е да определите дали дължината на пресичането на тези два интервала е просто число. Например, пресичането на интервалите (1, 3), (2, 4) е (2, 3), която има дължина 1, която не е просто число. Ако дължината на пресичането е просто число, върнете \"YES\", в противен случай върнете \"NO\". Ако двете интервала не се пресичат, върнете \"NO\".\n\n    [вход/изход] примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Всеки знае Фибоначи редицата, която беше дълбоко изучавана от математиците през последните няколко века. Обаче, това, което хората не знаят, е Трибоначи редицата. Трибоначи редицата се дефинира от рекурентността:\ntri(1) = 3\ntri(n) = 1 + n / 2, ако n е четно.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ако n е нечетно.\nНапример:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nДадено ви е неотрицателно цяло число n, трябва да върнете списък с първите n + 1 числа от Трибоначи редицата.\nПримери:\ntri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Всеки знае Фибоначи редицата, която беше дълбоко изучавана от математиците през последните няколко века. Обаче, това, което хората не знаят, е Трибоначи редицата. Трибоначи редицата се дефинира от рекурентността:\ntri(1) = 3\ntri(n) = 1 + n / 2, ако n е четно.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ако n е нечетно.\nНапример:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nДадено ви е неотрицателно цяло число n, трябва да върнете списък с първите n + 1 числа от Трибоначи редицата.\nПримери:\ntri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Дадено е положително цяло число n, върни произведението на нечетните цифри.\n    Върни 0, ако всички цифри са четни.\n    Например:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Дадено е положително цяло число n, върни произведението на нечетните цифри.\n    Върни 0, ако всички цифри са четни.\n    Например:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Създайте функция, която приема низ като вход, който съдържа само квадратни скоби.\nФункцията трябва да върне True само ако има валидна подпоследователност от скоби, където поне една скоба в подпоследователността е вложена.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Създайте функция, която приема низ като вход, който съдържа само квадратни скоби.\nФункцията трябва да върне True само ако има валидна подпоследователност от скоби, където поне една скоба в подпоследователността е вложена.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Даден ви е списък от числа.\nТрябва да върнете сумата на квадратните числа в дадения списък,\nзакръглете всеки елемент в списъка до горното цяло число (Ceiling) първо.\nПримери:\nЗа lst = [1,2,3] изходът трябва да бъде 14\nЗа lst = [1,4,9] изходът трябва да бъде 98\nЗа lst = [1,3,5,7] изходът трябва да бъде 84\nЗа lst = [1.4,4.2,0] изходът трябва да бъде 29\nЗа lst = [-2.4,1,1] изходът трябва да бъде 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Даден ви е списък от числа.\nТрябва да върнете сумата на квадратните числа в дадения списък,\nзакръглете всеки елемент в списъка до горното цяло число (Ceiling) първо.\nПримери:\nЗа lst = [1,2,3] изходът трябва да бъде 14\nЗа lst = [1,4,9] изходът трябва да бъде 98\nЗа lst = [1,3,5,7] изходът трябва да бъде 84\nЗа lst = [1.4,4.2,0] изходът трябва да бъде 29\nЗа lst = [-2.4,1,1] изходът трябва да бъде 6\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Създайте функция, която връща True, ако последният символ на даден низ е буква и не е част от дума, и False в противен случай. Забележка: \"дума\" е група от символи, разделени с интервал.\n\n    Примери:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Създайте функция, която връща True, ако последният символ на даден низ е буква и не е част от дума, и False в противен случай. Забележка: \"дума\" е група от символи, разделени с интервал.\n\n    Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Създайте функция, която връща най-големия индекс на елемент, който не е по-голям или равен на елемента, непосредствено преди него. Ако няма такъв елемент, върнете -1. Даденият масив няма да съдържа дублиращи се стойности.\n\n    Примери:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Създайте функция, която връща най-големия индекс на елемент, който не е по-голям или равен на елемента, непосредствено преди него. Ако няма такъв елемент, върнете -1. Даденият масив няма да съдържа дублиращи се стойности.\n\n    Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Създайте функция, която връща кортеж (a, b), където 'a' е най-големият от отрицателните цели числа, а 'b' е най-малкият от положителните цели числа в списък.\n    Ако няма отрицателни или положителни цели числа, върнете ги като None.\n\n        Примери:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Създайте функция, която връща кортеж (a, b), където 'a' е най-големият от отрицателните цели числа, а 'b' е най-малкият от положителните цели числа в списък.\n    Ако няма отрицателни или положителни цели числа, върнете ги като None.\n\n        Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"Бразилският факториел е дефиниран като:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    където n > 0\n\n        Например:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "Бразилският факториел е дефиниран като:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    където n > 0\n\n        Например:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Даден ви е низ, който представлява изречение,\n    изречението съдържа някои думи, разделени с интервал,\n    и трябва да върнете низ, който съдържа думите от оригиналното изречение,\n    чиито дължини са прости числа,\n    редът на думите в новия низ трябва да бъде същият като в оригиналния.\n\n        Пример 1:\n        Вход: изречение = \"This is a test\"\n        Изход: \"is\"\n\n        Пример 2:\n        Вход: изречение = \"lets go for swimming\"\n        Изход: \"go for\"\n\n        Ограничения:\n        * 1 <= len(изречение) <= 100\n        * изречението съдържа само букви\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Даден ви е низ, който представлява изречение,\n    изречението съдържа някои думи, разделени с интервал,\n    и трябва да върнете низ, който съдържа думите от оригиналното изречение,\n    чиито дължини са прости числа,\n    редът на думите в новия низ трябва да бъде същият като в оригиналния.\n\n        Пример 1:\n        Вход: изречение = \"This is a test\"\n        Изход: \"is\"\n\n        Пример 2:\n        Вход: изречение = \"lets go for swimming\"\n        Изход: \"go for\"\n\n        Ограничения:\n        * 1 <= len(изречение) <= 100\n        * изречението съдържа само букви\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Вашата задача е да реализирате функция, която ще опрости израза x * n. Функцията връща True, ако x * n се оценява като цяло число и False в противен случай. И двете x и n са символни представяния на дроб, и имат следния формат, <числител>/<знаменател>, където и числителят, и знаменателят са положителни цели числа.\n\n    Можете да предположите, че x и n са валидни дроби и нямат нула като знаменател.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Вашата задача е да реализирате функция, която ще опрости израза x * n. Функцията връща True, ако x * n се оценява като цяло число и False в противен случай. И двете x и n са символни представяния на дроб, и имат следния формат, <числител>/<знаменател>, където и числителят, и знаменателят са положителни цели числа.\n\n    Можете да предположите, че x и n са валидни дроби и нямат нула като знаменател.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Напишете функция, която сортира дадения списък от цели числа във възходящ ред според сумата на техните цифри. Внимание: ако има няколко елемента с подобна сума на техните цифри, подредете ги въз основа на техния индекс в оригиналния списък.\n\n    Например:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Напишете функция, която сортира дадения списък от цели числа във възходящ ред според сумата на техните цифри. Внимание: ако има няколко елемента с подобна сума на техните цифри, подредете ги въз основа на техния индекс в оригиналния списък.\n\n    Например:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Напишете функция, която приема масив от числа като вход и връща броя на елементите в масива, които са по-големи от 10 и първата и последната цифри на числото са нечетни (1, 3, 5, 7, 9). Например:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Напишете функция, която приема масив от числа като вход и връща броя на елементите в масива, които са по-големи от 10 и първата и последната цифри на числото са нечетни (1, 3, 5, 7, 9). Например:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Дадено ви е положително цяло число n. Трябва да създадете масив от цели числа a с дължина n. За всяко i (1 ≤ i ≤ n), стойността на a[i] = i * i - i + 1. Върнете броя на тройките (a[i], a[j], a[k]) от a, където i < j < k, и a[i] + a[j] + a[k] е кратно на 3.\n\n    Пример:\n    Вход: n = 5\n    Изход: 1\n    Обяснение:\n    a = [1, 3, 7, 13, 21]\n    Единствената валидна тройка е (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Дадено ви е положително цяло число n. Трябва да създадете масив от цели числа a с дължина n. За всяко i (1 ≤ i ≤ n), стойността на a[i] = i * i - i + 1. Върнете броя на тройките (a[i], a[j], a[k]) от a, където i < j < k, и a[i] + a[j] + a[k] е кратно на 3.\n\n    Пример:\n    Вход: n = 5\n    Изход: 1\n    Обяснение:\n    a = [1, 3, 7, 13, 21]\n    Единствената валидна тройка е (1, 7, 13).\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    В нашата слънчева система има осем планети: най-близката до Слънцето е Меркурий, следващата е Венера, след това Земята, Марс, Юпитер, Сатурн, Уран и Нептун. Напишете функция, която приема две имена на планети като низове planet1 и planet2. Функцията трябва да върне кортеж, който съдържа всички планети, чиито орбити се намират между орбитата на planet1 и орбитата на planet2, подредени по близост до Слънцето. Функцията трябва да върне празен кортеж, ако planet1 или planet2 не са правилни имена на планети. Примери:\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "В нашата слънчева система има осем планети: най-близката до Слънцето е Меркурий, следващата е Венера, след това Земята, Марс, Юпитер, Сатурн, Уран и Нептун. Напишете функция, която приема две имена на планети като низове planet1 и planet2. Функцията трябва да върне кортеж, който съдържа всички планети, чиито орбити се намират между орбитата на planet1 и орбитата на planet2, подредени по близост до Слънцето. Функцията трябва да върне празен кортеж, ако planet1 или planet2 не са правилни имена на планети. Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Една проста програма, която трябва да върне стойността на x, ако n е просто число, и трябва да върне стойността на y в противен случай.\n\n    Примери:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Една проста програма, която трябва да върне стойността на x, ако n е просто число, и трябва да върне стойността на y в противен случай.\n\n    Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Даден е списък от числа, върни сумата на квадратите на числата в списъка, които са нечетни. Пренебрегнете числата, които са отрицателни или не са цели числа.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n        Ако входният списък е празен, върни 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Даден е списък от числа, върни сумата на квадратите на числата в списъка, които са нечетни. Пренебрегнете числата, които са отрицателни или не са цели числа.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n        Ако входният списък е празен, върни 0.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Ще получите името на клас (низ) и списък от разширения.\n    Разширенията трябва да се използват за зареждане на допълнителни класове към класа. Силата на разширението е както следва: Нека CAP е броят на главните букви в името на разширението, а SM е броят на малките букви в името на разширението, силата се дава от дробта CAP - SM. Трябва да намерите най-силното разширение и да върнете низ в този формат: Име на клас.Име на най-силното разширение.\n    Ако има две или повече разширения с еднаква сила, трябва да изберете това, което е първо в списъка.\n    Например, ако получите \"Slices\" като клас и списък от разширения: ['SErviNGSliCes', 'Cheese', 'StuFfed'], трябва да върнете 'Slices.SErviNGSliCes', тъй като 'SErviNGSliCes' е най-силното разширение (неговата сила е -1).\n    Пример:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Ще получите името на клас (низ) и списък от разширения.\n    Разширенията трябва да се използват за зареждане на допълнителни класове към класа. Силата на разширението е както следва: Нека CAP е броят на главните букви в името на разширението, а SM е броят на малките букви в името на разширението, силата се дава от дробта CAP - SM. Трябва да намерите най-силното разширение и да върнете низ в този формат: Име на клас.Име на най-силното разширение.\n    Ако има две или повече разширения с еднаква сила, трябва да изберете това, което е първо в списъка.\n    Например, ако получите \"Slices\" като клас и списък от разширения: ['SErviNGSliCes', 'Cheese', 'StuFfed'], трябва да върнете 'Slices.SErviNGSliCes', тъй като 'SErviNGSliCes' е най-силното разширение (неговата сила е -1).\n    Пример:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Дадени са ви 2 думи. Трябва да върнете True, ако втората дума или някоя от нейните ротации е подниз на първата дума.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Дадени са ви 2 думи. Трябва да върнете True, ако втората дума или някоя от нейните ротации е подниз на първата дума.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Дадено е положително цяло число, получете неговото римско числово еквивалентно като низ и го върнете в малки букви.\nОграничения: 1 <= num <= 1000\n\n    Примери:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Дадено е положително цяло число, получете неговото римско числово еквивалентно като низ и го върнете в малки букви.\nОграничения: 1 <= num <= 1000\n\n    Примери:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Дадени са дължините на трите страни на триъгълник. Върни True, ако трите страни образуват правоъгълен триъгълник, и False в противен случай. Правоъгълен триъгълник е триъгълник, в който един от ъглите е прав ъгъл или 90 градуса. Пример:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Дадени са дължините на трите страни на триъгълник. Върни True, ако трите страни образуват правоъгълен триъгълник, и False в противен случай. Правоъгълен триъгълник е триъгълник, в който един от ъглите е прав ъгъл или 90 градуса. Пример:\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Даден е низ s.\n    Ако s[i] е буква, обръща се нейният регистър от малка в голяма или обратно,\n    в противен случай се запазва както е.\n    Ако низът не съдържа букви, низът се обръща.\n    Функцията трябва да върне получения низ.\n    Примери\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Даден е низ s.\n    Ако s[i] е буква, обръща се нейният регистър от малка в голяма или обратно,\n    в противен случай се запазва както е.\n    Ако низът не съдържа букви, низът се обръща.\n    Функцията трябва да върне получения низ.\n    Примери\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Даден е низ 'текст', върнете низ, който е еквивалент на md5 хеша му.\n    Ако 'текст' е празен низ, върнете null.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Даден е низ 'текст', върнете низ, който е еквивалент на md5 хеша му.\n    Ако 'текст' е празен низ, върнете null.\n    ", "natural_language": "Bulgarian"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Дадени са две положителни цели числа a и b, върнете четните цифри между a и b, във възходящ ред.\n\n        Например:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Дадени са две положителни цели числа a и b, върнете четните цифри между a и b, във възходящ ред.\n\n        Например:\n    ", "natural_language": "Bulgarian"}
