{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Σας δίνεται μια λίστα με λειτουργίες κατάθεσης και ανάληψης σε έναν τραπεζικό λογαριασμό που ξεκινά με μηδενικό υπόλοιπο. Η εργασία σας είναι να ανιχνεύσετε αν σε οποιοδήποτε σημείο το υπόλοιπο του λογαριασμού πέσει κάτω από το μηδέν, και σε αυτό το σημείο η συνάρτηση θα πρέπει να επιστρέψει True. Διαφορετικά θα πρέπει να επιστρέψει False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Σας δίνεται μια λίστα με λειτουργίες κατάθεσης και ανάληψης σε έναν τραπεζικό λογαριασμό που ξεκινά με μηδενικό υπόλοιπο. Η εργασία σας είναι να ανιχνεύσετε αν σε οποιοδήποτε σημείο το υπόλοιπο του λογαριασμού πέσει κάτω από το μηδέν, και σε αυτό το σημείο η συνάρτηση θα πρέπει να επιστρέψει True. Διαφορετικά θα πρέπει να επιστρέψει False.\n    ", "natural_language": "Greek"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Για μια δεδομένη λίστα ακεραίων, επιστρέψτε ένα tuple που αποτελείται από το άθροισμα και το γινόμενο όλων των ακεραίων στη λίστα.\nΤο άθροισμα της κενής λίστας πρέπει να είναι ίσο με 0 και το γινόμενο της κενής λίστας πρέπει να είναι ίσο με 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Για μια δεδομένη λίστα ακεραίων, επιστρέψτε ένα tuple που αποτελείται από το άθροισμα και το γινόμενο όλων των ακεραίων στη λίστα.\nΤο άθροισμα της κενής λίστας πρέπει να είναι ίσο με 0 και το γινόμενο της κενής λίστας πρέπει να είναι ίσο με 1.\n    ", "natural_language": "Greek"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Τα εισαγόμενα είναι δύο συμβολοσειρές a και b που αποτελούνται μόνο από 1s και 0s.\n    Εκτελέστε δυαδικό XOR σε αυτές τις εισόδους και επιστρέψτε το αποτέλεσμα επίσης ως συμβολοσειρά.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "Τα εισαγόμενα είναι δύο συμβολοσειρές a και b που αποτελούνται μόνο από 1s και 0s.\n    Εκτελέστε δυαδικό XOR σε αυτές τις εισόδους και επιστρέψτε το αποτέλεσμα επίσης ως συμβολοσειρά.\n    ", "natural_language": "Greek"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Από μια λίστα από αλφαριθμητικά, επιστρέψτε το μακρύτερο. Επιστρέψτε το πρώτο στην περίπτωση πολλαπλών αλφαριθμητικών με το ίδιο μήκος. Επιστρέψτε null στην περίπτωση που η εισαγωγική λίστα είναι άδεια.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "Από μια λίστα από αλφαριθμητικά, επιστρέψτε το μακρύτερο. Επιστρέψτε το πρώτο στην περίπτωση πολλαπλών αλφαριθμητικών με το ίδιο μήκος. Επιστρέψτε null στην περίπτωση που η εισαγωγική λίστα είναι άδεια.\n    ", "natural_language": "Greek"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Επιστροφή του μεγαλύτερου κοινού διαιρέτη δύο ακεραίων αριθμών a και b.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Επιστροφή του μεγαλύτερου κοινού διαιρέτη δύο ακεραίων αριθμών a και b.\n    ", "natural_language": "Greek"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Η είσοδος είναι μια συμβολοσειρά διαχωρισμένη με κενό από αριθμητικά χαρακτήρες από το 'μηδέν' έως το 'εννέα'.\n    Οι έγκυρες επιλογές είναι 'μηδέν', 'ένα', 'δύο', 'τρία', 'τέσσερα', 'πέντε', 'έξι', 'επτά', 'οκτώ' και 'εννέα'.\n    Επιστρέψτε τη συμβολοσειρά με τους αριθμούς ταξινομημένους από τον μικρότερο στον μεγαλύτερο.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "Η είσοδος είναι μια συμβολοσειρά διαχωρισμένη με κενό από αριθμητικά χαρακτήρες από το 'μηδέν' έως το 'εννέα'.\n    Οι έγκυρες επιλογές είναι 'μηδέν', 'ένα', 'δύο', 'τρία', 'τέσσερα', 'πέντε', 'έξι', 'επτά', 'οκτώ' και 'εννέα'.\n    Επιστρέψτε τη συμβολοσειρά με τους αριθμούς ταξινομημένους από τον μικρότερο στον μεγαλύτερο.\n    ", "natural_language": "Greek"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Δεδομένης μιας λίστας αριθμών (τουλάχιστον δύο στοιχείων), εφαρμόστε μια γραμμική μετασχηματιστική λειτουργία σε αυτήν τη λίστα, έτσι ώστε ο μικρότερος αριθμός να γίνει 0 και ο μεγαλύτερος να γίνει 1.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Δεδομένης μιας λίστας αριθμών (τουλάχιστον δύο στοιχείων), εφαρμόστε μια γραμμική μετασχηματιστική λειτουργία σε αυτήν τη λίστα, έτσι ώστε ο μικρότερος αριθμός να γίνει 0 και ο μεγαλύτερος να γίνει 1.\n    ", "natural_language": "Greek"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Για μια δεδομένη συμβολοσειρά, αντιστρέψτε τους πεζούς χαρακτήρες σε κεφαλαίους και τους κεφαλαίους σε πεζούς.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Για μια δεδομένη συμβολοσειρά, αντιστρέψτε τους πεζούς χαρακτήρες σε κεφαλαίους και τους κεφαλαίους σε πεζούς.\n    ", "natural_language": "Greek"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Επιστρέψτε μόνο θετικούς αριθμούς στη λίστα.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Επιστρέψτε μόνο θετικούς αριθμούς στη λίστα.\n    ", "natural_language": "Greek"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Επιστρέφει αληθές αν ένας δεδομένος αριθμός είναι πρώτος και ψευδές σε διαφορετική περίπτωση.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Επιστρέφει αληθές αν ένας δεδομένος αριθμός είναι πρώτος και ψευδές σε διαφορετική περίπτωση.\n    ", "natural_language": "Greek"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Επιστροφή ταξινομημένων μοναδικών στοιχείων σε μια λίστα.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Επιστροφή ταξινομημένων μοναδικών στοιχείων σε μια λίστα.\n    ", "natural_language": "Greek"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    Η prime_fib επιστρέφει τον n-οστό αριθμό που είναι Fibonacci και είναι επίσης πρώτος.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "Η prime_fib επιστρέφει τον n-οστό αριθμό που είναι Fibonacci και είναι επίσης πρώτος.\n    ", "natural_language": "Greek"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    Η triples_sum_to_zero λαμβάνει μια λίστα ακεραίων ως είσοδο.\n    επιστρέφει True αν υπάρχουν τρία διακριτά στοιχεία στη λίστα που\n    άθροισμα τους είναι μηδέν, και False διαφορετικά.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "Η triples_sum_to_zero λαμβάνει μια λίστα ακεραίων ως είσοδο.\n    επιστρέφει True αν υπάρχουν τρία διακριτά στοιχεία στη λίστα που\n    άθροισμα τους είναι μηδέν, και False διαφορετικά.\n    ", "natural_language": "Greek"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    Η συνάρτηση pairs_sum_to_zero παίρνει μια λίστα ακεραίων ως είσοδο.\n    Επιστρέφει True αν υπάρχουν δύο διακριτά στοιχεία στη λίστα που\n    έχουν άθροισμα μηδέν, και False αλλιώς.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "Η συνάρτηση pairs_sum_to_zero παίρνει μια λίστα ακεραίων ως είσοδο.\n    Επιστρέφει True αν υπάρχουν δύο διακριτά στοιχεία στη λίστα που\n    έχουν άθροισμα μηδέν, και False αλλιώς.\n    ", "natural_language": "Greek"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Η ακολουθία αριθμών Fib4 είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Παρακαλούμε γράψτε μια συνάρτηση για τον αποτελεσματικό υπολογισμό του n-οστού στοιχείου της ακολουθίας Fib4. Μην χρησιμοποιήσετε αναδρομή.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "Η ακολουθία αριθμών Fib4 είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Παρακαλούμε γράψτε μια συνάρτηση για τον αποτελεσματικό υπολογισμό του n-οστού στοιχείου της ακολουθίας Fib4. Μην χρησιμοποιήσετε αναδρομή.\n    ", "natural_language": "Greek"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Επιστροφή της μεσαίας τιμής των στοιχείων στη λίστα l.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Επιστροφή της μεσαίας τιμής των στοιχείων στη λίστα l.\n    ", "natural_language": "Greek"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Ελέγχει αν η δοθείσα συμβολοσειρά είναι παλίνδρομη.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Ελέγχει αν η δοθείσα συμβολοσειρά είναι παλίνδρομη.\n    ", "natural_language": "Greek"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    Η remove_vowels είναι μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει το αλφαριθμητικό χωρίς φωνήεντα.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "Η remove_vowels είναι μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει το αλφαριθμητικό χωρίς φωνήεντα.\n    ", "natural_language": "Greek"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Επιστρέφει True αν όλοι οι αριθμοί στη λίστα l είναι κάτω από το κατώφλι t.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Επιστρέφει True αν όλοι οι αριθμοί στη λίστα l είναι κάτω από το κατώφλι t.\n    ", "natural_language": "Greek"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Προσθέστε δύο αριθμούς x και y.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Προσθέστε δύο αριθμούς x και y.\n    ", "natural_language": "Greek"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Ελέγξτε αν δύο λέξεις έχουν τους ίδιους χαρακτήρες.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Ελέγξτε αν δύο λέξεις έχουν τους ίδιους χαρακτήρες.\n    ", "natural_language": "Greek"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Επιστροφή του n-οστού αριθμού Fibonacci.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Επιστροφή του n-οστού αριθμού Fibonacci.\n    ", "natural_language": "Greek"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Επιστροφή ταξινομημένων μοναδικών κοινών στοιχείων για δύο λίστες.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Επιστροφή ταξινομημένων μοναδικών κοινών στοιχείων για δύο λίστες.\n    ", "natural_language": "Greek"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Επιστρέφει το μεγαλύτερο πρώτο παράγοντα του n. Υποθέτουμε ότι το n > 1 και δεν είναι πρώτος.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Επιστρέφει το μεγαλύτερο πρώτο παράγοντα του n. Υποθέτουμε ότι το n > 1 και δεν είναι πρώτος.\n    ", "natural_language": "Greek"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"Η sum_to_n είναι μια συνάρτηση που αθροίζει αριθμούς από το 1 έως το n.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "Η sum_to_n είναι μια συνάρτηση που αθροίζει αριθμούς από το 1 έως το n.\n    ", "natural_language": "Greek"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" Οι xs αντιπροσωπεύουν τους συντελεστές ενός πολυωνύμου.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Επιστρέφει την παράγωγο αυτού του πολυωνύμου στην ίδια μορφή.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "Οι xs αντιπροσωπεύουν τους συντελεστές ενός πολυωνύμου.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Επιστρέφει την παράγωγο αυτού του πολυωνύμου στην ίδια μορφή.\n    ", "natural_language": "Greek"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"Η ακολουθία αριθμών FibFib είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Παρακαλούμε γράψτε μια συνάρτηση για τον αποδοτικό υπολογισμό του n-οστού στοιχείου της ακολουθίας αριθμών FibFib.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "Η ακολουθία αριθμών FibFib είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Παρακαλούμε γράψτε μια συνάρτηση για τον αποδοτικό υπολογισμό του n-οστού στοιχείου της ακολουθίας αριθμών FibFib.\n    ", "natural_language": "Greek"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Γράψτε μια συνάρτηση vowels_count η οποία παίρνει ως είσοδο μια συμβολοσειρά που αναπαριστά ένα λέξη και επιστρέφει τον αριθμό των φωνηέντων στη συμβολοσειρά. Τα φωνήεντα σε αυτήν την περίπτωση είναι 'a', 'e', 'i', 'o', 'u'. Εδώ, το 'y' είναι επίσης ένα φωνήεν, αλλά μόνο όταν βρίσκεται στο τέλος της δοθείσας λέξης.\n\n    Παράδειγμα:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Γράψτε μια συνάρτηση vowels_count η οποία παίρνει ως είσοδο μια συμβολοσειρά που αναπαριστά ένα λέξη και επιστρέφει τον αριθμό των φωνηέντων στη συμβολοσειρά. Τα φωνήεντα σε αυτήν την περίπτωση είναι 'a', 'e', 'i', 'o', 'u'. Εδώ, το 'y' είναι επίσης ένα φωνήεν, αλλά μόνο όταν βρίσκεται στο τέλος της δοθείσας λέξης.\n\n    Παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Σας δίνεται μια μη κενή λίστα θετικών ακεραίων. Επιστρέψτε το μεγαλύτερο ακέραιο που είναι μεγαλύτερο από το μηδέν και έχει συχνότητα μεγαλύτερη ή ίση με την τιμή του ακεραίου. Η συχνότητα ενός ακεραίου είναι ο αριθμός των φορών που εμφανίζεται στη λίστα. Εάν δεν υπάρχει τέτοια τιμή, επιστρέψτε -1. Παραδείγματα:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Σας δίνεται μια μη κενή λίστα θετικών ακεραίων. Επιστρέψτε το μεγαλύτερο ακέραιο που είναι μεγαλύτερο από το μηδέν και έχει συχνότητα μεγαλύτερη ή ίση με την τιμή του ακεραίου. Η συχνότητα ενός ακεραίου είναι ο αριθμός των φορών που εμφανίζεται στη λίστα. Εάν δεν υπάρχει τέτοια τιμή, επιστρέψτε -1. Παραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέψτε την περιοχή του τριγώνου στρογγυλοποιημένη στα 2 δεκαδικά ψηφία αν οι τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο. Διαφορετικά, επιστρέψτε -1. Τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο όταν το άθροισμα οποιωνδήποτε δύο πλευρών είναι μεγαλύτερο από την τρίτη πλευρά. Παράδειγμα:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέψτε την περιοχή του τριγώνου στρογγυλοποιημένη στα 2 δεκαδικά ψηφία αν οι τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο. Διαφορετικά, επιστρέψτε -1. Τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο όταν το άθροισμα οποιωνδήποτε δύο πλευρών είναι μεγαλύτερο από την τρίτη πλευρά. Παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Γράψτε μια συνάρτηση που επιστρέφει True αν το αντικείμενο q θα πετάξει, και False αλλιώς.\nΤο αντικείμενο q θα πετάξει αν είναι ισορροπημένο (είναι παλινδρομική λίστα) και άθροισμα των στοιχείων του είναι μικρότερο ή ίσο του μέγιστου δυνατού βάρους w.\n\n    Παράδειγμα:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 είναι μικρότερο από το μέγιστο δυνατό βάρος, αλλά δεν είναι ισορροπημένο.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# είναι ισορροπημένο, αλλά 3+2+3 είναι περισσότερο από το μέγιστο δυνατό βάρος.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n\n    will_it_fly([3], 5) ➞ True\n# 3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Γράψτε μια συνάρτηση που επιστρέφει True αν το αντικείμενο q θα πετάξει, και False αλλιώς.\nΤο αντικείμενο q θα πετάξει αν είναι ισορροπημένο (είναι παλινδρομική λίστα) και άθροισμα των στοιχείων του είναι μικρότερο ή ίσο του μέγιστου δυνατού βάρους w.\n\n    Παράδειγμα:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 είναι μικρότερο από το μέγιστο δυνατό βάρος, αλλά δεν είναι ισορροπημένο.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# είναι ισορροπημένο, αλλά 3+2+3 είναι περισσότερο από το μέγιστο δυνατό βάρος.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n\n    will_it_fly([3], 5) ➞ True\n# 3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n    ", "natural_language": "Greek"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Γράψτε μια συνάρτηση που επιστρέφει true αν το δοθέν αριθμός είναι το γινόμενο τριών πρώτων αριθμών και false σε διαφορετική περίπτωση.\n    Γνωρίζοντας ότι (α) είναι μικρότερο από το 100.\n    Παράδειγμα:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Γράψτε μια συνάρτηση που επιστρέφει true αν το δοθέν αριθμός είναι το γινόμενο τριών πρώτων αριθμών και false σε διαφορετική περίπτωση.\n    Γνωρίζοντας ότι (α) είναι μικρότερο από το 100.\n    Παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Θα σας δοθεί ένας αριθμός σε δεκαδική μορφή και η εργασία σας είναι να τον μετατρέψετε σε δυαδική μορφή. Η συνάρτηση θα πρέπει να επιστρέφει μια συμβολοσειρά, με κάθε χαρακτήρα που αντιπροσωπεύει ένα δυαδικό αριθμό. Κάθε χαρακτήρας στη συμβολοσειρά θα είναι '0' ή '1'.\n\n    Θα υπάρχουν μερικοί επιπλέον χαρακτήρες 'db' στην αρχή και στο τέλος της συμβολοσειράς. Οι επιπλέον χαρακτήρες είναι εκεί για να βοηθήσουν με τη μορφοποίηση.\n\n    Παραδείγματα:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Θα σας δοθεί ένας αριθμός σε δεκαδική μορφή και η εργασία σας είναι να τον μετατρέψετε σε δυαδική μορφή. Η συνάρτηση θα πρέπει να επιστρέφει μια συμβολοσειρά, με κάθε χαρακτήρα που αντιπροσωπεύει ένα δυαδικό αριθμό. Κάθε χαρακτήρας στη συμβολοσειρά θα είναι '0' ή '1'.\n\n    Θα υπάρχουν μερικοί επιπλέον χαρακτήρες 'db' στην αρχή και στο τέλος της συμβολοσειράς. Οι επιπλέον χαρακτήρες είναι εκεί για να βοηθήσουν με τη μορφοποίηση.\n\n    Παραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Σας δίνεται μια συμβολοσειρά s.\n    Η εργασία σας είναι να ελέγξετε αν η συμβολοσειρά είναι ευτυχισμένη ή όχι.\n    Μια συμβολοσειρά είναι ευτυχισμένη αν η μήκος της είναι τουλάχιστον 3 και κάθε 3 συνεχόμενα γράμματα είναι διαφορετικά.\n    Για παράδειγμα:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Σας δίνεται μια συμβολοσειρά s.\n    Η εργασία σας είναι να ελέγξετε αν η συμβολοσειρά είναι ευτυχισμένη ή όχι.\n    Μια συμβολοσειρά είναι ευτυχισμένη αν η μήκος της είναι τουλάχιστον 3 και κάθε 3 συνεχόμενα γράμματα είναι διαφορετικά.\n    Για παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Είναι η τελευταία εβδομάδα του εξαμήνου και ο καθηγητής πρέπει να δώσει τους βαθμούς στους μαθητές. Ο καθηγητής έχει δημιουργήσει το δικό του αλγόριθμο για τη βαθμολογία. Το μόνο πρόβλημα είναι ότι έχασε τον κώδικα που χρησιμοποιούσε για τη βαθμολογία. Σας έχει δώσει μια λίστα με τα GPA για μερικούς μαθητές και πρέπει να γράψετε μια συνάρτηση που μπορεί να εξάγει μια λίστα με τις βαθμολογίες γραμμάτων χρησιμοποιώντας τον παρακάτω πίνακα:\n             GPA       |    Βαθμός γράμματος\n              4.0                Α+\n            > 3.7                Α \n            > 3.3                Α- \n            > 3.0                Β+\n            > 2.7                Β \n            > 2.3                Β-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                Ε\n    \n\n        Παράδειγμα:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "Είναι η τελευταία εβδομάδα του εξαμήνου και ο καθηγητής πρέπει να δώσει τους βαθμούς στους μαθητές. Ο καθηγητής έχει δημιουργήσει το δικό του αλγόριθμο για τη βαθμολογία. Το μόνο πρόβλημα είναι ότι έχασε τον κώδικα που χρησιμοποιούσε για τη βαθμολογία. Σας έχει δώσει μια λίστα με τα GPA για μερικούς μαθητές και πρέπει να γράψετε μια συνάρτηση που μπορεί να εξάγει μια λίστα με τις βαθμολογίες γραμμάτων χρησιμοποιώντας τον παρακάτω πίνακα:\n             GPA       |    Βαθμός γράμματος\n              4.0                Α+\n            > 3.7                Α \n            > 3.3                Α- \n            > 3.0                Β+\n            > 2.7                Β \n            > 2.3                Β-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                Ε\n    \n\n        Παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Γράψτε μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει True αν το μήκος του αλφαριθμητικού είναι πρώτος αριθμός ή False αλλιώς. Παραδείγματα.\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Γράψτε μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει True αν το μήκος του αλφαριθμητικού είναι πρώτος αριθμός ή False αλλιώς. Παραδείγματα.\n    ", "natural_language": "Greek"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Δεδομένου ενός θετικού ακεραίου N, επιστρέφεται το συνολικό άθροισμα των ψηφίων του σε δυαδική μορφή.\n\n        Παράδειγμα\n        Για N = 1000, το άθροισμα των ψηφίων θα είναι 1 και η έξοδος θα πρέπει να είναι \"1\".\n        Για N = 150, το άθροισμα των ψηφίων θα είναι 6 και η έξοδος θα πρέπει να είναι \"110\".\n        Για N = 147, το άθροισμα των ψηφίων θα είναι 12 και η έξοδος θα πρέπει να είναι \"1100\".\n    \n    Μεταβλητές:\n        @N ακέραιος\n             Περιορισμοί: 0 ≤ N ≤ 10000.\n    Έξοδος:\n         μια συμβολοσειρά δυαδικού αριθμού\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Δεδομένου ενός θετικού ακεραίου N, επιστρέφεται το συνολικό άθροισμα των ψηφίων του σε δυαδική μορφή.\n\n        Παράδειγμα\n        Για N = 1000, το άθροισμα των ψηφίων θα είναι 1 και η έξοδος θα πρέπει να είναι \"1\".\n        Για N = 150, το άθροισμα των ψηφίων θα είναι 6 και η έξοδος θα πρέπει να είναι \"110\".\n        Για N = 147, το άθροισμα των ψηφίων θα είναι 12 και η έξοδος θα πρέπει να είναι \"1100\".\n    \n    Μεταβλητές:\n        @N ακέραιος\n             Περιορισμοί: 0 ≤ N ≤ 10000.\n    Έξοδος:\n         μια συμβολοσειρά δυαδικού αριθμού\n    ", "natural_language": "Greek"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Σας δίνεται μια δισδιάστατη δομή δεδομένων, ως εμφωλευμένες λίστες, που είναι παρόμοια με μια πίνακα, αλλά, αντίθετα από τους πίνακες, κάθε γραμμή μπορεί να περιέχει διαφορετικό αριθμό στηλών. Δεδομένης της λίστας lst και του ακεραίου x, βρείτε τους ακεραίους x στη λίστα και επιστρέψτε μια λίστα από tuples, [(x1, y1), (x2, y2) ...] ώστε κάθε tuple να είναι μια συντεταγμένη - (γραμμή, στήλες), ξεκινώντας από το 0. Ταξινομήστε αρχικά τις συντεταγμένες ανά γραμμή με αύξουσα σειρά. Επίσης, ταξινομήστε τις συντεταγμένες της γραμμής με φθίνουσα σειρά.\n\n    Παραδείγματα:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Σας δίνεται μια δισδιάστατη δομή δεδομένων, ως εμφωλευμένες λίστες, που είναι παρόμοια με μια πίνακα, αλλά, αντίθετα από τους πίνακες, κάθε γραμμή μπορεί να περιέχει διαφορετικό αριθμό στηλών. Δεδομένης της λίστας lst και του ακεραίου x, βρείτε τους ακεραίους x στη λίστα και επιστρέψτε μια λίστα από tuples, [(x1, y1), (x2, y2) ...] ώστε κάθε tuple να είναι μια συντεταγμένη - (γραμμή, στήλες), ξεκινώντας από το 0. Ταξινομήστε αρχικά τις συντεταγμένες ανά γραμμή με αύξουσα σειρά. Επίσης, ταξινομήστε τις συντεταγμένες της γραμμής με φθίνουσα σειρά.\n\n    Παραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Σας δίνεται μια λίστα ακεραίων.\nΓράψτε μια συνάρτηση next_smallest() που επιστρέφει τον δεύτερο μικρότερο στοιχείο της λίστας.\nΕπιστρέψτε null αν δεν υπάρχει τέτοιο στοιχείο.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Σας δίνεται μια λίστα ακεραίων.\nΓράψτε μια συνάρτηση next_smallest() που επιστρέφει τον δεύτερο μικρότερο στοιχείο της λίστας.\nΕπιστρέψτε null αν δεν υπάρχει τέτοιο στοιχείο.\n    ", "natural_language": "Greek"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Θα σας δοθεί μια συμβολοσειρά λέξεων και η εργασία σας είναι να μετρήσετε τον αριθμό των βαρεμάρων. Μια βαρεμάρα είναι μια πρόταση που ξεκινά με τη λέξη \"Εγώ\". Οι προτάσεις διαχωρίζονται μεταξύ τους με '.' , '?' ή '!'.\n\n    Για παράδειγμα:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Θα σας δοθεί μια συμβολοσειρά λέξεων και η εργασία σας είναι να μετρήσετε τον αριθμό των βαρεμάρων. Μια βαρεμάρα είναι μια πρόταση που ξεκινά με τη λέξη \"Εγώ\". Οι προτάσεις διαχωρίζονται μεταξύ τους με '.' , '?' ή '!'.\n\n    Για παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Σας δίνεται μια λίστα ακεραίων.\n    Πρέπει να βρείτε τη μεγαλύτερη πρώτη τιμή και να επιστρέψετε το άθροισμα των ψηφίων της.\n\n        Παραδείγματα:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Σας δίνεται μια λίστα ακεραίων.\n    Πρέπει να βρείτε τη μεγαλύτερη πρώτη τιμή και να επιστρέψετε το άθροισμα των ψηφίων της.\n\n        Παραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Δεδομένου ενός λεξικού, επιστρέψτε True αν όλα τα κλειδιά είναι συμβολοσειρές σε πεζά γράμματα ή όλα τα κλειδιά είναι συμβολοσειρές σε κεφαλαία γράμματα, αλλιώς επιστρέψτε False. Η συνάρτηση πρέπει να επιστρέφει False αν το δοσμένο λεξικό είναι κενό. Παραδείγματα:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Δεδομένου ενός λεξικού, επιστρέψτε True αν όλα τα κλειδιά είναι συμβολοσειρές σε πεζά γράμματα ή όλα τα κλειδιά είναι συμβολοσειρές σε κεφαλαία γράμματα, αλλιώς επιστρέψτε False. Η συνάρτηση πρέπει να επιστρέφει False αν το δοσμένο λεξικό είναι κενό. Παραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Δημιουργήστε μια συνάρτηση που παίρνει μια τιμή (συμβολοσειρά) που αναπαριστά έναν αριθμό και επιστρέφει τον πλησιέστερο ακέραιο αριθμό σε αυτόν. Εάν ο αριθμός είναι ισοαπόστακτος από δύο ακεραίους, στρογγυλοποιήστε τον μακριά από το μηδέν.\n\n    Παραδείγματα\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Δημιουργήστε μια συνάρτηση που παίρνει μια τιμή (συμβολοσειρά) που αναπαριστά έναν αριθμό και επιστρέφει τον πλησιέστερο ακέραιο αριθμό σε αυτόν. Εάν ο αριθμός είναι ισοαπόστακτος από δύο ακεραίους, στρογγυλοποιήστε τον μακριά από το μηδέν.\n\n    Παραδείγματα\n    ", "natural_language": "Greek"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Δεδομένου ενός θετικού ακεραίου n, πρέπει να φτιάξετε ένα σωρό από n επίπεδα πέτρες.\n    Το πρώτο επίπεδο έχει n πέτρες.\n    Ο αριθμός των πετρών στο επόμενο επίπεδο είναι:\n        - ο επόμενος μονός αριθμός αν το n είναι περιττός.\n        - ο επόμενος άρτιος αριθμός αν το n είναι άρτιος.\n    Επιστρέψτε τον αριθμό των πετρών σε κάθε επίπεδο σε μια λίστα, όπου το στοιχείο στη θέση\n    i αντιπροσωπεύει τον αριθμό των πετρών στο επίπεδο (i + 1).\n\n        Παραδείγματα:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Δεδομένου ενός θετικού ακεραίου n, πρέπει να φτιάξετε ένα σωρό από n επίπεδα πέτρες.\n    Το πρώτο επίπεδο έχει n πέτρες.\n    Ο αριθμός των πετρών στο επόμενο επίπεδο είναι:\n        - ο επόμενος μονός αριθμός αν το n είναι περιττός.\n        - ο επόμενος άρτιος αριθμός αν το n είναι άρτιος.\n    Επιστρέψτε τον αριθμό των πετρών σε κάθε επίπεδο σε μια λίστα, όπου το στοιχείο στη θέση\n    i αντιπροσωπεύει τον αριθμό των πετρών στο επίπεδο (i + 1).\n\n        Παραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Θα σας δοθεί μια συμβολοσειρά λέξεων που χωρίζονται με κόμματα ή κενά. Η εργασία σας είναι να χωρίσετε τη συμβολοσειρά σε λέξεις και να επιστρέψετε έναν πίνακα με τις λέξεις.\n\n    Για παράδειγμα:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Θα σας δοθεί μια συμβολοσειρά λέξεων που χωρίζονται με κόμματα ή κενά. Η εργασία σας είναι να χωρίσετε τη συμβολοσειρά σε λέξεις και να επιστρέψετε έναν πίνακα με τις λέξεις.\n\n    Για παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Αυτή η συνάρτηση παίρνει δύο θετικούς αριθμούς x και y και επιστρέφει το μεγαλύτερο άρτιο ακέραιο αριθμό που βρίσκεται στο διάστημα [x, y] συμπεριλαμβανομένου. Εάν δεν υπάρχει τέτοιος αριθμός, η συνάρτηση θα πρέπει να επιστρέψει -1.\n\n    Για παράδειγμα:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Αυτή η συνάρτηση παίρνει δύο θετικούς αριθμούς x και y και επιστρέφει το μεγαλύτερο άρτιο ακέραιο αριθμό που βρίσκεται στο διάστημα [x, y] συμπεριλαμβανομένου. Εάν δεν υπάρχει τέτοιος αριθμός, η συνάρτηση θα πρέπει να επιστρέψει -1.\n\n    Για παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Σας δίνονται δύο θετικοί ακέραιοι αριθμοί n και m, και η εργασία σας είναι να υπολογίσετε τον μέσο όρο των ακεραίων από το n έως το m (συμπεριλαμβανομένων του n και του m). Στρογγυλοποιήστε την απάντηση στον πλησιέστερο ακέραιο και μετατρέψτε τον σε δυαδικό. Εάν το n είναι μεγαλύτερο από το m, επιστρέψτε -1. Παράδειγμα:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Σας δίνονται δύο θετικοί ακέραιοι αριθμοί n και m, και η εργασία σας είναι να υπολογίσετε τον μέσο όρο των ακεραίων από το n έως το m (συμπεριλαμβανομένων του n και του m). Στρογγυλοποιήστε την απάντηση στον πλησιέστερο ακέραιο και μετατρέψτε τον σε δυαδικό. Εάν το n είναι μεγαλύτερο από το m, επιστρέψτε -1. Παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Υλοποιήστε τη συνάρτηση f που παίρνει το n ως παράμετρο και επιστρέφει μια λίστα μεγέθους n, όπου η τιμή του στοιχείου στη θέση i είναι το παραγοντικό του i αν είναι άρτιος ή άθροισμα αριθμών από 1 έως i αλλιώς. Το i ξεκινά από 1. Το παραγοντικό του i είναι ο πολλαπλασιασμός των αριθμών από 1 έως i (1 * 2 * ... * i). Παράδειγμα:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Υλοποιήστε τη συνάρτηση f που παίρνει το n ως παράμετρο και επιστρέφει μια λίστα μεγέθους n, όπου η τιμή του στοιχείου στη θέση i είναι το παραγοντικό του i αν είναι άρτιος ή άθροισμα αριθμών από 1 έως i αλλιώς. Το i ξεκινά από 1. Το παραγοντικό του i είναι ο πολλαπλασιασμός των αριθμών από 1 έως i (1 * 2 * ... * i). Παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Δεδομένου ενός θετικού ακεραίου n, επιστρέφεται ένα tuple που περιέχει τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών που βρίσκονται στο εύρος (1, n), συμπεριλαμβανομένου του n.\n\n        Παράδειγμα 1:\n\n            Είσοδος: 3\n        Έξοδος: (1, 2)\n        Εξήγηση:\n        Οι παλινδρομικοί αριθμοί είναι 1, 2, 3. Ένας από αυτούς είναι άρτιος και δύο είναι περιττοί.\n\n        Παράδειγμα 2:\n\n            Είσοδος: 12\n        Έξοδος: (4, 6)\n        Εξήγηση:\n        Οι παλινδρομικοί αριθμοί είναι 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Τέσσερις από αυτούς είναι άρτιοι και έξι είναι περιττοί.\n\n        Σημείωση:\n        1. 1 <= n <= 10^3\n        2. Το επιστρεφόμενο tuple περιέχει αντίστοιχα τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Δεδομένου ενός θετικού ακεραίου n, επιστρέφεται ένα tuple που περιέχει τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών που βρίσκονται στο εύρος (1, n), συμπεριλαμβανομένου του n.\n\n        Παράδειγμα 1:\n\n            Είσοδος: 3\n        Έξοδος: (1, 2)\n        Εξήγηση:\n        Οι παλινδρομικοί αριθμοί είναι 1, 2, 3. Ένας από αυτούς είναι άρτιος και δύο είναι περιττοί.\n\n        Παράδειγμα 2:\n\n            Είσοδος: 12\n        Έξοδος: (4, 6)\n        Εξήγηση:\n        Οι παλινδρομικοί αριθμοί είναι 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Τέσσερις από αυτούς είναι άρτιοι και έξι είναι περιττοί.\n\n        Σημείωση:\n        1. 1 <= n <= 10^3\n        2. Το επιστρεφόμενο tuple περιέχει αντίστοιχα τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών.\n    ", "natural_language": "Greek"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Έχουμε έναν πίνακα 'arr' από N ακεραίους arr[1], arr[2], ..., arr[N]. Οι αριθμοί στον πίνακα θα είναι τυχαία ταξινομημένοι. Η εργασία σας είναι να καθορίσετε εάν είναι δυνατόν να λάβετε έναν ταξινομημένο πίνακα σε μη φθίνουσα σειρά εκτελώντας την ακόλουθη λειτουργία στον δοσμένο πίνακα:\n        Σας επιτρέπεται να εκτελέσετε τη λειτουργία μετατόπισης δεξιά οποιοδήποτε αριθμό φορών.\n    \n    Μια λειτουργία μετατόπισης δεξιά σημαίνει τη μετατόπιση όλων των στοιχείων του πίνακα κατά ένα θέση προς τη δεξιά κατεύθυνση. Το τελευταίο στοιχείο του πίνακα θα μετακινηθεί στην αρχική θέση στον πίνακα, δηλαδή στη θέση 0. \n\n        Εάν είναι δυνατόν να λάβετε τον ταξινομημένο πίνακα εκτελώντας την παραπάνω λειτουργία, τότε επιστρέψτε True, αλλιώς επιστρέψτε False.\n    Εάν ο δοσμένος πίνακας είναι κενός, τότε επιστρέψτε True.\n\n        Σημείωση: Εγγυόμαστε ότι ο δοσμένος πίνακας θα έχει μοναδικά στοιχεία.\n\n        Για παράδειγμα:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Εξήγηση: Εκτελώντας 2 λειτουργίες μετατόπισης δεξιά, μπορεί να επιτευχθεί μη φθίνουσα σειρά για τον δοσμένο πίνακα.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Εξήγηση: Δεν είναι δυνατόν να λάβετε μη φθίνουσα σειρά για τον δοσμένο πίνακα εκτελώντας οποιονδήποτε αριθμό λειτουργιών μετατόπισης δεξιά.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Έχουμε έναν πίνακα 'arr' από N ακεραίους arr[1], arr[2], ..., arr[N]. Οι αριθμοί στον πίνακα θα είναι τυχαία ταξινομημένοι. Η εργασία σας είναι να καθορίσετε εάν είναι δυνατόν να λάβετε έναν ταξινομημένο πίνακα σε μη φθίνουσα σειρά εκτελώντας την ακόλουθη λειτουργία στον δοσμένο πίνακα:\n        Σας επιτρέπεται να εκτελέσετε τη λειτουργία μετατόπισης δεξιά οποιοδήποτε αριθμό φορών.\n    \n    Μια λειτουργία μετατόπισης δεξιά σημαίνει τη μετατόπιση όλων των στοιχείων του πίνακα κατά ένα θέση προς τη δεξιά κατεύθυνση. Το τελευταίο στοιχείο του πίνακα θα μετακινηθεί στην αρχική θέση στον πίνακα, δηλαδή στη θέση 0. \n\n        Εάν είναι δυνατόν να λάβετε τον ταξινομημένο πίνακα εκτελώντας την παραπάνω λειτουργία, τότε επιστρέψτε True, αλλιώς επιστρέψτε False.\n    Εάν ο δοσμένος πίνακας είναι κενός, τότε επιστρέψτε True.\n\n        Σημείωση: Εγγυόμαστε ότι ο δοσμένος πίνακας θα έχει μοναδικά στοιχεία.\n\n        Για παράδειγμα:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Εξήγηση: Εκτελώντας 2 λειτουργίες μετατόπισης δεξιά, μπορεί να επιτευχθεί μη φθίνουσα σειρά για τον δοσμένο πίνακα.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Εξήγηση: Δεν είναι δυνατόν να λάβετε μη φθίνουσα σειρά για τον δοσμένο πίνακα εκτελώντας οποιονδήποτε αριθμό λειτουργιών μετατόπισης δεξιά.\n    ", "natural_language": "Greek"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Σε αυτό το πρόβλημα, θα υλοποιήσετε μια συνάρτηση που παίρνει δύο λίστες αριθμών και καθορίζει εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ τους για να κάνει την lst1 μια λίστα μόνο με άρτιους αριθμούς. Δεν υπάρχει όριο στον αριθμό των ανταλλαγών στοιχείων μεταξύ lst1 και lst2. Εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ των lst1 και lst2 για να κάνει όλα τα στοιχεία της lst1 να είναι άρτια, επιστρέψτε \"YES\". Διαφορετικά, επιστρέψτε \"NO\". Για παράδειγμα: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\", exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Υποθέτειται ότι οι λίστες εισόδου θα είναι μη κενές.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "Σε αυτό το πρόβλημα, θα υλοποιήσετε μια συνάρτηση που παίρνει δύο λίστες αριθμών και καθορίζει εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ τους για να κάνει την lst1 μια λίστα μόνο με άρτιους αριθμούς. Δεν υπάρχει όριο στον αριθμό των ανταλλαγών στοιχείων μεταξύ lst1 και lst2. Εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ των lst1 και lst2 για να κάνει όλα τα στοιχεία της lst1 να είναι άρτια, επιστρέψτε \"YES\". Διαφορετικά, επιστρέψτε \"NO\". Για παράδειγμα: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\", exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Υποθέτειται ότι οι λίστες εισόδου θα είναι μη κενές.\n    ", "natural_language": "Greek"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Εργασία\n    Δίνονται δύο αλφαριθμητικά s και c, πρέπει να διαγράψετε όλους τους χαρακτήρες στο s που είναι ίσοι με οποιονδήποτε χαρακτήρα στο c\n    και στη συνέχεια να ελέγξετε αν το αποτέλεσμα είναι παλίνδρομο.\n    Ένα αλφαριθμητικό ονομάζεται παλίνδρομο αν διαβάζεται το ίδιο προς τα πίσω και προς τα εμπρός.\n    Θα πρέπει να επιστρέψετε ένα tuple που περιέχει το αποτέλεσμα αλφαριθμητικό και True/False για τον έλεγχο.\n    Παράδειγμα\n    Για s = \"abcde\", c = \"ae\", το αποτέλεσμα θα πρέπει να είναι ('bcd',False)\n    Για s = \"abcdef\", c = \"b\" το αποτέλεσμα θα πρέπει να είναι ('acdef',False)\n    Για s = \"abcdedcba\", c = \"ab\", το αποτέλεσμα θα πρέπει να είναι ('cdedc',True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Εργασία\n    Δίνονται δύο αλφαριθμητικά s και c, πρέπει να διαγράψετε όλους τους χαρακτήρες στο s που είναι ίσοι με οποιονδήποτε χαρακτήρα στο c\n    και στη συνέχεια να ελέγξετε αν το αποτέλεσμα είναι παλίνδρομο.\n    Ένα αλφαριθμητικό ονομάζεται παλίνδρομο αν διαβάζεται το ίδιο προς τα πίσω και προς τα εμπρός.\n    Θα πρέπει να επιστρέψετε ένα tuple που περιέχει το αποτέλεσμα αλφαριθμητικό και True/False για τον έλεγχο.\n    Παράδειγμα\n    Για s = \"abcde\", c = \"ae\", το αποτέλεσμα θα πρέπει να είναι ('bcd',False)\n    Για s = \"abcdef\", c = \"b\" το αποτέλεσμα θα πρέπει να είναι ('acdef',False)\n    Για s = \"abcdedcba\", c = \"ab\", το αποτέλεσμα θα πρέπει να είναι ('cdedc',True)\n    ", "natural_language": "Greek"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Σας δίνεται ένα ορθογώνιο πλέγμα από πηγάδια. Κάθε σειρά αντιπροσωπεύει ένα μόνο πηγάδι, και κάθε 1 σε μια σειρά αντιπροσωπεύει μια μονάδα νερού. Κάθε πηγάδι έχει ένα αντίστοιχο κουβά που μπορεί να χρησιμοποιηθεί για να αντλήσει νερό από αυτό, και όλοι οι κουβάδες έχουν την ίδια χωρητικότητα. Η εργασία σας είναι να χρησιμοποιήσετε τους κουβάδες για να αδειάσετε τα πηγάδια. Εξαγάγετε τον αριθμό των φορών που χρειάζεται να χαμηλώσετε τους κουβάδες.\n\n        Παράδειγμα 1:\n        Είσοδος:\n            grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            χωρητικότητα κουβά: 1\n        Έξοδος: 6\n\n        Παράδειγμα 2:\n        Είσοδος:\n            grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            χωρητικότητα κουβά: 2\n        Έξοδος: 5\n    \n    Παράδειγμα 3:\n        Είσοδος:\n            grid: [[0,0,0], [0,0,0]]\n            χωρητικότητα κουβά: 5\n        Έξοδος: 0\n\n        Περιορισμοί:\n        * όλα τα πηγάδια έχουν το ίδιο μήκος\n        * 1 <= μήκος πλέγματος <= 10^2\n        * 1 <= μήκος grid[:,1] <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= χωρητικότητα <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Σας δίνεται ένα ορθογώνιο πλέγμα από πηγάδια. Κάθε σειρά αντιπροσωπεύει ένα μόνο πηγάδι, και κάθε 1 σε μια σειρά αντιπροσωπεύει μια μονάδα νερού. Κάθε πηγάδι έχει ένα αντίστοιχο κουβά που μπορεί να χρησιμοποιηθεί για να αντλήσει νερό από αυτό, και όλοι οι κουβάδες έχουν την ίδια χωρητικότητα. Η εργασία σας είναι να χρησιμοποιήσετε τους κουβάδες για να αδειάσετε τα πηγάδια. Εξαγάγετε τον αριθμό των φορών που χρειάζεται να χαμηλώσετε τους κουβάδες.\n\n        Παράδειγμα 1:\n        Είσοδος:\n            grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            χωρητικότητα κουβά: 1\n        Έξοδος: 6\n\n        Παράδειγμα 2:\n        Είσοδος:\n            grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            χωρητικότητα κουβά: 2\n        Έξοδος: 5\n    \n    Παράδειγμα 3:\n        Είσοδος:\n            grid: [[0,0,0], [0,0,0]]\n            χωρητικότητα κουβά: 5\n        Έξοδος: 0\n\n        Περιορισμοί:\n        * όλα τα πηγάδια έχουν το ίδιο μήκος\n        * 1 <= μήκος πλέγματος <= 10^2\n        * 1 <= μήκος grid[:,1] <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= χωρητικότητα <= 10\n    ", "natural_language": "Greek"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Δεδομένου ενός αλφαριθμητικού s και ενός φυσικού αριθμού n, σας έχει ανατεθεί να υλοποιήσετε μια συνάρτηση που επιστρέφει μια λίστα με όλες τις λέξεις από το αλφαριθμητικό s που περιέχουν ακριβώς n σύμφωνα, με τη σειρά που εμφανίζονται στο αλφαριθμητικό s. Εάν το αλφαριθμητικό s είναι κενό, τότε η συνάρτηση θα πρέπει να επιστρέψει μια κενή λίστα. Σημείωση: μπορείτε να υποθέσετε ότι το εισαγόμενο αλφαριθμητικό περιέχει μόνο γράμματα και κενά. Παραδείγματα:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Δεδομένου ενός αλφαριθμητικού s και ενός φυσικού αριθμού n, σας έχει ανατεθεί να υλοποιήσετε μια συνάρτηση που επιστρέφει μια λίστα με όλες τις λέξεις από το αλφαριθμητικό s που περιέχουν ακριβώς n σύμφωνα, με τη σειρά που εμφανίζονται στο αλφαριθμητικό s. Εάν το αλφαριθμητικό s είναι κενό, τότε η συνάρτηση θα πρέπει να επιστρέψει μια κενή λίστα. Σημείωση: μπορείτε να υποθέσετε ότι το εισαγόμενο αλφαριθμητικό περιέχει μόνο γράμματα και κενά. Παραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Δεδομένου ενός πίνακα arr ακεραίων και ενός θετικού ακεραίου k, επιστρέφει μια ταξινομημένη λίστα μήκους k με τους μεγαλύτερους k αριθμούς στον πίνακα arr.\n\n        Παράδειγμα 1:\n\n            Είσοδος: arr = [-3, -4, 5], k = 3\n        Έξοδος: [-4, -3, 5]\n\n        Παράδειγμα 2:\n\n            Είσοδος: arr = [4, -4, 4], k = 2\n        Έξοδος: [4, 4]\n\n        Παράδειγμα 3:\n\n            Είσοδος: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Έξοδος: [2]\n\n        Σημείωση:\n        1. Το μήκος του πίνακα θα είναι στο εύρος [1, 1000].\n        2. Τα στοιχεία του πίνακα θα είναι στο εύρος [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Δεδομένου ενός πίνακα arr ακεραίων και ενός θετικού ακεραίου k, επιστρέφει μια ταξινομημένη λίστα μήκους k με τους μεγαλύτερους k αριθμούς στον πίνακα arr.\n\n        Παράδειγμα 1:\n\n            Είσοδος: arr = [-3, -4, 5], k = 3\n        Έξοδος: [-4, -3, 5]\n\n        Παράδειγμα 2:\n\n            Είσοδος: arr = [4, -4, 4], k = 2\n        Έξοδος: [4, 4]\n\n        Παράδειγμα 3:\n\n            Είσοδος: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Έξοδος: [2]\n\n        Σημείωση:\n        1. Το μήκος του πίνακα θα είναι στο εύρος [1, 1000].\n        2. Τα στοιχεία του πίνακα θα είναι στο εύρος [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    ", "natural_language": "Greek"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Δεδομένου ενός μη κενού πίνακα ακεραίων arr και ενός ακεραίου k, επιστρέφεται\n    το άθροισμα των στοιχείων με τουλάχιστον δύο ψηφία από τα πρώτα k στοιχεία του arr.\n\n        Παράδειγμα:\n\n            Είσοδος: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Έξοδος: 24 # άθροισμα των 21 + 3\n\n        Περιορισμοί:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Δεδομένου ενός μη κενού πίνακα ακεραίων arr και ενός ακεραίου k, επιστρέφεται\n    το άθροισμα των στοιχείων με τουλάχιστον δύο ψηφία από τα πρώτα k στοιχεία του arr.\n\n        Παράδειγμα:\n\n            Είσοδος: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Έξοδος: 24 # άθροισμα των 21 + 3\n\n        Περιορισμοί:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    ", "natural_language": "Greek"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Σας δίνονται δύο διαστήματα,\n    όπου κάθε διάστημα είναι ένα ζευγάρι ακεραίων. Για παράδειγμα, διάστημα = (αρχή, τέλος) = (1, 2).\n    Τα δεδομένα διαστήματα είναι κλειστά, που σημαίνει ότι το διάστημα (αρχή, τέλος)\n    περιλαμβάνει τόσο την αρχή όσο και το τέλος.\n    Για κάθε δοσμένο διάστημα, υποθέτεται ότι η αρχή του είναι μικρότερη ή ίση με το τέλος του.\n    Η εργασία σας είναι να καθορίσετε εάν το μήκος της τομής αυτών των δύο\n    διαστημάτων είναι ένας πρώτος αριθμός.\n    Για παράδειγμα, η τομή των διαστημάτων (1, 3), (2, 4) είναι (2, 3)\n    το οποίο το μήκος του είναι 1, που δεν είναι πρώτος αριθμός.\n    Εάν το μήκος της τομής είναι ένας πρώτος αριθμός, επιστρέψτε \"YES\",\n    διαφορετικά, επιστρέψτε \"NO\".\n    Εάν τα δύο διαστήματα δεν τέμνονται, επιστρέψτε \"NO\".\n\n    \n    [είσοδος/έξοδος] δείγματα:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Σας δίνονται δύο διαστήματα,\n    όπου κάθε διάστημα είναι ένα ζευγάρι ακεραίων. Για παράδειγμα, διάστημα = (αρχή, τέλος) = (1, 2).\n    Τα δεδομένα διαστήματα είναι κλειστά, που σημαίνει ότι το διάστημα (αρχή, τέλος)\n    περιλαμβάνει τόσο την αρχή όσο και το τέλος.\n    Για κάθε δοσμένο διάστημα, υποθέτεται ότι η αρχή του είναι μικρότερη ή ίση με το τέλος του.\n    Η εργασία σας είναι να καθορίσετε εάν το μήκος της τομής αυτών των δύο\n    διαστημάτων είναι ένας πρώτος αριθμός.\n    Για παράδειγμα, η τομή των διαστημάτων (1, 3), (2, 4) είναι (2, 3)\n    το οποίο το μήκος του είναι 1, που δεν είναι πρώτος αριθμός.\n    Εάν το μήκος της τομής είναι ένας πρώτος αριθμός, επιστρέψτε \"YES\",\n    διαφορετικά, επιστρέψτε \"NO\".\n    Εάν τα δύο διαστήματα δεν τέμνονται, επιστρέψτε \"NO\".\n\n    \n    [είσοδος/έξοδος] δείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Όλοι γνωρίζουν την ακολουθία του Fibonacci, η οποία μελετήθηκε βαθιά από μαθηματικούς τα τελευταία δύο αιώνες. Ωστόσο, αυτό που οι άνθρωποι δεν γνωρίζουν είναι η ακολουθία του Tribonacci. Η ακολουθία του Tribonacci ορίζεται από την επανάληψη:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, αν το n είναι ζυγός.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), αν το n είναι περιττό.\n    Για παράδειγμα:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    Σας δίνεται ένας μη αρνητικός ακέραιος αριθμός n, πρέπει να επιστρέψετε μια λίστα με τους πρώτους n + 1 αριθμούς της ακολουθίας του Tribonacci.\n    Παραδείγματα:\n    tri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Όλοι γνωρίζουν την ακολουθία του Fibonacci, η οποία μελετήθηκε βαθιά από μαθηματικούς τα τελευταία δύο αιώνες. Ωστόσο, αυτό που οι άνθρωποι δεν γνωρίζουν είναι η ακολουθία του Tribonacci. Η ακολουθία του Tribonacci ορίζεται από την επανάληψη:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, αν το n είναι ζυγός.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), αν το n είναι περιττό.\n    Για παράδειγμα:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    Σας δίνεται ένας μη αρνητικός ακέραιος αριθμός n, πρέπει να επιστρέψετε μια λίστα με τους πρώτους n + 1 αριθμούς της ακολουθίας του Tribonacci.\n    Παραδείγματα:\n    tri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Greek"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Δεδομένου ενός θετικού ακεραίου n, επιστρέφει το γινόμενο των μονών ψηφίων.\n    Επιστρέφει 0 αν όλα τα ψηφία είναι άρτια.\n    Για παράδειγμα:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Δεδομένου ενός θετικού ακεραίου n, επιστρέφει το γινόμενο των μονών ψηφίων.\n    Επιστρέφει 0 αν όλα τα ψηφία είναι άρτια.\n    Για παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Δημιουργήστε μια συνάρτηση που παίρνει μια συμβολοσειρά ως είσοδο η οποία περιέχει μόνο αγκύλες.\n    Η συνάρτηση θα πρέπει να επιστρέφει True μόνο αν υπάρχει μια έγκυρη υποακολουθία αγκυλών \n    όπου τουλάχιστον μια αγκύλη στην υποακολουθία είναι ενσωματωμένη.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Δημιουργήστε μια συνάρτηση που παίρνει μια συμβολοσειρά ως είσοδο η οποία περιέχει μόνο αγκύλες.\n    Η συνάρτηση θα πρέπει να επιστρέφει True μόνο αν υπάρχει μια έγκυρη υποακολουθία αγκυλών \n    όπου τουλάχιστον μια αγκύλη στην υποακολουθία είναι ενσωματωμένη.\n    ", "natural_language": "Greek"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Σας δίνεται μια λίστα αριθμών.\n    Χρειάζεστε να επιστρέψετε το άθροισμα των τετραγωνισμένων αριθμών στην δεδομένη λίστα,\n    στρογγυλοποιήστε κάθε στοιχείο στη λίστα στο ανώτατο ακέραιο (Ceiling) πρώτα.\n    Παραδείγματα:\n    Για lst = [1,2,3] η έξοδος πρέπει να είναι 14\n    Για lst = [1,4,9] η έξοδος πρέπει να είναι 98\n    Για lst = [1,3,5,7] η έξοδος πρέπει να είναι 84\n    Για lst = [1.4,4.2,0] η έξοδος πρέπει να είναι 29\n    Για lst = [-2.4,1,1] η έξοδος πρέπει να είναι 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Σας δίνεται μια λίστα αριθμών.\n    Χρειάζεστε να επιστρέψετε το άθροισμα των τετραγωνισμένων αριθμών στην δεδομένη λίστα,\n    στρογγυλοποιήστε κάθε στοιχείο στη λίστα στο ανώτατο ακέραιο (Ceiling) πρώτα.\n    Παραδείγματα:\n    Για lst = [1,2,3] η έξοδος πρέπει να είναι 14\n    Για lst = [1,4,9] η έξοδος πρέπει να είναι 98\n    Για lst = [1,3,5,7] η έξοδος πρέπει να είναι 84\n    Για lst = [1.4,4.2,0] η έξοδος πρέπει να είναι 29\n    Για lst = [-2.4,1,1] η έξοδος πρέπει να είναι 6\n    ", "natural_language": "Greek"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Δημιουργήστε μια συνάρτηση που επιστρέφει True αν ο τελευταίος χαρακτήρας\n    ενός δεδομένου string είναι αλφαβητικός χαρακτήρας και δεν είναι\n    μέρος ενός λέξης, και False αλλιώς.\n    Σημείωση: \"λέξη\" είναι μια ομάδα χαρακτήρων που χωρίζονται από κενό.\n\n        Παραδείγματα:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Δημιουργήστε μια συνάρτηση που επιστρέφει True αν ο τελευταίος χαρακτήρας\n    ενός δεδομένου string είναι αλφαβητικός χαρακτήρας και δεν είναι\n    μέρος ενός λέξης, και False αλλιώς.\n    Σημείωση: \"λέξη\" είναι μια ομάδα χαρακτήρων που χωρίζονται από κενό.\n\n        Παραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Δημιουργήστε μια συνάρτηση η οποία επιστρέφει το μεγαλύτερο δείκτη ενός στοιχείου που δεν είναι μεγαλύτερο ή ίσο από το στοιχείο που ακολουθεί αμέσως πριν από αυτό. Εάν δεν υπάρχει τέτοιο στοιχείο, τότε επιστρέψτε -1. Ο δοσμένος πίνακας δεν θα περιέχει διπλότυπες τιμές.\n\n    Παραδείγματα:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Δημιουργήστε μια συνάρτηση η οποία επιστρέφει το μεγαλύτερο δείκτη ενός στοιχείου που δεν είναι μεγαλύτερο ή ίσο από το στοιχείο που ακολουθεί αμέσως πριν από αυτό. Εάν δεν υπάρχει τέτοιο στοιχείο, τότε επιστρέψτε -1. Ο δοσμένος πίνακας δεν θα περιέχει διπλότυπες τιμές.\n\n    Παραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Δημιουργήστε μια συνάρτηση που επιστρέφει ένα tuple (a, b), όπου 'a' είναι ο μεγαλύτερος από τους αρνητικούς ακέραιους και 'b' είναι ο μικρότερος από τους θετικούς ακέραιους σε μια λίστα. Εάν δεν υπάρχουν αρνητικοί ή θετικοί ακέραιοι, επιστρέψτε τους ως None.\n\n    Παραδείγματα:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Δημιουργήστε μια συνάρτηση που επιστρέφει ένα tuple (a, b), όπου 'a' είναι ο μεγαλύτερος από τους αρνητικούς ακέραιους και 'b' είναι ο μικρότερος από τους θετικούς ακέραιους σε μια λίστα. Εάν δεν υπάρχουν αρνητικοί ή θετικοί ακέραιοι, επιστρέψτε τους ως None.\n\n    Παραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"Το βραζιλιάνικο παραγοντικό ορίζεται ως:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    όπου n > 0\n\n        Για παράδειγμα:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "Το βραζιλιάνικο παραγοντικό ορίζεται ως:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    όπου n > 0\n\n        Για παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Σας δίνεται μια συμβολοσειρά που αντιπροσωπεύει μια πρόταση,\n    η πρόταση περιέχει μερικές λέξεις που χωρίζονται από ένα κενό,\n    και πρέπει να επιστρέψετε μια συμβολοσειρά που περιέχει τις λέξεις από την αρχική πρόταση,\n    οι οποίες έχουν πρωταρχικά μήκη,\n    η σειρά των λέξεων στη νέα συμβολοσειρά πρέπει να είναι η ίδια με την αρχική.\n\n        Παράδειγμα 1:\n        Είσοδος: πρόταση = \"Αυτό είναι ένα τεστ\"\n        Έξοδος: \"είναι\"\n\n        Παράδειγμα 2:\n        Είσοδος: πρόταση = \"πάμε για κολύμπι\"\n        Έξοδος: \"για\"\n\n        Περιορισμοί:\n        * 1 <= len(sentence) <= 100\n        * Η πρόταση περιέχει μόνο γράμματα.\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Σας δίνεται μια συμβολοσειρά που αντιπροσωπεύει μια πρόταση,\n    η πρόταση περιέχει μερικές λέξεις που χωρίζονται από ένα κενό,\n    και πρέπει να επιστρέψετε μια συμβολοσειρά που περιέχει τις λέξεις από την αρχική πρόταση,\n    οι οποίες έχουν πρωταρχικά μήκη,\n    η σειρά των λέξεων στη νέα συμβολοσειρά πρέπει να είναι η ίδια με την αρχική.\n\n        Παράδειγμα 1:\n        Είσοδος: πρόταση = \"Αυτό είναι ένα τεστ\"\n        Έξοδος: \"είναι\"\n\n        Παράδειγμα 2:\n        Είσοδος: πρόταση = \"πάμε για κολύμπι\"\n        Έξοδος: \"για\"\n\n        Περιορισμοί:\n        * 1 <= len(sentence) <= 100\n        * Η πρόταση περιέχει μόνο γράμματα.\n    ", "natural_language": "Greek"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Η εργασία σας είναι να υλοποιήσετε μια συνάρτηση που θα απλοποιεί την έκφραση x * n. Η συνάρτηση επιστρέφει True αν το x * n αξιολογείται σε έναν ακέραιο αριθμό και False διαφορετικά. Και τα δύο x και n είναι αναπαράσταση συντελεστή, και έχουν την ακόλουθη μορφή, <αριθμητέας>/<παρονομαστής> όπου και ο αριθμητέας και ο παρονομαστής είναι θετικοί ακέραιοι αριθμοί.\n\n    Μπορείτε να υποθέσετε ότι το x και το n είναι έγκυροι συντελεστές και δεν έχουν μηδέν ως παρονομαστή.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Η εργασία σας είναι να υλοποιήσετε μια συνάρτηση που θα απλοποιεί την έκφραση x * n. Η συνάρτηση επιστρέφει True αν το x * n αξιολογείται σε έναν ακέραιο αριθμό και False διαφορετικά. Και τα δύο x και n είναι αναπαράσταση συντελεστή, και έχουν την ακόλουθη μορφή, <αριθμητέας>/<παρονομαστής> όπου και ο αριθμητέας και ο παρονομαστής είναι θετικοί ακέραιοι αριθμοί.\n\n    Μπορείτε να υποθέσετε ότι το x και το n είναι έγκυροι συντελεστές και δεν έχουν μηδέν ως παρονομαστή.\n    ", "natural_language": "Greek"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Γράψτε μια συνάρτηση η οποία ταξινομεί τη δοσμένη λίστα ακεραίων σε αύξουσα σειρά βάσει του αθροίσματος των ψηφίων τους. Σημείωση: αν υπάρχουν πολλά στοιχεία με παρόμοιο άθροισμα των ψηφίων τους, ταξινομήστε τα βάσει της θέσης τους στην αρχική λίστα.\n\n    Παράδειγμα:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Γράψτε μια συνάρτηση η οποία ταξινομεί τη δοσμένη λίστα ακεραίων σε αύξουσα σειρά βάσει του αθροίσματος των ψηφίων τους. Σημείωση: αν υπάρχουν πολλά στοιχεία με παρόμοιο άθροισμα των ψηφίων τους, ταξινομήστε τα βάσει της θέσης τους στην αρχική λίστα.\n\n    Παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Γράψτε μια συνάρτηση που παίρνει έναν πίνακα αριθμών ως είσοδο και επιστρέφει τον αριθμό των στοιχείων στον πίνακα που είναι μεγαλύτερα από 10 και και οι πρώτοι και οι τελευταίοι αριθμοί ενός αριθμού είναι περιττοί (1, 3, 5, 7, 9). Για παράδειγμα:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Γράψτε μια συνάρτηση που παίρνει έναν πίνακα αριθμών ως είσοδο και επιστρέφει τον αριθμό των στοιχείων στον πίνακα που είναι μεγαλύτερα από 10 και και οι πρώτοι και οι τελευταίοι αριθμοί ενός αριθμού είναι περιττοί (1, 3, 5, 7, 9). Για παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Σας δίνεται ένα θετικό ακέραιο n. Πρέπει να δημιουργήσετε έναν πίνακα ακεραίων a μήκους n. Για κάθε i (1 ≤ i ≤ n), η τιμή του a[i] = i * i - i + 1. Επιστρέψτε τον αριθμό των τριάδων (a[i], a[j], a[k]) του a όπου i < j < k, και a[i] + a[j] + a[k] είναι πολλαπλάσιο του 3.\n\n    Παράδειγμα:\n    Είσοδος: n = 5\n    Έξοδος: 1\n    Εξήγηση:\n    a = [1, 3, 7, 13, 21]\n    Η μόνη έγκυρη τριάδα είναι (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Σας δίνεται ένα θετικό ακέραιο n. Πρέπει να δημιουργήσετε έναν πίνακα ακεραίων a μήκους n. Για κάθε i (1 ≤ i ≤ n), η τιμή του a[i] = i * i - i + 1. Επιστρέψτε τον αριθμό των τριάδων (a[i], a[j], a[k]) του a όπου i < j < k, και a[i] + a[j] + a[k] είναι πολλαπλάσιο του 3.\n\n    Παράδειγμα:\n    Είσοδος: n = 5\n    Έξοδος: 1\n    Εξήγηση:\n    a = [1, 3, 7, 13, 21]\n    Η μόνη έγκυρη τριάδα είναι (1, 7, 13).\n    ", "natural_language": "Greek"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    Υπάρχουν οκτώ πλανήτες στο ηλιακό μας σύστημα: ο πλανήτης που βρίσκεται πιο κοντά στον Ήλιο είναι ο Ερμής, ο επόμενος είναι η Αφροδίτη, έπειτα η Γη, ο Άρης, ο Δίας, ο Κρόνος, ο Ουρανός και ο Ποσειδώνας. \nΓράψτε μια συνάρτηση που παίρνει δύο ονόματα πλανητών ως αλφαριθμητικά planet1 και planet2. Η συνάρτηση θα πρέπει να επιστρέφει ένα tuple που περιέχει όλους τους πλανήτες των οποίων οι τροχιές βρίσκονται μεταξύ της τροχιάς του πλανήτη1 και της τροχιάς του πλανήτη2, ταξινομημένους κατά την εγγύτητά τους στον Ήλιο. Η συνάρτηση θα πρέπει να επιστρέφει ένα κενό tuple εάν το planet1 ή το planet2 δεν είναι σωστά ονόματα πλανητών. \nΠαραδείγματα:\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "Υπάρχουν οκτώ πλανήτες στο ηλιακό μας σύστημα: ο πλανήτης που βρίσκεται πιο κοντά στον Ήλιο είναι ο Ερμής, ο επόμενος είναι η Αφροδίτη, έπειτα η Γη, ο Άρης, ο Δίας, ο Κρόνος, ο Ουρανός και ο Ποσειδώνας. \nΓράψτε μια συνάρτηση που παίρνει δύο ονόματα πλανητών ως αλφαριθμητικά planet1 και planet2. Η συνάρτηση θα πρέπει να επιστρέφει ένα tuple που περιέχει όλους τους πλανήτες των οποίων οι τροχιές βρίσκονται μεταξύ της τροχιάς του πλανήτη1 και της τροχιάς του πλανήτη2, ταξινομημένους κατά την εγγύτητά τους στον Ήλιο. Η συνάρτηση θα πρέπει να επιστρέφει ένα κενό tuple εάν το planet1 ή το planet2 δεν είναι σωστά ονόματα πλανητών. \nΠαραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Ένα απλό πρόγραμμα που θα πρέπει να επιστρέφει την τιμή του x αν το n είναι πρώτος αριθμός και θα πρέπει να επιστρέφει την τιμή του y σε διαφορετική περίπτωση.\n\n    Παραδείγματα:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Ένα απλό πρόγραμμα που θα πρέπει να επιστρέφει την τιμή του x αν το n είναι πρώτος αριθμός και θα πρέπει να επιστρέφει την τιμή του y σε διαφορετική περίπτωση.\n\n    Παραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Δεδομένης μιας λίστας αριθμών, επιστρέψτε το άθροισμα των τετραγώνων των αριθμών στη λίστα που είναι περιττοί. Αγνοήστε τους αριθμούς που είναι αρνητικοί ή δεν είναι ακέραιοι.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n        Εάν η είσοδος είναι κενή λίστα, επιστρέψτε 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Δεδομένης μιας λίστας αριθμών, επιστρέψτε το άθροισμα των τετραγώνων των αριθμών στη λίστα που είναι περιττοί. Αγνοήστε τους αριθμούς που είναι αρνητικοί ή δεν είναι ακέραιοι.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n        Εάν η είσοδος είναι κενή λίστα, επιστρέψτε 0.\n    ", "natural_language": "Greek"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Θα σας δοθεί το όνομα μιας κλάσης (ένα string) και μια λίστα επεκτάσεων. Οι επεκτάσεις πρέπει να χρησιμοποιηθούν για να φορτώσουν επιπλέον κλάσεις στην κλάση. Η δύναμη της επέκτασης είναι ως εξής: Ας είναι CAP ο αριθμός των κεφαλαίων γραμμάτων στο όνομα της επέκτασης και ας είναι SM ο αριθμός των πεζών γραμμάτων στο όνομα της επέκτασης, η δύναμη δίνεται από το κλάσμα CAP - SM. Θα πρέπει να βρείτε την ισχυρότερη επέκταση και να επιστρέψετε ένα string σε αυτή τη μορφή: ClassName.StrongestExtensionName. Εάν υπάρχουν δύο ή περισσότερες επεκτάσεις με την ίδια δύναμη, θα πρέπει να επιλέξετε αυτή που έρχεται πρώτη στη λίστα. Για παράδειγμα, εάν σας δοθεί \"Slices\" ως κλάση και μια λίστα επεκτάσεων: ['SErviNGSliCes', 'Cheese', 'StuFfed'], τότε θα πρέπει να επιστρέψετε 'Slices.SErviNGSliCes' καθώς η 'SErviNGSliCes' είναι η ισχυρότερη επέκταση (η δύναμή της είναι -1). Παράδειγμα:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Θα σας δοθεί το όνομα μιας κλάσης (ένα string) και μια λίστα επεκτάσεων. Οι επεκτάσεις πρέπει να χρησιμοποιηθούν για να φορτώσουν επιπλέον κλάσεις στην κλάση. Η δύναμη της επέκτασης είναι ως εξής: Ας είναι CAP ο αριθμός των κεφαλαίων γραμμάτων στο όνομα της επέκτασης και ας είναι SM ο αριθμός των πεζών γραμμάτων στο όνομα της επέκτασης, η δύναμη δίνεται από το κλάσμα CAP - SM. Θα πρέπει να βρείτε την ισχυρότερη επέκταση και να επιστρέψετε ένα string σε αυτή τη μορφή: ClassName.StrongestExtensionName. Εάν υπάρχουν δύο ή περισσότερες επεκτάσεις με την ίδια δύναμη, θα πρέπει να επιλέξετε αυτή που έρχεται πρώτη στη λίστα. Για παράδειγμα, εάν σας δοθεί \"Slices\" ως κλάση και μια λίστα επεκτάσεων: ['SErviNGSliCes', 'Cheese', 'StuFfed'], τότε θα πρέπει να επιστρέψετε 'Slices.SErviNGSliCes' καθώς η 'SErviNGSliCes' είναι η ισχυρότερη επέκταση (η δύναμή της είναι -1). Παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Σας δίνονται 2 λέξεις. Χρειάζεται να επιστρέψετε True αν η δεύτερη λέξη ή οποιαδήποτε από τις περιστροφές της είναι υποσυμβολοσειρά στην πρώτη λέξη.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Σας δίνονται 2 λέξεις. Χρειάζεται να επιστρέψετε True αν η δεύτερη λέξη ή οποιαδήποτε από τις περιστροφές της είναι υποσυμβολοσειρά στην πρώτη λέξη.\n    ", "natural_language": "Greek"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Δεδομένου ενός θετικού ακεραίου, να ανακτηθεί η αντίστοιχη ρωμαϊκή αριθμητική του σε μορφή συμβολοσειράς και να επιστραφεί σε πεζά γράμματα.\n    Περιορισμοί: 1 <= num <= 1000\n\n        Παραδείγματα:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Δεδομένου ενός θετικού ακεραίου, να ανακτηθεί η αντίστοιχη ρωμαϊκή αριθμητική του σε μορφή συμβολοσειράς και να επιστραφεί σε πεζά γράμματα.\n    Περιορισμοί: 1 <= num <= 1000\n\n        Παραδείγματα:\n    ", "natural_language": "Greek"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέφει True αν οι τρεις πλευρές σχηματίζουν ένα ορθογώνιο τρίγωνο, False διαφορετικά. Ένα ορθογώνιο τρίγωνο είναι ένα τρίγωνο στο οποίο ένα γωνία είναι ορθή ή 90 μοίρες. Παράδειγμα:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέφει True αν οι τρεις πλευρές σχηματίζουν ένα ορθογώνιο τρίγωνο, False διαφορετικά. Ένα ορθογώνιο τρίγωνο είναι ένα τρίγωνο στο οποίο ένα γωνία είναι ορθή ή 90 μοίρες. Παράδειγμα:\n    ", "natural_language": "Greek"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Σας δίνεται μια συμβολοσειρά s.\n    Αν s[i] είναι γράμμα, αντιστρέψτε την πεζή πεζή σε κεφαλαία ή αντίστροφα, \n    διαφορετικά κρατήστε το όπως είναι.\n    Εάν η συμβολοσειρά δεν περιέχει γράμματα, αντιστρέψτε τη συμβολοσειρά.\n    Η συνάρτηση πρέπει να επιστρέψει τη συμβολοσειρά που προέκυψε.\n    Παραδείγματα\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Σας δίνεται μια συμβολοσειρά s.\n    Αν s[i] είναι γράμμα, αντιστρέψτε την πεζή πεζή σε κεφαλαία ή αντίστροφα, \n    διαφορετικά κρατήστε το όπως είναι.\n    Εάν η συμβολοσειρά δεν περιέχει γράμματα, αντιστρέψτε τη συμβολοσειρά.\n    Η συνάρτηση πρέπει να επιστρέψει τη συμβολοσειρά που προέκυψε.\n    Παραδείγματα\n    ", "natural_language": "Greek"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Δεδομένου ενός αλφαριθμητικού 'text', επιστρέψτε ένα αντίστοιχο αλφαριθμητικό md5 hash του. Εάν το 'text' είναι ένα κενό αλφαριθμητικό, επιστρέψτε null.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Δεδομένου ενός αλφαριθμητικού 'text', επιστρέψτε ένα αντίστοιχο αλφαριθμητικό md5 hash του. Εάν το 'text' είναι ένα κενό αλφαριθμητικό, επιστρέψτε null.\n    ", "natural_language": "Greek"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Δεδομένων δύο θετικών ακεραίων a και b, επιστρέφονται οι άρτιοι αριθμοί μεταξύ a και b, με αύξουσα σειρά.\n\n    Για παράδειγμα:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Δεδομένων δύο θετικών ακεραίων a και b, επιστρέφονται οι άρτιοι αριθμοί μεταξύ a και b, με αύξουσα σειρά.\n\n    Για παράδειγμα:\n    ", "natural_language": "Greek"}
