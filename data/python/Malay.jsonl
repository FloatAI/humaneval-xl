{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Anda diberikan senarai operasi deposit dan pengeluaran pada akaun bank yang bermula dengan baki sifar. Tugas anda adalah untuk mengesan jika pada bila-bila masa baki akaun jatuh di bawah sifar, dan pada titik itu fungsi harus mengembalikan True. Jika tidak, ia harus mengembalikan False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Anda diberikan senarai operasi deposit dan pengeluaran pada akaun bank yang bermula dengan baki sifar. Tugas anda adalah untuk mengesan jika pada bila-bila masa baki akaun jatuh di bawah sifar, dan pada titik itu fungsi harus mengembalikan True. Jika tidak, ia harus mengembalikan False.\n    ", "natural_language": "Malay"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Untuk senarai integer yang diberikan, kembalikan tuple yang terdiri daripada jumlah dan hasil darab semua integer dalam senarai.\nJumlah kosong harus sama dengan 0 dan hasil darab kosong harus sama dengan 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Untuk senarai integer yang diberikan, kembalikan tuple yang terdiri daripada jumlah dan hasil darab semua integer dalam senarai.\nJumlah kosong harus sama dengan 0 dan hasil darab kosong harus sama dengan 1.\n    ", "natural_language": "Malay"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input adalah dua rentetan a dan b yang terdiri daripada hanya 1 dan 0.\nLakukan XOR binari pada input ini dan kembalikan hasilnya juga sebagai rentetan.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "Input adalah dua rentetan a dan b yang terdiri daripada hanya 1 dan 0.\nLakukan XOR binari pada input ini dan kembalikan hasilnya juga sebagai rentetan.\n    ", "natural_language": "Malay"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Dari senarai rentetan, pulangkan yang terpanjang. Pulangkan yang pertama sekiranya terdapat beberapa rentetan dengan panjang yang sama. Pulangkan null sekiranya senarai input kosong.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "Dari senarai rentetan, pulangkan yang terpanjang. Pulangkan yang pertama sekiranya terdapat beberapa rentetan dengan panjang yang sama. Pulangkan null sekiranya senarai input kosong.\n    ", "natural_language": "Malay"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Kembalikan divisor terbesar antara dua integer a dan b.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Kembalikan divisor terbesar antara dua integer a dan b.\n    ", "natural_language": "Malay"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input adalah rentetan nombor yang dipisahkan dengan ruang dari 'kosong' hingga 'sembilan'.\nPilihan yang sah adalah 'kosong', 'satu', 'dua', 'tiga', 'empat', 'lima', 'enam', 'tujuh', 'lapan' dan 'sembilan'.\nKembalikan rentetan dengan nombor yang disusun dari yang terkecil hingga yang terbesar.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "Input adalah rentetan nombor yang dipisahkan dengan ruang dari 'kosong' hingga 'sembilan'.\nPilihan yang sah adalah 'kosong', 'satu', 'dua', 'tiga', 'empat', 'lima', 'enam', 'tujuh', 'lapan' dan 'sembilan'.\nKembalikan rentetan dengan nombor yang disusun dari yang terkecil hingga yang terbesar.\n    ", "natural_language": "Malay"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Diberikan senarai nombor (sekurang-kurangnya dua elemen), laksanakan transformasi linear ke atas senarai tersebut, di mana nombor terkecil akan menjadi 0 dan yang terbesar akan menjadi 1.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Diberikan senarai nombor (sekurang-kurangnya dua elemen), laksanakan transformasi linear ke atas senarai tersebut, di mana nombor terkecil akan menjadi 0 dan yang terbesar akan menjadi 1.\n    ", "natural_language": "Malay"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Untuk suatu rentetan yang diberikan, tukar huruf kecil kepada huruf besar dan huruf besar kepada huruf kecil.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Untuk suatu rentetan yang diberikan, tukar huruf kecil kepada huruf besar dan huruf besar kepada huruf kecil.\n    ", "natural_language": "Malay"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Kembalikan hanya nombor positif dalam senarai.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Kembalikan hanya nombor positif dalam senarai.\n    ", "natural_language": "Malay"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Kembalikan nilai benar jika nombor yang diberikan adalah nombor perdana, dan palsu sebaliknya.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Kembalikan nilai benar jika nombor yang diberikan adalah nombor perdana, dan palsu sebaliknya.\n    ", "natural_language": "Malay"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Kembalikan elemen-elemen unik yang telah diurutkan dalam senarai.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Kembalikan elemen-elemen unik yang telah diurutkan dalam senarai.\n    ", "natural_language": "Malay"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib mengembalikan nombor ke-n yang merupakan nombor Fibonacci dan juga nombor perdana.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib mengembalikan nombor ke-n yang merupakan nombor Fibonacci dan juga nombor perdana.\n    ", "natural_language": "Malay"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero mengambil senarai integer sebagai input.\nIa akan mengembalikan True jika terdapat tiga elemen yang berbeza dalam senarai tersebut yang menjumlahkan kepada sifar, dan False jika sebaliknya.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "triples_sum_to_zero mengambil senarai integer sebagai input.\nIa akan mengembalikan True jika terdapat tiga elemen yang berbeza dalam senarai tersebut yang menjumlahkan kepada sifar, dan False jika sebaliknya.\n    ", "natural_language": "Malay"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero mengambil senarai integer sebagai input.\nIa akan mengembalikan True jika terdapat dua elemen yang berbeza dalam senarai tersebut yang menjumlahkan kepada sifar, dan False jika tidak.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "pairs_sum_to_zero mengambil senarai integer sebagai input.\nIa akan mengembalikan True jika terdapat dua elemen yang berbeza dalam senarai tersebut yang menjumlahkan kepada sifar, dan False jika tidak.\n    ", "natural_language": "Malay"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Sekuen Fib4 adalah sekuen yang serupa dengan sekuen Fibbonacci yang ditakrifkan seperti berikut:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Sila tulis fungsi untuk mengira elemen ke-n dengan cekap dalam sekuen nombor fib4. Jangan gunakan pengulangan.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "Sekuen Fib4 adalah sekuen yang serupa dengan sekuen Fibbonacci yang ditakrifkan seperti berikut:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Sila tulis fungsi untuk mengira elemen ke-n dengan cekap dalam sekuen nombor fib4. Jangan gunakan pengulangan.\n    ", "natural_language": "Malay"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Kembalikan median elemen dalam senarai l.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Kembalikan median elemen dalam senarai l.\n    ", "natural_language": "Malay"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Memeriksa sama ada rentetan yang diberikan adalah palindrom\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Memeriksa sama ada rentetan yang diberikan adalah palindrom\n    ", "natural_language": "Malay"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels adalah sebuah fungsi yang mengambil string dan mengembalikan string tanpa huruf vokal.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels adalah sebuah fungsi yang mengambil string dan mengembalikan string tanpa huruf vokal.\n    ", "natural_language": "Malay"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Kembalikan Benar jika semua nombor dalam senarai l di bawah ambang t.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Kembalikan Benar jika semua nombor dalam senarai l di bawah ambang t.\n    ", "natural_language": "Malay"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Tambah dua nombor x dan y.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Tambah dua nombor x dan y.\n    ", "natural_language": "Malay"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Periksa sama ada dua perkataan mempunyai huruf yang sama.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Periksa sama ada dua perkataan mempunyai huruf yang sama.\n    ", "natural_language": "Malay"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Kembalikan nombor Fibonacci ke-n.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Kembalikan nombor Fibonacci ke-n.\n    ", "natural_language": "Malay"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Kembalikan elemen-elemen yang sama yang unik dan tersusun bagi dua senarai.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Kembalikan elemen-elemen yang sama yang unik dan tersusun bagi dua senarai.\n    ", "natural_language": "Malay"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Kembalikan faktor nombor perdana terbesar. Andaikan n > 1 dan bukan nombor perdana.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Kembalikan faktor nombor perdana terbesar. Andaikan n > 1 dan bukan nombor perdana.\n    ", "natural_language": "Malay"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n adalah sebuah fungsi yang menjumlahkan nombor dari 1 hingga n.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n adalah sebuah fungsi yang menjumlahkan nombor dari 1 hingga n.\n    ", "natural_language": "Malay"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs mewakili pekali bagi suatu polinomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Kembalikan turunan polinomial ini dalam bentuk yang sama.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs mewakili pekali bagi suatu polinomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Kembalikan turunan polinomial ini dalam bentuk yang sama.\n    ", "natural_language": "Malay"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"Sekuens nombor FibFib adalah sekuen yang serupa dengan sekuen Fibbonacci yang ditakrifkan seperti berikut:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Sila tulis fungsi untuk mengira elemen ke-n dengan cekap dalam sekuen nombor FibFib.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "Sekuens nombor FibFib adalah sekuen yang serupa dengan sekuen Fibbonacci yang ditakrifkan seperti berikut:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Sila tulis fungsi untuk mengira elemen ke-n dengan cekap dalam sekuen nombor FibFib.\n    ", "natural_language": "Malay"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Tulis sebuah fungsi vowels_count yang mengambil sebuah string yang mewakili sebuah kata sebagai input dan mengembalikan jumlah huruf vokal dalam string tersebut. Vokal dalam hal ini adalah 'a', 'e', 'i', 'o', 'u'. Di sini, 'y' juga merupakan vokal, tetapi hanya jika ia berada di akhir kata yang diberikan.\n\n    Contoh:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Tulis sebuah fungsi vowels_count yang mengambil sebuah string yang mewakili sebuah kata sebagai input dan mengembalikan jumlah huruf vokal dalam string tersebut. Vokal dalam hal ini adalah 'a', 'e', 'i', 'o', 'u'. Di sini, 'y' juga merupakan vokal, tetapi hanya jika ia berada di akhir kata yang diberikan.\n\n    Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Anda diberikan senarai integer positif yang tidak kosong. Kembalikan integer terbesar yang lebih besar daripada sifar, dan mempunyai frekuensi yang lebih besar atau sama dengan nilai integer itu sendiri. Frekuensi integer adalah jumlah kali ia muncul dalam senarai. Jika tiada nilai seperti itu wujud, kembalikan -1. Contoh:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Anda diberikan senarai integer positif yang tidak kosong. Kembalikan integer terbesar yang lebih besar daripada sifar, dan mempunyai frekuensi yang lebih besar atau sama dengan nilai integer itu sendiri. Frekuensi integer adalah jumlah kali ia muncul dalam senarai. Jika tiada nilai seperti itu wujud, kembalikan -1. Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Diberikan panjang tiga sisi segitiga. Kembalikan luas segitiga dibulatkan ke 2 titik desimal jika ketiga sisi membentuk segitiga yang valid. Jika tidak, kembalikan -1. Tiga sisi membentuk segitiga yang valid ketika jumlah dari dua sisi lebih besar dari sisi ketiga. Contoh:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Diberikan panjang tiga sisi segitiga. Kembalikan luas segitiga dibulatkan ke 2 titik desimal jika ketiga sisi membentuk segitiga yang valid. Jika tidak, kembalikan -1. Tiga sisi membentuk segitiga yang valid ketika jumlah dari dua sisi lebih besar dari sisi ketiga. Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Tulis sebuah fungsi yang mengembalikan True jika objek q akan terbang, dan False jika tidak.\nObjek q akan terbang jika seimbang (merupakan daftar palindrom) dan jumlah elemennya kurang dari atau sama dengan berat maksimum yang mungkin w.\n\n    Contoh:\nwill_it_fly([1, 2], 5) ➞ Salah\n# 1+2 kurang dari berat maksimum yang mungkin, tetapi tidak seimbang.\n\n    will_it_fly([3, 2, 3], 1) ➞ Salah\n# seimbang, tetapi 3+2+3 lebih dari berat maksimum yang mungkin.\n\n    will_it_fly([3, 2, 3], 9) ➞ Benar\n# 3+2+3 kurang dari berat maksimum yang mungkin, dan seimbang.\n\n    will_it_fly([3], 5) ➞ Benar\n# 3 kurang dari berat maksimum yang mungkin, dan seimbang.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Tulis sebuah fungsi yang mengembalikan True jika objek q akan terbang, dan False jika tidak.\nObjek q akan terbang jika seimbang (merupakan daftar palindrom) dan jumlah elemennya kurang dari atau sama dengan berat maksimum yang mungkin w.\n\n    Contoh:\nwill_it_fly([1, 2], 5) ➞ Salah\n# 1+2 kurang dari berat maksimum yang mungkin, tetapi tidak seimbang.\n\n    will_it_fly([3, 2, 3], 1) ➞ Salah\n# seimbang, tetapi 3+2+3 lebih dari berat maksimum yang mungkin.\n\n    will_it_fly([3, 2, 3], 9) ➞ Benar\n# 3+2+3 kurang dari berat maksimum yang mungkin, dan seimbang.\n\n    will_it_fly([3], 5) ➞ Benar\n# 3 kurang dari berat maksimum yang mungkin, dan seimbang.\n    ", "natural_language": "Malay"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Tulis sebuah fungsi yang mengembalikan nilai benar jika bilangan yang diberikan adalah hasil kali dari 3 bilangan prima\n    dan salah jika tidak.\n    Mengetahui bahwa (a) kurang dari 100.\n    Contoh:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Tulis sebuah fungsi yang mengembalikan nilai benar jika bilangan yang diberikan adalah hasil kali dari 3 bilangan prima\n    dan salah jika tidak.\n    Mengetahui bahwa (a) kurang dari 100.\n    Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Anda akan diberikan satu nombor dalam bentuk desimal dan tugas anda adalah untuk menukarkannya ke dalam format binari. Fungsi tersebut harus mengembalikan sebuah string, dengan setiap karakter mewakili satu nombor binari. Setiap karakter dalam string akan menjadi '0' atau '1'.\n\n    Terdapat beberapa karakter tambahan 'db' di awal dan di akhir string. Karakter tambahan tersebut ada untuk membantu dengan format.\n\n    Contoh:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Anda akan diberikan satu nombor dalam bentuk desimal dan tugas anda adalah untuk menukarkannya ke dalam format binari. Fungsi tersebut harus mengembalikan sebuah string, dengan setiap karakter mewakili satu nombor binari. Setiap karakter dalam string akan menjadi '0' atau '1'.\n\n    Terdapat beberapa karakter tambahan 'db' di awal dan di akhir string. Karakter tambahan tersebut ada untuk membantu dengan format.\n\n    Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Anda diberikan satu rentetan s.\n    Tugas anda adalah untuk memeriksa sama ada rentetan itu gembira atau tidak.\n    Satu rentetan dikatakan gembira jika panjangnya sekurang-kurangnya 3 dan setiap 3 huruf berturut-turut adalah berbeza.\n    Contohnya:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Anda diberikan satu rentetan s.\n    Tugas anda adalah untuk memeriksa sama ada rentetan itu gembira atau tidak.\n    Satu rentetan dikatakan gembira jika panjangnya sekurang-kurangnya 3 dan setiap 3 huruf berturut-turut adalah berbeza.\n    Contohnya:\n    ", "natural_language": "Malay"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Ini adalah minggu terakhir semester dan guru perlu memberikan markah kepada pelajar. Guru tersebut telah membuat algoritma sendiri untuk memberikan markah. Satu-satunya masalah ialah, beliau telah kehilangan kod yang digunakan untuk memberikan markah. Beliau telah memberikan anda senarai GPA untuk beberapa pelajar dan anda perlu menulis satu fungsi yang dapat mengeluarkan senarai gred huruf menggunakan jadual berikut:\n             GPA       |    Gred huruf\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Contoh:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "Ini adalah minggu terakhir semester dan guru perlu memberikan markah kepada pelajar. Guru tersebut telah membuat algoritma sendiri untuk memberikan markah. Satu-satunya masalah ialah, beliau telah kehilangan kod yang digunakan untuk memberikan markah. Beliau telah memberikan anda senarai GPA untuk beberapa pelajar dan anda perlu menulis satu fungsi yang dapat mengeluarkan senarai gred huruf menggunakan jadual berikut:\n             GPA       |    Gred huruf\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Tulis sebuah fungsi yang mengambil sebuah string dan mengembalikan True jika panjang string tersebut adalah bilangan prima atau False jika tidak.\nContoh:\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Tulis sebuah fungsi yang mengambil sebuah string dan mengembalikan True jika panjang string tersebut adalah bilangan prima atau False jika tidak.\nContoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Diberikan integer positif N, kembalikan jumlah total digitnya dalam bentuk biner.\n\n        Contoh\n        Untuk N = 1000, jumlah digitnya adalah 1, outputnya harus \"1\".\n        Untuk N = 150, jumlah digitnya adalah 6, outputnya harus \"110\".\n        Untuk N = 147, jumlah digitnya adalah 12, outputnya harus \"1100\".\n    \n    Variabel:\n        @N integer\n             Batasan: 0 ≤ N ≤ 10000.\n    Output:\n         sebuah string dalam bentuk bilangan biner.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Diberikan integer positif N, kembalikan jumlah total digitnya dalam bentuk biner.\n\n        Contoh\n        Untuk N = 1000, jumlah digitnya adalah 1, outputnya harus \"1\".\n        Untuk N = 150, jumlah digitnya adalah 6, outputnya harus \"110\".\n        Untuk N = 147, jumlah digitnya adalah 12, outputnya harus \"1100\".\n    \n    Variabel:\n        @N integer\n             Batasan: 0 ≤ N ≤ 10000.\n    Output:\n         sebuah string dalam bentuk bilangan biner.\n    ", "natural_language": "Malay"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Anda diberikan data 2 dimensi, sebagai senarai bersarang,\nyang serupa dengan matriks, namun berbeza dengan matriks,\nsetiap baris mungkin mengandungi bilangan lajur yang berbeza.\nDiberikan lst, dan integer x, cari integer x dalam senarai,\ndan kembalikan senarai tuple, [(x1, y1), (x2, y2) ...] supaya\nsetiap tuple adalah koordinat - (baris, lajur), bermula dengan 0.\nUrutkan koordinat awalnya mengikut baris dalam urutan menaik.\nJuga, urutkan koordinat baris mengikut lajur dalam urutan menurun.\n\n    Contoh:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Anda diberikan data 2 dimensi, sebagai senarai bersarang,\nyang serupa dengan matriks, namun berbeza dengan matriks,\nsetiap baris mungkin mengandungi bilangan lajur yang berbeza.\nDiberikan lst, dan integer x, cari integer x dalam senarai,\ndan kembalikan senarai tuple, [(x1, y1), (x2, y2) ...] supaya\nsetiap tuple adalah koordinat - (baris, lajur), bermula dengan 0.\nUrutkan koordinat awalnya mengikut baris dalam urutan menaik.\nJuga, urutkan koordinat baris mengikut lajur dalam urutan menurun.\n\n    Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Anda diberikan senarai integer.\n    Tulis satu fungsi next_smallest() yang akan mengembalikan elemen kedua terkecil dalam senarai.\n    Kembalikan null jika tiada elemen seperti itu.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Anda diberikan senarai integer.\n    Tulis satu fungsi next_smallest() yang akan mengembalikan elemen kedua terkecil dalam senarai.\n    Kembalikan null jika tiada elemen seperti itu.\n    ", "natural_language": "Malay"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Anda akan diberikan satu rentetan perkataan, dan tugas anda adalah untuk mengira bilangan kebosanan. Kebosanan adalah ayat yang bermula dengan perkataan \"Saya\". Ayat-ayat dipisahkan oleh '.', '?' atau '!'.\n\n    Contoh:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Anda akan diberikan satu rentetan perkataan, dan tugas anda adalah untuk mengira bilangan kebosanan. Kebosanan adalah ayat yang bermula dengan perkataan \"Saya\". Ayat-ayat dipisahkan oleh '.', '?' atau '!'.\n\n    Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Anda diberikan senarai integer.\nAnda perlu mencari nilai nombor perdana terbesar dan mengembalikan jumlah digitnya.\n\n    Contoh:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Anda diberikan senarai integer.\nAnda perlu mencari nilai nombor perdana terbesar dan mengembalikan jumlah digitnya.\n\n    Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Diberikan kamus, kembalikan True jika semua kunci adalah string dalam huruf kecil atau semua kunci adalah string dalam huruf besar, jika tidak kembalikan False. Fungsi harus mengembalikan False jika kamus yang diberikan kosong. Contoh:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Diberikan kamus, kembalikan True jika semua kunci adalah string dalam huruf kecil atau semua kunci adalah string dalam huruf besar, jika tidak kembalikan False. Fungsi harus mengembalikan False jika kamus yang diberikan kosong. Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Cipta satu fungsi yang mengambil nilai (rentetan) yang mewakili nombor dan mengembalikan integer terdekat dengannya. Jika nombor itu sama jauhnya dari dua integer, bulatkan ke arah jauh dari sifar.\n\n    Contoh-contoh\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Cipta satu fungsi yang mengambil nilai (rentetan) yang mewakili nombor dan mengembalikan integer terdekat dengannya. Jika nombor itu sama jauhnya dari dua integer, bulatkan ke arah jauh dari sifar.\n\n    Contoh-contoh\n    ", "natural_language": "Malay"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Diberikan integer positif n, anda perlu membuat timbunan batu sebanyak n aras.\n    Aras pertama mempunyai n batu.\n    Bilangan batu pada aras seterusnya adalah:\n        - nombor ganjil seterusnya jika n adalah ganjil.\n        - nombor genap seterusnya jika n adalah genap.\n    Kembalikan bilangan batu pada setiap aras dalam senarai, di mana elemen pada indeks\n    i mewakili bilangan batu pada aras (i+1).\n\n        Contoh:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Diberikan integer positif n, anda perlu membuat timbunan batu sebanyak n aras.\n    Aras pertama mempunyai n batu.\n    Bilangan batu pada aras seterusnya adalah:\n        - nombor ganjil seterusnya jika n adalah ganjil.\n        - nombor genap seterusnya jika n adalah genap.\n    Kembalikan bilangan batu pada setiap aras dalam senarai, di mana elemen pada indeks\n    i mewakili bilangan batu pada aras (i+1).\n\n        Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Anda akan diberikan satu rentetan perkataan yang dipisahkan oleh koma atau ruang. Tugas anda adalah untuk memecahkan rentetan tersebut kepada perkataan-perkataan dan mengembalikan satu array perkataan.\n\n    Contoh:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Anda akan diberikan satu rentetan perkataan yang dipisahkan oleh koma atau ruang. Tugas anda adalah untuk memecahkan rentetan tersebut kepada perkataan-perkataan dan mengembalikan satu array perkataan.\n\n    Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Fungsi ini mengambil dua nombor positif x dan y dan mengembalikan nombor integer genap terbesar yang berada dalam julat [x, y] termasuk. Jika tidak ada nombor seperti itu, maka fungsi harus mengembalikan -1.\n\n    Contoh:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Fungsi ini mengambil dua nombor positif x dan y dan mengembalikan nombor integer genap terbesar yang berada dalam julat [x, y] termasuk. Jika tidak ada nombor seperti itu, maka fungsi harus mengembalikan -1.\n\n    Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Anda diberikan dua integer positif n dan m, dan tugas anda adalah untuk mengira purata integer dari n hingga m (termasuk n dan m). Bundarkan jawapan kepada integer terdekat dan tukarkan ke dalam binari. Jika n lebih besar daripada m, kembalikan -1. Contoh:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Anda diberikan dua integer positif n dan m, dan tugas anda adalah untuk mengira purata integer dari n hingga m (termasuk n dan m). Bundarkan jawapan kepada integer terdekat dan tukarkan ke dalam binari. Jika n lebih besar daripada m, kembalikan -1. Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Laksanakan fungsi f yang mengambil n sebagai parameter,\n    dan mengembalikan senarai berukuran n, di mana nilai elemen pada indeks i adalah faktorial i jika i adalah genap\n    atau jumlah nombor dari 1 hingga i jika tidak.\n    i bermula dari 1.\n    faktorial i adalah perkalian nombor dari 1 hingga i (1 * 2 * ... * i).\n    Contoh:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Laksanakan fungsi f yang mengambil n sebagai parameter,\n    dan mengembalikan senarai berukuran n, di mana nilai elemen pada indeks i adalah faktorial i jika i adalah genap\n    atau jumlah nombor dari 1 hingga i jika tidak.\n    i bermula dari 1.\n    faktorial i adalah perkalian nombor dari 1 hingga i (1 * 2 * ... * i).\n    Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Diberikan integer positif n, kembalikan tuple yang memiliki jumlah bilangan palindrome genap dan ganjil yang berada dalam rentang (1, n), inklusif.\n\n    Contoh 1:\n\n        Input: 3\n    Output: (1, 2)\n    Penjelasan:\n    Bilangan palindrome adalah 1, 2, 3. Satu di antaranya genap, dan dua di antaranya ganjil.\n\n    Contoh 2:\n\n        Input: 12\n    Output: (4, 6)\n    Penjelasan:\n    Bilangan palindrome adalah 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Empat di antaranya genap, dan enam di antaranya ganjil.\n\n    Catatan:\n    1. 1 <= n <= 10^3\n    2. tuple yang dikembalikan memiliki jumlah bilangan palindrome genap dan ganjil secara berturut-turut.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Diberikan integer positif n, kembalikan tuple yang memiliki jumlah bilangan palindrome genap dan ganjil yang berada dalam rentang (1, n), inklusif.\n\n    Contoh 1:\n\n        Input: 3\n    Output: (1, 2)\n    Penjelasan:\n    Bilangan palindrome adalah 1, 2, 3. Satu di antaranya genap, dan dua di antaranya ganjil.\n\n    Contoh 2:\n\n        Input: 12\n    Output: (4, 6)\n    Penjelasan:\n    Bilangan palindrome adalah 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Empat di antaranya genap, dan enam di antaranya ganjil.\n\n    Catatan:\n    1. 1 <= n <= 10^3\n    2. tuple yang dikembalikan memiliki jumlah bilangan palindrome genap dan ganjil secara berturut-turut.\n    ", "natural_language": "Malay"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Kami mempunyai array 'arr' dengan N integer arr[1], arr[2], ..., arr[N]. Nombor dalam array akan diatur secara rawak. Tugas anda adalah untuk menentukan sama ada ia mungkin untuk mendapatkan array yang diurutkan dalam urutan tidak menurun dengan melakukan operasi berikut pada array yang diberikan:\n        Anda dibenarkan untuk melakukan operasi pergeseran kanan seberapa banyak yang anda mahu.\n    \n    Satu operasi pergeseran kanan bermaksud menggeser semua elemen array satu posisi ke arah kanan. Elemen terakhir array akan dipindahkan ke posisi permulaan dalam array iaitu indeks 0. \n\n        Jika ia mungkin untuk mendapatkan array yang diurutkan dengan melakukan operasi di atas, maka kembalikan True jika tidak kembalikan False.\n    Jika array yang diberikan kosong, maka kembalikan True.\n\n        Nota: Senarai yang diberikan dijamin mempunyai elemen yang unik.\n\n        Contoh:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Penjelasan: Dengan melakukan 2 operasi pergeseran kanan, urutan tidak menurun dapat dicapai untuk array yang diberikan.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Penjelasan: Tidak mungkin untuk mendapatkan urutan tidak menurun untuk array yang diberikan dengan melakukan sebarang jumlah operasi pergeseran kanan.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Kami mempunyai array 'arr' dengan N integer arr[1], arr[2], ..., arr[N]. Nombor dalam array akan diatur secara rawak. Tugas anda adalah untuk menentukan sama ada ia mungkin untuk mendapatkan array yang diurutkan dalam urutan tidak menurun dengan melakukan operasi berikut pada array yang diberikan:\n        Anda dibenarkan untuk melakukan operasi pergeseran kanan seberapa banyak yang anda mahu.\n    \n    Satu operasi pergeseran kanan bermaksud menggeser semua elemen array satu posisi ke arah kanan. Elemen terakhir array akan dipindahkan ke posisi permulaan dalam array iaitu indeks 0. \n\n        Jika ia mungkin untuk mendapatkan array yang diurutkan dengan melakukan operasi di atas, maka kembalikan True jika tidak kembalikan False.\n    Jika array yang diberikan kosong, maka kembalikan True.\n\n        Nota: Senarai yang diberikan dijamin mempunyai elemen yang unik.\n\n        Contoh:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Penjelasan: Dengan melakukan 2 operasi pergeseran kanan, urutan tidak menurun dapat dicapai untuk array yang diberikan.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Penjelasan: Tidak mungkin untuk mendapatkan urutan tidak menurun untuk array yang diberikan dengan melakukan sebarang jumlah operasi pergeseran kanan.\n    ", "natural_language": "Malay"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Dalam masalah ini, anda akan melaksanakan fungsi yang mengambil dua senarai nombor,\n    dan menentukan sama ada ia mungkin untuk melakukan pertukaran elemen\n    di antara mereka untuk membuat lst1 menjadi senarai hanya nombor genap.\n    Tiada had pada bilangan elemen yang dipertukarkan antara lst1 dan lst2.\n    Jika ia mungkin untuk menukar elemen antara lst1 dan lst2 untuk membuat\n    semua elemen lst1 menjadi genap, kembalikan \"YES\".\n    Jika tidak, kembalikan \"NO\".\n    Sebagai contoh:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    Dikatakan bahawa senarai input akan tidak kosong.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "Dalam masalah ini, anda akan melaksanakan fungsi yang mengambil dua senarai nombor,\n    dan menentukan sama ada ia mungkin untuk melakukan pertukaran elemen\n    di antara mereka untuk membuat lst1 menjadi senarai hanya nombor genap.\n    Tiada had pada bilangan elemen yang dipertukarkan antara lst1 dan lst2.\n    Jika ia mungkin untuk menukar elemen antara lst1 dan lst2 untuk membuat\n    semua elemen lst1 menjadi genap, kembalikan \"YES\".\n    Jika tidak, kembalikan \"NO\".\n    Sebagai contoh:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    Dikatakan bahawa senarai input akan tidak kosong.\n    ", "natural_language": "Malay"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Tugasan\n    Diberikan dua rentetan s dan c, anda perlu memadamkan semua aksara dalam s yang sama dengan mana-mana aksara dalam c\n    kemudian periksa sama ada rentetan hasil adalah palindrom.\n    Satu rentetan dipanggil palindrom jika ia dibaca sama dari belakang ke depan.\n    Anda perlu mengembalikan tupel yang mengandungi rentetan hasil dan True/False untuk pemeriksaan.\n    Contoh\n    Untuk s = \"abcde\", c = \"ae\", hasilnya harus ('bcd',False)\n    Untuk s = \"abcdef\", c = \"b\" hasilnya harus ('acdef',False)\n    Untuk s = \"abcdedcba\", c = \"ab\", hasilnya harus ('cdedc',True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Tugasan\n    Diberikan dua rentetan s dan c, anda perlu memadamkan semua aksara dalam s yang sama dengan mana-mana aksara dalam c\n    kemudian periksa sama ada rentetan hasil adalah palindrom.\n    Satu rentetan dipanggil palindrom jika ia dibaca sama dari belakang ke depan.\n    Anda perlu mengembalikan tupel yang mengandungi rentetan hasil dan True/False untuk pemeriksaan.\n    Contoh\n    Untuk s = \"abcde\", c = \"ae\", hasilnya harus ('bcd',False)\n    Untuk s = \"abcdef\", c = \"b\" hasilnya harus ('acdef',False)\n    Untuk s = \"abcdedcba\", c = \"ab\", hasilnya harus ('cdedc',True)\n    ", "natural_language": "Malay"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Anda diberikan petak sumur yang berbentuk segi empat. Setiap baris mewakili satu sumur, dan setiap 1 dalam satu baris mewakili satu unit air. Setiap sumur mempunyai baldi yang sesuai yang boleh digunakan untuk mengekstrak air daripadanya, dan semua baldi mempunyai kapasiti yang sama. Tugas anda adalah menggunakan baldi untuk mengosongkan sumur. Outputkan bilangan kali anda perlu menurunkan baldi.\n\n    Contoh 1:\n    Input:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        kapasiti_baldi: 1\n    Output: 6\n\n    Contoh 2:\n    Input:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        kapasiti_baldi: 2\n    Output: 5\n\n    Contoh 3:\n    Input:\n        grid: [[0,0,0], [0,0,0]]\n        kapasiti_baldi: 5\n    Output: 0\n\n    Sekatan:\n    * semua sumur mempunyai panjang yang sama\n    * 1 <= panjang_grid <= 10^2\n    * 1 <= grid[:,1].panjang <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= kapasiti <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Anda diberikan petak sumur yang berbentuk segi empat. Setiap baris mewakili satu sumur, dan setiap 1 dalam satu baris mewakili satu unit air. Setiap sumur mempunyai baldi yang sesuai yang boleh digunakan untuk mengekstrak air daripadanya, dan semua baldi mempunyai kapasiti yang sama. Tugas anda adalah menggunakan baldi untuk mengosongkan sumur. Outputkan bilangan kali anda perlu menurunkan baldi.\n\n    Contoh 1:\n    Input:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        kapasiti_baldi: 1\n    Output: 6\n\n    Contoh 2:\n    Input:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        kapasiti_baldi: 2\n    Output: 5\n\n    Contoh 3:\n    Input:\n        grid: [[0,0,0], [0,0,0]]\n        kapasiti_baldi: 5\n    Output: 0\n\n    Sekatan:\n    * semua sumur mempunyai panjang yang sama\n    * 1 <= panjang_grid <= 10^2\n    * 1 <= grid[:,1].panjang <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= kapasiti <= 10\n    ", "natural_language": "Malay"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Diberikan sebuah string s dan sebuah bilangan semula jadi n, anda telah diberi tugas untuk melaksanakan sebuah fungsi yang mengembalikan senarai semua perkataan dari string s yang mengandungi tepat n konsonan, dalam urutan perkataan-perkataan ini muncul dalam string s. Jika string s kosong, maka fungsi harus mengembalikan senarai kosong. Nota: anda boleh menganggap string input hanya mengandungi huruf dan ruang. Contoh:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Diberikan sebuah string s dan sebuah bilangan semula jadi n, anda telah diberi tugas untuk melaksanakan sebuah fungsi yang mengembalikan senarai semua perkataan dari string s yang mengandungi tepat n konsonan, dalam urutan perkataan-perkataan ini muncul dalam string s. Jika string s kosong, maka fungsi harus mengembalikan senarai kosong. Nota: anda boleh menganggap string input hanya mengandungi huruf dan ruang. Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Diberikan sebuah array arr berisi bilangan bulat dan sebuah bilangan bulat positif k, kembalikan sebuah daftar yang diurutkan dengan panjang k yang berisi k bilangan terbesar dalam arr.\n\n    Contoh 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n    Output: [-4, -3, 5]\n\n    Contoh 2:\n\n        Input: arr = [4, -4, 4], k = 2\n    Output: [4, 4]\n\n    Contoh 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Output: [2]\n\n    Catatan:\n    1. Panjang array akan berada dalam rentang [1, 1000].\n    2. Elemen-elemen dalam array akan berada dalam rentang [-1000, 1000].\n    3. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Diberikan sebuah array arr berisi bilangan bulat dan sebuah bilangan bulat positif k, kembalikan sebuah daftar yang diurutkan dengan panjang k yang berisi k bilangan terbesar dalam arr.\n\n    Contoh 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n    Output: [-4, -3, 5]\n\n    Contoh 2:\n\n        Input: arr = [4, -4, 4], k = 2\n    Output: [4, 4]\n\n    Contoh 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Output: [2]\n\n    Catatan:\n    1. Panjang array akan berada dalam rentang [1, 1000].\n    2. Elemen-elemen dalam array akan berada dalam rentang [-1000, 1000].\n    3. 0 <= k <= len(arr)\n    ", "natural_language": "Malay"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Diberikan satu array integer yang tidak kosong, arr dan satu integer k, kembalikan jumlah elemen yang mempunyai paling banyak dua digit dari k elemen pertama arr.\n\n    Contoh:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Output: 24 # jumlah 21 + 3\n\n    Batasan:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Diberikan satu array integer yang tidak kosong, arr dan satu integer k, kembalikan jumlah elemen yang mempunyai paling banyak dua digit dari k elemen pertama arr.\n\n    Contoh:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Output: 24 # jumlah 21 + 3\n\n    Batasan:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    ", "natural_language": "Malay"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Anda diberikan dua selang,\n    di mana setiap selang adalah sepasang integer. Contohnya, selang = (mula, akhir) = (1, 2).\n    Selang yang diberikan adalah tertutup yang bermaksud bahawa selang (mula, akhir)\n    termasuk kedua-dua mula dan akhir.\n    Untuk setiap selang yang diberikan, diasumsikan bahawa mula adalah kurang atau sama dengan akhirnya.\n    Tugas anda adalah untuk menentukan sama ada panjang persilangan dua selang ini\n    adalah nombor perdana.\n    Contohnya, persilangan selang (1, 3), (2, 4) adalah (2, 3)\n    yang panjangnya 1, yang bukan nombor perdana.\n    Jika panjang persilangan adalah nombor perdana, kembalikan \"YES\",\n    sebaliknya, kembalikan \"NO\".\n    Jika dua selang tidak berpotongan, kembalikan \"NO\".\n\n    \n    contoh input/output:\n\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Anda diberikan dua selang,\n    di mana setiap selang adalah sepasang integer. Contohnya, selang = (mula, akhir) = (1, 2).\n    Selang yang diberikan adalah tertutup yang bermaksud bahawa selang (mula, akhir)\n    termasuk kedua-dua mula dan akhir.\n    Untuk setiap selang yang diberikan, diasumsikan bahawa mula adalah kurang atau sama dengan akhirnya.\n    Tugas anda adalah untuk menentukan sama ada panjang persilangan dua selang ini\n    adalah nombor perdana.\n    Contohnya, persilangan selang (1, 3), (2, 4) adalah (2, 3)\n    yang panjangnya 1, yang bukan nombor perdana.\n    Jika panjang persilangan adalah nombor perdana, kembalikan \"YES\",\n    sebaliknya, kembalikan \"NO\".\n    Jika dua selang tidak berpotongan, kembalikan \"NO\".\n\n    \n    contoh input/output:\n\n    ", "natural_language": "Malay"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Semua orang tahu tentang urutan Fibonacci, ia telah dikaji secara mendalam oleh ahli matematik dalam beberapa abad yang lalu. Walau bagaimanapun, apa yang orang tidak tahu adalah urutan Tribonacci. Urutan Tribonacci ditakrifkan oleh pengulangan: tri(1) = 3 tri(n) = 1 + n / 2, jika n adalah genap. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), jika n adalah ganjil. Sebagai contoh: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Anda diberikan nombor integer bukan negatif n, anda perlu mengembalikan senarai nombor pertama urutan Tribonacci. Contoh: tri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Semua orang tahu tentang urutan Fibonacci, ia telah dikaji secara mendalam oleh ahli matematik dalam beberapa abad yang lalu. Walau bagaimanapun, apa yang orang tidak tahu adalah urutan Tribonacci. Urutan Tribonacci ditakrifkan oleh pengulangan: tri(1) = 3 tri(n) = 1 + n / 2, jika n adalah genap. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), jika n adalah ganjil. Sebagai contoh: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Anda diberikan nombor integer bukan negatif n, anda perlu mengembalikan senarai nombor pertama urutan Tribonacci. Contoh: tri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Malay"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Diberikan integer positif n, kembalikan hasil kali dari digit ganjil.\n    Kembalikan 0 jika semua digit adalah genap.\n    Contohnya:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Diberikan integer positif n, kembalikan hasil kali dari digit ganjil.\n    Kembalikan 0 jika semua digit adalah genap.\n    Contohnya:\n    ", "natural_language": "Malay"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Cipta satu fungsi yang mengambil rentetan sebagai input yang hanya mengandungi kurungan siku.\nFungsi tersebut harus mengembalikan True jika dan hanya jika terdapat subrentetan kurungan yang sah\ndi mana sekurang-kurangnya satu kurungan dalam subrentetan tersebut bersarang.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Cipta satu fungsi yang mengambil rentetan sebagai input yang hanya mengandungi kurungan siku.\nFungsi tersebut harus mengembalikan True jika dan hanya jika terdapat subrentetan kurungan yang sah\ndi mana sekurang-kurangnya satu kurungan dalam subrentetan tersebut bersarang.\n    ", "natural_language": "Malay"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Anda diberikan senarai nombor.\nAnda perlu mengembalikan jumlah nombor dikuadratkan dalam senarai yang diberikan,\nbulatkan setiap elemen dalam senarai ke int atas (Ceiling) terlebih dahulu.\nContoh:\nUntuk lst = [1,2,3] output harus menjadi 14\nUntuk lst = [1,4,9] output harus menjadi 98\nUntuk lst = [1,3,5,7] output harus menjadi 84\nUntuk lst = [1.4,4.2,0] output harus menjadi 29\nUntuk lst = [-2.4,1,1] output harus menjadi 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Anda diberikan senarai nombor.\nAnda perlu mengembalikan jumlah nombor dikuadratkan dalam senarai yang diberikan,\nbulatkan setiap elemen dalam senarai ke int atas (Ceiling) terlebih dahulu.\nContoh:\nUntuk lst = [1,2,3] output harus menjadi 14\nUntuk lst = [1,4,9] output harus menjadi 98\nUntuk lst = [1,3,5,7] output harus menjadi 84\nUntuk lst = [1.4,4.2,0] output harus menjadi 29\nUntuk lst = [-2.4,1,1] output harus menjadi 6\n    ", "natural_language": "Malay"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Cipta satu fungsi yang mengembalikan nilai Benar jika karakter terakhir\n    dalam rentetan yang diberikan adalah karakter abjad dan bukan\n    sebahagian daripada perkataan, dan palsu sebaliknya.\n    Nota: \"perkataan\" adalah kumpulan karakter yang dipisahkan oleh ruang.\n\n        Contoh:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Cipta satu fungsi yang mengembalikan nilai Benar jika karakter terakhir\n    dalam rentetan yang diberikan adalah karakter abjad dan bukan\n    sebahagian daripada perkataan, dan palsu sebaliknya.\n    Nota: \"perkataan\" adalah kumpulan karakter yang dipisahkan oleh ruang.\n\n        Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Cipta satu fungsi yang mengembalikan indeks terbesar elemen yang tidak lebih besar atau sama dengan elemen yang terletak sebelumnya. Jika tidak ada elemen seperti itu, kembalikan -1. Array yang diberikan tidak akan mengandungi nilai yang sama.\n\n    Contoh:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Cipta satu fungsi yang mengembalikan indeks terbesar elemen yang tidak lebih besar atau sama dengan elemen yang terletak sebelumnya. Jika tidak ada elemen seperti itu, kembalikan -1. Array yang diberikan tidak akan mengandungi nilai yang sama.\n\n    Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Cipta fungsi yang mengembalikan tuple (a, b), di mana 'a' adalah\n    integer negatif terbesar, dan 'b' adalah integer positif terkecil\n    dalam senarai.\n    Jika tiada integer negatif atau positif, kembalikan None.\n\n        Contoh:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Cipta fungsi yang mengembalikan tuple (a, b), di mana 'a' adalah\n    integer negatif terbesar, dan 'b' adalah integer positif terkecil\n    dalam senarai.\n    Jika tiada integer negatif atau positif, kembalikan None.\n\n        Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"Faktorial Brazil ditakrifkan sebagai:\n    faktorial_brazil(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    di mana n > 0\n\n        Contohnya:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "Faktorial Brazil ditakrifkan sebagai:\n    faktorial_brazil(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    di mana n > 0\n\n        Contohnya:\n    ", "natural_language": "Malay"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Anda diberikan sebuah rentetan yang mewakili satu ayat,\n    ayat tersebut mengandungi beberapa perkataan yang dipisahkan oleh satu ruang,\n    dan anda perlu mengembalikan sebuah rentetan yang mengandungi perkataan-perkataan dari ayat asal,\n    yang panjangnya adalah nombor perdana,\n    urutan perkataan dalam rentetan baru harus sama seperti ayat asal.\n\n        Contoh 1:\n        Input: ayat = \"Ini adalah ujian\"\n        Output: \"adalah\"\n\n        Contoh 2:\n        Input: ayat = \"mari pergi berenang\"\n        Output: \"pergi berenang\"\n\n        Keadaan terhad:\n        * 1 <= len(ayat) <= 100\n        * ayat hanya mengandungi huruf-huruf sahaja\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Anda diberikan sebuah rentetan yang mewakili satu ayat,\n    ayat tersebut mengandungi beberapa perkataan yang dipisahkan oleh satu ruang,\n    dan anda perlu mengembalikan sebuah rentetan yang mengandungi perkataan-perkataan dari ayat asal,\n    yang panjangnya adalah nombor perdana,\n    urutan perkataan dalam rentetan baru harus sama seperti ayat asal.\n\n        Contoh 1:\n        Input: ayat = \"Ini adalah ujian\"\n        Output: \"adalah\"\n\n        Contoh 2:\n        Input: ayat = \"mari pergi berenang\"\n        Output: \"pergi berenang\"\n\n        Keadaan terhad:\n        * 1 <= len(ayat) <= 100\n        * ayat hanya mengandungi huruf-huruf sahaja\n    ", "natural_language": "Malay"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Tugas anda adalah untuk melaksanakan fungsi yang akan menyederhanakan ungkapan x * n. Fungsi tersebut akan mengembalikan True jika x * n dievaluasi menjadi bilangan bulat dan False jika tidak. Kedua-dua x dan n, adalah representasi rentetan pecahan, dan mempunyai format berikut, <pembilang>/<penyebut> di mana kedua-dua pembilang dan penyebut adalah nombor bulat positif.\n\n    Anda boleh menganggap bahawa x dan n adalah pecahan yang sah, dan tidak mempunyai sifar sebagai penyebut.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Tugas anda adalah untuk melaksanakan fungsi yang akan menyederhanakan ungkapan x * n. Fungsi tersebut akan mengembalikan True jika x * n dievaluasi menjadi bilangan bulat dan False jika tidak. Kedua-dua x dan n, adalah representasi rentetan pecahan, dan mempunyai format berikut, <pembilang>/<penyebut> di mana kedua-dua pembilang dan penyebut adalah nombor bulat positif.\n\n    Anda boleh menganggap bahawa x dan n adalah pecahan yang sah, dan tidak mempunyai sifar sebagai penyebut.\n    ", "natural_language": "Malay"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Tulis sebuah fungsi yang mengurutkan senarai integer yang diberikan\n    dalam urutan menaik mengikut jumlah digit mereka.\n    Nota: jika terdapat beberapa item dengan jumlah digit yang sama,\n    urutkan mereka berdasarkan indeks mereka dalam senarai asal.\n\n        Contohnya:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Tulis sebuah fungsi yang mengurutkan senarai integer yang diberikan\n    dalam urutan menaik mengikut jumlah digit mereka.\n    Nota: jika terdapat beberapa item dengan jumlah digit yang sama,\n    urutkan mereka berdasarkan indeks mereka dalam senarai asal.\n\n        Contohnya:\n    ", "natural_language": "Malay"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Tulis sebuah fungsi yang mengambil array nombor sebagai input dan mengembalikan jumlah elemen dalam array yang lebih besar dari 10 dan kedua digit pertama dan terakhir nombor adalah ganjil (1, 3, 5, 7, 9). Contohnya:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Tulis sebuah fungsi yang mengambil array nombor sebagai input dan mengembalikan jumlah elemen dalam array yang lebih besar dari 10 dan kedua digit pertama dan terakhir nombor adalah ganjil (1, 3, 5, 7, 9). Contohnya:\n    ", "natural_language": "Malay"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Anda diberikan integer positif n. Anda perlu membuat array integer a dengan panjang n.\n        Untuk setiap i (1 ≤ i ≤ n), nilai a[i] = i * i - i + 1.\n        Kembalikan jumlah triple (a[i], a[j], a[k]) dari a dimana i < j < k, \n    dan a[i] + a[j] + a[k] adalah kelipatan 3.\n\n        Contoh :\n        Input: n = 5\n        Output: 1\n        Penjelasan: \n        a = [1, 3, 7, 13, 21]\n        Satu-satunya triple yang valid adalah (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Anda diberikan integer positif n. Anda perlu membuat array integer a dengan panjang n.\n        Untuk setiap i (1 ≤ i ≤ n), nilai a[i] = i * i - i + 1.\n        Kembalikan jumlah triple (a[i], a[j], a[k]) dari a dimana i < j < k, \n    dan a[i] + a[j] + a[k] adalah kelipatan 3.\n\n        Contoh :\n        Input: n = 5\n        Output: 1\n        Penjelasan: \n        a = [1, 3, 7, 13, 21]\n        Satu-satunya triple yang valid adalah (1, 7, 13).\n    ", "natural_language": "Malay"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    Terdapat lapan planet dalam sistem solar kita: yang terdekat dengan Matahari ialah Merkuri, yang seterusnya ialah Venus, kemudian Bumi, Mars, Jupiter, Saturnus, Uranus, Neptunus. Tulis satu fungsi yang mengambil dua nama planet sebagai rentetan planet1 dan planet2. Fungsi tersebut harus mengembalikan satu tuple yang mengandungi semua planet yang orbitnya terletak di antara orbit planet1 dan orbit planet2, diurutkan mengikut kedekatan dengan Matahari. Fungsi tersebut harus mengembalikan tuple kosong jika planet1 atau planet2 bukan nama planet yang betul. Contoh-contoh.\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "Terdapat lapan planet dalam sistem solar kita: yang terdekat dengan Matahari ialah Merkuri, yang seterusnya ialah Venus, kemudian Bumi, Mars, Jupiter, Saturnus, Uranus, Neptunus. Tulis satu fungsi yang mengambil dua nama planet sebagai rentetan planet1 dan planet2. Fungsi tersebut harus mengembalikan satu tuple yang mengandungi semua planet yang orbitnya terletak di antara orbit planet1 dan orbit planet2, diurutkan mengikut kedekatan dengan Matahari. Fungsi tersebut harus mengembalikan tuple kosong jika planet1 atau planet2 bukan nama planet yang betul. Contoh-contoh.\n    ", "natural_language": "Malay"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Satu program mudah yang sepatutnya mengembalikan nilai x jika n adalah nombor perdana dan sepatutnya mengembalikan nilai y jika tidak.\n\n    Contoh:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Satu program mudah yang sepatutnya mengembalikan nilai x jika n adalah nombor perdana dan sepatutnya mengembalikan nilai y jika tidak.\n\n    Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Diberi senarai nombor, kembalikan jumlah kuasa dua nombor dalam senarai yang ganjil. Abaikan nombor yang negatif atau bukan integer.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n    \n    Jika senarai input kosong, kembalikan 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Diberi senarai nombor, kembalikan jumlah kuasa dua nombor dalam senarai yang ganjil. Abaikan nombor yang negatif atau bukan integer.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n    \n    Jika senarai input kosong, kembalikan 0.\n    ", "natural_language": "Malay"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Anda akan diberikan nama kelas (string) dan senarai sambungan. Sambungan tersebut akan digunakan untuk memuatkan kelas tambahan ke dalam kelas. Kekuatan sambungan adalah seperti berikut: Biarkan CAP menjadi jumlah huruf besar dalam nama sambungan, dan biarkan SM menjadi jumlah huruf kecil dalam nama sambungan, kekuatan diberikan oleh pecahan CAP - SM. Anda harus mencari sambungan yang paling kuat dan mengembalikan string dalam format ini: ClassName.StrongestExtensionName. Jika terdapat dua atau lebih sambungan dengan kekuatan yang sama, anda harus memilih yang terletak di bahagian atas senarai. Sebagai contoh, jika anda diberikan \"Slices\" sebagai kelas dan senarai sambungan: ['SErviNGSliCes', 'Cheese', 'StuFfed'], maka anda harus mengembalikan 'Slices.SErviNGSliCes' kerana 'SErviNGSliCes' adalah sambungan yang paling kuat (kekuatannya adalah -1). Contoh:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Anda akan diberikan nama kelas (string) dan senarai sambungan. Sambungan tersebut akan digunakan untuk memuatkan kelas tambahan ke dalam kelas. Kekuatan sambungan adalah seperti berikut: Biarkan CAP menjadi jumlah huruf besar dalam nama sambungan, dan biarkan SM menjadi jumlah huruf kecil dalam nama sambungan, kekuatan diberikan oleh pecahan CAP - SM. Anda harus mencari sambungan yang paling kuat dan mengembalikan string dalam format ini: ClassName.StrongestExtensionName. Jika terdapat dua atau lebih sambungan dengan kekuatan yang sama, anda harus memilih yang terletak di bahagian atas senarai. Sebagai contoh, jika anda diberikan \"Slices\" sebagai kelas dan senarai sambungan: ['SErviNGSliCes', 'Cheese', 'StuFfed'], maka anda harus mengembalikan 'Slices.SErviNGSliCes' kerana 'SErviNGSliCes' adalah sambungan yang paling kuat (kekuatannya adalah -1). Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Anda diberikan 2 perkataan. Anda perlu mengembalikan True jika perkataan kedua atau mana-mana rotasinya adalah substring dalam perkataan pertama.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Anda diberikan 2 perkataan. Anda perlu mengembalikan True jika perkataan kedua atau mana-mana rotasinya adalah substring dalam perkataan pertama.\n    ", "natural_language": "Malay"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Diberikan sebuah integer positif, dapatkan nilai romawi yang setara sebagai string,\n    dan kembalikan dalam huruf kecil.\n    Batasan: 1 <= num <= 1000\n\n        Contoh:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Diberikan sebuah integer positif, dapatkan nilai romawi yang setara sebagai string,\n    dan kembalikan dalam huruf kecil.\n    Batasan: 1 <= num <= 1000\n\n        Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Diberikan panjang tiga sisi segitiga. Kembalikan True jika ketiga sisi membentuk segitiga siku-siku, False jika tidak. Segitiga siku-siku adalah segitiga di mana salah satu sudutnya adalah sudut siku-siku atau 90 derajat. Contoh:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Diberikan panjang tiga sisi segitiga. Kembalikan True jika ketiga sisi membentuk segitiga siku-siku, False jika tidak. Segitiga siku-siku adalah segitiga di mana salah satu sudutnya adalah sudut siku-siku atau 90 derajat. Contoh:\n    ", "natural_language": "Malay"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Anda diberikan sebuah rentetan s.\n    jika s[i] adalah huruf, ubah keadaannya dari kecil ke besar atau sebaliknya,\n    jika tidak, biarkan seperti itu.\n    Jika rentetan tidak mengandungi huruf, balikkan rentetan.\n    Fungsi harus mengembalikan rentetan yang dihasilkan.\n    Contoh-contoh\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Anda diberikan sebuah rentetan s.\n    jika s[i] adalah huruf, ubah keadaannya dari kecil ke besar atau sebaliknya,\n    jika tidak, biarkan seperti itu.\n    Jika rentetan tidak mengandungi huruf, balikkan rentetan.\n    Fungsi harus mengembalikan rentetan yang dihasilkan.\n    Contoh-contoh\n    ", "natural_language": "Malay"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Diberikan sebuah string 'text', kembalikan string yang setara dengan hash md5-nya.\n    Jika 'text' adalah string kosong, kembalikan null.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Diberikan sebuah string 'text', kembalikan string yang setara dengan hash md5-nya.\n    Jika 'text' adalah string kosong, kembalikan null.\n    ", "natural_language": "Malay"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Diberikan dua integer positif a dan b, kembalikan digit genap antara a dan b, dalam urutan menaik.\n\n    Contoh:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Diberikan dua integer positif a dan b, kembalikan digit genap antara a dan b, dalam urutan menaik.\n\n    Contoh:\n    ", "natural_language": "Malay"}
