{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" קיבלת רשימה של פעולות הפקדה ומשיכה בחשבון בנק שמתחיל עם מאזן שווה לאפס. המטרה שלך היא לזהות אם בכל נקודה המאזן של החשבון יורד מתחת לאפס, ובאותה נקודה הפונקציה צריכה להחזיר True. אחרת זה צריך להחזיר False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "קיבלת רשימה של פעולות הפקדה ומשיכה בחשבון בנק שמתחיל עם מאזן שווה לאפס. המטרה שלך היא לזהות אם בכל נקודה המאזן של החשבון יורד מתחת לאפס, ובאותה נקודה הפונקציה צריכה להחזיר True. אחרת זה צריך להחזיר False.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" עבור רשימת מספרים נתונה, החזר צמד של סכום וכפל כל המספרים ברשימה.\nסכום ריק צריך להיות שווה ל-0 וכפל ריק צריך להיות שווה ל-1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "עבור רשימת מספרים נתונה, החזר צמד של סכום וכפל כל המספרים ברשימה.\nסכום ריק צריך להיות שווה ל-0 וכפל ריק צריך להיות שווה ל-1.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" הקלט הוא שני מחרוזות a ו-b המורכבות רק מ-1 ו-0.\nבצע XOR בינארי על הקלטים הללו והחזר את התוצאה גם כמחרוזת.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "הקלט הוא שני מחרוזות a ו-b המורכבות רק מ-1 ו-0.\nבצע XOR בינארי על הקלטים הללו והחזר את התוצאה גם כמחרוזת.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" מתוך רשימת מחרוזות, החזר את הארוכה ביותר. החזר את הראשונה במקרה של מספר מחרוזות באותו אורך. החזר null במקרה של רשימת הקלט ריקה.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "מתוך רשימת מחרוזות, החזר את הארוכה ביותר. החזר את הראשונה במקרה של מספר מחרוזות באותו אורך. החזר null במקרה של רשימת הקלט ריקה.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" החזר את המחלק המשותף הגדול ביותר של שני מספרים a ו-b.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "החזר את המחלק המשותף הגדול ביותר של שני מספרים a ו-b.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" הקלט הוא מחרוזת המופרדת ברווחים של מספרים מ-'אפס' עד 'תשע'.\nהאפשרויות החוקיות הן 'אפס', 'אחד', 'שניים', 'שלושה', 'ארבעה', 'חמישה', 'ששה', 'שבעה', 'שמונה' ו-'תשע'.\nהחזר את המחרוזת עם המספרים ממוינים מהקטן לגדול.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "הקלט הוא מחרוזת המופרדת ברווחים של מספרים מ-'אפס' עד 'תשע'.\nהאפשרויות החוקיות הן 'אפס', 'אחד', 'שניים', 'שלושה', 'ארבעה', 'חמישה', 'ששה', 'שבעה', 'שמונה' ו-'תשע'.\nהחזר את המחרוזת עם המספרים ממוינים מהקטן לגדול.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" נתונה רשימה של מספרים (בפחות משני איברים), להחיל המרה לינארית על הרשימה כך שהמספר הקטן ביותר יהפוך ל-0 והגדול ביותר יהפוך ל-1.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "נתונה רשימה של מספרים (בפחות משני איברים), להחיל המרה לינארית על הרשימה כך שהמספר הקטן ביותר יהפוך ל-0 והגדול ביותר יהפוך ל-1.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" עבור מחרוזת נתונה, הפוך תווים באותיות קטנות לאותיות גדולות ואותיות גדולות לאותיות קטנות.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "עבור מחרוזת נתונה, הפוך תווים באותיות קטנות לאותיות גדולות ואותיות גדולות לאותיות קטנות.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"החזר רק מספרים חיוביים ברשימה.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "החזר רק מספרים חיוביים ברשימה.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"החזר ערך אמת אם המספר הנתון הוא מספר ראשוני, ושקר אחרת.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "החזר ערך אמת אם המספר הנתון הוא מספר ראשוני, ושקר אחרת.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"החזר אלמנטים ייחודיים ממוינים ברשימה\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "החזר אלמנטים ייחודיים ממוינים ברשימה\n    ", "natural_language": "Hebrew"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib מחזיר את המספר ה-n של סדרת פיבונאצ'י שהוא גם מספר ראשוני.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib מחזיר את המספר ה-n של סדרת פיבונאצ'י שהוא גם מספר ראשוני.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    הפונקציה triples_sum_to_zero מקבלת רשימה של מספרים שלמים כקלט.\nהיא מחזירה True אם יש שלושה איברים שונים ברשימה שסכומם שווה לאפס, ו-False אחרת.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "הפונקציה triples_sum_to_zero מקבלת רשימה של מספרים שלמים כקלט.\nהיא מחזירה True אם יש שלושה איברים שונים ברשימה שסכומם שווה לאפס, ו-False אחרת.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero מקבל רשימה של מספרים שלמים כקלט.\nהפונקציה מחזירה True אם ישנם שני איברים שונים ברשימה שסכומם שווה לאפס, ו-False אחרת.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "pairs_sum_to_zero מקבל רשימה של מספרים שלמים כקלט.\nהפונקציה מחזירה True אם ישנם שני איברים שונים ברשימה שסכומם שווה לאפס, ו-False אחרת.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"סדרת מספרי Fib4 היא סדרה דומה לסדרת פיבונאצ'י המוגדרת כך:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    אנא כתוב פונקציה לחישוב ביצועי של האיבר ה-n של סדרת מספרי Fib4. אין להשתמש ברקורסיה.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "סדרת מספרי Fib4 היא סדרה דומה לסדרת פיבונאצ'י המוגדרת כך:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    אנא כתוב פונקציה לחישוב ביצועי של האיבר ה-n של סדרת מספרי Fib4. אין להשתמש ברקורסיה.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"החזר את החציון של האיברים ברשימה l.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "החזר את החציון של האיברים ברשימה l.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    בודק אם המחרוזת הנתונה היא פלינדרום.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "בודק אם המחרוזת הנתונה היא פלינדרום.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels היא פונקציה שמקבלת מחרוזת ומחזירה מחרוזת ללא תנועות שפתיים.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels היא פונקציה שמקבלת מחרוזת ומחזירה מחרוזת ללא תנועות שפתיים.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"החזר True אם כל המספרים ברשימה l נמצאים מתחת לסף t.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "החזר True אם כל המספרים ברשימה l נמצאים מתחת לסף t.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"הוסף שני מספרים x ו-y\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "הוסף שני מספרים x ו-y\n    ", "natural_language": "Hebrew"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    בדוק אם שתי מילים כוללות את אותם התווים.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "בדוק אם שתי מילים כוללות את אותם התווים.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"החזר את המספר ה-n של סדרת פיבונאצ'י.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "החזר את המספר ה-n של סדרת פיבונאצ'י.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"החזר את האיברים המשותפים והייחודיים של שני רשימות ממוינות.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "החזר את האיברים המשותפים והייחודיים של שני רשימות ממוינות.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"החזר את הגורם הראשון הגדול ביותר של n. הנח כי n > 1 ואינו מספר ראשוני.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "החזר את הגורם הראשון הגדול ביותר של n. הנח כי n > 1 ואינו מספר ראשוני.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n הוא פונקציה שמסכמת מספרים מ-1 עד n.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n הוא פונקציה שמסכמת מספרים מ-1 עד n.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs מייצגים מקדמים של פולינום.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     החזר את הנגזרת של הפולינום הזה באותה הצורה.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs מייצגים מקדמים של פולינום.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     החזר את הנגזרת של הפולינום הזה באותה הצורה.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"הרצף מספרי FibFib הוא רצף דומה לרצף פיבונאצ'י המוגדר כך:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    אנא כתוב פונקציה לחישוב ביצועי של האיבר ה-n של רצף מספרי FibFib.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "הרצף מספרי FibFib הוא רצף דומה לרצף פיבונאצ'י המוגדר כך:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    אנא כתוב פונקציה לחישוב ביצועי של האיבר ה-n של רצף מספרי FibFib.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"כתוב פונקציה בשם vowels_count המקבלת מחרוזת המייצגת מילה ומחזירה את מספר התווים הקוליים במחרוזת. התווים הקוליים במקרה זה הם 'a', 'e', 'i', 'o', 'u'. כאן, 'y' הוא גם תו קולי, אך רק כאשר הוא בסוף המילה הנתונה.\n\n    דוגמה:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "כתוב פונקציה בשם vowels_count המקבלת מחרוזת המייצגת מילה ומחזירה את מספר התווים הקוליים במחרוזת. התווים הקוליים במקרה זה הם 'a', 'e', 'i', 'o', 'u'. כאן, 'y' הוא גם תו קולי, אך רק כאשר הוא בסוף המילה הנתונה.\n\n    דוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    קיבלתם רשימה לא ריקה של מספרים שלמים חיוביים. החזירו את המספר הגדול ביותר שהוא גדול מאפס והתדירות שלו גדולה או שווה לערך של המספר עצמו. התדירות של מספר הוא מספר הפעמים שהוא מופיע ברשימה. אם אין ערך כזה, החזירו -1.\nדוגמאות:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "קיבלתם רשימה לא ריקה של מספרים שלמים חיוביים. החזירו את המספר הגדול ביותר שהוא גדול מאפס והתדירות שלו גדולה או שווה לערך של המספר עצמו. התדירות של מספר הוא מספר הפעמים שהוא מופיע ברשימה. אם אין ערך כזה, החזירו -1.\nדוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    נתונות אורכי הצלעות של משולש. החזר את שטח המשולש מעוגל ל-2 נקודות עשרוניות אם הצלעות מהווים משולש תקין. אחרת, החזר -1. שלושת הצלעות מהוות משולש תקין כאשר סכום כל שני צלעות גדול מהצלע השלישי. דוגמה:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "נתונות אורכי הצלעות של משולש. החזר את שטח המשולש מעוגל ל-2 נקודות עשרוניות אם הצלעות מהווים משולש תקין. אחרת, החזר -1. שלושת הצלעות מהוות משולש תקין כאשר סכום כל שני צלעות גדול מהצלע השלישי. דוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    כתוב פונקציה שמחזירה True אם האובייקט q יכול לטוס, ו-False אחרת.\nהאובייקט q יכול לטוס אם הוא מאוזן (זהו רשימה פלינדרומית) וסכום האיברים שלו קטן או שווה למשקל המקסימלי האפשרי w.\n\n    דוגמה:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 קטן מהמשקל המקסימלי האפשרי, אך הוא לא מאוזן.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# הוא מאוזן, אך 3+2+3 גדול מהמשקל המקסימלי האפשרי.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 קטן מהמשקל המקסימלי האפשרי, והוא מאוזן.\n\n    will_it_fly([3], 5) ➞ True\n# 3 קטן מהמשקל המקסימלי האפשרי, והוא מאוזן.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "כתוב פונקציה שמחזירה True אם האובייקט q יכול לטוס, ו-False אחרת.\nהאובייקט q יכול לטוס אם הוא מאוזן (זהו רשימה פלינדרומית) וסכום האיברים שלו קטן או שווה למשקל המקסימלי האפשרי w.\n\n    דוגמה:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 קטן מהמשקל המקסימלי האפשרי, אך הוא לא מאוזן.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# הוא מאוזן, אך 3+2+3 גדול מהמשקל המקסימלי האפשרי.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 קטן מהמשקל המקסימלי האפשרי, והוא מאוזן.\n\n    will_it_fly([3], 5) ➞ True\n# 3 קטן מהמשקל המקסימלי האפשרי, והוא מאוזן.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"כתוב פונקציה שמחזירה אמת אם המספר הנתון הוא כפל של 3 מספרים ראשוניים ושקר אחרת.\n    ידוע ש-(a) קטן מ-100.\n    לדוגמה:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "כתוב פונקציה שמחזירה אמת אם המספר הנתון הוא כפל של 3 מספרים ראשוניים ושקר אחרת.\n    ידוע ש-(a) קטן מ-100.\n    לדוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"יש לך מספר בצורת עשרונית והמטרה שלך היא להמיר אותו לפורמט בינארי. הפונקציה צריכה להחזיר מחרוזת, כאשר כל תו מייצג מספר בינארי. כל תו במחרוזת יהיה '0' או '1'.\n\n    יהיו זוג תווים נוספים 'db' בתחילת ובסוף המחרוזת. התווים הנוספים נמצאים שם כדי לעזור עם הפורמט.\n\n    דוגמאות:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "יש לך מספר בצורת עשרונית והמטרה שלך היא להמיר אותו לפורמט בינארי. הפונקציה צריכה להחזיר מחרוזת, כאשר כל תו מייצג מספר בינארי. כל תו במחרוזת יהיה '0' או '1'.\n\n    יהיו זוג תווים נוספים 'db' בתחילת ובסוף המחרוזת. התווים הנוספים נמצאים שם כדי לעזור עם הפורמט.\n\n    דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"נתון לך מחרוזת s.\nהמטרה שלך היא לבדוק אם המחרוזת היא שמחה או לא.\nמחרוזת שמחה היא אם אורכה הוא לפחות 3 וכל 3 אותיות רצופות הם שונים.\nלדוגמה:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "נתון לך מחרוזת s.\nהמטרה שלך היא לבדוק אם המחרוזת היא שמחה או לא.\nמחרוזת שמחה היא אם אורכה הוא לפחות 3 וכל 3 אותיות רצופות הם שונים.\nלדוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"זו השבוע האחרון של הסמסטר והמורה צריך לתת את הציונים לתלמידים. המורה יצרה אלגוריתם משלה לציון. הבעיה היחידה היא שהיא איבדה את הקוד שהשתמשה בו לציון. היא נתנה לך רשימה של ציוני GPA לכמה תלמידים ואתה צריך לכתוב פונקציה שיכולה להפיק רשימה של ציוני אותיות באמצעות הטבלה הבאה:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        דוגמה:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "זו השבוע האחרון של הסמסטר והמורה צריך לתת את הציונים לתלמידים. המורה יצרה אלגוריתם משלה לציון. הבעיה היחידה היא שהיא איבדה את הקוד שהשתמשה בו לציון. היא נתנה לך רשימה של ציוני GPA לכמה תלמידים ואתה צריך לכתוב פונקציה שיכולה להפיק רשימה של ציוני אותיות באמצעות הטבלה הבאה:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        דוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"כתוב פונקציה שמקבלת מחרוזת ומחזירה True אם אורך המחרוזת הוא מספר ראשוני או False אחרת\nדוגמאות\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "כתוב פונקציה שמקבלת מחרוזת ומחזירה True אם אורך המחרוזת הוא מספר ראשוני או False אחרת\nדוגמאות\n    ", "natural_language": "Hebrew"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"נתון מספר שלם חיובי N, החזר את סכום הספרות שלו במספרים בינאריים.\n\n    דוגמה:\nעבור N = 1000, סכום הספרות יהיה 1 והפלט צריך להיות \"1\".\nעבור N = 150, סכום הספרות יהיה 6 והפלט צריך להיות \"110\".\nעבור N = 147, סכום הספרות יהיה 12 והפלט צריך להיות \"1100\".\n\n    משתנים:\n@N מספר שלם\n     הגבלות: 0 ≤ N ≤ 10000.\n\n    פלט:\nמחרוזת מספר בינארי.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "נתון מספר שלם חיובי N, החזר את סכום הספרות שלו במספרים בינאריים.\n\n    דוגמה:\nעבור N = 1000, סכום הספרות יהיה 1 והפלט צריך להיות \"1\".\nעבור N = 150, סכום הספרות יהיה 6 והפלט צריך להיות \"110\".\nעבור N = 147, סכום הספרות יהיה 12 והפלט צריך להיות \"1100\".\n\n    משתנים:\n@N מספר שלם\n     הגבלות: 0 ≤ N ≤ 10000.\n\n    פלט:\nמחרוזת מספר בינארי.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    נתון לך נתונים דו-ממדיים, בתור רשימות מקוננות, הדומים למטריצה, אך לא כמו מטריצות, כיוון שכל שורה עשויה להכיל מספר שונה של עמודות. נתון רשימה (lst) ומספר שלם (x), מצא מספרים שווים ל-x ברשימה והחזר רשימת זוגות, [(x1, y1), (x2, y2) ...] כך שכל זוג הוא קואורדינטה - (שורה, עמודות), החל מ-0. מיין את הקואורדינטות בהתחלה לפי השורות בסדר עולה. כמו כן, מיין את הקואורדינטות של השורה לפי העמודות בסדר יורד.\n\n    דוגמאות:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "נתון לך נתונים דו-ממדיים, בתור רשימות מקוננות, הדומים למטריצה, אך לא כמו מטריצות, כיוון שכל שורה עשויה להכיל מספר שונה של עמודות. נתון רשימה (lst) ומספר שלם (x), מצא מספרים שווים ל-x ברשימה והחזר רשימת זוגות, [(x1, y1), (x2, y2) ...] כך שכל זוג הוא קואורדינטה - (שורה, עמודות), החל מ-0. מיין את הקואורדינטות בהתחלה לפי השורות בסדר עולה. כמו כן, מיין את הקואורדינטות של השורה לפי העמודות בסדר יורד.\n\n    דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    קיבלת רשימה של מספרים שלמים.\nכתוב פונקציה next_smallest() שמחזירה את האיבר השני הקטן ביותר ברשימה.\nהחזר null אם אין איבר כזה.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "קיבלת רשימה של מספרים שלמים.\nכתוב פונקציה next_smallest() שמחזירה את האיבר השני הקטן ביותר ברשימה.\nהחזר null אם אין איבר כזה.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    ינתן לך מחרוזת של מילים, ומטרתך היא לספור את מספר המשעממויות. משעממות הן משפטים שמתחילים עם המילה \"אני\". משפטים מופרדים על ידי '.', '?' או '!'.\n\n    לדוגמה:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "ינתן לך מחרוזת של מילים, ומטרתך היא לספור את מספר המשעממויות. משעממות הן משפטים שמתחילים עם המילה \"אני\". משפטים מופרדים על ידי '.', '?' או '!'.\n\n    לדוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"נתונה לך רשימה של מספרים שלמים.\nעליך למצוא את הערך הראשון הגדול ביותר שהוא מספר ראשוני ולהחזיר את סכום הספרות שלו.\n\n    דוגמאות:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "נתונה לך רשימה של מספרים שלמים.\nעליך למצוא את הערך הראשון הגדול ביותר שהוא מספר ראשוני ולהחזיר את סכום הספרות שלו.\n\n    דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    נתון מילון, החזר True אם כל המפתחות הם מחרוזות באותיות קטנות או כל המפתחות הם מחרוזות באותיות גדולות, אחרת החזר False. הפונקציה צריכה להחזיר False אם המילון הנתון ריק. דוגמאות:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "נתון מילון, החזר True אם כל המפתחות הם מחרוזות באותיות קטנות או כל המפתחות הם מחרוזות באותיות גדולות, אחרת החזר False. הפונקציה צריכה להחזיר False אם המילון הנתון ריק. דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    צור פונקציה שמקבלת ערך (מחרוזת) המייצג מספר ומחזירה את המספר השלם הקרוב ביותר אליו. אם המספר זהה מרחק משני מספרים שלמים, עגל אותו לפי הכיוון המרחק מהאפס.\n\n    דוגמאות:\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "צור פונקציה שמקבלת ערך (מחרוזת) המייצג מספר ומחזירה את המספר השלם הקרוב ביותר אליו. אם המספר זהה מרחק משני מספרים שלמים, עגל אותו לפי הכיוון המרחק מהאפס.\n\n    דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    נתון מספר שלם חיובי n, עליך ליצור ערימה של n רמות אבנים.\nהרמה הראשונה כוללת n אבנים.\nמספר האבנים ברמה הבאה הוא:\n- המספר הבא האי-זוגי אם n הוא מספר אי-זוגי.\n- המספר הבא הזוגי אם n הוא מספר זוגי.\nהחזר את מספר האבנים בכל רמה ברשימה, כאשר האיבר במקום i מייצג את מספר האבנים ברמה (i+1).\n\n    דוגמאות:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "נתון מספר שלם חיובי n, עליך ליצור ערימה של n רמות אבנים.\nהרמה הראשונה כוללת n אבנים.\nמספר האבנים ברמה הבאה הוא:\n- המספר הבא האי-זוגי אם n הוא מספר אי-זוגי.\n- המספר הבא הזוגי אם n הוא מספר זוגי.\nהחזר את מספר האבנים בכל רמה ברשימה, כאשר האיבר במקום i מייצג את מספר האבנים ברמה (i+1).\n\n    דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    ינתן לך מחרוזת של מילים המופרדות בפסיקים או ברווחים. המטרה שלך היא לפצל את המחרוזת למילים ולהחזיר מערך של המילים.\n\n    לדוגמה:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "ינתן לך מחרוזת של מילים המופרדות בפסיקים או ברווחים. המטרה שלך היא לפצל את המחרוזת למילים ולהחזיר מערך של המילים.\n\n    לדוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"פונקציה זו מקבלת שני מספרים חיוביים x ו-y ומחזירה את המספר הזוגי הגדול ביותר שנמצא בטווח [x, y] כולל. אם אין מספר כזה, הפונקציה צריכה להחזיר -1.\n\n    לדוגמה:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "פונקציה זו מקבלת שני מספרים חיוביים x ו-y ומחזירה את המספר הזוגי הגדול ביותר שנמצא בטווח [x, y] כולל. אם אין מספר כזה, הפונקציה צריכה להחזיר -1.\n\n    לדוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"נתונים שני מספרים שלמים חיוביים n ו-m, והמטרה שלך היא לחשב את הממוצע של המספרים מ-n עד m (כולל n ו-m). עגל את התשובה למספר השלם הקרוב ביותר והמר את זה לבינארי. אם n גדול מ-m, החזר -1. דוגמה:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "נתונים שני מספרים שלמים חיוביים n ו-m, והמטרה שלך היא לחשב את הממוצע של המספרים מ-n עד m (כולל n ו-m). עגל את התשובה למספר השלם הקרוב ביותר והמר את זה לבינארי. אם n גדול מ-m, החזר -1. דוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" מימוש הפונקציה f שמקבלת את n כפרמטר ומחזירה רשימה בגודל n, כך שערך האיבר במקום i הוא הפקטוריאל של i אם i הוא מספר זוגי, או סכום המספרים מ-1 עד i אחרת. i מתחיל מ-1. הפקטוריאל של i הוא הכפל של המספרים מ-1 עד i (1 * 2 * ... * i). דוגמה:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "מימוש הפונקציה f שמקבלת את n כפרמטר ומחזירה רשימה בגודל n, כך שערך האיבר במקום i הוא הפקטוריאל של i אם i הוא מספר זוגי, או סכום המספרים מ-1 עד i אחרת. i מתחיל מ-1. הפקטוריאל של i הוא הכפל של המספרים מ-1 עד i (1 * 2 * ... * i). דוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    נתון מספר שלם חיובי n, יש להחזיר טאפל שמכיל את מספר הפלינדרומים הזוגיים והאי זוגיים שנמצאים בטווח (1, n), כולל.\n\n    דוגמה 1:\n\n        קלט: 3\n    פלט: (1, 2)\n    הסבר:\n    פלינדרומים הם 1, 2, 3. אחד מהם הוא זוגי ושניים מהם הם אי זוגיים.\n\n    דוגמה 2:\n\n        קלט: 12\n    פלט: (4, 6)\n    הסבר:\n    פלינדרומים הם 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. ארבעה מהם הם זוגיים וששה מהם הם אי זוגיים.\n\n    הערה:\n    1. 1 <= n <= 10^3\n    2. הטאפל שמוחזר מכיל את מספר הפלינדרומים הזוגיים והאי זוגיים בהתאמה.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "נתון מספר שלם חיובי n, יש להחזיר טאפל שמכיל את מספר הפלינדרומים הזוגיים והאי זוגיים שנמצאים בטווח (1, n), כולל.\n\n    דוגמה 1:\n\n        קלט: 3\n    פלט: (1, 2)\n    הסבר:\n    פלינדרומים הם 1, 2, 3. אחד מהם הוא זוגי ושניים מהם הם אי זוגיים.\n\n    דוגמה 2:\n\n        קלט: 12\n    פלט: (4, 6)\n    הסבר:\n    פלינדרומים הם 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. ארבעה מהם הם זוגיים וששה מהם הם אי זוגיים.\n\n    הערה:\n    1. 1 <= n <= 10^3\n    2. הטאפל שמוחזר מכיל את מספר הפלינדרומים הזוגיים והאי זוגיים בהתאמה.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"יש לנו מערך 'arr' של N מספרים arr[1], arr[2], ..., arr[N]. המספרים במערך יהיו בסדר רנדומלי. המטרה שלך היא לקבוע אם ניתן לקבל מערך ממוין בסדר לא יורד על ידי ביצוע הפעולה הבאה על המערך הנתון:\n    ניתן לבצע פעולת הזזת ימינה כל מספר של פעמים.\n    \n    פעולת ההזזה הימנית אחת משמעותה להזיז את כל האיברים של המערך במקום אחד לכיוון הימין. האיבר האחרון של המערך יועבר למקום ההתחלתי במערך, כלומר לאינדקס 0.\n\n        אם ניתן לקבל את המערך הממוין על ידי ביצוע הפעולה הנ\"ל, יש להחזיר True, אחרת יש להחזיר False.\n    אם המערך הנתון ריק, יש להחזיר True.\n\n        לתשומת לב: הרשימה הנתונה מובטחת להכיל איברים ייחודיים.\n\n        לדוגמה:\n\n        move_one_ball([3, 4, 5, 1, 2])==>True\n    הסבר: על ידי ביצוע 2 פעולות הזזה ימינה, ניתן להשיג סדר לא יורד עבור המערך הנתון.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    הסבר: אי אפשר לקבל סדר לא יורד עבור המערך הנתון על ידי ביצוע כל מספר של פעולות הזזה ימינה.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "יש לנו מערך 'arr' של N מספרים arr[1], arr[2], ..., arr[N]. המספרים במערך יהיו בסדר רנדומלי. המטרה שלך היא לקבוע אם ניתן לקבל מערך ממוין בסדר לא יורד על ידי ביצוע הפעולה הבאה על המערך הנתון:\n    ניתן לבצע פעולת הזזת ימינה כל מספר של פעמים.\n    \n    פעולת ההזזה הימנית אחת משמעותה להזיז את כל האיברים של המערך במקום אחד לכיוון הימין. האיבר האחרון של המערך יועבר למקום ההתחלתי במערך, כלומר לאינדקס 0.\n\n        אם ניתן לקבל את המערך הממוין על ידי ביצוע הפעולה הנ\"ל, יש להחזיר True, אחרת יש להחזיר False.\n    אם המערך הנתון ריק, יש להחזיר True.\n\n        לתשומת לב: הרשימה הנתונה מובטחת להכיל איברים ייחודיים.\n\n        לדוגמה:\n\n        move_one_ball([3, 4, 5, 1, 2])==>True\n    הסבר: על ידי ביצוע 2 פעולות הזזה ימינה, ניתן להשיג סדר לא יורד עבור המערך הנתון.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    הסבר: אי אפשר לקבל סדר לא יורד עבור המערך הנתון על ידי ביצוע כל מספר של פעולות הזזה ימינה.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"בבעיה זו, תכתבו פונקציה שמקבלת שתי רשימות של מספרים,\n    ומקבלת החלטה אם ניתן לבצע החלפת איברים\n    ביניהם כדי להפוך את lst1 לרשימה של מספרים זוגיים בלבד.\n    אין מגבלה על מספר האיברים שניתן להחליף בין lst1 ו-lst2.\n    אם ניתן להחליף איברים בין lst1 ו-lst2 כדי להפוך\n    את כל האיברים של lst1 להיות זוגיים, יש להחזיר \"YES\".\n    אחרת, יש להחזיר \"NO\".\n    לדוגמה:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    ניתן להניח כי הרשימות הקלט יהיו לא ריקות.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "בבעיה זו, תכתבו פונקציה שמקבלת שתי רשימות של מספרים,\n    ומקבלת החלטה אם ניתן לבצע החלפת איברים\n    ביניהם כדי להפוך את lst1 לרשימה של מספרים זוגיים בלבד.\n    אין מגבלה על מספר האיברים שניתן להחליף בין lst1 ו-lst2.\n    אם ניתן להחליף איברים בין lst1 ו-lst2 כדי להפוך\n    את כל האיברים של lst1 להיות זוגיים, יש להחזיר \"YES\".\n    אחרת, יש להחזיר \"NO\".\n    לדוגמה:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    ניתן להניח כי הרשימות הקלט יהיו לא ריקות.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"מטלה\n    נתונות שתי מחרוזות s ו-c, עליכם למחוק את כל התווים ב-s שזהים לכל תו ב-c\n    ולאחר מכן לבדוק אם המחרוזת התוצאה היא פלינדרום.\n    מחרוזת נקראת פלינדרום אם היא קוראת אותו הדבר לפנים ולאחור.\n    עליכם להחזיר טופל המכיל את המחרוזת התוצאה ו-True/False עבור הבדיקה.\n    דוגמא\n    עבור s = \"abcde\", c = \"ae\", התוצאה צריכה להיות ('bcd',False)\n    עבור s = \"abcdef\", c = \"b\" התוצאה צריכה להיות ('acdef',False)\n    עבור s = \"abcdedcba\", c = \"ab\", התוצאה צריכה להיות ('cdedc',True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "מטלה\n    נתונות שתי מחרוזות s ו-c, עליכם למחוק את כל התווים ב-s שזהים לכל תו ב-c\n    ולאחר מכן לבדוק אם המחרוזת התוצאה היא פלינדרום.\n    מחרוזת נקראת פלינדרום אם היא קוראת אותו הדבר לפנים ולאחור.\n    עליכם להחזיר טופל המכיל את המחרוזת התוצאה ו-True/False עבור הבדיקה.\n    דוגמא\n    עבור s = \"abcde\", c = \"ae\", התוצאה צריכה להיות ('bcd',False)\n    עבור s = \"abcdef\", c = \"b\" התוצאה צריכה להיות ('acdef',False)\n    עבור s = \"abcdedcba\", c = \"ab\", התוצאה צריכה להיות ('cdedc',True)\n    ", "natural_language": "Hebrew"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    קיבלתם רשת מלבנית של בארות. כל שורה מייצגת באר יחידה, וכל 1 בשורה מייצג יחידת מים יחידה. לכל באר יש דלי תואם שניתן להשתמש בו כדי לחלץ מים ממנו, וכל הדליים יש להם את אותה הקיבולת. המטרה שלכם היא להשתמש בדליים כדי לרוקן את הבארות. פלט: מספר הפעמים שעליכם להוריד את הדליים.\n\n    דוגמה 1:\n    קלט:\n        grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        bucket_capacity : 1\n    פלט: 6\n\n    דוגמה 2:\n    קלט:\n        grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        bucket_capacity : 2\n    פלט: 5\n\n    דוגמה 3:\n    קלט:\n        grid : [[0,0,0], [0,0,0]]\n        bucket_capacity : 5\n    פלט: 0\n\n    הגבלות:\n    * כל הבארות יש להם אותו אורך\n    * 1 <= אורך הרשת <= 10^2\n    * 1 <= אורך השורה הראשונה של הרשת <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= קיבולת <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "קיבלתם רשת מלבנית של בארות. כל שורה מייצגת באר יחידה, וכל 1 בשורה מייצג יחידת מים יחידה. לכל באר יש דלי תואם שניתן להשתמש בו כדי לחלץ מים ממנו, וכל הדליים יש להם את אותה הקיבולת. המטרה שלכם היא להשתמש בדליים כדי לרוקן את הבארות. פלט: מספר הפעמים שעליכם להוריד את הדליים.\n\n    דוגמה 1:\n    קלט:\n        grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        bucket_capacity : 1\n    פלט: 6\n\n    דוגמה 2:\n    קלט:\n        grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        bucket_capacity : 2\n    פלט: 5\n\n    דוגמה 3:\n    קלט:\n        grid : [[0,0,0], [0,0,0]]\n        bucket_capacity : 5\n    פלט: 0\n\n    הגבלות:\n    * כל הבארות יש להם אותו אורך\n    * 1 <= אורך הרשת <= 10^2\n    * 1 <= אורך השורה הראשונה של הרשת <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= קיבולת <= 10\n    ", "natural_language": "Hebrew"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"נתון מחרוזת s ומספר טבעי n, עליך לממש פונקציה שמחזירה רשימה של כל המילים מהמחרוזת s שמכילות בדיוק n עיצורים, בסדר שהן מופיעות במחרוזת s. אם המחרוזת s ריקה, הפונקציה צריכה להחזיר רשימה ריקה. שים לב: ניתן להניח שהמחרוזת הקלט מכילה רק אותיות ורווחים. דוגמאות:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "נתון מחרוזת s ומספר טבעי n, עליך לממש פונקציה שמחזירה רשימה של כל המילים מהמחרוזת s שמכילות בדיוק n עיצורים, בסדר שהן מופיעות במחרוזת s. אם המחרוזת s ריקה, הפונקציה צריכה להחזיר רשימה ריקה. שים לב: ניתן להניח שהמחרוזת הקלט מכילה רק אותיות ורווחים. דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    נתון מערך של מספרים שלמים ומספר שלם חיובי k, יש להחזיר רשימה ממוינת בגודל k עם המספרים הגדולים ביותר במערך.\n\n    דוגמה 1:\n    קלט: arr = [-3, -4, 5], k = 3\n    פלט: [-4, -3, 5]\n\n    דוגמה 2:\n    קלט: arr = [4, -4, 4], k = 2\n    פלט: [4, 4]\n\n    דוגמה 3:\n    קלט: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    פלט: [2]\n\n    הערות:\n    1. אורך המערך יהיה בטווח של [1, 1000].\n    2. האיברים במערך יהיו בטווח של [-1000, 1000].\n    3. 0 <= k <= אורך המערך.\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "נתון מערך של מספרים שלמים ומספר שלם חיובי k, יש להחזיר רשימה ממוינת בגודל k עם המספרים הגדולים ביותר במערך.\n\n    דוגמה 1:\n    קלט: arr = [-3, -4, 5], k = 3\n    פלט: [-4, -3, 5]\n\n    דוגמה 2:\n    קלט: arr = [4, -4, 4], k = 2\n    פלט: [4, 4]\n\n    דוגמה 3:\n    קלט: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    פלט: [2]\n\n    הערות:\n    1. אורך המערך יהיה בטווח של [1, 1000].\n    2. האיברים במערך יהיו בטווח של [-1000, 1000].\n    3. 0 <= k <= אורך המערך.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    נתון מערך של מספרים שלמים לא ריקים arr ומספר שלם k, החזר את סכום האיברים עם לכל היותר שני ספרות מה-k הראשונים של arr.\n\n    דוגמה:\n\n        קלט: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    פלט: 24 # סכום של 21 + 3\n\n    הגבלות:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "נתון מערך של מספרים שלמים לא ריקים arr ומספר שלם k, החזר את סכום האיברים עם לכל היותר שני ספרות מה-k הראשונים של arr.\n\n    דוגמה:\n\n        קלט: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    פלט: 24 # סכום של 21 + 3\n\n    הגבלות:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    ", "natural_language": "Hebrew"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"נתונים לך שני מרווחים,\n    כאשר כל מרווח הוא זוג של מספרים שלמים. למשל, מרווח = (התחלה, סיום) = (1, 2).\n    המרווחים הנתונים הם סגורים, כלומר המרווח (התחלה, סיום)\n    כולל את ההתחלה והסיום.\n    עבור כל מרווח נתון, נניח שההתחלה שלו קטנה או שווה לסיום שלו.\n    המטרה שלך היא לקבוע אם אורך החיתוך של שני המרווחים הוא מספר ראשוני.\n    למשל, החיתוך של המרווחים (1, 3), (2, 4) הוא (2, 3)\n    שאורכו הוא 1, שאינו מספר ראשוני.\n    אם אורך החיתוך הוא מספר ראשוני, החזר \"YES\",\n    אחרת, החזר \"NO\".\n    אם שני המרווחים אינם מתקלקלים, החזר \"NO\".\n\n    \n    [קלט/פלט] דוגמאות:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "נתונים לך שני מרווחים,\n    כאשר כל מרווח הוא זוג של מספרים שלמים. למשל, מרווח = (התחלה, סיום) = (1, 2).\n    המרווחים הנתונים הם סגורים, כלומר המרווח (התחלה, סיום)\n    כולל את ההתחלה והסיום.\n    עבור כל מרווח נתון, נניח שההתחלה שלו קטנה או שווה לסיום שלו.\n    המטרה שלך היא לקבוע אם אורך החיתוך של שני המרווחים הוא מספר ראשוני.\n    למשל, החיתוך של המרווחים (1, 3), (2, 4) הוא (2, 3)\n    שאורכו הוא 1, שאינו מספר ראשוני.\n    אם אורך החיתוך הוא מספר ראשוני, החזר \"YES\",\n    אחרת, החזר \"NO\".\n    אם שני המרווחים אינם מתקלקלים, החזר \"NO\".\n\n    \n    [קלט/פלט] דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"כולם מכירים את רצף פיבונאצ'י, הוא נחקר עמוקות על ידי מתמטיקאים במאה האחרונה. אך מה שאנשים לא יודעים זה רצף טריבונאצ'י. רצף טריבונאצ'י מוגדר על ידי הנוסחה הבאה:\ntri(1) = 3\ntri(n) = 1 + n / 2, אם n הוא זוגי.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), אם n הוא אי-זוגי.\nלדוגמה:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nנתון לך מספר שלם לא-שלילי n, עליך להחזיר רשימה של n + 1 המספרים הראשונים ברצף טריבונאצ'י.\nלדוגמה:\ntri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "כולם מכירים את רצף פיבונאצ'י, הוא נחקר עמוקות על ידי מתמטיקאים במאה האחרונה. אך מה שאנשים לא יודעים זה רצף טריבונאצ'י. רצף טריבונאצ'י מוגדר על ידי הנוסחה הבאה:\ntri(1) = 3\ntri(n) = 1 + n / 2, אם n הוא זוגי.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), אם n הוא אי-זוגי.\nלדוגמה:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nנתון לך מספר שלם לא-שלילי n, עליך להחזיר רשימה של n + 1 המספרים הראשונים ברצף טריבונאצ'י.\nלדוגמה:\ntri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Hebrew"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"נתון מספר שלם חיובי n, החזר את כפל הספרות האי-זוגיות.\nהחזר 0 אם כל הספרות הן זוגיות.\nלדוגמה:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "נתון מספר שלם חיובי n, החזר את כפל הספרות האי-זוגיות.\nהחזר 0 אם כל הספרות הן זוגיות.\nלדוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    צור פונקציה שמקבלת מחרוזת כקלט המכילה רק סוגריים מרובעים.\nהפונקציה צריכה להחזיר אמת רק אם קיים תת-רצף תקין של סוגריים מרובעים\nבו לפחות סוגריים מרובעים אחד מכיל סוגריים מרובעים נושאים.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "צור פונקציה שמקבלת מחרוזת כקלט המכילה רק סוגריים מרובעים.\nהפונקציה צריכה להחזיר אמת רק אם קיים תת-רצף תקין של סוגריים מרובעים\nבו לפחות סוגריים מרובעים אחד מכיל סוגריים מרובעים נושאים.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"קיבלת רשימה של מספרים.\n    עליך להחזיר את סכום המספרים ברשימה שהוצבעו בריבוע,\n    לעגל כל איבר ברשימה למספר שלם עליון (Ceiling) תחילה.\n    דוגמאות:\n    עבור lst = [1,2,3] הפלט צריך להיות 14\n    עבור lst = [1,4,9] הפלט צריך להיות 98\n    עבור lst = [1,3,5,7] הפלט צריך להיות 84\n    עבור lst = [1.4,4.2,0] הפלט צריך להיות 29\n    עבור lst = [-2.4,1,1] הפלט צריך להיות 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "קיבלת רשימה של מספרים.\n    עליך להחזיר את סכום המספרים ברשימה שהוצבעו בריבוע,\n    לעגל כל איבר ברשימה למספר שלם עליון (Ceiling) תחילה.\n    דוגמאות:\n    עבור lst = [1,2,3] הפלט צריך להיות 14\n    עבור lst = [1,4,9] הפלט צריך להיות 98\n    עבור lst = [1,3,5,7] הפלט צריך להיות 84\n    עבור lst = [1.4,4.2,0] הפלט צריך להיות 29\n    עבור lst = [-2.4,1,1] הפלט צריך להיות 6\n    ", "natural_language": "Hebrew"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    צור פונקציה שמחזירה True אם התו האחרון במחרוזת הנתונה הוא תו אלפביתי ואינו חלק ממילה, ו-False אחרת.\nלתשומת לב: \"מילה\" היא קבוצת תווים המופרדים באמצעות רווח.\n\n    דוגמאות:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "צור פונקציה שמחזירה True אם התו האחרון במחרוזת הנתונה הוא תו אלפביתי ואינו חלק ממילה, ו-False אחרת.\nלתשומת לב: \"מילה\" היא קבוצת תווים המופרדים באמצעות רווח.\n\n    דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"צור פונקציה שמחזירה את האינדקס הגדול ביותר של אלמנט שאינו גדול או שווה לאלמנט הקודם לו. אם לא קיים אלמנט כזה, החזר -1. המערך הנתון לא יכיל ערכים כפולים.\n\n    דוגמאות:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "צור פונקציה שמחזירה את האינדקס הגדול ביותר של אלמנט שאינו גדול או שווה לאלמנט הקודם לו. אם לא קיים אלמנט כזה, החזר -1. המערך הנתון לא יכיל ערכים כפולים.\n\n    דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    צור פונקציה שמחזירה טופל (a, b), כאשר 'a' הוא המספר השלילי הגדול ביותר, ו-'b' הוא המספר החיובי הקטן ביותר ברשימה.\n    אם אין מספרים שליליים או חיוביים, החזר אותם כ-None.\n\n        דוגמאות:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "צור פונקציה שמחזירה טופל (a, b), כאשר 'a' הוא המספר השלילי הגדול ביותר, ו-'b' הוא המספר החיובי הקטן ביותר ברשימה.\n    אם אין מספרים שליליים או חיוביים, החזר אותם כ-None.\n\n        דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"הפקטוריאל הברזילאי מוגדר כך:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    כאשר n > 0\n\n        לדוגמה:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "הפקטוריאל הברזילאי מוגדר כך:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    כאשר n > 0\n\n        לדוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    קיבלת מחרוזת המייצגת משפט,\nהמשפט מכיל מילים מופרדות על ידי רווח,\nועליך להחזיר מחרוזת המכילה את המילים מהמשפט המקורי,\nשאורכן הוא מספר ראשוני,\nסדר המילים במחרוזת החדשה צריך להיות זהה למקורי.\n\n    דוגמה 1:\n    קלט: sentence = \"This is a test\"\n    פלט: \"is\"\n\n    דוגמה 2:\n    קלט: sentence = \"lets go for swimming\"\n    פלט: \"go for\"\n\n    הגבלות:\n    * 1 <= len(sentence) <= 100\n    * המשפט מכיל רק אותיות.\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "קיבלת מחרוזת המייצגת משפט,\nהמשפט מכיל מילים מופרדות על ידי רווח,\nועליך להחזיר מחרוזת המכילה את המילים מהמשפט המקורי,\nשאורכן הוא מספר ראשוני,\nסדר המילים במחרוזת החדשה צריך להיות זהה למקורי.\n\n    דוגמה 1:\n    קלט: sentence = \"This is a test\"\n    פלט: \"is\"\n\n    דוגמה 2:\n    קלט: sentence = \"lets go for swimming\"\n    פלט: \"go for\"\n\n    הגבלות:\n    * 1 <= len(sentence) <= 100\n    * המשפט מכיל רק אותיות.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"המטרה שלך היא ליישם פונקציה שתפשט את הביטוי\n    x * n. הפונקציה מחזירה True אם x * n מבוצע למספר שלם ו-False\n    אחרת. המשתנים x ו-n הם מיוצגים כמחרוזות של שבר, ויש להם את הפורמט הבא,\n    <מונה>/<מכנה> כאשר המונה והמכנה הם מספרים שלמים חיוביים.\n\n        אתה יכול להניח ש-x ו-n הם שברים תקינים ואינם מכילים אפס כמכנה.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "המטרה שלך היא ליישם פונקציה שתפשט את הביטוי\n    x * n. הפונקציה מחזירה True אם x * n מבוצע למספר שלם ו-False\n    אחרת. המשתנים x ו-n הם מיוצגים כמחרוזות של שבר, ויש להם את הפורמט הבא,\n    <מונה>/<מכנה> כאשר המונה והמכנה הם מספרים שלמים חיוביים.\n\n        אתה יכול להניח ש-x ו-n הם שברים תקינים ואינם מכילים אפס כמכנה.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    כתוב פונקציה הממיינת את רשימת המספרים הנתונה בסדר עולה לפי סכום הספרות שלהם. שים לב: אם ישנם פריטים מרובים עם סכום דומה של הספרות שלהם, מיין אותם על פי האינדקס שלהם ברשימה המקורית.\n\n    לדוגמה:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "כתוב פונקציה הממיינת את רשימת המספרים הנתונה בסדר עולה לפי סכום הספרות שלהם. שים לב: אם ישנם פריטים מרובים עם סכום דומה של הספרות שלהם, מיין אותם על פי האינדקס שלהם ברשימה המקורית.\n\n    לדוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"כתוב פונקציה שמקבלת מערך של מספרים כקלט ומחזירה את מספר האיברים במערך שגדולים מ-10 ושהספרות הראשונות והאחרונות של המספר הן אי-זוגיות (1, 3, 5, 7, 9). לדוגמה:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "כתוב פונקציה שמקבלת מערך של מספרים כקלט ומחזירה את מספר האיברים במערך שגדולים מ-10 ושהספרות הראשונות והאחרונות של המספר הן אי-זוגיות (1, 3, 5, 7, 9). לדוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    קיבלתם מספר שלם חיובי n. עליכם ליצור מערך של מספרים שלמים a באורך n.\n        עבור כל i (1 ≤ i ≤ n), ערך a[i] יהיה i * i - i + 1.\n        החזירו את מספר הטריפלטים (a[i], a[j], a[k]) של a כאשר i < j < k, \n    ו-a[i] + a[j] + a[k] הוא מרובע של 3.\n\n        דוגמה :\n        קלט: n = 5\n        פלט: 1\n        הסבר: \n        a = [1, 3, 7, 13, 21]\n        הטריפלט היחיד החוקי הוא (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "קיבלתם מספר שלם חיובי n. עליכם ליצור מערך של מספרים שלמים a באורך n.\n        עבור כל i (1 ≤ i ≤ n), ערך a[i] יהיה i * i - i + 1.\n        החזירו את מספר הטריפלטים (a[i], a[j], a[k]) של a כאשר i < j < k, \n    ו-a[i] + a[j] + a[k] הוא מרובע של 3.\n\n        דוגמה :\n        קלט: n = 5\n        פלט: 1\n        הסבר: \n        a = [1, 3, 7, 13, 21]\n        הטריפלט היחיד החוקי הוא (1, 7, 13).\n    ", "natural_language": "Hebrew"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    יש שמונה כוכבי לכת במערכת השמש שלנו: הכוכב הקרוב ביותר לשמש הוא מרקורי, הבא בתור הוא ונוס, אז כדור הארץ, מאדים, יופיטר, כוכב השבת, אורנוס ונפטון. כתוב פונקציה שמקבלת שני שמות כוכבי לכת כמחרוזות planet1 ו- planet2. הפונקציה צריכה להחזיר טופל שמכיל את כל הכוכבים שלהם המסלולים נמצאים בין מסלול הכוכב planet1 למסלול הכוכב planet2, ממוינים לפי הקירבה לשמש. הפונקציה צריכה להחזיר טופל ריק אם planet1 או planet2 אינם שמות כוכבי לכת נכונים. דוגמאות\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "יש שמונה כוכבי לכת במערכת השמש שלנו: הכוכב הקרוב ביותר לשמש הוא מרקורי, הבא בתור הוא ונוס, אז כדור הארץ, מאדים, יופיטר, כוכב השבת, אורנוס ונפטון. כתוב פונקציה שמקבלת שני שמות כוכבי לכת כמחרוזות planet1 ו- planet2. הפונקציה צריכה להחזיר טופל שמכיל את כל הכוכבים שלהם המסלולים נמצאים בין מסלול הכוכב planet1 למסלול הכוכב planet2, ממוינים לפי הקירבה לשמש. הפונקציה צריכה להחזיר טופל ריק אם planet1 או planet2 אינם שמות כוכבי לכת נכונים. דוגמאות\n    ", "natural_language": "Hebrew"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"תיאור התוכנית היא תוכנית פשוטה שצריכה להחזיר את ערך x אם n הוא מספר ראשוני ולהחזיר את ערך y אחרת.\n\n    דוגמאות:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "תיאור התוכנית היא תוכנית פשוטה שצריכה להחזיר את ערך x אם n הוא מספר ראשוני ולהחזיר את ערך y אחרת.\n\n    דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    נתונה רשימה של מספרים, החזר את סכום הריבועים של המספרים ברשימה שזוגיים. התעלם ממספרים שהם שליליים או לא שלמים.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    אם הרשימה ריקה, החזר 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "נתונה רשימה של מספרים, החזר את סכום הריבועים של המספרים ברשימה שזוגיים. התעלם ממספרים שהם שליליים או לא שלמים.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    אם הרשימה ריקה, החזר 0.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"ינתן לך שם של מחלקה (מחרוזת) ורשימת הרחבות.\nהרחבות יש להשתמש בהן כדי לטעון מחלקות נוספות למחלקה. כוח ההרחבה הוא כדלקמן: תהיינה CAP מספר האותיות הגדולות בשם ההרחבה, ו- SM מספר האותיות הקטנות בשם ההרחבה, הכוח נתון על ידי המנה CAP - SM. עליך למצוא את ההרחבה החזקה ביותר ולהחזיר מחרוזת בפורמט הבא: ClassName.StrongestExtensionName.\nאם ישנן שתי או יותר הרחבות עם אותו כוח, עליך לבחור את האחת שמופיעה ראשונה ברשימה.\nלדוגמה, אם ניתן לך \"Slices\" כמחלקה ורשימת הרחבות: ['SErviNGSliCes', 'Cheese', 'StuFfed'] אז עליך להחזיר 'Slices.SErviNGSliCes' מכיוון ש-'SErviNGSliCes' היא ההרחבה החזקה ביותר (הכוח שלה הוא -1).\nדוגמה:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "ינתן לך שם של מחלקה (מחרוזת) ורשימת הרחבות.\nהרחבות יש להשתמש בהן כדי לטעון מחלקות נוספות למחלקה. כוח ההרחבה הוא כדלקמן: תהיינה CAP מספר האותיות הגדולות בשם ההרחבה, ו- SM מספר האותיות הקטנות בשם ההרחבה, הכוח נתון על ידי המנה CAP - SM. עליך למצוא את ההרחבה החזקה ביותר ולהחזיר מחרוזת בפורמט הבא: ClassName.StrongestExtensionName.\nאם ישנן שתי או יותר הרחבות עם אותו כוח, עליך לבחור את האחת שמופיעה ראשונה ברשימה.\nלדוגמה, אם ניתן לך \"Slices\" כמחלקה ורשימת הרחבות: ['SErviNGSliCes', 'Cheese', 'StuFfed'] אז עליך להחזיר 'Slices.SErviNGSliCes' מכיוון ש-'SErviNGSliCes' היא ההרחבה החזקה ביותר (הכוח שלה הוא -1).\nדוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"קיבלת שתי מילים. עליך להחזיר True אם המילה השנייה או אף אחת מהסיבובים שלה היא תת מחרוזת במילה הראשונה.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "קיבלת שתי מילים. עליך להחזיר True אם המילה השנייה או אף אחת מהסיבובים שלה היא תת מחרוזת במילה הראשונה.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    נתון מספר שלם חיובי, לקבל את המספר הרומי המתאים לו כמחרוזת ולהחזיר אותו באותיות קטנות.\nהגבלות: 1 <= num <= 1000\n\n    דוגמאות:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "נתון מספר שלם חיובי, לקבל את המספר הרומי המתאים לו כמחרוזת ולהחזיר אותו באותיות קטנות.\nהגבלות: 1 <= num <= 1000\n\n    דוגמאות:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    נתונות אורכי הצלעות של משולש. החזר True אם השלושה צלעים מהווים משולש ישר-זווית, אחרת החזר False. משולש ישר-זווית הוא משולש שבו זווית אחת היא זווית ישרה או 90 מעלות. דוגמה:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "נתונות אורכי הצלעות של משולש. החזר True אם השלושה צלעים מהווים משולש ישר-זווית, אחרת החזר False. משולש ישר-זווית הוא משולש שבו זווית אחת היא זווית ישרה או 90 מעלות. דוגמה:\n    ", "natural_language": "Hebrew"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"נתונה מחרוזת s.\n    אם s[i] הוא אות, הפוך את המקרה שלו מקטן לגדול או להיפך,\n    אחרת השאר אותו כפי שהוא.\n    אם המחרוזת אינה מכילה אותיות, הפוך את המחרוזת.\n    הפונקציה צריכה להחזיר את המחרוזת התוצאה.\n    דוגמאות\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "נתונה מחרוזת s.\n    אם s[i] הוא אות, הפוך את המקרה שלו מקטן לגדול או להיפך,\n    אחרת השאר אותו כפי שהוא.\n    אם המחרוזת אינה מכילה אותיות, הפוך את המחרוזת.\n    הפונקציה צריכה להחזיר את המחרוזת התוצאה.\n    דוגמאות\n    ", "natural_language": "Hebrew"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    נתון מחרוזת 'טקסט', החזר מחרוזת שקולה ל-md5 שלה.\n    אם 'טקסט' הוא מחרוזת ריקה, החזר null.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "נתון מחרוזת 'טקסט', החזר מחרוזת שקולה ל-md5 שלה.\n    אם 'טקסט' הוא מחרוזת ריקה, החזר null.\n    ", "natural_language": "Hebrew"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    נתונים שני מספרים חיוביים a ו-b, החזר את הספרות הזוגיות בין a ל-b, בסדר עולה.\n\n    לדוגמה:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "נתונים שני מספרים חיוביים a ו-b, החזר את הספרות הזוגיות בין a ל-b, בסדר עולה.\n\n    לדוגמה:\n    ", "natural_language": "Hebrew"}
