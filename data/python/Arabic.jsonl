{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" تم تزويدك بقائمة عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفري. مهمتك هي الكشف عما إذا كان رصيد الحساب ينخفض دون الصفر في أي نقطة، وفي ذلك الوقت يجب أن تعيد الدالة True. وإلا يجب أن تعيد False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "تم تزويدك بقائمة عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفري. مهمتك هي الكشف عما إذا كان رصيد الحساب ينخفض دون الصفر في أي نقطة، وفي ذلك الوقت يجب أن تعيد الدالة True. وإلا يجب أن تعيد False.\n    ", "natural_language": "Arabic"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" لقائمة معينة من الأعداد الصحيحة، أرجع tuple يتكون من مجموع وضرب جميع الأعداد في القائمة.\nيجب أن يكون مجموع القائمة الفارغة يساوي 0 وضربها الفارغ يساوي 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "لقائمة معينة من الأعداد الصحيحة، أرجع tuple يتكون من مجموع وضرب جميع الأعداد في القائمة.\nيجب أن يكون مجموع القائمة الفارغة يساوي 0 وضربها الفارغ يساوي 1.\n    ", "natural_language": "Arabic"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" المدخلات هي سلسلتان a و b تتكونان فقط من 1 و 0.\n    قم بتنفيذ عملية XOR الثنائية على هذه المدخلات وإرجاع النتيجة أيضًا كسلسلة.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "المدخلات هي سلسلتان a و b تتكونان فقط من 1 و 0.\n    قم بتنفيذ عملية XOR الثنائية على هذه المدخلات وإرجاع النتيجة أيضًا كسلسلة.\n    ", "natural_language": "Arabic"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" من بين قائمة السلاسل، ارجع الأطول. ارجع الأولى في حالة وجود عدة سلاسل بنفس الطول. ارجع قيمة فارغة في حالة أن القائمة الدخلية فارغة.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "من بين قائمة السلاسل، ارجع الأطول. ارجع الأولى في حالة وجود عدة سلاسل بنفس الطول. ارجع قيمة فارغة في حالة أن القائمة الدخلية فارغة.\n    ", "natural_language": "Arabic"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" إرجاع أكبر مقسوم مشترك بين عددين a و b\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "إرجاع أكبر مقسوم مشترك بين عددين a و b\n    ", "natural_language": "Arabic"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" المدخلات هي سلسلة من الأرقام المفصولة بمسافة من \"صفر\" إلى \"تسعة\".\nالخيارات الصالحة هي \"صفر\"، \"واحد\"، \"اثنان\"، \"ثلاثة\"، \"أربعة\"، \"خمسة\"، \"ستة\"، \"سبعة\"، \"ثمانية\" و \"تسعة\".\nإرجاع السلسلة مع الأرقام مرتبة من الأصغر إلى الأكبر.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "المدخلات هي سلسلة من الأرقام المفصولة بمسافة من \"صفر\" إلى \"تسعة\".\nالخيارات الصالحة هي \"صفر\"، \"واحد\"، \"اثنان\"، \"ثلاثة\"، \"أربعة\"، \"خمسة\"، \"ستة\"، \"سبعة\"، \"ثمانية\" و \"تسعة\".\nإرجاع السلسلة مع الأرقام مرتبة من الأصغر إلى الأكبر.\n    ", "natural_language": "Arabic"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" عندما يتم إعطاء قائمة من الأرقام (تحتوي على على الأقل عنصرين)، يتم تطبيق تحويل خطي على تلك القائمة، بحيث يتم جعل العدد الأصغر يصبح 0 والأكبر يصبح 1.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "عندما يتم إعطاء قائمة من الأرقام (تحتوي على على الأقل عنصرين)، يتم تطبيق تحويل خطي على تلك القائمة، بحيث يتم جعل العدد الأصغر يصبح 0 والأكبر يصبح 1.\n    ", "natural_language": "Arabic"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" لسلسلة محددة، قم بتبديل الأحرف الصغيرة إلى أحرف كبيرة والأحرف الكبيرة إلى أحرف صغيرة.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "لسلسلة محددة، قم بتبديل الأحرف الصغيرة إلى أحرف كبيرة والأحرف الكبيرة إلى أحرف صغيرة.\n    ", "natural_language": "Arabic"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"ارجع فقط الأرقام الإيجابية في القائمة.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "ارجع فقط الأرقام الإيجابية في القائمة.\n    ", "natural_language": "Arabic"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"إرجاع صحيح إذا كان الرقم المعطى هو عدد أولي، وإلا فهو خطأ.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "إرجاع صحيح إذا كان الرقم المعطى هو عدد أولي، وإلا فهو خطأ.\n    ", "natural_language": "Arabic"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"إرجاع عناصر فريدة مرتبة في قائمة\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "إرجاع عناصر فريدة مرتبة في قائمة\n    ", "natural_language": "Arabic"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib يعيد العدد رقم n الذي هو عدد فيبوناتشي وهو أيضًا عدد أولي.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib يعيد العدد رقم n الذي هو عدد فيبوناتشي وهو أيضًا عدد أولي.\n    ", "natural_language": "Arabic"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    تأخذ triples_sum_to_zero قائمة من الأعداد الصحيحة كمدخلات.\n    يعيد True إذا كان هناك ثلاثة عناصر متميزة في القائمة تجمع إلى الصفر ، و False في الحالة الأخرى.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "تأخذ triples_sum_to_zero قائمة من الأعداد الصحيحة كمدخلات.\n    يعيد True إذا كان هناك ثلاثة عناصر متميزة في القائمة تجمع إلى الصفر ، و False في الحالة الأخرى.\n    ", "natural_language": "Arabic"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    يأخذ pairs_sum_to_zero قائمة من الأعداد الصحيحة كمدخلات.\nيعيد True إذا كان هناك عنصران متميزان في القائمة يجمعان إلى الصفر ، و False في الحالة الأخرى.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "يأخذ pairs_sum_to_zero قائمة من الأعداد الصحيحة كمدخلات.\nيعيد True إذا كان هناك عنصران متميزان في القائمة يجمعان إلى الصفر ، و False في الحالة الأخرى.\n    ", "natural_language": "Arabic"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"تتمثل متتابعة أرقام Fib4 في متتابعة مشابهة لمتتابعة فيبوناتشي والتي تعرف على النحو التالي:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    يرجى كتابة وظيفة لحساب العنصر الثامن من متتابعة أرقام Fib4 بكفاءة. لا تستخدم الاستدعاء العكسي.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "تتمثل متتابعة أرقام Fib4 في متتابعة مشابهة لمتتابعة فيبوناتشي والتي تعرف على النحو التالي:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    يرجى كتابة وظيفة لحساب العنصر الثامن من متتابعة أرقام Fib4 بكفاءة. لا تستخدم الاستدعاء العكسي.\n    ", "natural_language": "Arabic"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"إرجاع الوسيط لعناصر القائمة l.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "إرجاع الوسيط لعناصر القائمة l.\n    ", "natural_language": "Arabic"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    يتحقق مما إذا كانت السلسلة المعطاة هي باليندروم.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "يتحقق مما إذا كانت السلسلة المعطاة هي باليندروم.\n    ", "natural_language": "Arabic"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels هي وظيفة تأخذ سلسلة نصية وتعيد سلسلة نصية بدون حروف العلة.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels هي وظيفة تأخذ سلسلة نصية وتعيد سلسلة نصية بدون حروف العلة.\n    ", "natural_language": "Arabic"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"\"ارجع صحيح إذا كانت جميع الأرقام في القائمة l أقل من الحد t.\"\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "\"ارجع صحيح إذا كانت جميع الأرقام في القائمة l أقل من الحد t.\"\n    ", "natural_language": "Arabic"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"إضافة رقمين x و y\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "إضافة رقمين x و y\n    ", "natural_language": "Arabic"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    تحقق مما إذا كانت كلمتان لديهما نفس الأحرف.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "تحقق مما إذا كانت كلمتان لديهما نفس الأحرف.\n    ", "natural_language": "Arabic"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"إرجاع العدد الفيبوناتشي رقم n.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "إرجاع العدد الفيبوناتشي رقم n.\n    ", "natural_language": "Arabic"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"إرجاع العناصر المشتركة الفريدة المرتبة لاثنين من القوائم.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "إرجاع العناصر المشتركة الفريدة المرتبة لاثنين من القوائم.\n    ", "natural_language": "Arabic"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"\"ارجع أكبر عامل أولي لـ n. افترض أن n> 1 وليس عددًا أوليًا.\"\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "\"ارجع أكبر عامل أولي لـ n. افترض أن n> 1 وليس عددًا أوليًا.\"\n    ", "natural_language": "Arabic"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n هي وظيفة تجمع الأرقام من 1 إلى n.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n هي وظيفة تجمع الأرقام من 1 إلى n.\n    ", "natural_language": "Arabic"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs تمثل معاملات متعددة الحدود.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\nإرجاع المشتقة لهذه المعادلة متعددة الحدود بنفس الصيغة.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs تمثل معاملات متعددة الحدود.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\nإرجاع المشتقة لهذه المعادلة متعددة الحدود بنفس الصيغة.\n    ", "natural_language": "Arabic"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"تتبع سلسلة أرقام فيبفيب هي سلسلة مشابهة لسلسلة فيبوناتشي التي تعرف على النحو التالي:\n    فيبفيب(0) == 0\n    فيبفيب(1) == 0\n    فيبفيب(2) == 1\n    فيبفيب(n) == فيبفيب(n-1) + فيبفيب(n-2) + فيبفيب(n-3).\n    يرجى كتابة وظيفة لحساب العنصر الثالث عشر بكفاءة في سلسلة أرقام فيبفيب.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "تتبع سلسلة أرقام فيبفيب هي سلسلة مشابهة لسلسلة فيبوناتشي التي تعرف على النحو التالي:\n    فيبفيب(0) == 0\n    فيبفيب(1) == 0\n    فيبفيب(2) == 1\n    فيبفيب(n) == فيبفيب(n-1) + فيبفيب(n-2) + فيبفيب(n-3).\n    يرجى كتابة وظيفة لحساب العنصر الثالث عشر بكفاءة في سلسلة أرقام فيبفيب.\n    ", "natural_language": "Arabic"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"اكتب دالة تسمى vowels_count تأخذ سلسلة نصية تمثل كلمة كإدخال وتعيد عدد الحروف الصوتية في السلسلة. الحروف الصوتية في هذه الحالة هي 'a'، 'e'، 'i'، 'o'، 'u'. هنا، 'y' هو أيضًا حرف صوتي، ولكن فقط عندما يكون في نهاية الكلمة المعطاة.\n\n    مثال:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "اكتب دالة تسمى vowels_count تأخذ سلسلة نصية تمثل كلمة كإدخال وتعيد عدد الحروف الصوتية في السلسلة. الحروف الصوتية في هذه الحالة هي 'a'، 'e'، 'i'، 'o'، 'u'. هنا، 'y' هو أيضًا حرف صوتي، ولكن فقط عندما يكون في نهاية الكلمة المعطاة.\n\n    مثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    يتم تزويدك بقائمة غير فارغة من الأعداد الصحيحة الإيجابية. يجب إرجاع أكبر عدد صحيح يكون أكبر من الصفر وله تكرار أكبر من أو يساوي قيمة العدد الصحيح نفسه. تكرار العدد الصحيح هو عدد مرات ظهوره في القائمة. إذا لم يكن هناك قيمة كهذه ، فأرجع -1. أمثلة:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "يتم تزويدك بقائمة غير فارغة من الأعداد الصحيحة الإيجابية. يجب إرجاع أكبر عدد صحيح يكون أكبر من الصفر وله تكرار أكبر من أو يساوي قيمة العدد الصحيح نفسه. تكرار العدد الصحيح هو عدد مرات ظهوره في القائمة. إذا لم يكن هناك قيمة كهذه ، فأرجع -1. أمثلة:\n    ", "natural_language": "Arabic"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    بالنظر إلى أطوال الأضلاع الثلاثة لمثلث. يرجى إرجاع مساحة المثلث مستديرة إلى 2 نقطة عشرية إذا كانت الأضلاع الثلاثة تشكل مثلثًا صالحًا. وإلا، يرجى إرجاع -1. تشكل الأضلاع الثلاثة مثلثًا صالحًا عندما يكون مجموع أي ضلعين أكبر من الضلع الثالث. مثال:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "بالنظر إلى أطوال الأضلاع الثلاثة لمثلث. يرجى إرجاع مساحة المثلث مستديرة إلى 2 نقطة عشرية إذا كانت الأضلاع الثلاثة تشكل مثلثًا صالحًا. وإلا، يرجى إرجاع -1. تشكل الأضلاع الثلاثة مثلثًا صالحًا عندما يكون مجموع أي ضلعين أكبر من الضلع الثالث. مثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    اكتب دالة تعيد القيمة صحيحة إذا كان الكائن q سيطير، وخطأ في حالة عدم ذلك.\nسيطير الكائن q إذا كان متوازنًا (هو قائمة متناظرة) ومجموع عناصره أقل من أو يساوي الحد الأقصى الممكن للوزن w.\n\n    مثال:\nwill_it_fly([1، 2]، 5) ➞ خطأ\n# 1 + 2 أقل من الحد الأقصى الممكن للوزن ، لكنه غير متوازن.\n\n    will_it_fly([3، 2، 3]، 1) ➞ خطأ\n# إنه متوازن ، لكن 3 + 2 + 3 أكثر من الحد الأقصى الممكن للوزن.\n\n    will_it_fly([3، 2، 3]، 9) ➞ صحيح\n# 3 + 2 + 3 أقل من الحد الأقصى الممكن للوزن ، وهو متوازن.\n\n    will_it_fly([3]، 5) ➞ صحيح\n# 3 أقل من الحد الأقصى الممكن للوزن ، وهو متوازن.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "اكتب دالة تعيد القيمة صحيحة إذا كان الكائن q سيطير، وخطأ في حالة عدم ذلك.\nسيطير الكائن q إذا كان متوازنًا (هو قائمة متناظرة) ومجموع عناصره أقل من أو يساوي الحد الأقصى الممكن للوزن w.\n\n    مثال:\nwill_it_fly([1، 2]، 5) ➞ خطأ\n# 1 + 2 أقل من الحد الأقصى الممكن للوزن ، لكنه غير متوازن.\n\n    will_it_fly([3، 2، 3]، 1) ➞ خطأ\n# إنه متوازن ، لكن 3 + 2 + 3 أكثر من الحد الأقصى الممكن للوزن.\n\n    will_it_fly([3، 2، 3]، 9) ➞ صحيح\n# 3 + 2 + 3 أقل من الحد الأقصى الممكن للوزن ، وهو متوازن.\n\n    will_it_fly([3]، 5) ➞ صحيح\n# 3 أقل من الحد الأقصى الممكن للوزن ، وهو متوازن.\n    ", "natural_language": "Arabic"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"اكتب دالة تعيد القيمة الصحيحة إذا كان الرقم المعطى هو ضرب 3 أعداد أولية، وإلا فهي تعيد القيمة الخاطئة. علمًا بأن (أ) أقل من 100. \n\n    مثال:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "اكتب دالة تعيد القيمة الصحيحة إذا كان الرقم المعطى هو ضرب 3 أعداد أولية، وإلا فهي تعيد القيمة الخاطئة. علمًا بأن (أ) أقل من 100. \n\n    مثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"سيتم إعطاؤك رقمًا بالشكل العشري ومهمتك هي تحويله إلى الشكل الثنائي. يجب أن تعيد الدالة سلسلة نصية، حيث يمثل كل حرف رقمًا ثنائيًا. سيكون كل حرف في السلسلة هو '0' أو '1'.\n\n    سيكون هناك حرفان إضافيان 'db' في بداية ونهاية السلسلة. الحروف الإضافية موجودة للمساعدة في التنسيق.\n\n    أمثلة:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "سيتم إعطاؤك رقمًا بالشكل العشري ومهمتك هي تحويله إلى الشكل الثنائي. يجب أن تعيد الدالة سلسلة نصية، حيث يمثل كل حرف رقمًا ثنائيًا. سيكون كل حرف في السلسلة هو '0' أو '1'.\n\n    سيكون هناك حرفان إضافيان 'db' في بداية ونهاية السلسلة. الحروف الإضافية موجودة للمساعدة في التنسيق.\n\n    أمثلة:\n    ", "natural_language": "Arabic"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"يتم إعطاؤك سلسلة s.\nمهمتك هي التحقق مما إذا كانت السلسلة سعيدة أم لا.\nتعتبر السلسلة سعيدة إذا كان طولها على الأقل 3 وكانت كل 3 أحرف متتالية مختلفة.\nعلى سبيل المثال:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "يتم إعطاؤك سلسلة s.\nمهمتك هي التحقق مما إذا كانت السلسلة سعيدة أم لا.\nتعتبر السلسلة سعيدة إذا كان طولها على الأقل 3 وكانت كل 3 أحرف متتالية مختلفة.\nعلى سبيل المثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"هذا هو الأسبوع الأخير من الفصل الدراسي ويجب على المعلم إعطاء الدرجات للطلاب. كان المعلم يقوم بإنشاء خوارزمية خاصة به لتقييم الدرجات. المشكلة الوحيدة هي أنها فقدت الكود الذي استخدمته للتقييم. لقد قدمت لك قائمة بمعدلات النجاح لبعض الطلاب ويجب عليك كتابة وظيفة يمكنها إخراج قائمة بالدرجات الحرفية باستخدام الجدول التالي:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        مثال:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "هذا هو الأسبوع الأخير من الفصل الدراسي ويجب على المعلم إعطاء الدرجات للطلاب. كان المعلم يقوم بإنشاء خوارزمية خاصة به لتقييم الدرجات. المشكلة الوحيدة هي أنها فقدت الكود الذي استخدمته للتقييم. لقد قدمت لك قائمة بمعدلات النجاح لبعض الطلاب ويجب عليك كتابة وظيفة يمكنها إخراج قائمة بالدرجات الحرفية باستخدام الجدول التالي:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        مثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"اكتب دالة تأخذ سلسلة نصية وتعيد True إذا كان طول السلسلة عددًا أوليًا أو False في حالة عكس ذلك\n    أمثلة\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "اكتب دالة تأخذ سلسلة نصية وتعيد True إذا كان طول السلسلة عددًا أوليًا أو False في حالة عكس ذلك\n    أمثلة\n    ", "natural_language": "Arabic"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"بالنظر إلى عدد صحيح موجب N، يتم إرجاع إجمالي مجموع أرقامه في النظام الثنائي.\n\n    مثال:\n    بالنسبة لـ N = 1000، سيكون مجموع الأرقام 1 ويجب أن يكون الإخراج \"1\".\n    بالنسبة لـ N = 150، سيكون مجموع الأرقام 6 ويجب أن يكون الإخراج \"110\".\n    بالنسبة لـ N = 147، سيكون مجموع الأرقام 12 ويجب أن يكون الإخراج \"1100\".\n\n    المتغيرات:\n    @N عدد صحيح\n         القيود: 0 ≤ N ≤ 10000.\nالإخراج:\n     سلسلة من الأرقام الثنائية.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "بالنظر إلى عدد صحيح موجب N، يتم إرجاع إجمالي مجموع أرقامه في النظام الثنائي.\n\n    مثال:\n    بالنسبة لـ N = 1000، سيكون مجموع الأرقام 1 ويجب أن يكون الإخراج \"1\".\n    بالنسبة لـ N = 150، سيكون مجموع الأرقام 6 ويجب أن يكون الإخراج \"110\".\n    بالنسبة لـ N = 147، سيكون مجموع الأرقام 12 ويجب أن يكون الإخراج \"1100\".\n\n    المتغيرات:\n    @N عدد صحيح\n         القيود: 0 ≤ N ≤ 10000.\nالإخراج:\n     سلسلة من الأرقام الثنائية.\n    ", "natural_language": "Arabic"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    يتم تزويدك ببيانات ثنائية الأبعاد، على شكل قوائم متداخلة،\n    والتي تشبه المصفوفة، ولكن على عكس المصفوفات،\n    قد تحتوي كل صف على عدد مختلف من الأعمدة.\n    بالنظر إلى lst و x عدد صحيح، ابحث عن الأعداد الصحيحة x في القائمة،\n    وأرجع قائمة من الأزواج، [(x1، y1)، (x2، y2) ...] بحيث\n    يكون كل زوج إحداثيات - (صف، أعمدة)، بدءًا من 0.\n    فرز الإحداثيات في البداية حسب الصفوف بترتيب تصاعدي.\n    أيضًا، فرز إحداثيات الصف حسب الأعمدة بترتيب تنازلي.\n    \n    أمثلة:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "يتم تزويدك ببيانات ثنائية الأبعاد، على شكل قوائم متداخلة،\n    والتي تشبه المصفوفة، ولكن على عكس المصفوفات،\n    قد تحتوي كل صف على عدد مختلف من الأعمدة.\n    بالنظر إلى lst و x عدد صحيح، ابحث عن الأعداد الصحيحة x في القائمة،\n    وأرجع قائمة من الأزواج، [(x1، y1)، (x2، y2) ...] بحيث\n    يكون كل زوج إحداثيات - (صف، أعمدة)، بدءًا من 0.\n    فرز الإحداثيات في البداية حسب الصفوف بترتيب تصاعدي.\n    أيضًا، فرز إحداثيات الصف حسب الأعمدة بترتيب تنازلي.\n    \n    أمثلة:\n    ", "natural_language": "Arabic"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    تمنحك قائمة من الأعداد الصحيحة.\nاكتب دالة next_smallest() التي تعيد العنصر الثاني الأصغر في القائمة.\nإرجاع قيمة فارغة إذا لم يكن هناك عنصر من هذا النوع.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "تمنحك قائمة من الأعداد الصحيحة.\nاكتب دالة next_smallest() التي تعيد العنصر الثاني الأصغر في القائمة.\nإرجاع قيمة فارغة إذا لم يكن هناك عنصر من هذا النوع.\n    ", "natural_language": "Arabic"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    سيتم تزويدك بسلسلة من الكلمات، ومهمتك هي عدد الملل. الملل هو جملة تبدأ بكلمة \"أنا\". تتم فصل الجمل بواسطة '.' أو '?' أو '!'.\n\n    على سبيل المثال:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "سيتم تزويدك بسلسلة من الكلمات، ومهمتك هي عدد الملل. الملل هو جملة تبدأ بكلمة \"أنا\". تتم فصل الجمل بواسطة '.' أو '?' أو '!'.\n\n    على سبيل المثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"تمنحك قائمة من الأعداد الصحيحة.\n    تحتاج إلى العثور على أكبر قيمة أولية وإرجاع مجموع أرقامها.\n\n        أمثلة:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "تمنحك قائمة من الأعداد الصحيحة.\n    تحتاج إلى العثور على أكبر قيمة أولية وإرجاع مجموع أرقامها.\n\n        أمثلة:\n    ", "natural_language": "Arabic"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    بالنظر إلى قاموس، إرجاع قيمة True إذا كانت جميع المفاتيح هي سلاسل نصية في الحالة الصغيرة أو جميع المفاتيح هي سلاسل نصية في الحالة الكبيرة، وإلا فإنه يجب إرجاع False. يجب أن يعيد الدالة False إذا كان القاموس المعطى فارغًا. أمثلة:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "بالنظر إلى قاموس، إرجاع قيمة True إذا كانت جميع المفاتيح هي سلاسل نصية في الحالة الصغيرة أو جميع المفاتيح هي سلاسل نصية في الحالة الكبيرة، وإلا فإنه يجب إرجاع False. يجب أن يعيد الدالة False إذا كان القاموس المعطى فارغًا. أمثلة:\n    ", "natural_language": "Arabic"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    أنشئ دالة تأخذ قيمة (سلسلة نصية) تمثل رقمًا وتعيد أقرب عدد صحيح إليه. إذا كان الرقم على بعد مسافة متساوية من عددين صحيحين ، فقم بتقريبه بعيدًا عن الصفر.\n\n        أمثلة\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "أنشئ دالة تأخذ قيمة (سلسلة نصية) تمثل رقمًا وتعيد أقرب عدد صحيح إليه. إذا كان الرقم على بعد مسافة متساوية من عددين صحيحين ، فقم بتقريبه بعيدًا عن الصفر.\n\n        أمثلة\n    ", "natural_language": "Arabic"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    بالنظر إلى عدد صحيح موجب n، يجب عليك إنشاء كومة من n مستويات من الحجارة.\nالمستوى الأول يحتوي على n حجرًا.\nعدد الحجارة في المستوى التالي هو:\n- العدد الفردي التالي إذا كان n فرديًا.\n- العدد الزوجي التالي إذا كان n زوجيًا.\nيرجع عدد الحجارة في كل مستوى في قائمة، حيث يمثل العنصر في المؤشر i عدد الحجارة في المستوى (i + 1).\n\n    أمثلة:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "بالنظر إلى عدد صحيح موجب n، يجب عليك إنشاء كومة من n مستويات من الحجارة.\nالمستوى الأول يحتوي على n حجرًا.\nعدد الحجارة في المستوى التالي هو:\n- العدد الفردي التالي إذا كان n فرديًا.\n- العدد الزوجي التالي إذا كان n زوجيًا.\nيرجع عدد الحجارة في كل مستوى في قائمة، حيث يمثل العنصر في المؤشر i عدد الحجارة في المستوى (i + 1).\n\n    أمثلة:\n    ", "natural_language": "Arabic"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    سيتم إعطاؤك سلسلة من الكلمات مفصولة بفواصل أو مسافات. مهمتك هي تقسيم السلسلة إلى كلمات وإرجاع مصفوفة من الكلمات.\n\n    على سبيل المثال:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "سيتم إعطاؤك سلسلة من الكلمات مفصولة بفواصل أو مسافات. مهمتك هي تقسيم السلسلة إلى كلمات وإرجاع مصفوفة من الكلمات.\n\n    على سبيل المثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"هذه الدالة تأخذ رقمين موجبين x و y وتعيد أكبر عدد صحيح زوجي يقع في النطاق [x، y] بما في ذلك. إذا لم يكن هناك عدد كهذا ، يجب أن تعيد الدالة -1.\n\n    على سبيل المثال:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "هذه الدالة تأخذ رقمين موجبين x و y وتعيد أكبر عدد صحيح زوجي يقع في النطاق [x، y] بما في ذلك. إذا لم يكن هناك عدد كهذا ، يجب أن تعيد الدالة -1.\n\n    على سبيل المثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"يتم إعطاؤك عددين صحيحين موجبين n و m ، ومهمتك هي حساب المتوسط ​​للأعداد الصحيحة من n إلى m (بما في ذلك n و m). قم بتقريب الإجابة إلى أقرب عدد صحيح وتحويلها إلى النظام الثنائي. إذا كان n أكبر من m ، فأرجع -1. مثال:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "يتم إعطاؤك عددين صحيحين موجبين n و m ، ومهمتك هي حساب المتوسط ​​للأعداد الصحيحة من n إلى m (بما في ذلك n و m). قم بتقريب الإجابة إلى أقرب عدد صحيح وتحويلها إلى النظام الثنائي. إذا كان n أكبر من m ، فأرجع -1. مثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" قم بتنفيذ الدالة f التي تأخذ n كمعلمة،\nوترجع قائمة بحجم n، بحيث يكون قيمة العنصر في المؤشر i هو عاملي الرقم i إذا كان i فرديًا،\nأو مجموع الأرقام من 1 إلى i في حالة أخرى.\ni يبدأ من 1.\nعاملي الرقم i هو الضرب من الأرقام من 1 إلى i (1 * 2 * ... * i).\nمثال:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "قم بتنفيذ الدالة f التي تأخذ n كمعلمة،\nوترجع قائمة بحجم n، بحيث يكون قيمة العنصر في المؤشر i هو عاملي الرقم i إذا كان i فرديًا،\nأو مجموع الأرقام من 1 إلى i في حالة أخرى.\ni يبدأ من 1.\nعاملي الرقم i هو الضرب من الأرقام من 1 إلى i (1 * 2 * ... * i).\nمثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    بالنظر إلى عدد صحيح موجب n ، يرجع tuple الذي يحتوي على عدد palindrome الصحيحة الزوجية والفردية التي تقع ضمن النطاق (1، n) ، شاملاً.\n\n    مثال 1:\n\n        الإدخال: 3\n    النتيجة: (1، 2)\n    الشرح:\n    عدد palindrome الصحيحة هي 1 و 2 و 3. واحد منهم زوجي ، واثنان منهم فرديان.\n\n    مثال 2:\n\n        الإدخال: 12\n    النتيجة: (4، 6)\n    الشرح:\n    عدد palindrome الصحيحة هي 1 و 2 و 3 و 4 و 5 و 6 و 7 و 8 و 9 و 11. أربعة منهم زوجيون ، و 6 منهم فرديون.\n\n    ملاحظة:\n    1. 1 <= n <= 10^3\n    2. tuple المرجع يحتوي على عدد palindrome الصحيحة الزوجية والفردية على التوالي.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "بالنظر إلى عدد صحيح موجب n ، يرجع tuple الذي يحتوي على عدد palindrome الصحيحة الزوجية والفردية التي تقع ضمن النطاق (1، n) ، شاملاً.\n\n    مثال 1:\n\n        الإدخال: 3\n    النتيجة: (1، 2)\n    الشرح:\n    عدد palindrome الصحيحة هي 1 و 2 و 3. واحد منهم زوجي ، واثنان منهم فرديان.\n\n    مثال 2:\n\n        الإدخال: 12\n    النتيجة: (4، 6)\n    الشرح:\n    عدد palindrome الصحيحة هي 1 و 2 و 3 و 4 و 5 و 6 و 7 و 8 و 9 و 11. أربعة منهم زوجيون ، و 6 منهم فرديون.\n\n    ملاحظة:\n    1. 1 <= n <= 10^3\n    2. tuple المرجع يحتوي على عدد palindrome الصحيحة الزوجية والفردية على التوالي.\n    ", "natural_language": "Arabic"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"لدينا مصفوفة 'arr' من N أعداد صحيحة arr [1]، arr [2]، ...، arr [N]. سيتم ترتيب الأرقام في المصفوفة بشكل عشوائي. مهمتك هي تحديد ما إذا كان من الممكن الحصول على مصفوفة مرتبة بترتيب غير تنازلي عن طريق تنفيذ العملية التالية على المصفوفة المعطاة:\n    يسمح لك بتنفيذ عملية التحويل اليميني أي عدد من المرات.\n\n        تعني عملية التحويل اليميني الواحد تحويل جميع عناصر المصفوفة بمقدار واحد في الاتجاه الصحيح. سيتم نقل العنصر الأخير في المصفوفة إلى الموضع البدء في المصفوفة أي الفهرس 0.\n\n        إذا كان من الممكن الحصول على المصفوفة المرتبة بتنفيذ العملية أعلاه ، فأرجع True وإلا فأرجع False. إذا كانت المصفوفة المعطاة فارغة ، فأرجع True.\n\n        ملاحظة: يتم ضمان وجود عناصر فريدة في القائمة المعطاة.\n\n        على سبيل المثال:\n\n        move_one_ball ([3، 4، 5، 1، 2]) ==> True\n    تفسير: يمكن تحقيق الترتيب غير التنازلي للمصفوفة المعطاة بتنفيذ 2 عمليات تحويل يمينية.\n    move_one_ball ([3، 5، 4، 1، 2]) ==> False\n    تفسير: لا يمكن الحصول على ترتيب غير تنازلي للمصفوفة المعطاة بتنفيذ أي عدد من عمليات التحويل اليميني.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "لدينا مصفوفة 'arr' من N أعداد صحيحة arr [1]، arr [2]، ...، arr [N]. سيتم ترتيب الأرقام في المصفوفة بشكل عشوائي. مهمتك هي تحديد ما إذا كان من الممكن الحصول على مصفوفة مرتبة بترتيب غير تنازلي عن طريق تنفيذ العملية التالية على المصفوفة المعطاة:\n    يسمح لك بتنفيذ عملية التحويل اليميني أي عدد من المرات.\n\n        تعني عملية التحويل اليميني الواحد تحويل جميع عناصر المصفوفة بمقدار واحد في الاتجاه الصحيح. سيتم نقل العنصر الأخير في المصفوفة إلى الموضع البدء في المصفوفة أي الفهرس 0.\n\n        إذا كان من الممكن الحصول على المصفوفة المرتبة بتنفيذ العملية أعلاه ، فأرجع True وإلا فأرجع False. إذا كانت المصفوفة المعطاة فارغة ، فأرجع True.\n\n        ملاحظة: يتم ضمان وجود عناصر فريدة في القائمة المعطاة.\n\n        على سبيل المثال:\n\n        move_one_ball ([3، 4، 5، 1، 2]) ==> True\n    تفسير: يمكن تحقيق الترتيب غير التنازلي للمصفوفة المعطاة بتنفيذ 2 عمليات تحويل يمينية.\n    move_one_ball ([3، 5، 4، 1، 2]) ==> False\n    تفسير: لا يمكن الحصول على ترتيب غير تنازلي للمصفوفة المعطاة بتنفيذ أي عدد من عمليات التحويل اليميني.\n    ", "natural_language": "Arabic"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"في هذه المشكلة، ستقوم بتنفيذ وظيفة تأخذ قائمتين من الأرقام، وتحدد ما إذا كان من الممكن القيام بتبادل العناصر بينهما لجعل lst1 قائمة من الأرقام الزوجية فقط. لا يوجد حد لعدد العناصر المتبادلة بين lst1 و lst2. إذا كان من الممكن تبادل العناصر بين lst1 و lst2 لجعل جميع عناصر lst1 زوجية، فأرجع \"نعم\". وإلا، أرجع \"لا\". على سبيل المثال: exchange([1، 2، 3، 4]، [1، 2، 3، 4]) => \"نعم\" exchange([1، 2، 3، 4]، [1، 5، 3، 4]) => \"لا\" يفترض أن تكون القوائم المدخلة غير فارغة.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "في هذه المشكلة، ستقوم بتنفيذ وظيفة تأخذ قائمتين من الأرقام، وتحدد ما إذا كان من الممكن القيام بتبادل العناصر بينهما لجعل lst1 قائمة من الأرقام الزوجية فقط. لا يوجد حد لعدد العناصر المتبادلة بين lst1 و lst2. إذا كان من الممكن تبادل العناصر بين lst1 و lst2 لجعل جميع عناصر lst1 زوجية، فأرجع \"نعم\". وإلا، أرجع \"لا\". على سبيل المثال: exchange([1، 2، 3، 4]، [1، 2، 3، 4]) => \"نعم\" exchange([1، 2، 3، 4]، [1، 5، 3، 4]) => \"لا\" يفترض أن تكون القوائم المدخلة غير فارغة.\n    ", "natural_language": "Arabic"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"المهمة\nنحن نحصل على سلسلتين s و c ، يجب عليك حذف جميع الأحرف في s التي تساوي أي حرف في c\nثم التحقق مما إذا كانت سلسلة النتيجة هي palindrome.\nيسمى سلسلة palindrome إذا قرأت بالمعكوس نفسها.\nيجب عليك إرجاع tuple يحتوي على سلسلة النتيجة و True / False للتحقق.\nمثال\nبالنسبة لـ s = \"abcde\" ، c = \"ae\" ، يجب أن يكون النتيجة ('bcd'،False)\nبالنسبة لـ s = \"abcdef\" ، c = \"b\" يجب أن يكون النتيجة ('acdef'،False)\nبالنسبة لـ s = \"abcdedcba\" ، c = \"ab\" يجب أن يكون النتيجة ('cdedc'،True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "المهمة\nنحن نحصل على سلسلتين s و c ، يجب عليك حذف جميع الأحرف في s التي تساوي أي حرف في c\nثم التحقق مما إذا كانت سلسلة النتيجة هي palindrome.\nيسمى سلسلة palindrome إذا قرأت بالمعكوس نفسها.\nيجب عليك إرجاع tuple يحتوي على سلسلة النتيجة و True / False للتحقق.\nمثال\nبالنسبة لـ s = \"abcde\" ، c = \"ae\" ، يجب أن يكون النتيجة ('bcd'،False)\nبالنسبة لـ s = \"abcdef\" ، c = \"b\" يجب أن يكون النتيجة ('acdef'،False)\nبالنسبة لـ s = \"abcdedcba\" ، c = \"ab\" يجب أن يكون النتيجة ('cdedc'،True)\n    ", "natural_language": "Arabic"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    يتم تزويدك بشبكة مستطيلة من الآبار. تمثل كل صف بئرًا ويمثل الرقم 1 في الصف وحدة واحدة من الماء. لكل بئر دلو مقابل يمكن استخدامه لاستخراج الماء منه، وجميع الدلاء لديها نفس السعة. مهمتك هي استخدام الدلاء لتفريغ الآبار. أخرج عدد المرات التي تحتاج فيها إلى خفض الدلاء.\n\n    مثال 1:\n    المدخلات:\n        grid: [[0،0،1،0]، [0،1،0،0]، [1،1،1،1]]\n        bucket_capacity: 1\n    الناتج: 6\n\n    مثال 2:\n    المدخلات:\n        grid: [[0،0،1،1]، [0،0،0،0]، [1،1،1،1]، [0،1،1،1]]\n        bucket_capacity: 2\n    الناتج: 5\n\n    مثال 3:\n    المدخلات:\n        grid: [[0،0،0]، [0،0،0]]\n        bucket_capacity: 5\n    الناتج: 0\n\n    القيود:\n    * جميع الآبار لديها نفس الطول\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid [:،1].length <= 10^2\n    * grid [i] [j] -> 0 | 1\n    * 1 <= capacity <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "يتم تزويدك بشبكة مستطيلة من الآبار. تمثل كل صف بئرًا ويمثل الرقم 1 في الصف وحدة واحدة من الماء. لكل بئر دلو مقابل يمكن استخدامه لاستخراج الماء منه، وجميع الدلاء لديها نفس السعة. مهمتك هي استخدام الدلاء لتفريغ الآبار. أخرج عدد المرات التي تحتاج فيها إلى خفض الدلاء.\n\n    مثال 1:\n    المدخلات:\n        grid: [[0،0،1،0]، [0،1،0،0]، [1،1،1،1]]\n        bucket_capacity: 1\n    الناتج: 6\n\n    مثال 2:\n    المدخلات:\n        grid: [[0،0،1،1]، [0،0،0،0]، [1،1،1،1]، [0،1،1،1]]\n        bucket_capacity: 2\n    الناتج: 5\n\n    مثال 3:\n    المدخلات:\n        grid: [[0،0،0]، [0،0،0]]\n        bucket_capacity: 5\n    الناتج: 0\n\n    القيود:\n    * جميع الآبار لديها نفس الطول\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid [:،1].length <= 10^2\n    * grid [i] [j] -> 0 | 1\n    * 1 <= capacity <= 10\n    ", "natural_language": "Arabic"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"تم تكليفك بتنفيذ وظيفة تعيد قائمة بجميع الكلمات من السلسلة s التي تحتوي بالضبط على n حروف ساكنة، بالترتيب الذي تظهر به هذه الكلمات في السلسلة s. إذا كانت السلسلة s فارغة ، يجب أن تعيد الوظيفة قائمة فارغة. ملاحظة: يمكنك الافتراض بأن سلسلة الإدخال تحتوي فقط على الحروف والمسافات.\n    أمثلة:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "تم تكليفك بتنفيذ وظيفة تعيد قائمة بجميع الكلمات من السلسلة s التي تحتوي بالضبط على n حروف ساكنة، بالترتيب الذي تظهر به هذه الكلمات في السلسلة s. إذا كانت السلسلة s فارغة ، يجب أن تعيد الوظيفة قائمة فارغة. ملاحظة: يمكنك الافتراض بأن سلسلة الإدخال تحتوي فقط على الحروف والمسافات.\n    أمثلة:\n    ", "natural_language": "Arabic"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    بالنظر إلى مصفوفة arr من الأعداد الصحيحة وعدد صحيح موجب k ، يتم إرجاع قائمة مرتبة بطول k مع أكبر k أرقام في arr.\n\n        مثال 1:\n\n            المدخلات: arr = [-3، -4، 5]، k = 3\n        الناتج: [-4، -3، 5]\n\n        مثال 2:\n\n            المدخلات: arr = [4، -4، 4]، k = 2\n        الناتج: [4، 4]\n\n        مثال 3:\n\n            المدخلات: arr = [-3، 2، 1، 2، -1، -2، 1]، k = 1\n        الناتج: [2]\n\n        ملاحظة:\n        1. سيكون طول المصفوفة في نطاق [1، 1000].\n        2. ستكون العناصر في المصفوفة في نطاق [-1000، 1000].\n        3. 0 <= k <= len (arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "بالنظر إلى مصفوفة arr من الأعداد الصحيحة وعدد صحيح موجب k ، يتم إرجاع قائمة مرتبة بطول k مع أكبر k أرقام في arr.\n\n        مثال 1:\n\n            المدخلات: arr = [-3، -4، 5]، k = 3\n        الناتج: [-4، -3، 5]\n\n        مثال 2:\n\n            المدخلات: arr = [4، -4، 4]، k = 2\n        الناتج: [4، 4]\n\n        مثال 3:\n\n            المدخلات: arr = [-3، 2، 1، 2، -1، -2، 1]، k = 1\n        الناتج: [2]\n\n        ملاحظة:\n        1. سيكون طول المصفوفة في نطاق [1، 1000].\n        2. ستكون العناصر في المصفوفة في نطاق [-1000، 1000].\n        3. 0 <= k <= len (arr)\n    ", "natural_language": "Arabic"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    عندما يتم إعطاء مصفوفة غير فارغة من الأعداد الصحيحة arr وعدد صحيح k ، يتم إرجاع مجموع العناصر التي لديها رقمين على الأكثر من أول k عنصرًا في arr.\n\n        مثال:\n\n            المدخلات: arr = [111،21،3،4000،5،6،7،8،9] ، k = 4\n        الإخراج: 24 # مجموع 21 + 3\n\n        القيود:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "عندما يتم إعطاء مصفوفة غير فارغة من الأعداد الصحيحة arr وعدد صحيح k ، يتم إرجاع مجموع العناصر التي لديها رقمين على الأكثر من أول k عنصرًا في arr.\n\n        مثال:\n\n            المدخلات: arr = [111،21،3،4000،5،6،7،8،9] ، k = 4\n        الإخراج: 24 # مجموع 21 + 3\n\n        القيود:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    ", "natural_language": "Arabic"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"يتم تزويدك بنطاقين،\nحيث يتكون كل نطاق من زوج من الأعداد الصحيحة. على سبيل المثال، النطاق = (البداية، النهاية) = (1، 2).\nالنطاقات المعطاة مغلقة مما يعني أن النطاق (البداية، النهاية)\nيشمل كل من البداية والنهاية.\nيفترض لكل نطاق معطى أن بدايته أقل أو يساوي نهايته.\nمهمتك هي تحديد ما إذا كان طول تقاطع هذين النطاقين هو عدد أولي.\nعلى سبيل المثال، تقاطع النطاقات (1، 3)، (2، 4) هو (2، 3)\nالذي يبلغ طوله 1، وهو ليس عددًا أوليًا.\nإذا كان طول التقاطع عددًا أوليًا، فأرجع \"نعم\"،\nوإلا، أرجع \"لا\".\nإذا لم يتقاطع النطاقان، فأرجع \"لا\".\n\n    [المدخلات/المخرجات] الأمثلة:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "يتم تزويدك بنطاقين،\nحيث يتكون كل نطاق من زوج من الأعداد الصحيحة. على سبيل المثال، النطاق = (البداية، النهاية) = (1، 2).\nالنطاقات المعطاة مغلقة مما يعني أن النطاق (البداية، النهاية)\nيشمل كل من البداية والنهاية.\nيفترض لكل نطاق معطى أن بدايته أقل أو يساوي نهايته.\nمهمتك هي تحديد ما إذا كان طول تقاطع هذين النطاقين هو عدد أولي.\nعلى سبيل المثال، تقاطع النطاقات (1، 3)، (2، 4) هو (2، 3)\nالذي يبلغ طوله 1، وهو ليس عددًا أوليًا.\nإذا كان طول التقاطع عددًا أوليًا، فأرجع \"نعم\"،\nوإلا، أرجع \"لا\".\nإذا لم يتقاطع النطاقان، فأرجع \"لا\".\n\n    [المدخلات/المخرجات] الأمثلة:\n    ", "natural_language": "Arabic"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"الجميع يعرف سلسلة فيبوناتشي، وقد درسها الرياضيون بعمق في القرون القليلة الماضية. ومع ذلك، ما لا يعرفه الناس هو سلسلة تريبوناتشي. تعرف سلسلة تريبوناتشي بالتكرار:\ntri(1) = 3\ntri(n) = 1 + n / 2، إذا كان n زوجيًا.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، إذا كان n فرديًا.\nعلى سبيل المثال:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nيتم إعطاؤك عدد صحيح غير سلبي n ، ويجب عليك إرجاع قائمة بأول n + 1 عددًا في سلسلة تريبوناتشي.\nأمثلة:\ntri(3) = [1، 3، 2، 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "الجميع يعرف سلسلة فيبوناتشي، وقد درسها الرياضيون بعمق في القرون القليلة الماضية. ومع ذلك، ما لا يعرفه الناس هو سلسلة تريبوناتشي. تعرف سلسلة تريبوناتشي بالتكرار:\ntri(1) = 3\ntri(n) = 1 + n / 2، إذا كان n زوجيًا.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، إذا كان n فرديًا.\nعلى سبيل المثال:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nيتم إعطاؤك عدد صحيح غير سلبي n ، ويجب عليك إرجاع قائمة بأول n + 1 عددًا في سلسلة تريبوناتشي.\nأمثلة:\ntri(3) = [1، 3، 2، 8]\n    ", "natural_language": "Arabic"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"بالنظر إلى عدد صحيح موجب n، يتم إرجاع حاصل ضرب الأرقام الفردية.\nإذا كانت جميع الأرقام زوجية، يتم إرجاع القيمة 0.\nعلى سبيل المثال:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "بالنظر إلى عدد صحيح موجب n، يتم إرجاع حاصل ضرب الأرقام الفردية.\nإذا كانت جميع الأرقام زوجية، يتم إرجاع القيمة 0.\nعلى سبيل المثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    أنشئ دالة تأخذ سلسلة نصية كمدخلات تحتوي فقط على أقواس مربعة.\nيجب أن تعيد الدالة True إذا وفقط إذا كان هناك متتالية صحيحة من الأقواس\nحيث يتم تضمين على الأقل قوس واحد في المتتالية.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "أنشئ دالة تأخذ سلسلة نصية كمدخلات تحتوي فقط على أقواس مربعة.\nيجب أن تعيد الدالة True إذا وفقط إذا كان هناك متتالية صحيحة من الأقواس\nحيث يتم تضمين على الأقل قوس واحد في المتتالية.\n    ", "natural_language": "Arabic"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"تمنحك قائمة من الأرقام.\nتحتاج إلى إرجاع مجموع الأرقام المربعة في القائمة المعطاة،\nقم بتقريب كل عنصر في القائمة إلى العدد الصحيح الأعلى (السقف) أولاً.\nأمثلة:\nللقائمة = [1،2،3] يجب أن يكون الإخراج 14\nللقائمة = [1،4،9] يجب أن يكون الإخراج 98\nللقائمة = [1،3،5،7] يجب أن يكون الإخراج 84\nللقائمة = [1.4،4.2،0] يجب أن يكون الإخراج 29\nللقائمة = [-2.4،1،1] يجب أن يكون الإخراج 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "تمنحك قائمة من الأرقام.\nتحتاج إلى إرجاع مجموع الأرقام المربعة في القائمة المعطاة،\nقم بتقريب كل عنصر في القائمة إلى العدد الصحيح الأعلى (السقف) أولاً.\nأمثلة:\nللقائمة = [1،2،3] يجب أن يكون الإخراج 14\nللقائمة = [1،4،9] يجب أن يكون الإخراج 98\nللقائمة = [1،3،5،7] يجب أن يكون الإخراج 84\nللقائمة = [1.4،4.2،0] يجب أن يكون الإخراج 29\nللقائمة = [-2.4،1،1] يجب أن يكون الإخراج 6\n    ", "natural_language": "Arabic"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    أنشئ دالة تعيد True إذا كان الحرف الأخير في السلسلة المعطاة حرفًا أبجديًا وليس جزءًا من كلمة، وتعيد False في الحالة الأخرى.\nملاحظة: \"الكلمة\" هي مجموعة من الأحرف مفصولة بمسافة.\n\n    أمثلة:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "أنشئ دالة تعيد True إذا كان الحرف الأخير في السلسلة المعطاة حرفًا أبجديًا وليس جزءًا من كلمة، وتعيد False في الحالة الأخرى.\nملاحظة: \"الكلمة\" هي مجموعة من الأحرف مفصولة بمسافة.\n\n    أمثلة:\n    ", "natural_language": "Arabic"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"أنشئ دالة تعيد أكبر فهرس لعنصر لا يزيد عن العنصر الذي يسبقه. إذا لم يوجد عنصر كهذا ، فأرجع -1. لن يحتوي المصفوفة المعطاة على قيم مكررة.\n\n        أمثلة:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "أنشئ دالة تعيد أكبر فهرس لعنصر لا يزيد عن العنصر الذي يسبقه. إذا لم يوجد عنصر كهذا ، فأرجع -1. لن يحتوي المصفوفة المعطاة على قيم مكررة.\n\n        أمثلة:\n    ", "natural_language": "Arabic"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    أنشئ دالة تعيد tuple (a، b) ، حيث يكون 'a' هو أكبر الأعداد الصحيحة السالبة ، و 'b' هو أصغر الأعداد الصحيحة الموجبة في القائمة. إذا لم يكن هناك أعداد صحيحة سالبة أو موجبة ، فأرجعها كـ None.\n\n        Examples:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "أنشئ دالة تعيد tuple (a، b) ، حيث يكون 'a' هو أكبر الأعداد الصحيحة السالبة ، و 'b' هو أصغر الأعداد الصحيحة الموجبة في القائمة. إذا لم يكن هناك أعداد صحيحة سالبة أو موجبة ، فأرجعها كـ None.\n\n        Examples:\n    ", "natural_language": "Arabic"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"العامل البرازيلي يعرف على أنه:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    حيث n > 0\n\n        على سبيل المثال:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "العامل البرازيلي يعرف على أنه:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    حيث n > 0\n\n        على سبيل المثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    يتم تزويدك بسلسلة تمثل جملة،\nالجملة تحتوي على بعض الكلمات المفصولة بمسافة،\nويجب عليك إرجاع سلسلة تحتوي على الكلمات من الجملة الأصلية،\nالتي تحتوي على أعداد أولية من الأحرف،\nيجب أن يكون ترتيب الكلمات في السلسلة الجديدة هو نفس الترتيب الأصلي.\n\n    مثال 1:\n    المدخلات: الجملة = \"This is a test\"\n    الناتج: \"is\"\n\n    مثال 2:\n    المدخلات: الجملة = \"lets go for swimming\"\n    الناتج: \"go for\"\n\n    القيود:\n    * 1 <= len(sentence) <= 100\n    * تحتوي الجملة على أحرف فقط\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "يتم تزويدك بسلسلة تمثل جملة،\nالجملة تحتوي على بعض الكلمات المفصولة بمسافة،\nويجب عليك إرجاع سلسلة تحتوي على الكلمات من الجملة الأصلية،\nالتي تحتوي على أعداد أولية من الأحرف،\nيجب أن يكون ترتيب الكلمات في السلسلة الجديدة هو نفس الترتيب الأصلي.\n\n    مثال 1:\n    المدخلات: الجملة = \"This is a test\"\n    الناتج: \"is\"\n\n    مثال 2:\n    المدخلات: الجملة = \"lets go for swimming\"\n    الناتج: \"go for\"\n\n    القيود:\n    * 1 <= len(sentence) <= 100\n    * تحتوي الجملة على أحرف فقط\n    ", "natural_language": "Arabic"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"مهمتك هي تنفيذ وظيفة ستبسط التعبير\nx * n. تعيد الوظيفة True إذا كان x * n يقيم إلى عدد صحيح و False\nإلا في ذلك. كل من x و n هما تمثيل سلسلة لكسر ، ولهما التنسيق التالي ،\n<البسط>/<المقام> حيث كل من البسط والمقام هما أعداد صحيحة موجبة.\n\n    يمكنك الافتراض أن x و n هما كسور صالحة ، ولا يحتويان على الصفر كمقام.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "مهمتك هي تنفيذ وظيفة ستبسط التعبير\nx * n. تعيد الوظيفة True إذا كان x * n يقيم إلى عدد صحيح و False\nإلا في ذلك. كل من x و n هما تمثيل سلسلة لكسر ، ولهما التنسيق التالي ،\n<البسط>/<المقام> حيث كل من البسط والمقام هما أعداد صحيحة موجبة.\n\n    يمكنك الافتراض أن x و n هما كسور صالحة ، ولا يحتويان على الصفر كمقام.\n    ", "natural_language": "Arabic"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    اكتب دالة تقوم بفرز القائمة المعطاة من الأعداد الصحيحة بترتيب تصاعدي وفقًا لمجموع أرقامها. ملاحظة: إذا كان هناك عدة عناصر بمجموع أرقام مماثل ، فقم بترتيبها بناءً على مؤشرها في القائمة الأصلية.\n\n    على سبيل المثال:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "اكتب دالة تقوم بفرز القائمة المعطاة من الأعداد الصحيحة بترتيب تصاعدي وفقًا لمجموع أرقامها. ملاحظة: إذا كان هناك عدة عناصر بمجموع أرقام مماثل ، فقم بترتيبها بناءً على مؤشرها في القائمة الأصلية.\n\n    على سبيل المثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"اكتب دالة تأخذ مصفوفة من الأرقام كمدخلات وتعيد عدد العناصر في المصفوفة التي تزيد عن 10 وكلاً من الأرقام الأولى والأخيرة للعدد فردية (1، 3، 5، 7، 9). على سبيل المثال:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "اكتب دالة تأخذ مصفوفة من الأرقام كمدخلات وتعيد عدد العناصر في المصفوفة التي تزيد عن 10 وكلاً من الأرقام الأولى والأخيرة للعدد فردية (1، 3، 5، 7، 9). على سبيل المثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    تمنحك عدد صحيح موجب n. يجب عليك إنشاء مصفوفة صحيحة a طولها n.\n        بالنسبة لكل i (1 ≤ i ≤ n) ، قيمة a [i] = i * i - i + 1.\n        إرجاع عدد الثلاثيات (a [i]، a [j]، a [k]) من a حيث i <j <k ،\n    و a [i] + a [j] + a [k] هو مضاعف للعدد 3.\n\n        مثال:\n        المدخلات: n = 5\n        الناتج: 1\n        شرح:\n        a = [1، 3، 7، 13، 21]\n        الثلاثية الوحيدة الصالحة هي (1، 7، 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "تمنحك عدد صحيح موجب n. يجب عليك إنشاء مصفوفة صحيحة a طولها n.\n        بالنسبة لكل i (1 ≤ i ≤ n) ، قيمة a [i] = i * i - i + 1.\n        إرجاع عدد الثلاثيات (a [i]، a [j]، a [k]) من a حيث i <j <k ،\n    و a [i] + a [j] + a [k] هو مضاعف للعدد 3.\n\n        مثال:\n        المدخلات: n = 5\n        الناتج: 1\n        شرح:\n        a = [1، 3، 7، 13، 21]\n        الثلاثية الوحيدة الصالحة هي (1، 7، 13).\n    ", "natural_language": "Arabic"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    هناك ثمانية كواكب في نظامنا الشمسي: الأقرب إلى الشمس هو عطارد، الكوكب التالي هو الزهرة، ثم الأرض، المريخ، المشتري، زحل، أورانوس، نبتون.\nاكتب دالة تأخذ اسمي كوكب كسلسلة نصية planet1 و planet2. يجب أن تعيد الدالة tuple يحتوي على جميع الكواكب التي تقع مداراتها بين مدار كوكب1 ومدار كوكب2، مرتبة حسب القرب من الشمس. يجب أن تعيد الدالة tuple فارغًا إذا كان planet1 أو planet2 ليستا أسماء كواكب صحيحة.\nأمثلة\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "هناك ثمانية كواكب في نظامنا الشمسي: الأقرب إلى الشمس هو عطارد، الكوكب التالي هو الزهرة، ثم الأرض، المريخ، المشتري، زحل، أورانوس، نبتون.\nاكتب دالة تأخذ اسمي كوكب كسلسلة نصية planet1 و planet2. يجب أن تعيد الدالة tuple يحتوي على جميع الكواكب التي تقع مداراتها بين مدار كوكب1 ومدار كوكب2، مرتبة حسب القرب من الشمس. يجب أن تعيد الدالة tuple فارغًا إذا كان planet1 أو planet2 ليستا أسماء كواكب صحيحة.\nأمثلة\n    ", "natural_language": "Arabic"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"برنامج بسيط يجب أن يعيد قيمة x إذا كان n عددًا أولًا ويجب أن يعيد قيمة y في حالة أخرى.\n\n    أمثلة:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "برنامج بسيط يجب أن يعيد قيمة x إذا كان n عددًا أولًا ويجب أن يعيد قيمة y في حالة أخرى.\n\n    أمثلة:\n    ", "natural_language": "Arabic"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    عندما يتم إعطاء قائمة من الأرقام، يتم إرجاع مجموع مربعات الأرقام في القائمة التي هي فردية. يتم تجاهل الأرقام التي هي سلبية أو غير صحيحة.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0\n\n    إذا كانت القائمة المدخلة فارغة، يتم إرجاع 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "عندما يتم إعطاء قائمة من الأرقام، يتم إرجاع مجموع مربعات الأرقام في القائمة التي هي فردية. يتم تجاهل الأرقام التي هي سلبية أو غير صحيحة.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0\n\n    إذا كانت القائمة المدخلة فارغة، يتم إرجاع 0.\n    ", "natural_language": "Arabic"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"سيتم تزويدك بإسم الصف (سلسلة نصية) وقائمة من الامتدادات.\nيجب استخدام الامتدادات لتحميل صفوف إضافية إلى الصف. قوة الامتداد هي كما يلي: دع CAP يكون عدد الأحرف الكبيرة في اسم الامتداد، ودع SM يكون عدد الأحرف الصغيرة في اسم الامتداد، يتم إعطاء القوة بواسطة الكسر CAP - SM. يجب عليك العثور على الامتداد الأقوى وإرجاع سلسلة بهذا الشكل: اسم الصف.اسم الامتداد الأقوى.\nإذا كان هناك اثنين أو أكثر من الامتدادات بنفس القوة، يجب اختيار الذي يأتي أولاً في القائمة.\nعلى سبيل المثال، إذا تم تزويدك بـ \"Slices\" كصف وقائمة من الامتدادات: ['SErviNGSliCes'، 'Cheese'، 'StuFfed']، فيجب عليك إرجاع 'Slices.SErviNGSliCes' لأن 'SErviNGSliCes' هو الامتداد الأقوى (قوته -1).\nمثال:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "سيتم تزويدك بإسم الصف (سلسلة نصية) وقائمة من الامتدادات.\nيجب استخدام الامتدادات لتحميل صفوف إضافية إلى الصف. قوة الامتداد هي كما يلي: دع CAP يكون عدد الأحرف الكبيرة في اسم الامتداد، ودع SM يكون عدد الأحرف الصغيرة في اسم الامتداد، يتم إعطاء القوة بواسطة الكسر CAP - SM. يجب عليك العثور على الامتداد الأقوى وإرجاع سلسلة بهذا الشكل: اسم الصف.اسم الامتداد الأقوى.\nإذا كان هناك اثنين أو أكثر من الامتدادات بنفس القوة، يجب اختيار الذي يأتي أولاً في القائمة.\nعلى سبيل المثال، إذا تم تزويدك بـ \"Slices\" كصف وقائمة من الامتدادات: ['SErviNGSliCes'، 'Cheese'، 'StuFfed']، فيجب عليك إرجاع 'Slices.SErviNGSliCes' لأن 'SErviNGSliCes' هو الامتداد الأقوى (قوته -1).\nمثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"يتم تزويدك بكلمتين. تحتاج إلى إرجاع True إذا كانت الكلمة الثانية أو أي من دوراناتها هي متعابدة في الكلمة الأولى.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "يتم تزويدك بكلمتين. تحتاج إلى إرجاع True إذا كانت الكلمة الثانية أو أي من دوراناتها هي متعابدة في الكلمة الأولى.\n    ", "natural_language": "Arabic"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    بالنظر إلى عدد صحيح موجب، احصل على ما يعادله من الأرقام الرومانية كسلسلة نصية، وارجعها بأحرف صغيرة.\nالقيود: 1 <= num <= 1000\n\n    أمثلة:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "بالنظر إلى عدد صحيح موجب، احصل على ما يعادله من الأرقام الرومانية كسلسلة نصية، وارجعها بأحرف صغيرة.\nالقيود: 1 <= num <= 1000\n\n    أمثلة:\n    ", "natural_language": "Arabic"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    بالنظر إلى أطوال الأضلاع الثلاثة لمثلث. إرجاع قيمة صحيحة (True) إذا كانت الأضلاع الثلاثة تشكل مثلثاً قائم الزاوية، وإرجاع قيمة خاطئة (False) في الحالات الأخرى. يعتبر المثلث القائم الزاوية هو مثلث يحتوي على زاوية قائمة أو بزاوية 90 درجة. مثال:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "بالنظر إلى أطوال الأضلاع الثلاثة لمثلث. إرجاع قيمة صحيحة (True) إذا كانت الأضلاع الثلاثة تشكل مثلثاً قائم الزاوية، وإرجاع قيمة خاطئة (False) في الحالات الأخرى. يعتبر المثلث القائم الزاوية هو مثلث يحتوي على زاوية قائمة أو بزاوية 90 درجة. مثال:\n    ", "natural_language": "Arabic"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"تمنحك سلسلة s.\n    إذا كان s[i] حرفًا، فعكس حالته من الحروف الصغيرة إلى الحروف الكبيرة أو العكس،\n    وإلا فاحتفظ به كما هو.\n    إذا لم تحتوي السلسلة على أحرف، فعكس السلسلة.\n    يجب أن تعيد الدالة السلسلة الناتجة.\n    أمثلة\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "تمنحك سلسلة s.\n    إذا كان s[i] حرفًا، فعكس حالته من الحروف الصغيرة إلى الحروف الكبيرة أو العكس،\n    وإلا فاحتفظ به كما هو.\n    إذا لم تحتوي السلسلة على أحرف، فعكس السلسلة.\n    يجب أن تعيد الدالة السلسلة الناتجة.\n    أمثلة\n    ", "natural_language": "Arabic"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    بالنظر إلى سلسلة 'text'، أرجع سلسلة مكافئة لها بتشفير md5.\nإذا كانت 'text' فارغة، أرجع قيمة فارغة.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "بالنظر إلى سلسلة 'text'، أرجع سلسلة مكافئة لها بتشفير md5.\nإذا كانت 'text' فارغة، أرجع قيمة فارغة.\n    ", "natural_language": "Arabic"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    بالنظر إلى عددين صحيحين موجبين a و b، يتم إرجاع الأرقام الزوجية بين a و b بترتيب تصاعدي.\n\n    على سبيل المثال:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "بالنظر إلى عددين صحيحين موجبين a و b، يتم إرجاع الأرقام الزوجية بين a و b بترتيب تصاعدي.\n\n    على سبيل المثال:\n    ", "natural_language": "Arabic"}
