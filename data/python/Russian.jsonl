{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Вам дан список операций по вкладу и снятию денег с банковского счета, который начинается с нулевого баланса. Ваша задача - обнаружить, если на каком-то этапе баланс счета падает ниже нуля, и в этой точке функция должна вернуть True. В противном случае она должна вернуть False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Вам дан список операций по вкладу и снятию денег с банковского счета, который начинается с нулевого баланса. Ваша задача - обнаружить, если на каком-то этапе баланс счета падает ниже нуля, и в этой точке функция должна вернуть True. В противном случае она должна вернуть False.\n    ", "natural_language": "Russian"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Для заданного списка целых чисел вернуть кортеж, состоящий из суммы и произведения всех целых чисел в списке. Пустая сумма должна быть равна 0, а пустое произведение должно быть равно 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Для заданного списка целых чисел вернуть кортеж, состоящий из суммы и произведения всех целых чисел в списке. Пустая сумма должна быть равна 0, а пустое произведение должно быть равно 1.\n    ", "natural_language": "Russian"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Входными данными являются две строки a и b, состоящие только из 1 и 0.\n    Выполните бинарное исключающее ИЛИ на этих входных данных и верните результат также в виде строки.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "Входными данными являются две строки a и b, состоящие только из 1 и 0.\n    Выполните бинарное исключающее ИЛИ на этих входных данных и верните результат также в виде строки.\n    ", "natural_language": "Russian"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Из списка строк вернуть самую длинную. В случае нескольких строк одинаковой длины вернуть первую. В случае пустого списка вернуть null.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "Из списка строк вернуть самую длинную. В случае нескольких строк одинаковой длины вернуть первую. В случае пустого списка вернуть null.\n    ", "natural_language": "Russian"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Вернуть наибольший общий делитель двух целых чисел a и b.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Вернуть наибольший общий делитель двух целых чисел a и b.\n    ", "natural_language": "Russian"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Вводится строка чисел, разделенных пробелами, от 'ноль' до 'девять'.\n    Допустимыми вариантами являются 'ноль', 'один', 'два', 'три', 'четыре', 'пять', 'шесть', 'семь', 'восемь' и 'девять'.\n    Вернуть строку с отсортированными числами от наименьшего к наибольшему.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "Вводится строка чисел, разделенных пробелами, от 'ноль' до 'девять'.\n    Допустимыми вариантами являются 'ноль', 'один', 'два', 'три', 'четыре', 'пять', 'шесть', 'семь', 'восемь' и 'девять'.\n    Вернуть строку с отсортированными числами от наименьшего к наибольшему.\n    ", "natural_language": "Russian"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Дан список чисел (не менее двух элементов), примените линейное преобразование к этому списку, так что наименьшее число станет равным 0, а наибольшее - 1.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Дан список чисел (не менее двух элементов), примените линейное преобразование к этому списку, так что наименьшее число станет равным 0, а наибольшее - 1.\n    ", "natural_language": "Russian"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Для заданной строки перевернуть символы в нижнем регистре в верхний регистр и символы в верхнем регистре в нижний регистр.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Для заданной строки перевернуть символы в нижнем регистре в верхний регистр и символы в верхнем регистре в нижний регистр.\n    ", "natural_language": "Russian"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Вернуть только положительные числа в списке.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Вернуть только положительные числа в списке.\n    ", "natural_language": "Russian"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Вернуть true, если данное число является простым, и false в противном случае.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Вернуть true, если данное число является простым, и false в противном случае.\n    ", "natural_language": "Russian"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Вернуть отсортированные уникальные элементы в списке.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Вернуть отсортированные уникальные элементы в списке.\n    ", "natural_language": "Russian"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib возвращает n-ое число, которое является числом Фибоначчи и простым числом.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib возвращает n-ое число, которое является числом Фибоначчи и простым числом.\n    ", "natural_language": "Russian"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero принимает список целых чисел в качестве входных данных.\n    Он возвращает True, если в списке есть три различных элемента, которые\n    суммируются в ноль, и False в противном случае.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "triples_sum_to_zero принимает список целых чисел в качестве входных данных.\n    Он возвращает True, если в списке есть три различных элемента, которые\n    суммируются в ноль, и False в противном случае.\n    ", "natural_language": "Russian"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    Функция pairs_sum_to_zero принимает список целых чисел в качестве входных данных. Она возвращает True, если в списке есть два различных элемента, сумма которых равна нулю, и False в противном случае.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "Функция pairs_sum_to_zero принимает список целых чисел в качестве входных данных. Она возвращает True, если в списке есть два различных элемента, сумма которых равна нулю, и False в противном случае.\n    ", "natural_language": "Russian"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Последовательность чисел Fib4 - это последовательность, аналогичная последовательности Фибоначчи, которая определяется следующим образом:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Пожалуйста, напишите функцию для эффективного вычисления n-го элемента последовательности чисел fib4. Не используйте рекурсию.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "Последовательность чисел Fib4 - это последовательность, аналогичная последовательности Фибоначчи, которая определяется следующим образом:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Пожалуйста, напишите функцию для эффективного вычисления n-го элемента последовательности чисел fib4. Не используйте рекурсию.\n    ", "natural_language": "Russian"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Вернуть медиану элементов в списке l.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Вернуть медиану элементов в списке l.\n    ", "natural_language": "Russian"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Проверяет, является ли данная строка палиндромом.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Проверяет, является ли данная строка палиндромом.\n    ", "natural_language": "Russian"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels - это функция, которая принимает строку и возвращает строку без гласных.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels - это функция, которая принимает строку и возвращает строку без гласных.\n    ", "natural_language": "Russian"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Вернуть True, если все числа в списке l меньше порога t.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Вернуть True, если все числа в списке l меньше порога t.\n    ", "natural_language": "Russian"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Добавить два числа x и y.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Добавить два числа x и y.\n    ", "natural_language": "Russian"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Проверить, имеют ли два слова одинаковые символы.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Проверить, имеют ли два слова одинаковые символы.\n    ", "natural_language": "Russian"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Вернуть n-ое число Фибоначчи.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Вернуть n-ое число Фибоначчи.\n    ", "natural_language": "Russian"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Вернуть отсортированные уникальные общие элементы для двух списков.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Вернуть отсортированные уникальные общие элементы для двух списков.\n    ", "natural_language": "Russian"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Вернуть наибольший простой множитель n. Предполагается, что n > 1 и не является простым числом.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Вернуть наибольший простой множитель n. Предполагается, что n > 1 и не является простым числом.\n    ", "natural_language": "Russian"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n - это функция, которая суммирует числа от 1 до n.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n - это функция, которая суммирует числа от 1 до n.\n    ", "natural_language": "Russian"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs представляют коэффициенты многочлена.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Вернуть производную этого многочлена в том же виде.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs представляют коэффициенты многочлена.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Вернуть производную этого многочлена в том же виде.\n    ", "natural_language": "Russian"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"Последовательность чисел ФибФиб - это последовательность, аналогичная последовательности Фибоначчи, которая определяется следующим образом:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Пожалуйста, напишите функцию для эффективного вычисления n-го элемента последовательности чисел ФибФиб.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "Последовательность чисел ФибФиб - это последовательность, аналогичная последовательности Фибоначчи, которая определяется следующим образом:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Пожалуйста, напишите функцию для эффективного вычисления n-го элемента последовательности чисел ФибФиб.\n    ", "natural_language": "Russian"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Напишите функцию vowels_count, которая принимает в качестве входных данных строку, представляющую слово, и возвращает количество гласных в строке. Гласные в этом случае - 'a', 'e', 'i', 'o', 'u'. Здесь 'y' также является гласной, но только когда она находится в конце данного слова.\n\n    Пример:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Напишите функцию vowels_count, которая принимает в качестве входных данных строку, представляющую слово, и возвращает количество гласных в строке. Гласные в этом случае - 'a', 'e', 'i', 'o', 'u'. Здесь 'y' также является гласной, но только когда она находится в конце данного слова.\n\n    Пример:\n    ", "natural_language": "Russian"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Вам дан непустой список положительных целых чисел. Верните наибольшее целое число, которое больше нуля и имеет частоту, большую или равную значению самого числа. Частота целого числа - это количество раз, которое оно появляется в списке. Если такого значения не существует, верните -1. Примеры:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Вам дан непустой список положительных целых чисел. Верните наибольшее целое число, которое больше нуля и имеет частоту, большую или равную значению самого числа. Частота целого числа - это количество раз, которое оно появляется в списке. Если такого значения не существует, верните -1. Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Даны длины трех сторон треугольника. Вернуть площадь треугольника, округленную до 2 десятичных знаков, если три стороны образуют допустимый треугольник. В противном случае вернуть -1. Три стороны образуют допустимый треугольник, когда сумма любых двух сторон больше третьей стороны. Пример:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Даны длины трех сторон треугольника. Вернуть площадь треугольника, округленную до 2 десятичных знаков, если три стороны образуют допустимый треугольник. В противном случае вернуть -1. Три стороны образуют допустимый треугольник, когда сумма любых двух сторон больше третьей стороны. Пример:\n    ", "natural_language": "Russian"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Напишите функцию, которая возвращает True, если объект q полетит, и False в противном случае. Объект q полетит, если он сбалансирован (является палиндромным списком) и сумма его элементов меньше или равна максимально возможному весу w.\n\n    Пример:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 меньше максимально возможного веса, но он несбалансирован.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# он сбалансирован, но 3+2+3 больше максимально возможного веса.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 меньше максимально возможного веса, и он сбалансирован.\n\n    will_it_fly([3], 5) ➞ True\n# 3 меньше максимально возможного веса, и он сбалансирован.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Напишите функцию, которая возвращает True, если объект q полетит, и False в противном случае. Объект q полетит, если он сбалансирован (является палиндромным списком) и сумма его элементов меньше или равна максимально возможному весу w.\n\n    Пример:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 меньше максимально возможного веса, но он несбалансирован.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# он сбалансирован, но 3+2+3 больше максимально возможного веса.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 меньше максимально возможного веса, и он сбалансирован.\n\n    will_it_fly([3], 5) ➞ True\n# 3 меньше максимально возможного веса, и он сбалансирован.\n    ", "natural_language": "Russian"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Напишите функцию, которая возвращает true, если данное число является произведением трех простых чисел, и false в противном случае. Известно, что (a) меньше 100. Пример:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Напишите функцию, которая возвращает true, если данное число является произведением трех простых чисел, и false в противном случае. Известно, что (a) меньше 100. Пример:\n    ", "natural_language": "Russian"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Вам будет дано число в десятичной форме, и ваша задача - преобразовать его в двоичный формат. Функция должна возвращать строку, в которой каждый символ представляет двоичное число. Каждый символ в строке будет '0' или '1'.\n\n    В начале и в конце строки будет дополнительная пара символов 'db'. Дополнительные символы нужны для форматирования.\n\n    Примеры:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Вам будет дано число в десятичной форме, и ваша задача - преобразовать его в двоичный формат. Функция должна возвращать строку, в которой каждый символ представляет двоичное число. Каждый символ в строке будет '0' или '1'.\n\n    В начале и в конце строки будет дополнительная пара символов 'db'. Дополнительные символы нужны для форматирования.\n\n    Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Вам дана строка s.\n    Ваша задача - проверить, является ли строка счастливой или нет.\n    Строка счастлива, если ее длина не менее 3 и каждые 3 последовательные буквы отличаются друг от друга.\n    Например:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Вам дана строка s.\n    Ваша задача - проверить, является ли строка счастливой или нет.\n    Строка счастлива, если ее длина не менее 3 и каждые 3 последовательные буквы отличаются друг от друга.\n    Например:\n    ", "natural_language": "Russian"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Это последняя неделя семестра, и учитель должен выставить оценки студентам. Учитель разработала свой алгоритм для оценки. Единственная проблема в том, что она потеряла код, который использовала для оценки. Она дала вам список средних баллов для некоторых студентов, и вам нужно написать функцию, которая может вывести список буквенных оценок, используя следующую таблицу:\n\n                 Средний балл       |    Буквенная оценка\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Пример:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "Это последняя неделя семестра, и учитель должен выставить оценки студентам. Учитель разработала свой алгоритм для оценки. Единственная проблема в том, что она потеряла код, который использовала для оценки. Она дала вам список средних баллов для некоторых студентов, и вам нужно написать функцию, которая может вывести список буквенных оценок, используя следующую таблицу:\n\n                 Средний балл       |    Буквенная оценка\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Пример:\n    ", "natural_language": "Russian"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Напишите функцию, которая принимает строку и возвращает True, если длина строки является простым числом, и False в противном случае. Примеры:\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Напишите функцию, которая принимает строку и возвращает True, если длина строки является простым числом, и False в противном случае. Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Дано положительное целое число N, вернуть общую сумму его цифр в двоичном виде.\n\n        Пример\n        Для N = 1000 сумма цифр будет равна 1, вывод должен быть \"1\".\n        Для N = 150 сумма цифр будет равна 6, вывод должен быть \"110\".\n        Для N = 147 сумма цифр будет равна 12, вывод должен быть \"1100\".\n    \n    Переменные:\n        @N целое число\n             Ограничения: 0 ≤ N ≤ 10000.\n    Вывод:\n         строка двоичного числа\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Дано положительное целое число N, вернуть общую сумму его цифр в двоичном виде.\n\n        Пример\n        Для N = 1000 сумма цифр будет равна 1, вывод должен быть \"1\".\n        Для N = 150 сумма цифр будет равна 6, вывод должен быть \"110\".\n        Для N = 147 сумма цифр будет равна 12, вывод должен быть \"1100\".\n    \n    Переменные:\n        @N целое число\n             Ограничения: 0 ≤ N ≤ 10000.\n    Вывод:\n         строка двоичного числа\n    ", "natural_language": "Russian"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Вам даны двумерные данные в виде вложенных списков, которые похожи на матрицы, однако, в отличие от матриц, каждая строка может содержать разное количество столбцов. Дан список lst и целое число x, найдите целые числа x в списке и верните список кортежей [(x1, y1), (x2, y2) ...], таких что каждый кортеж является координатой - (строка, столбцы), начиная с 0. Сначала отсортируйте координаты по строкам в порядке возрастания. Также отсортируйте координаты строки по столбцам в порядке убывания.\n\n    Примеры:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Вам даны двумерные данные в виде вложенных списков, которые похожи на матрицы, однако, в отличие от матриц, каждая строка может содержать разное количество столбцов. Дан список lst и целое число x, найдите целые числа x в списке и верните список кортежей [(x1, y1), (x2, y2) ...], таких что каждый кортеж является координатой - (строка, столбцы), начиная с 0. Сначала отсортируйте координаты по строкам в порядке возрастания. Также отсортируйте координаты строки по столбцам в порядке убывания.\n\n    Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Вам дан список целых чисел.\nНапишите функцию next_smallest(), которая возвращает второй наименьший элемент списка.\nВерните null, если такого элемента нет.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Вам дан список целых чисел.\nНапишите функцию next_smallest(), которая возвращает второй наименьший элемент списка.\nВерните null, если такого элемента нет.\n    ", "natural_language": "Russian"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Вам будет дана строка слов, и ваша задача - подсчитать количество скуки. Скука - это предложение, которое начинается со слова \"Я\". Предложения разделяются '.' , '?' или '!'.\n\n    Например:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Вам будет дана строка слов, и ваша задача - подсчитать количество скуки. Скука - это предложение, которое начинается со слова \"Я\". Предложения разделяются '.' , '?' или '!'.\n\n    Например:\n    ", "natural_language": "Russian"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"У вас есть список целых чисел.\n    Вам нужно найти наибольшее простое значение и вернуть сумму его цифр.\n\n        Примеры:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "У вас есть список целых чисел.\n    Вам нужно найти наибольшее простое значение и вернуть сумму его цифр.\n\n        Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Дан словарь, вернуть True, если все ключи являются строками в нижнем регистре или все ключи являются строками в верхнем регистре, в противном случае вернуть False. Функция должна возвращать False, если данный словарь пуст. Примеры:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Дан словарь, вернуть True, если все ключи являются строками в нижнем регистре или все ключи являются строками в верхнем регистре, в противном случае вернуть False. Функция должна возвращать False, если данный словарь пуст. Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Создайте функцию, которая принимает значение (строку), представляющую число, и возвращает ближайшее целое число к нему. Если число находится на равном расстоянии от двух целых чисел, округлите его в сторону от нуля.\n\n    Примеры:\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Создайте функцию, которая принимает значение (строку), представляющую число, и возвращает ближайшее целое число к нему. Если число находится на равном расстоянии от двух целых чисел, округлите его в сторону от нуля.\n\n    Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Дано положительное целое число n, вы должны сделать кучу из n уровней камней.\n    Первый уровень имеет n камней.\n    Количество камней в следующем уровне равно:\n        - следующее нечетное число, если n нечетное.\n        - следующее четное число, если n четное.\n    Вернуть количество камней в каждом уровне в виде списка, где элемент с индексом\n    i представляет количество камней в уровне (i+1).\n\n        Примеры:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Дано положительное целое число n, вы должны сделать кучу из n уровней камней.\n    Первый уровень имеет n камней.\n    Количество камней в следующем уровне равно:\n        - следующее нечетное число, если n нечетное.\n        - следующее четное число, если n четное.\n    Вернуть количество камней в каждом уровне в виде списка, где элемент с индексом\n    i представляет количество камней в уровне (i+1).\n\n        Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Вам будет дана строка слов, разделенных запятыми или пробелами. Ваша задача - разбить строку на слова и вернуть массив слов.\n\n    Например:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Вам будет дана строка слов, разделенных запятыми или пробелами. Ваша задача - разбить строку на слова и вернуть массив слов.\n\n    Например:\n    ", "natural_language": "Russian"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Эта функция принимает два положительных числа x и y и возвращает наибольшее четное целое число, которое находится в диапазоне [x, y], включительно. Если такого числа нет, то функция должна вернуть -1.\n\n    Например:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Эта функция принимает два положительных числа x и y и возвращает наибольшее четное целое число, которое находится в диапазоне [x, y], включительно. Если такого числа нет, то функция должна вернуть -1.\n\n    Например:\n    ", "natural_language": "Russian"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Даны два положительных целых числа n и m, и ваша задача - вычислить среднее значение целых чисел от n до m (включая n и m).\n    Округлите ответ до ближайшего целого и преобразуйте его в двоичное число.\n    Если n больше, чем m, верните -1.\n    Пример:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Даны два положительных целых числа n и m, и ваша задача - вычислить среднее значение целых чисел от n до m (включая n и m).\n    Округлите ответ до ближайшего целого и преобразуйте его в двоичное число.\n    Если n больше, чем m, верните -1.\n    Пример:\n    ", "natural_language": "Russian"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Реализуйте функцию f, которая принимает n в качестве параметра и возвращает список размера n, такой, что значение элемента с индексом i является факториалом i, если i четное, или суммой чисел от 1 до i в противном случае. i начинается с 1. Факториал i - это умножение чисел от 1 до i (1 * 2 * ... * i). Пример:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Реализуйте функцию f, которая принимает n в качестве параметра и возвращает список размера n, такой, что значение элемента с индексом i является факториалом i, если i четное, или суммой чисел от 1 до i в противном случае. i начинается с 1. Факториал i - это умножение чисел от 1 до i (1 * 2 * ... * i). Пример:\n    ", "natural_language": "Russian"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Дано положительное целое число n, вернуть кортеж, который содержит количество четных и нечетных целых палиндромов, которые попадают в диапазон (1, n), включительно.\n\n        Пример 1:\n\n            Ввод: 3\n        Вывод: (1, 2)\n        Объяснение:\n        Целые палиндромы - 1, 2, 3. Один из них четный, а два нечетных.\n\n        Пример 2:\n\n            Ввод: 12\n        Вывод: (4, 6)\n        Объяснение:\n        Целые палиндромы - 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Четыре из них четные, а шесть нечетные.\n\n        Примечание:\n        1. 1 <= n <= 10^3\n        2. Возвращаемый кортеж содержит количество четных и нечетных целых палиндромов соответственно.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Дано положительное целое число n, вернуть кортеж, который содержит количество четных и нечетных целых палиндромов, которые попадают в диапазон (1, n), включительно.\n\n        Пример 1:\n\n            Ввод: 3\n        Вывод: (1, 2)\n        Объяснение:\n        Целые палиндромы - 1, 2, 3. Один из них четный, а два нечетных.\n\n        Пример 2:\n\n            Ввод: 12\n        Вывод: (4, 6)\n        Объяснение:\n        Целые палиндромы - 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Четыре из них четные, а шесть нечетные.\n\n        Примечание:\n        1. 1 <= n <= 10^3\n        2. Возвращаемый кортеж содержит количество четных и нечетных целых палиндромов соответственно.\n    ", "natural_language": "Russian"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"У нас есть массив 'arr' из N целых чисел arr[1], arr[2], ..., arr[N]. Числа в массиве будут случайно упорядочены. Ваша задача - определить, можно ли получить массив, упорядоченный в неубывающем порядке, выполнив следующую операцию над данным массивом:\n        Вы можете выполнять операцию сдвига вправо любое количество раз.\n    \n    Одна операция сдвига вправо означает сдвиг всех элементов массива на одну позицию вправо. Последний элемент массива будет перемещен на начальную позицию в массиве, т.е. на 0-й индекс. \n\n        Если возможно получить упорядоченный массив, выполнив вышеуказанную операцию, то верните True, иначе верните False.\n    Если данный массив пуст, верните True.\n\n        Примечание: данный список гарантированно имеет уникальные элементы.\n\n        Например:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Объяснение: выполнив 2 операции сдвига вправо, можно достичь неубывающего порядка для данного массива.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Объяснение: невозможно получить неубывающий порядок для данного массива, выполнив любое количество операций сдвига вправо.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "У нас есть массив 'arr' из N целых чисел arr[1], arr[2], ..., arr[N]. Числа в массиве будут случайно упорядочены. Ваша задача - определить, можно ли получить массив, упорядоченный в неубывающем порядке, выполнив следующую операцию над данным массивом:\n        Вы можете выполнять операцию сдвига вправо любое количество раз.\n    \n    Одна операция сдвига вправо означает сдвиг всех элементов массива на одну позицию вправо. Последний элемент массива будет перемещен на начальную позицию в массиве, т.е. на 0-й индекс. \n\n        Если возможно получить упорядоченный массив, выполнив вышеуказанную операцию, то верните True, иначе верните False.\n    Если данный массив пуст, верните True.\n\n        Примечание: данный список гарантированно имеет уникальные элементы.\n\n        Например:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Объяснение: выполнив 2 операции сдвига вправо, можно достичь неубывающего порядка для данного массива.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Объяснение: невозможно получить неубывающий порядок для данного массива, выполнив любое количество операций сдвига вправо.\n    ", "natural_language": "Russian"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"В этой задаче вы реализуете функцию, которая принимает два списка чисел и определяет, возможно ли выполнить обмен элементами между ними, чтобы lst1 стал списком только четных чисел. Нет ограничений на количество обменяемых элементов между lst1 и lst2. Если возможно обменять элементы между lst1 и lst2, чтобы все элементы lst1 были четными, верните \"YES\". В противном случае верните \"NO\". Например: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Предполагается, что входные списки будут непустыми.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "В этой задаче вы реализуете функцию, которая принимает два списка чисел и определяет, возможно ли выполнить обмен элементами между ними, чтобы lst1 стал списком только четных чисел. Нет ограничений на количество обменяемых элементов между lst1 и lst2. Если возможно обменять элементы между lst1 и lst2, чтобы все элементы lst1 были четными, верните \"YES\". В противном случае верните \"NO\". Например: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Предполагается, что входные списки будут непустыми.\n    ", "natural_language": "Russian"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Задача\n    Даны две строки s и c, необходимо удалить все символы в s, которые равны любому символу в c,\n    затем проверить, является ли полученная строка палиндромом.\n    Строка называется палиндромом, если она читается одинаково как слева направо, так и справа налево.\n    Вы должны вернуть кортеж, содержащий полученную строку и True/False для проверки.\n    Пример\n    Для s = \"abcde\", c = \"ae\", результат должен быть ('bcd',False)\n    Для s = \"abcdef\", c = \"b\" результат должен быть ('acdef',False)\n    Для s = \"abcdedcba\", c = \"ab\", результат должен быть ('cdedc',True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Задача\n    Даны две строки s и c, необходимо удалить все символы в s, которые равны любому символу в c,\n    затем проверить, является ли полученная строка палиндромом.\n    Строка называется палиндромом, если она читается одинаково как слева направо, так и справа налево.\n    Вы должны вернуть кортеж, содержащий полученную строку и True/False для проверки.\n    Пример\n    Для s = \"abcde\", c = \"ae\", результат должен быть ('bcd',False)\n    Для s = \"abcdef\", c = \"b\" результат должен быть ('acdef',False)\n    Для s = \"abcdedcba\", c = \"ab\", результат должен быть ('cdedc',True)\n    ", "natural_language": "Russian"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Вам дан прямоугольная сетка скважин. Каждая строка представляет собой одну скважину, а каждая единица в строке представляет собой одну единицу воды. У каждой скважины есть соответствующий ведро, которое можно использовать для извлечения воды из нее, и все ведра имеют одинаковую вместимость. Ваша задача - использовать ведра, чтобы опустошить скважины. Выведите количество раз, которое вам нужно опустить ведра.\n\n    Пример 1:\n    Ввод:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        bucket_capacity: 1\n    Вывод: 6\n\n    Пример 2:\n    Ввод:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        bucket_capacity: 2\n    Вывод: 5\n\n    Пример 3:\n    Ввод:\n        grid: [[0,0,0], [0,0,0]]\n        bucket_capacity: 5\n    Вывод: 0\n\n    Ограничения:\n    * все скважины имеют одинаковую длину\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid[:,1].length <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= capacity <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Вам дан прямоугольная сетка скважин. Каждая строка представляет собой одну скважину, а каждая единица в строке представляет собой одну единицу воды. У каждой скважины есть соответствующий ведро, которое можно использовать для извлечения воды из нее, и все ведра имеют одинаковую вместимость. Ваша задача - использовать ведра, чтобы опустошить скважины. Выведите количество раз, которое вам нужно опустить ведра.\n\n    Пример 1:\n    Ввод:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        bucket_capacity: 1\n    Вывод: 6\n\n    Пример 2:\n    Ввод:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        bucket_capacity: 2\n    Вывод: 5\n\n    Пример 3:\n    Ввод:\n        grid: [[0,0,0], [0,0,0]]\n        bucket_capacity: 5\n    Вывод: 0\n\n    Ограничения:\n    * все скважины имеют одинаковую длину\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid[:,1].length <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= capacity <= 10\n    ", "natural_language": "Russian"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Дана строка s и натуральное число n. Вам поручено реализовать функцию, которая возвращает список всех слов из строки s, содержащих ровно n согласных букв, в порядке, в котором эти слова появляются в строке s. Если строка s пуста, то функция должна вернуть пустой список. Примечание: вы можете предположить, что входная строка содержит только буквы и пробелы. Примеры:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Дана строка s и натуральное число n. Вам поручено реализовать функцию, которая возвращает список всех слов из строки s, содержащих ровно n согласных букв, в порядке, в котором эти слова появляются в строке s. Если строка s пуста, то функция должна вернуть пустой список. Примечание: вы можете предположить, что входная строка содержит только буквы и пробелы. Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Дан массив arr целых чисел и положительное целое число k, вернуть отсортированный список длиной k с максимальными k числами в arr.\n\n        Пример 1:\n\n            Ввод: arr = [-3, -4, 5], k = 3\n        Вывод: [-4, -3, 5]\n\n        Пример 2:\n\n            Ввод: arr = [4, -4, 4], k = 2\n        Вывод: [4, 4]\n\n        Пример 3:\n\n            Ввод: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Вывод: [2]\n\n        Примечание:\n        1. Длина массива будет в диапазоне [1, 1000].\n        2. Элементы в массиве будут в диапазоне [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Дан массив arr целых чисел и положительное целое число k, вернуть отсортированный список длиной k с максимальными k числами в arr.\n\n        Пример 1:\n\n            Ввод: arr = [-3, -4, 5], k = 3\n        Вывод: [-4, -3, 5]\n\n        Пример 2:\n\n            Ввод: arr = [4, -4, 4], k = 2\n        Вывод: [4, 4]\n\n        Пример 3:\n\n            Ввод: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Вывод: [2]\n\n        Примечание:\n        1. Длина массива будет в диапазоне [1, 1000].\n        2. Элементы в массиве будут в диапазоне [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    ", "natural_language": "Russian"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Дан непустой массив целых чисел arr и целое число k. Вернуть сумму элементов с не более чем двумя цифрами из первых k элементов arr.\n\n        Пример:\n\n            Ввод: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Вывод: 24 # сумма 21 + 3\n\n        Ограничения:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Дан непустой массив целых чисел arr и целое число k. Вернуть сумму элементов с не более чем двумя цифрами из первых k элементов arr.\n\n        Пример:\n\n            Ввод: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Вывод: 24 # сумма 21 + 3\n\n        Ограничения:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    ", "natural_language": "Russian"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Даны два интервала, каждый из которых представляет собой пару целых чисел. Например, интервал = (начало, конец) = (1, 2). Данные интервалы являются замкнутыми, что означает, что интервал (начало, конец) включает в себя и начало, и конец. Для каждого данного интервала предполагается, что его начало меньше или равно его концу. Ваша задача - определить, является ли длина пересечения этих двух интервалов простым числом. Например, пересечение интервалов (1, 3), (2, 4) равно (2, 3), длина которого равна 1, что не является простым числом. Если длина пересечения является простым числом, вернуть \"YES\", в противном случае вернуть \"NO\". Если два интервала не пересекаются, вернуть \"NO\".\n\n    [ввод/вывод] примеры:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Даны два интервала, каждый из которых представляет собой пару целых чисел. Например, интервал = (начало, конец) = (1, 2). Данные интервалы являются замкнутыми, что означает, что интервал (начало, конец) включает в себя и начало, и конец. Для каждого данного интервала предполагается, что его начало меньше или равно его концу. Ваша задача - определить, является ли длина пересечения этих двух интервалов простым числом. Например, пересечение интервалов (1, 3), (2, 4) равно (2, 3), длина которого равна 1, что не является простым числом. Если длина пересечения является простым числом, вернуть \"YES\", в противном случае вернуть \"NO\". Если два интервала не пересекаются, вернуть \"NO\".\n\n    [ввод/вывод] примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Каждый знает последовательность Фибоначчи, которая была глубоко изучена математиками в последние пару столетий. Однако то, чего люди не знают, это последовательность Трибоначчи. Последовательность Трибоначчи определяется рекуррентностью:\ntri(1) = 3\ntri(n) = 1 + n / 2, если n четное.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), если n нечетное.\nНапример:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nВам дано неотрицательное целое число n, вы должны вернуть список первых n + 1 чисел последовательности Трибоначчи.\nПримеры:\ntri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Каждый знает последовательность Фибоначчи, которая была глубоко изучена математиками в последние пару столетий. Однако то, чего люди не знают, это последовательность Трибоначчи. Последовательность Трибоначчи определяется рекуррентностью:\ntri(1) = 3\ntri(n) = 1 + n / 2, если n четное.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), если n нечетное.\nНапример:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nВам дано неотрицательное целое число n, вы должны вернуть список первых n + 1 чисел последовательности Трибоначчи.\nПримеры:\ntri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Russian"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Дано положительное целое число n, вернуть произведение нечетных цифр.\n    Вернуть 0, если все цифры четные.\n    Например:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Дано положительное целое число n, вернуть произведение нечетных цифр.\n    Вернуть 0, если все цифры четные.\n    Например:\n    ", "natural_language": "Russian"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Создайте функцию, которая принимает строку в качестве входных данных, содержащую только квадратные скобки. Функция должна возвращать True только в том случае, если существует допустимая подпоследовательность скобок, где хотя бы одна скобка вложена.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Создайте функцию, которая принимает строку в качестве входных данных, содержащую только квадратные скобки. Функция должна возвращать True только в том случае, если существует допустимая подпоследовательность скобок, где хотя бы одна скобка вложена.\n    ", "natural_language": "Russian"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Вам дан список чисел.\nВам нужно вернуть сумму квадратов чисел в данном списке,\nокруглить каждый элемент в списке до ближайшего целого числа (в большую сторону).\nПримеры:\nДля lst = [1,2,3] вывод должен быть 14\nДля lst = [1,4,9] вывод должен быть 98\nДля lst = [1,3,5,7] вывод должен быть 84\nДля lst = [1.4,4.2,0] вывод должен быть 29\nДля lst = [-2.4,1,1] вывод должен быть 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Вам дан список чисел.\nВам нужно вернуть сумму квадратов чисел в данном списке,\nокруглить каждый элемент в списке до ближайшего целого числа (в большую сторону).\nПримеры:\nДля lst = [1,2,3] вывод должен быть 14\nДля lst = [1,4,9] вывод должен быть 98\nДля lst = [1,3,5,7] вывод должен быть 84\nДля lst = [1.4,4.2,0] вывод должен быть 29\nДля lst = [-2.4,1,1] вывод должен быть 6\n    ", "natural_language": "Russian"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Создайте функцию, которая возвращает True, если последний символ заданной строки является буквенным символом и не является частью слова, и False в противном случае. Примечание: \"слово\" - это группа символов, разделенных пробелом.\n\n    Примеры:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Создайте функцию, которая возвращает True, если последний символ заданной строки является буквенным символом и не является частью слова, и False в противном случае. Примечание: \"слово\" - это группа символов, разделенных пробелом.\n\n    Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Создайте функцию, которая возвращает наибольший индекс элемента, который не больше или равен элементу, непосредственно предшествующему ему. Если такого элемента не существует, верните -1. Данный массив не будет содержать повторяющихся значений.\n\n    Примеры:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Создайте функцию, которая возвращает наибольший индекс элемента, который не больше или равен элементу, непосредственно предшествующему ему. Если такого элемента не существует, верните -1. Данный массив не будет содержать повторяющихся значений.\n\n    Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Создайте функцию, которая возвращает кортеж (a, b), где 'a' - наибольшее из отрицательных целых чисел, а 'b' - наименьшее из положительных целых чисел в списке. Если нет отрицательных или положительных целых чисел, верните их как None.\n\n    Примеры:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Создайте функцию, которая возвращает кортеж (a, b), где 'a' - наибольшее из отрицательных целых чисел, а 'b' - наименьшее из положительных целых чисел в списке. Если нет отрицательных или положительных целых чисел, верните их как None.\n\n    Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"Факториал Бразилии определяется как:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    где n > 0\n\n        Например:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "Факториал Бразилии определяется как:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    где n > 0\n\n        Например:\n    ", "natural_language": "Russian"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Вам дана строка, представляющая предложение,\n    предложение содержит некоторые слова, разделенные пробелом,\n    и вы должны вернуть строку, которая содержит слова из исходного предложения,\n    длины которых являются простыми числами,\n    порядок слов в новой строке должен быть таким же, как в исходной.\n\n        Пример 1:\n        Ввод: sentence = \"This is a test\"\n        Вывод: \"is\"\n\n        Пример 2:\n        Ввод: sentence = \"lets go for swimming\"\n        Вывод: \"go for\"\n\n        Ограничения:\n        * 1 <= len(sentence) <= 100\n        * предложение содержит только буквы\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Вам дана строка, представляющая предложение,\n    предложение содержит некоторые слова, разделенные пробелом,\n    и вы должны вернуть строку, которая содержит слова из исходного предложения,\n    длины которых являются простыми числами,\n    порядок слов в новой строке должен быть таким же, как в исходной.\n\n        Пример 1:\n        Ввод: sentence = \"This is a test\"\n        Вывод: \"is\"\n\n        Пример 2:\n        Ввод: sentence = \"lets go for swimming\"\n        Вывод: \"go for\"\n\n        Ограничения:\n        * 1 <= len(sentence) <= 100\n        * предложение содержит только буквы\n    ", "natural_language": "Russian"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Ваша задача - реализовать функцию, которая упростит выражение x * n. Функция возвращает True, если x * n вычисляется как целое число, и False в противном случае. Оба x и n являются строковым представлением дроби и имеют следующий формат, <числитель>/<знаменатель>, где и числитель, и знаменатель являются положительными целыми числами.\n\n    Вы можете предположить, что x и n являются допустимыми дробями и не имеют нуля в знаменателе.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Ваша задача - реализовать функцию, которая упростит выражение x * n. Функция возвращает True, если x * n вычисляется как целое число, и False в противном случае. Оба x и n являются строковым представлением дроби и имеют следующий формат, <числитель>/<знаменатель>, где и числитель, и знаменатель являются положительными целыми числами.\n\n    Вы можете предположить, что x и n являются допустимыми дробями и не имеют нуля в знаменателе.\n    ", "natural_language": "Russian"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Напишите функцию, которая сортирует заданный список целых чисел в порядке возрастания суммы их цифр. Обратите внимание: если есть несколько элементов с похожей суммой цифр, упорядочьте их на основе их индекса в исходном списке.\n\n    Например:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Напишите функцию, которая сортирует заданный список целых чисел в порядке возрастания суммы их цифр. Обратите внимание: если есть несколько элементов с похожей суммой цифр, упорядочьте их на основе их индекса в исходном списке.\n\n    Например:\n    ", "natural_language": "Russian"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Напишите функцию, которая принимает массив чисел в качестве входных данных и возвращает количество элементов в массиве, которые больше 10 и у которых первая и последняя цифры числа нечетные (1, 3, 5, 7, 9). Например:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Напишите функцию, которая принимает массив чисел в качестве входных данных и возвращает количество элементов в массиве, которые больше 10 и у которых первая и последняя цифры числа нечетные (1, 3, 5, 7, 9). Например:\n    ", "natural_language": "Russian"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Дано положительное целое число n. Вам нужно создать целочисленный массив a длиной n.\n        Для каждого i (1 ≤ i ≤ n) значение a[i] = i * i - i + 1.\n        Вернуть количество троек (a[i], a[j], a[k]) из a, где i < j < k, \n    и a[i] + a[j] + a[k] является кратным 3.\n\n        Пример :\n        Ввод: n = 5\n        Вывод: 1\n        Объяснение: \n        a = [1, 3, 7, 13, 21]\n        Единственная допустимая тройка - (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Дано положительное целое число n. Вам нужно создать целочисленный массив a длиной n.\n        Для каждого i (1 ≤ i ≤ n) значение a[i] = i * i - i + 1.\n        Вернуть количество троек (a[i], a[j], a[k]) из a, где i < j < k, \n    и a[i] + a[j] + a[k] является кратным 3.\n\n        Пример :\n        Ввод: n = 5\n        Вывод: 1\n        Объяснение: \n        a = [1, 3, 7, 13, 21]\n        Единственная допустимая тройка - (1, 7, 13).\n    ", "natural_language": "Russian"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    В нашей солнечной системе восемь планет: ближайшая к Солнцу - Меркурий, следующая - Венера, затем Земля, Марс, Юпитер, Сатурн, Уран и Нептун. Напишите функцию, которая принимает два названия планет в виде строк planet1 и planet2. Функция должна возвращать кортеж, содержащий все планеты, орбиты которых находятся между орбитами planet1 и planet2, отсортированные по близости к Солнцу. Функция должна возвращать пустой кортеж, если planet1 или planet2 не являются правильными названиями планет. Примеры:\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "В нашей солнечной системе восемь планет: ближайшая к Солнцу - Меркурий, следующая - Венера, затем Земля, Марс, Юпитер, Сатурн, Уран и Нептун. Напишите функцию, которая принимает два названия планет в виде строк planet1 и planet2. Функция должна возвращать кортеж, содержащий все планеты, орбиты которых находятся между орбитами planet1 и planet2, отсортированные по близости к Солнцу. Функция должна возвращать пустой кортеж, если planet1 или planet2 не являются правильными названиями планет. Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Простая программа, которая должна возвращать значение x, если n - простое число, и должна возвращать значение y в противном случае.\n\n    Примеры:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Простая программа, которая должна возвращать значение x, если n - простое число, и должна возвращать значение y в противном случае.\n\n    Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Дан список чисел, вернуть сумму квадратов чисел в списке, которые нечетные. Игнорировать числа, которые отрицательные или не являются целыми числами.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0\n\n    Если входной список пуст, вернуть 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Дан список чисел, вернуть сумму квадратов чисел в списке, которые нечетные. Игнорировать числа, которые отрицательные или не являются целыми числами.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0\n\n    Если входной список пуст, вернуть 0.\n    ", "natural_language": "Russian"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Вам будет дано имя класса (строка) и список расширений. Расширения должны использоваться для загрузки дополнительных классов в класс. Сила расширения определяется следующим образом: пусть CAP - это количество заглавных букв в имени расширения, а SM - количество строчных букв в имени расширения, сила определяется дробью CAP - SM. Вы должны найти самое сильное расширение и вернуть строку в следующем формате: ClassName.StrongestExtensionName. Если есть два или более расширения с одинаковой силой, вы должны выбрать то, которое идет первым в списке. Например, если вам дан класс \"Slices\" и список расширений: ['SErviNGSliCes', 'Cheese', 'StuFfed'], то вы должны вернуть 'Slices.SErviNGSliCes', так как 'SErviNGSliCes' является самым сильным расширением (его сила равна -1). Пример:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Вам будет дано имя класса (строка) и список расширений. Расширения должны использоваться для загрузки дополнительных классов в класс. Сила расширения определяется следующим образом: пусть CAP - это количество заглавных букв в имени расширения, а SM - количество строчных букв в имени расширения, сила определяется дробью CAP - SM. Вы должны найти самое сильное расширение и вернуть строку в следующем формате: ClassName.StrongestExtensionName. Если есть два или более расширения с одинаковой силой, вы должны выбрать то, которое идет первым в списке. Например, если вам дан класс \"Slices\" и список расширений: ['SErviNGSliCes', 'Cheese', 'StuFfed'], то вы должны вернуть 'Slices.SErviNGSliCes', так как 'SErviNGSliCes' является самым сильным расширением (его сила равна -1). Пример:\n    ", "natural_language": "Russian"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Вам даны 2 слова. Вам нужно вернуть True, если второе слово или любая из его перестановок является подстрокой в первом слове.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Вам даны 2 слова. Вам нужно вернуть True, если второе слово или любая из его перестановок является подстрокой в первом слове.\n    ", "natural_language": "Russian"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Для заданного положительного целого числа получить его эквивалент в римских цифрах в виде строки и вернуть его в нижнем регистре.\nОграничения: 1 <= num <= 1000\n\n    Примеры:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Для заданного положительного целого числа получить его эквивалент в римских цифрах в виде строки и вернуть его в нижнем регистре.\nОграничения: 1 <= num <= 1000\n\n    Примеры:\n    ", "natural_language": "Russian"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Даны длины трех сторон треугольника. Вернуть True, если эти три стороны образуют прямоугольный треугольник, и False в противном случае. Прямоугольный треугольник - это треугольник, в котором один угол является прямым или равен 90 градусам. Пример:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Даны длины трех сторон треугольника. Вернуть True, если эти три стороны образуют прямоугольный треугольник, и False в противном случае. Прямоугольный треугольник - это треугольник, в котором один угол является прямым или равен 90 градусам. Пример:\n    ", "natural_language": "Russian"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Вам дана строка s.\n    Если s[i] - это буква, измените ее регистр с нижнего на верхний или наоборот,\n    в противном случае оставьте ее без изменений.\n    Если строка не содержит букв, переверните ее.\n    Функция должна вернуть полученную строку.\n    Примеры\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Вам дана строка s.\n    Если s[i] - это буква, измените ее регистр с нижнего на верхний или наоборот,\n    в противном случае оставьте ее без изменений.\n    Если строка не содержит букв, переверните ее.\n    Функция должна вернуть полученную строку.\n    Примеры\n    ", "natural_language": "Russian"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Дана строка 'text', вернуть ее эквивалентную строку хэша md5.\n    Если 'text' является пустой строкой, вернуть null.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Дана строка 'text', вернуть ее эквивалентную строку хэша md5.\n    Если 'text' является пустой строкой, вернуть null.\n    ", "natural_language": "Russian"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Даны два положительных целых числа a и b. Вернуть четные цифры между a и b в порядке возрастания.\n\n    Например:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Даны два положительных целых числа a и b. Вернуть четные цифры между a и b в порядке возрастания.\n\n    Например:\n    ", "natural_language": "Russian"}
