{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Anda diberikan daftar operasi deposit dan penarikan pada rekening bank yang dimulai dengan saldo nol. Tugas Anda adalah untuk mendeteksi apakah pada suatu titik saldo rekening jatuh di bawah nol, dan pada titik itu fungsi harus mengembalikan True. Jika tidak, harus mengembalikan False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Anda diberikan daftar operasi deposit dan penarikan pada rekening bank yang dimulai dengan saldo nol. Tugas Anda adalah untuk mendeteksi apakah pada suatu titik saldo rekening jatuh di bawah nol, dan pada titik itu fungsi harus mengembalikan True. Jika tidak, harus mengembalikan False.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Untuk daftar bilangan bulat yang diberikan, kembalikan tuple yang terdiri dari jumlah dan hasil kali semua bilangan dalam daftar.\n    Jumlah kosong harus sama dengan 0 dan hasil kali kosong harus sama dengan 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Untuk daftar bilangan bulat yang diberikan, kembalikan tuple yang terdiri dari jumlah dan hasil kali semua bilangan dalam daftar.\n    Jumlah kosong harus sama dengan 0 dan hasil kali kosong harus sama dengan 1.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input adalah dua string a dan b yang hanya terdiri dari angka 1 dan 0.\n    Lakukan operasi XOR biner pada kedua input tersebut dan kembalikan hasilnya juga sebagai string.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "Input adalah dua string a dan b yang hanya terdiri dari angka 1 dan 0.\n    Lakukan operasi XOR biner pada kedua input tersebut dan kembalikan hasilnya juga sebagai string.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Dari daftar string, kembalikan yang terpanjang. Kembalikan yang pertama jika terdapat beberapa string dengan panjang yang sama. Kembalikan null jika daftar input kosong.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "Dari daftar string, kembalikan yang terpanjang. Kembalikan yang pertama jika terdapat beberapa string dengan panjang yang sama. Kembalikan null jika daftar input kosong.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Kembalikan nilai dari pembagi terbesar antara dua bilangan bulat a dan b.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Kembalikan nilai dari pembagi terbesar antara dua bilangan bulat a dan b.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input adalah string yang dipisahkan oleh spasi dari angka 'nol' hingga 'sembilan'.\nPilihan yang valid adalah 'nol', 'satu', 'dua', 'tiga', 'empat', 'lima', 'enam', 'tujuh', 'delapan', dan 'sembilan'.\nKembalikan string dengan angka yang diurutkan dari yang terkecil hingga yang terbesar.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "Input adalah string yang dipisahkan oleh spasi dari angka 'nol' hingga 'sembilan'.\nPilihan yang valid adalah 'nol', 'satu', 'dua', 'tiga', 'empat', 'lima', 'enam', 'tujuh', 'delapan', dan 'sembilan'.\nKembalikan string dengan angka yang diurutkan dari yang terkecil hingga yang terbesar.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Diberikan daftar angka (setidaknya dua elemen), terapkan transformasi linear pada daftar tersebut,\n    sehingga angka terkecil akan menjadi 0 dan yang terbesar akan menjadi 1.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Diberikan daftar angka (setidaknya dua elemen), terapkan transformasi linear pada daftar tersebut,\n    sehingga angka terkecil akan menjadi 0 dan yang terbesar akan menjadi 1.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Untuk sebuah string yang diberikan, ubah karakter huruf kecil menjadi huruf besar dan huruf besar menjadi huruf kecil.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Untuk sebuah string yang diberikan, ubah karakter huruf kecil menjadi huruf besar dan huruf besar menjadi huruf kecil.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Kembalikan hanya angka positif dalam daftar.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Kembalikan hanya angka positif dalam daftar.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Kembalikan nilai benar jika suatu bilangan diberikan adalah bilangan prima, dan kembalikan nilai salah jika tidak.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Kembalikan nilai benar jika suatu bilangan diberikan adalah bilangan prima, dan kembalikan nilai salah jika tidak.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Kembalikan elemen-elemen unik yang telah diurutkan dalam sebuah daftar.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Kembalikan elemen-elemen unik yang telah diurutkan dalam sebuah daftar.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib mengembalikan bilangan ke-n yang merupakan bilangan Fibonacci dan juga bilangan prima.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib mengembalikan bilangan ke-n yang merupakan bilangan Fibonacci dan juga bilangan prima.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero mengambil daftar bilangan bulat sebagai masukan.\n    ia mengembalikan True jika ada tiga elemen yang berbeda dalam daftar yang\n    jumlahnya nol, dan False sebaliknya.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "triples_sum_to_zero mengambil daftar bilangan bulat sebagai masukan.\n    ia mengembalikan True jika ada tiga elemen yang berbeda dalam daftar yang\n    jumlahnya nol, dan False sebaliknya.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero mengambil daftar bilangan bulat sebagai masukan.\n    itu mengembalikan True jika ada dua elemen yang berbeda dalam daftar yang\n    jumlahnya nol, dan False sebaliknya.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "pairs_sum_to_zero mengambil daftar bilangan bulat sebagai masukan.\n    itu mengembalikan True jika ada dua elemen yang berbeda dalam daftar yang\n    jumlahnya nol, dan False sebaliknya.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Sekuens nomor Fib4 adalah sekuen yang mirip dengan sekuen Fibonacci yang didefinisikan sebagai berikut:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Silakan tulis sebuah fungsi untuk menghitung elemen ke-n dari sekuen nomor Fib4 dengan efisien. Jangan gunakan rekursi.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "Sekuens nomor Fib4 adalah sekuen yang mirip dengan sekuen Fibonacci yang didefinisikan sebagai berikut:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Silakan tulis sebuah fungsi untuk menghitung elemen ke-n dari sekuen nomor Fib4 dengan efisien. Jangan gunakan rekursi.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Kembalikan median dari elemen-elemen dalam daftar l.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Kembalikan median dari elemen-elemen dalam daftar l.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Memeriksa apakah string yang diberikan adalah palindrom\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Memeriksa apakah string yang diberikan adalah palindrom\n    ", "natural_language": "Indonesian"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels adalah sebuah fungsi yang mengambil string dan mengembalikan string tanpa huruf vokal.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels adalah sebuah fungsi yang mengambil string dan mengembalikan string tanpa huruf vokal.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Kembalikan True jika semua angka dalam daftar l berada di bawah ambang batas t.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Kembalikan True jika semua angka dalam daftar l berada di bawah ambang batas t.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Tambahkan dua bilangan x dan y\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Tambahkan dua bilangan x dan y\n    ", "natural_language": "Indonesian"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Periksa apakah dua kata memiliki karakter yang sama.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Periksa apakah dua kata memiliki karakter yang sama.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Kembalikan bilangan Fibonacci ke-n.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Kembalikan bilangan Fibonacci ke-n.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Kembalikan elemen-elemen umum yang unik yang telah diurutkan untuk dua daftar.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Kembalikan elemen-elemen umum yang unik yang telah diurutkan untuk dua daftar.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Kembalikan faktor prima terbesar dari n. Anggap n > 1 dan bukan bilangan prima.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Kembalikan faktor prima terbesar dari n. Anggap n > 1 dan bukan bilangan prima.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n adalah sebuah fungsi yang menjumlahkan angka dari 1 hingga n.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n adalah sebuah fungsi yang menjumlahkan angka dari 1 hingga n.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs mewakili koefisien dari sebuah polinomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Kembalikan turunan dari polinomial ini dalam bentuk yang sama.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs mewakili koefisien dari sebuah polinomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Kembalikan turunan dari polinomial ini dalam bentuk yang sama.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"Sekuens nomor FibFib adalah sekuen yang mirip dengan sekuen Fibonacci yang didefinisikan sebagai berikut:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Silakan tulis fungsi untuk menghitung elemen ke-n dari sekuen nomor FibFib secara efisien.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "Sekuens nomor FibFib adalah sekuen yang mirip dengan sekuen Fibonacci yang didefinisikan sebagai berikut:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Silakan tulis fungsi untuk menghitung elemen ke-n dari sekuen nomor FibFib secara efisien.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Tulis sebuah fungsi vowels_count yang mengambil sebuah string yang mewakili sebuah kata sebagai input dan mengembalikan jumlah huruf vokal dalam string tersebut. Vokal dalam hal ini adalah 'a', 'e', 'i', 'o', 'u'. Di sini, 'y' juga merupakan vokal, tetapi hanya jika berada di akhir kata yang diberikan.\n\n    Contoh:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Tulis sebuah fungsi vowels_count yang mengambil sebuah string yang mewakili sebuah kata sebagai input dan mengembalikan jumlah huruf vokal dalam string tersebut. Vokal dalam hal ini adalah 'a', 'e', 'i', 'o', 'u'. Di sini, 'y' juga merupakan vokal, tetapi hanya jika berada di akhir kata yang diberikan.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Anda diberikan sebuah daftar bilangan bulat positif yang tidak kosong. Kembalikan bilangan bulat terbesar yang lebih besar dari nol, dan memiliki frekuensi yang lebih besar atau sama dengan nilai bilangan itu sendiri. Frekuensi sebuah bilangan adalah jumlah kali bilangan tersebut muncul dalam daftar. Jika tidak ada nilai seperti itu, kembalikan -1. Contoh:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Anda diberikan sebuah daftar bilangan bulat positif yang tidak kosong. Kembalikan bilangan bulat terbesar yang lebih besar dari nol, dan memiliki frekuensi yang lebih besar atau sama dengan nilai bilangan itu sendiri. Frekuensi sebuah bilangan adalah jumlah kali bilangan tersebut muncul dalam daftar. Jika tidak ada nilai seperti itu, kembalikan -1. Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Diberikan panjang dari tiga sisi segitiga. Kembalikan luas segitiga dibulatkan menjadi 2 angka desimal jika ketiga sisi membentuk segitiga yang valid. Jika tidak, kembalikan -1. Tiga sisi membentuk segitiga yang valid ketika jumlah dari dua sisi lebih besar dari sisi ketiga. Contoh:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Diberikan panjang dari tiga sisi segitiga. Kembalikan luas segitiga dibulatkan menjadi 2 angka desimal jika ketiga sisi membentuk segitiga yang valid. Jika tidak, kembalikan -1. Tiga sisi membentuk segitiga yang valid ketika jumlah dari dua sisi lebih besar dari sisi ketiga. Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Buatlah sebuah fungsi yang mengembalikan nilai True jika objek q akan terbang, dan False jika tidak.\n    Objek q akan terbang jika seimbang (merupakan daftar palindrom) dan jumlah elemennya kurang dari atau sama dengan berat maksimum yang mungkin w.\n\n        Contoh:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 kurang dari berat maksimum yang mungkin, tetapi tidak seimbang.\n\n        will_it_fly([3, 2, 3], 1) ➞ False\n    # seimbang, tetapi 3+2+3 lebih dari berat maksimum yang mungkin.\n\n        will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 kurang dari berat maksimum yang mungkin, dan seimbang.\n\n        will_it_fly([3], 5) ➞ True\n    # 3 kurang dari berat maksimum yang mungkin, dan seimbang.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Buatlah sebuah fungsi yang mengembalikan nilai True jika objek q akan terbang, dan False jika tidak.\n    Objek q akan terbang jika seimbang (merupakan daftar palindrom) dan jumlah elemennya kurang dari atau sama dengan berat maksimum yang mungkin w.\n\n        Contoh:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 kurang dari berat maksimum yang mungkin, tetapi tidak seimbang.\n\n        will_it_fly([3, 2, 3], 1) ➞ False\n    # seimbang, tetapi 3+2+3 lebih dari berat maksimum yang mungkin.\n\n        will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 kurang dari berat maksimum yang mungkin, dan seimbang.\n\n        will_it_fly([3], 5) ➞ True\n    # 3 kurang dari berat maksimum yang mungkin, dan seimbang.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Tulis sebuah fungsi yang mengembalikan nilai benar jika angka yang diberikan adalah hasil kali dari 3 bilangan prima\n    dan salah jika tidak.\n    Diketahui bahwa (a) kurang dari 100.\n    Contoh:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Tulis sebuah fungsi yang mengembalikan nilai benar jika angka yang diberikan adalah hasil kali dari 3 bilangan prima\n    dan salah jika tidak.\n    Diketahui bahwa (a) kurang dari 100.\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Anda akan diberikan sebuah angka dalam bentuk desimal dan tugas Anda adalah mengonversinya ke dalam format biner. Fungsi harus mengembalikan sebuah string, dengan setiap karakter mewakili sebuah angka biner. Setiap karakter dalam string akan berupa '0' atau '1'.\n\n    Akan ada beberapa karakter tambahan 'db' di awal dan di akhir string. Karakter tambahan tersebut ada untuk membantu dalam format.\n\n    Contoh:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Anda akan diberikan sebuah angka dalam bentuk desimal dan tugas Anda adalah mengonversinya ke dalam format biner. Fungsi harus mengembalikan sebuah string, dengan setiap karakter mewakili sebuah angka biner. Setiap karakter dalam string akan berupa '0' atau '1'.\n\n    Akan ada beberapa karakter tambahan 'db' di awal dan di akhir string. Karakter tambahan tersebut ada untuk membantu dalam format.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Anda diberikan sebuah string s.\nTugas Anda adalah untuk memeriksa apakah string tersebut bahagia atau tidak.\nSebuah string dianggap bahagia jika panjangnya setidaknya 3 dan setiap 3 huruf berturut-turut berbeda.\nContohnya:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Anda diberikan sebuah string s.\nTugas Anda adalah untuk memeriksa apakah string tersebut bahagia atau tidak.\nSebuah string dianggap bahagia jika panjangnya setidaknya 3 dan setiap 3 huruf berturut-turut berbeda.\nContohnya:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Ini adalah minggu terakhir semester dan guru harus memberikan nilai kepada siswa. Guru telah membuat algoritma sendiri untuk penilaian. Satu-satunya masalah adalah, dia telah kehilangan kode yang digunakan untuk penilaian. Dia telah memberi Anda daftar IPK untuk beberapa siswa dan Anda harus menulis fungsi yang dapat mengeluarkan daftar nilai huruf menggunakan tabel berikut:\n\n                 IPK       |    Nilai huruf\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Contoh:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "Ini adalah minggu terakhir semester dan guru harus memberikan nilai kepada siswa. Guru telah membuat algoritma sendiri untuk penilaian. Satu-satunya masalah adalah, dia telah kehilangan kode yang digunakan untuk penilaian. Dia telah memberi Anda daftar IPK untuk beberapa siswa dan Anda harus menulis fungsi yang dapat mengeluarkan daftar nilai huruf menggunakan tabel berikut:\n\n                 IPK       |    Nilai huruf\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Tulis sebuah fungsi yang mengambil sebuah string dan mengembalikan True jika panjang string tersebut adalah bilangan prima atau False jika tidak.\nContoh:\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Tulis sebuah fungsi yang mengambil sebuah string dan mengembalikan True jika panjang string tersebut adalah bilangan prima atau False jika tidak.\nContoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Diberikan sebuah bilangan bulat positif N, kembalikan total jumlah digitnya dalam bentuk biner.\n\n        Contoh\n        Untuk N = 1000, jumlah digitnya adalah 1, outputnya harus \"1\".\n        Untuk N = 150, jumlah digitnya adalah 6, outputnya harus \"110\".\n        Untuk N = 147, jumlah digitnya adalah 12, outputnya harus \"1100\".\n    \n    Variabel:\n        @N bilangan bulat\n             Batasan: 0 ≤ N ≤ 10000.\n    Output:\n         sebuah string dalam bentuk bilangan biner.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Diberikan sebuah bilangan bulat positif N, kembalikan total jumlah digitnya dalam bentuk biner.\n\n        Contoh\n        Untuk N = 1000, jumlah digitnya adalah 1, outputnya harus \"1\".\n        Untuk N = 150, jumlah digitnya adalah 6, outputnya harus \"110\".\n        Untuk N = 147, jumlah digitnya adalah 12, outputnya harus \"1100\".\n    \n    Variabel:\n        @N bilangan bulat\n             Batasan: 0 ≤ N ≤ 10000.\n    Output:\n         sebuah string dalam bentuk bilangan biner.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Anda diberikan data 2 dimensi, sebagai daftar bertingkat,\nyang mirip dengan matriks, namun tidak seperti matriks,\nsetiap baris dapat berisi jumlah kolom yang berbeda.\nDiberikan lst, dan bilangan bulat x, temukan bilangan bulat x dalam daftar,\ndan kembalikan daftar tuple, [(x1, y1), (x2, y2) ...] sehingga\nsetiap tuple adalah koordinat - (baris, kolom), dimulai dari 0.\nUrutkan koordinat awalnya berdasarkan baris secara menaik.\nJuga, urutkan koordinat baris berdasarkan kolom secara menurun.\n\n    Contoh:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Anda diberikan data 2 dimensi, sebagai daftar bertingkat,\nyang mirip dengan matriks, namun tidak seperti matriks,\nsetiap baris dapat berisi jumlah kolom yang berbeda.\nDiberikan lst, dan bilangan bulat x, temukan bilangan bulat x dalam daftar,\ndan kembalikan daftar tuple, [(x1, y1), (x2, y2) ...] sehingga\nsetiap tuple adalah koordinat - (baris, kolom), dimulai dari 0.\nUrutkan koordinat awalnya berdasarkan baris secara menaik.\nJuga, urutkan koordinat baris berdasarkan kolom secara menurun.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Anda diberikan sebuah daftar bilangan bulat.\n    Tulis sebuah fungsi next_smallest() yang mengembalikan elemen terkecil kedua dari daftar.\n    Kembalikan null jika tidak ada elemen seperti itu.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Anda diberikan sebuah daftar bilangan bulat.\n    Tulis sebuah fungsi next_smallest() yang mengembalikan elemen terkecil kedua dari daftar.\n    Kembalikan null jika tidak ada elemen seperti itu.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Anda akan diberikan sebuah string kata-kata, dan tugas Anda adalah menghitung jumlah kebosanan. Kebosanan adalah kalimat yang diawali dengan kata \"Saya\". Kalimat-kalimat dipisahkan oleh '.', '?' atau '!'.\n\n    Contoh:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Anda akan diberikan sebuah string kata-kata, dan tugas Anda adalah menghitung jumlah kebosanan. Kebosanan adalah kalimat yang diawali dengan kata \"Saya\". Kalimat-kalimat dipisahkan oleh '.', '?' atau '!'.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Anda diberikan sebuah daftar bilangan bulat.\nAnda perlu mencari nilai prima terbesar dan mengembalikan jumlah digitnya.\n\n    Contoh:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Anda diberikan sebuah daftar bilangan bulat.\nAnda perlu mencari nilai prima terbesar dan mengembalikan jumlah digitnya.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Diberikan sebuah kamus, kembalikan True jika semua kunci berupa string huruf kecil atau semua kunci berupa string huruf besar, jika tidak kembalikan False. Fungsi harus mengembalikan False jika kamus yang diberikan kosong. Contoh:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Diberikan sebuah kamus, kembalikan True jika semua kunci berupa string huruf kecil atau semua kunci berupa string huruf besar, jika tidak kembalikan False. Fungsi harus mengembalikan False jika kamus yang diberikan kosong. Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Buatlah sebuah fungsi yang mengambil nilai (string) yang mewakili sebuah angka dan mengembalikan bilangan bulat terdekat. Jika angka berjarak sama jauhnya dari dua bilangan bulat, bulatkan ke arah yang lebih besar.\n\n    Contoh:\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Buatlah sebuah fungsi yang mengambil nilai (string) yang mewakili sebuah angka dan mengembalikan bilangan bulat terdekat. Jika angka berjarak sama jauhnya dari dua bilangan bulat, bulatkan ke arah yang lebih besar.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Diberikan sebuah bilangan bulat positif n, Anda harus membuat tumpukan batu sebanyak n tingkat.\n    Tingkat pertama memiliki n batu.\n    Jumlah batu pada tingkat berikutnya adalah:\n        - bilangan ganjil berikutnya jika n ganjil.\n        - bilangan genap berikutnya jika n genap.\n    Kembalikan jumlah batu pada setiap tingkat dalam sebuah daftar, di mana elemen pada indeks\n    i mewakili jumlah batu pada tingkat (i+1).\n\n        Contoh:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Diberikan sebuah bilangan bulat positif n, Anda harus membuat tumpukan batu sebanyak n tingkat.\n    Tingkat pertama memiliki n batu.\n    Jumlah batu pada tingkat berikutnya adalah:\n        - bilangan ganjil berikutnya jika n ganjil.\n        - bilangan genap berikutnya jika n genap.\n    Kembalikan jumlah batu pada setiap tingkat dalam sebuah daftar, di mana elemen pada indeks\n    i mewakili jumlah batu pada tingkat (i+1).\n\n        Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Anda akan diberikan sebuah string kata yang dipisahkan oleh koma atau spasi. Tugas Anda adalah untuk memisahkan string tersebut menjadi kata-kata dan mengembalikan sebuah array dari kata-kata tersebut.\n\n    Contoh:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Anda akan diberikan sebuah string kata yang dipisahkan oleh koma atau spasi. Tugas Anda adalah untuk memisahkan string tersebut menjadi kata-kata dan mengembalikan sebuah array dari kata-kata tersebut.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Fungsi ini mengambil dua bilangan positif x dan y dan mengembalikan bilangan bulat genap terbesar yang berada dalam rentang [x, y] inklusif. Jika tidak ada bilangan seperti itu, maka fungsi harus mengembalikan -1.\n\n    Contoh:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Fungsi ini mengambil dua bilangan positif x dan y dan mengembalikan bilangan bulat genap terbesar yang berada dalam rentang [x, y] inklusif. Jika tidak ada bilangan seperti itu, maka fungsi harus mengembalikan -1.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Anda diberikan dua bilangan bulat positif n dan m, dan tugas Anda adalah untuk menghitung rata-rata bilangan bulat dari n hingga m (termasuk n dan m). Bulatkan jawaban ke bilangan bulat terdekat dan konversikan ke biner. Jika n lebih besar dari m, kembalikan -1. Contoh:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Anda diberikan dua bilangan bulat positif n dan m, dan tugas Anda adalah untuk menghitung rata-rata bilangan bulat dari n hingga m (termasuk n dan m). Bulatkan jawaban ke bilangan bulat terdekat dan konversikan ke biner. Jika n lebih besar dari m, kembalikan -1. Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Implementasikan fungsi f yang mengambil n sebagai parameter,\n    dan mengembalikan daftar berukuran n, sehingga nilai elemen pada indeks i adalah faktorial dari i jika i genap\n    atau jumlah angka dari 1 hingga i jika tidak.\n    i dimulai dari 1.\n    faktorial dari i adalah perkalian dari angka-angka dari 1 hingga i (1 * 2 * ... * i).\n    Contoh:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Implementasikan fungsi f yang mengambil n sebagai parameter,\n    dan mengembalikan daftar berukuran n, sehingga nilai elemen pada indeks i adalah faktorial dari i jika i genap\n    atau jumlah angka dari 1 hingga i jika tidak.\n    i dimulai dari 1.\n    faktorial dari i adalah perkalian dari angka-angka dari 1 hingga i (1 * 2 * ... * i).\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Diberikan sebuah bilangan bulat positif n, kembalikan sebuah tuple yang berisi jumlah bilangan palindrome genap dan ganjil yang berada dalam rentang (1, n), inklusif.\n\n    Contoh 1:\n\n        Input: 3\n    Output: (1, 2)\n    Penjelasan:\n    Bilangan palindrome adalah 1, 2, 3. Satu di antaranya genap, dan dua di antaranya ganjil.\n\n    Contoh 2:\n\n        Input: 12\n    Output: (4, 6)\n    Penjelasan:\n    Bilangan palindrome adalah 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Empat di antaranya genap, dan enam di antaranya ganjil.\n\n    Catatan:\n    1. 1 <= n <= 10^3\n    2. tuple yang dikembalikan berisi jumlah bilangan palindrome genap dan ganjil secara berturut-turut.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Diberikan sebuah bilangan bulat positif n, kembalikan sebuah tuple yang berisi jumlah bilangan palindrome genap dan ganjil yang berada dalam rentang (1, n), inklusif.\n\n    Contoh 1:\n\n        Input: 3\n    Output: (1, 2)\n    Penjelasan:\n    Bilangan palindrome adalah 1, 2, 3. Satu di antaranya genap, dan dua di antaranya ganjil.\n\n    Contoh 2:\n\n        Input: 12\n    Output: (4, 6)\n    Penjelasan:\n    Bilangan palindrome adalah 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Empat di antaranya genap, dan enam di antaranya ganjil.\n\n    Catatan:\n    1. 1 <= n <= 10^3\n    2. tuple yang dikembalikan berisi jumlah bilangan palindrome genap dan ganjil secara berturut-turut.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Kami memiliki array 'arr' dengan N bilangan bulat arr[1], arr[2], ..., arr[N]. Bilangan dalam array akan diacak. Tugas Anda adalah menentukan apakah mungkin untuk mendapatkan array yang diurutkan dalam urutan tidak menurun dengan melakukan operasi berikut pada array yang diberikan:\n        Anda diizinkan melakukan operasi pergeseran kanan sebanyak mungkin.\n\n        Satu operasi pergeseran kanan berarti memindahkan semua elemen array satu posisi ke arah kanan. Elemen terakhir dari array akan dipindahkan ke posisi awal dalam array yaitu indeks 0.\n\n        Jika memungkinkan untuk memperoleh array yang diurutkan dengan melakukan operasi di atas, maka kembalikan True jika tidak kembalikan False.\n    Jika array yang diberikan kosong, maka kembalikan True.\n\n        Catatan: Daftar yang diberikan dijamin memiliki elemen unik.\n\n        Contoh:\n\n        move_one_ball([3, 4, 5, 1, 2])==>True\n    Penjelasan: Dengan melakukan 2 operasi pergeseran kanan, urutan tidak menurun dapat dicapai untuk array yang diberikan.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Penjelasan: Tidak mungkin untuk mendapatkan urutan tidak menurun untuk array yang diberikan dengan melakukan operasi pergeseran kanan apa pun.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Kami memiliki array 'arr' dengan N bilangan bulat arr[1], arr[2], ..., arr[N]. Bilangan dalam array akan diacak. Tugas Anda adalah menentukan apakah mungkin untuk mendapatkan array yang diurutkan dalam urutan tidak menurun dengan melakukan operasi berikut pada array yang diberikan:\n        Anda diizinkan melakukan operasi pergeseran kanan sebanyak mungkin.\n\n        Satu operasi pergeseran kanan berarti memindahkan semua elemen array satu posisi ke arah kanan. Elemen terakhir dari array akan dipindahkan ke posisi awal dalam array yaitu indeks 0.\n\n        Jika memungkinkan untuk memperoleh array yang diurutkan dengan melakukan operasi di atas, maka kembalikan True jika tidak kembalikan False.\n    Jika array yang diberikan kosong, maka kembalikan True.\n\n        Catatan: Daftar yang diberikan dijamin memiliki elemen unik.\n\n        Contoh:\n\n        move_one_ball([3, 4, 5, 1, 2])==>True\n    Penjelasan: Dengan melakukan 2 operasi pergeseran kanan, urutan tidak menurun dapat dicapai untuk array yang diberikan.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Penjelasan: Tidak mungkin untuk mendapatkan urutan tidak menurun untuk array yang diberikan dengan melakukan operasi pergeseran kanan apa pun.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Dalam masalah ini, Anda akan mengimplementasikan sebuah fungsi yang mengambil dua daftar angka,\n    dan menentukan apakah mungkin untuk melakukan pertukaran elemen\n    antara mereka untuk membuat lst1 menjadi daftar hanya angka genap.\n    Tidak ada batasan pada jumlah elemen yang ditukar antara lst1 dan lst2.\n    Jika memungkinkan untuk menukar elemen antara lst1 dan lst2 untuk membuat\n    semua elemen lst1 menjadi genap, kembalikan \"YES\".\n    Jika tidak, kembalikan \"NO\".\n    Sebagai contoh:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    Diasumsikan bahwa daftar input akan tidak kosong.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "Dalam masalah ini, Anda akan mengimplementasikan sebuah fungsi yang mengambil dua daftar angka,\n    dan menentukan apakah mungkin untuk melakukan pertukaran elemen\n    antara mereka untuk membuat lst1 menjadi daftar hanya angka genap.\n    Tidak ada batasan pada jumlah elemen yang ditukar antara lst1 dan lst2.\n    Jika memungkinkan untuk menukar elemen antara lst1 dan lst2 untuk membuat\n    semua elemen lst1 menjadi genap, kembalikan \"YES\".\n    Jika tidak, kembalikan \"NO\".\n    Sebagai contoh:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    Diasumsikan bahwa daftar input akan tidak kosong.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Tugas\n    Diberikan dua string s dan c, Anda harus menghapus semua karakter dalam s yang sama dengan karakter apa pun dalam c\n    kemudian periksa apakah string hasilnya palindrom.\n    String disebut palindrom jika dibaca sama dari belakang maupun dari depan.\n    Anda harus mengembalikan tuple yang berisi string hasilnya dan True/False untuk pemeriksaan.\n    Contoh\n    Untuk s = \"abcde\", c = \"ae\", hasilnya harus ('bcd',False)\n    Untuk s = \"abcdef\", c = \"b\" hasilnya harus ('acdef',False)\n    Untuk s = \"abcdedcba\", c = \"ab\", hasilnya harus ('cdedc',True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Tugas\n    Diberikan dua string s dan c, Anda harus menghapus semua karakter dalam s yang sama dengan karakter apa pun dalam c\n    kemudian periksa apakah string hasilnya palindrom.\n    String disebut palindrom jika dibaca sama dari belakang maupun dari depan.\n    Anda harus mengembalikan tuple yang berisi string hasilnya dan True/False untuk pemeriksaan.\n    Contoh\n    Untuk s = \"abcde\", c = \"ae\", hasilnya harus ('bcd',False)\n    Untuk s = \"abcdef\", c = \"b\" hasilnya harus ('acdef',False)\n    Untuk s = \"abcdedcba\", c = \"ab\", hasilnya harus ('cdedc',True)\n    ", "natural_language": "Indonesian"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Anda diberikan sebuah grid persegi panjang sumur-sumur. Setiap baris merepresentasikan satu sumur, dan setiap 1 dalam satu baris merepresentasikan satu unit air. Setiap sumur memiliki ember yang sesuai yang dapat digunakan untuk mengambil air dari sumur tersebut, dan semua ember memiliki kapasitas yang sama. Tugas Anda adalah menggunakan ember-ember tersebut untuk mengosongkan sumur-sumur tersebut. Outputkan jumlah kali yang Anda perlu menurunkan ember-ember tersebut.\n\n    Contoh 1:\n    Input:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        kapasitas_ember: 1\n    Output: 6\n\n    Contoh 2:\n    Input:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        kapasitas_ember: 2\n    Output: 5\n\n    Contoh 3:\n    Input:\n        grid: [[0,0,0], [0,0,0]]\n        kapasitas_ember: 5\n    Output: 0\n\n    Kendala:\n    * semua sumur memiliki panjang yang sama\n    * 1 <= panjang grid <= 10^2\n    * 1 <= panjang grid[:,1] <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= kapasitas <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Anda diberikan sebuah grid persegi panjang sumur-sumur. Setiap baris merepresentasikan satu sumur, dan setiap 1 dalam satu baris merepresentasikan satu unit air. Setiap sumur memiliki ember yang sesuai yang dapat digunakan untuk mengambil air dari sumur tersebut, dan semua ember memiliki kapasitas yang sama. Tugas Anda adalah menggunakan ember-ember tersebut untuk mengosongkan sumur-sumur tersebut. Outputkan jumlah kali yang Anda perlu menurunkan ember-ember tersebut.\n\n    Contoh 1:\n    Input:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        kapasitas_ember: 1\n    Output: 6\n\n    Contoh 2:\n    Input:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        kapasitas_ember: 2\n    Output: 5\n\n    Contoh 3:\n    Input:\n        grid: [[0,0,0], [0,0,0]]\n        kapasitas_ember: 5\n    Output: 0\n\n    Kendala:\n    * semua sumur memiliki panjang yang sama\n    * 1 <= panjang grid <= 10^2\n    * 1 <= panjang grid[:,1] <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= kapasitas <= 10\n    ", "natural_language": "Indonesian"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Diberikan sebuah string s dan sebuah bilangan bulat n, Anda diminta untuk mengimplementasikan sebuah fungsi yang mengembalikan daftar semua kata dari string s yang mengandung tepat n konsonan, dalam urutan kata-kata tersebut muncul dalam string s. Jika string s kosong, maka fungsi harus mengembalikan daftar kosong. Catatan: Anda dapat mengasumsikan string input hanya berisi huruf dan spasi. Contoh:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Diberikan sebuah string s dan sebuah bilangan bulat n, Anda diminta untuk mengimplementasikan sebuah fungsi yang mengembalikan daftar semua kata dari string s yang mengandung tepat n konsonan, dalam urutan kata-kata tersebut muncul dalam string s. Jika string s kosong, maka fungsi harus mengembalikan daftar kosong. Catatan: Anda dapat mengasumsikan string input hanya berisi huruf dan spasi. Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Diberikan sebuah array arr berisi bilangan bulat dan sebuah bilangan bulat positif k, kembalikan sebuah daftar yang diurutkan dengan panjang k yang berisi k bilangan terbesar di dalam arr.\n\n    Contoh 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n    Output: [-4, -3, 5]\n\n    Contoh 2:\n\n        Input: arr = [4, -4, 4], k = 2\n    Output: [4, 4]\n\n    Contoh 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Output: [2]\n\n    Catatan:\n    1. Panjang array akan berada dalam rentang [1, 1000].\n    2. Elemen-elemen dalam array akan berada dalam rentang [-1000, 1000].\n    3. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Diberikan sebuah array arr berisi bilangan bulat dan sebuah bilangan bulat positif k, kembalikan sebuah daftar yang diurutkan dengan panjang k yang berisi k bilangan terbesar di dalam arr.\n\n    Contoh 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n    Output: [-4, -3, 5]\n\n    Contoh 2:\n\n        Input: arr = [4, -4, 4], k = 2\n    Output: [4, 4]\n\n    Contoh 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Output: [2]\n\n    Catatan:\n    1. Panjang array akan berada dalam rentang [1, 1000].\n    2. Elemen-elemen dalam array akan berada dalam rentang [-1000, 1000].\n    3. 0 <= k <= len(arr)\n    ", "natural_language": "Indonesian"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Diberikan sebuah array bilangan bulat arr yang tidak kosong dan sebuah bilangan bulat k, kembalikan jumlah elemen dengan paling banyak dua digit dari k elemen pertama arr.\n\n    Contoh:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Output: 24 # jumlah dari 21 + 3\n\n    Batasan:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Diberikan sebuah array bilangan bulat arr yang tidak kosong dan sebuah bilangan bulat k, kembalikan jumlah elemen dengan paling banyak dua digit dari k elemen pertama arr.\n\n    Contoh:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Output: 24 # jumlah dari 21 + 3\n\n    Batasan:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    ", "natural_language": "Indonesian"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Anda diberikan dua interval,\n    di mana setiap interval adalah sepasang bilangan bulat. Misalnya, interval = (start, end) = (1, 2).\n    Interval yang diberikan adalah tertutup yang berarti interval (start, end)\n    termasuk kedua start dan end.\n    Untuk setiap interval yang diberikan, diasumsikan bahwa awalnya kurang dari atau sama dengan akhirnya.\n    Tugas Anda adalah menentukan apakah panjang irisan dari kedua\n    interval adalah bilangan prima.\n    Contohnya, irisan dari interval (1, 3), (2, 4) adalah (2, 3)\n    yang panjangnya adalah 1, yang bukan bilangan prima.\n    Jika panjang irisan adalah bilangan prima, kembalikan \"YES\",\n    jika tidak, kembalikan \"NO\".\n    Jika kedua interval tidak berpotongan, kembalikan \"NO\".\n\n    \n    [input/output] contoh:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Anda diberikan dua interval,\n    di mana setiap interval adalah sepasang bilangan bulat. Misalnya, interval = (start, end) = (1, 2).\n    Interval yang diberikan adalah tertutup yang berarti interval (start, end)\n    termasuk kedua start dan end.\n    Untuk setiap interval yang diberikan, diasumsikan bahwa awalnya kurang dari atau sama dengan akhirnya.\n    Tugas Anda adalah menentukan apakah panjang irisan dari kedua\n    interval adalah bilangan prima.\n    Contohnya, irisan dari interval (1, 3), (2, 4) adalah (2, 3)\n    yang panjangnya adalah 1, yang bukan bilangan prima.\n    Jika panjang irisan adalah bilangan prima, kembalikan \"YES\",\n    jika tidak, kembalikan \"NO\".\n    Jika kedua interval tidak berpotongan, kembalikan \"NO\".\n\n    \n    [input/output] contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Semua orang tahu urutan Fibonacci, itu telah dipelajari secara mendalam oleh para matematikawan dalam beberapa abad terakhir. Namun, yang tidak diketahui orang adalah urutan Tribonacci. Urutan Tribonacci didefinisikan oleh rekurensi: tri(1) = 3 tri(n) = 1 + n / 2, jika n genap. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), jika n ganjil. Sebagai contoh: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Anda diberikan bilangan bulat non-negatif n, Anda harus mengembalikan daftar n + 1 angka pertama dari urutan Tribonacci. Contoh: tri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Semua orang tahu urutan Fibonacci, itu telah dipelajari secara mendalam oleh para matematikawan dalam beberapa abad terakhir. Namun, yang tidak diketahui orang adalah urutan Tribonacci. Urutan Tribonacci didefinisikan oleh rekurensi: tri(1) = 3 tri(n) = 1 + n / 2, jika n genap. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), jika n ganjil. Sebagai contoh: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Anda diberikan bilangan bulat non-negatif n, Anda harus mengembalikan daftar n + 1 angka pertama dari urutan Tribonacci. Contoh: tri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Indonesian"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Diberikan sebuah bilangan bulat positif n, kembalikan hasil kali dari digit-digit ganjil.\n    Kembalikan 0 jika semua digit adalah genap.\n    Contohnya:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Diberikan sebuah bilangan bulat positif n, kembalikan hasil kali dari digit-digit ganjil.\n    Kembalikan 0 jika semua digit adalah genap.\n    Contohnya:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Buatlah sebuah fungsi yang menerima sebuah string yang hanya berisi tanda kurung siku.\nFungsi tersebut harus mengembalikan nilai True jika dan hanya jika terdapat subsequence tanda kurung yang valid\ndimana setidaknya satu tanda kurung dalam subsequence tersebut bersarang.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Buatlah sebuah fungsi yang menerima sebuah string yang hanya berisi tanda kurung siku.\nFungsi tersebut harus mengembalikan nilai True jika dan hanya jika terdapat subsequence tanda kurung yang valid\ndimana setidaknya satu tanda kurung dalam subsequence tersebut bersarang.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Anda diberikan sebuah daftar angka.\nAnda perlu mengembalikan jumlah angka yang dikuadratkan dalam daftar yang diberikan,\nmembulatkan setiap elemen dalam daftar ke int atas (Ceiling) terlebih dahulu.\nContoh:\nUntuk lst = [1,2,3] output harusnya 14\nUntuk lst = [1,4,9] output harusnya 98\nUntuk lst = [1,3,5,7] output harusnya 84\nUntuk lst = [1.4,4.2,0] output harusnya 29\nUntuk lst = [-2.4,1,1] output harusnya 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Anda diberikan sebuah daftar angka.\nAnda perlu mengembalikan jumlah angka yang dikuadratkan dalam daftar yang diberikan,\nmembulatkan setiap elemen dalam daftar ke int atas (Ceiling) terlebih dahulu.\nContoh:\nUntuk lst = [1,2,3] output harusnya 14\nUntuk lst = [1,4,9] output harusnya 98\nUntuk lst = [1,3,5,7] output harusnya 84\nUntuk lst = [1.4,4.2,0] output harusnya 29\nUntuk lst = [-2.4,1,1] output harusnya 6\n    ", "natural_language": "Indonesian"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Buatlah sebuah fungsi yang mengembalikan nilai True jika karakter terakhir dari sebuah string yang diberikan adalah karakter alfabet dan bukan bagian dari sebuah kata, dan False jika sebaliknya.\nCatatan: \"kata\" adalah sekelompok karakter yang dipisahkan oleh spasi.\n\n    Contoh:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Buatlah sebuah fungsi yang mengembalikan nilai True jika karakter terakhir dari sebuah string yang diberikan adalah karakter alfabet dan bukan bagian dari sebuah kata, dan False jika sebaliknya.\nCatatan: \"kata\" adalah sekelompok karakter yang dipisahkan oleh spasi.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Buatlah sebuah fungsi yang mengembalikan indeks terbesar dari sebuah elemen yang tidak lebih besar atau sama dengan elemen yang langsung mendahuluinya. Jika tidak ada elemen seperti itu, maka kembalikan -1. Array yang diberikan tidak akan mengandung nilai duplikat.\n\n    Contoh:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Buatlah sebuah fungsi yang mengembalikan indeks terbesar dari sebuah elemen yang tidak lebih besar atau sama dengan elemen yang langsung mendahuluinya. Jika tidak ada elemen seperti itu, maka kembalikan -1. Array yang diberikan tidak akan mengandung nilai duplikat.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Buatlah sebuah fungsi yang mengembalikan tuple (a, b), dimana 'a' adalah bilangan bulat negatif terbesar, dan 'b' adalah bilangan bulat positif terkecil dalam sebuah list. Jika tidak ada bilangan bulat negatif atau positif, kembalikan None.\n\n    Contoh:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Buatlah sebuah fungsi yang mengembalikan tuple (a, b), dimana 'a' adalah bilangan bulat negatif terbesar, dan 'b' adalah bilangan bulat positif terkecil dalam sebuah list. Jika tidak ada bilangan bulat negatif atau positif, kembalikan None.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"Faktorial Brasil didefinisikan sebagai:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    di mana n > 0\n\n        Sebagai contoh:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "Faktorial Brasil didefinisikan sebagai:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    di mana n > 0\n\n        Sebagai contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Anda diberikan sebuah string yang mewakili sebuah kalimat,\n    kalimat tersebut berisi beberapa kata yang dipisahkan oleh spasi,\n    dan Anda harus mengembalikan sebuah string yang berisi kata-kata dari kalimat asli,\n    yang panjangnya adalah bilangan prima,\n    urutan kata dalam string baru harus sama dengan urutan aslinya.\n\n        Contoh 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n        Contoh 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n        Batasan:\n        * 1 <= len(sentence) <= 100\n        * sentence hanya berisi huruf.\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Anda diberikan sebuah string yang mewakili sebuah kalimat,\n    kalimat tersebut berisi beberapa kata yang dipisahkan oleh spasi,\n    dan Anda harus mengembalikan sebuah string yang berisi kata-kata dari kalimat asli,\n    yang panjangnya adalah bilangan prima,\n    urutan kata dalam string baru harus sama dengan urutan aslinya.\n\n        Contoh 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n        Contoh 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n        Batasan:\n        * 1 <= len(sentence) <= 100\n        * sentence hanya berisi huruf.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Tugas Anda adalah mengimplementasikan sebuah fungsi yang akan menyederhanakan ekspresi x * n. Fungsi tersebut akan mengembalikan True jika x * n dievaluasi menjadi bilangan bulat dan False jika tidak. Baik x maupun n, adalah representasi string dari pecahan, dan memiliki format berikut, <pembilang>/<penyebut> di mana keduanya adalah bilangan bulat positif.\n\n    Anda dapat mengasumsikan bahwa x dan n adalah pecahan yang valid, dan tidak memiliki nol sebagai penyebut.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Tugas Anda adalah mengimplementasikan sebuah fungsi yang akan menyederhanakan ekspresi x * n. Fungsi tersebut akan mengembalikan True jika x * n dievaluasi menjadi bilangan bulat dan False jika tidak. Baik x maupun n, adalah representasi string dari pecahan, dan memiliki format berikut, <pembilang>/<penyebut> di mana keduanya adalah bilangan bulat positif.\n\n    Anda dapat mengasumsikan bahwa x dan n adalah pecahan yang valid, dan tidak memiliki nol sebagai penyebut.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Tulis sebuah fungsi yang mengurutkan daftar bilangan bulat yang diberikan\n    secara menaik berdasarkan jumlah digit mereka.\n    Catatan: jika ada beberapa item dengan jumlah digit yang sama,\n    urutkan berdasarkan indeks mereka dalam daftar asli.\n\n        Contoh:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Tulis sebuah fungsi yang mengurutkan daftar bilangan bulat yang diberikan\n    secara menaik berdasarkan jumlah digit mereka.\n    Catatan: jika ada beberapa item dengan jumlah digit yang sama,\n    urutkan berdasarkan indeks mereka dalam daftar asli.\n\n        Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Tulis sebuah fungsi yang mengambil sebuah array angka sebagai input dan mengembalikan jumlah elemen dalam array yang lebih besar dari 10 dan digit pertama dan terakhir dari sebuah angka adalah ganjil (1, 3, 5, 7, 9). Contohnya:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Tulis sebuah fungsi yang mengambil sebuah array angka sebagai input dan mengembalikan jumlah elemen dalam array yang lebih besar dari 10 dan digit pertama dan terakhir dari sebuah angka adalah ganjil (1, 3, 5, 7, 9). Contohnya:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Anda diberikan sebuah bilangan bulat positif n. Anda harus membuat sebuah array integer a dengan panjang n.\n        Untuk setiap i (1 ≤ i ≤ n), nilai dari a[i] = i * i - i + 1.\n        Kembalikan jumlah triple (a[i], a[j], a[k]) dari a dimana i < j < k, \n    dan a[i] + a[j] + a[k] adalah kelipatan dari 3.\n\n        Contoh :\n        Input: n = 5\n        Output: 1\n        Penjelasan: \n        a = [1, 3, 7, 13, 21]\n        Satu-satunya triple yang valid adalah (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Anda diberikan sebuah bilangan bulat positif n. Anda harus membuat sebuah array integer a dengan panjang n.\n        Untuk setiap i (1 ≤ i ≤ n), nilai dari a[i] = i * i - i + 1.\n        Kembalikan jumlah triple (a[i], a[j], a[k]) dari a dimana i < j < k, \n    dan a[i] + a[j] + a[k] adalah kelipatan dari 3.\n\n        Contoh :\n        Input: n = 5\n        Output: 1\n        Penjelasan: \n        a = [1, 3, 7, 13, 21]\n        Satu-satunya triple yang valid adalah (1, 7, 13).\n    ", "natural_language": "Indonesian"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    Ada delapan planet di tata surya kita: yang paling dekat dengan Matahari adalah Merkurius, yang berikutnya adalah Venus, kemudian Bumi, Mars, Jupiter, Saturnus, Uranus, Neptunus. Tulis sebuah fungsi yang mengambil dua nama planet sebagai string planet1 dan planet2. Fungsi tersebut harus mengembalikan sebuah tuple yang berisi semua planet yang orbitnya terletak di antara orbit planet1 dan orbit planet2, diurutkan berdasarkan kedekatan dengan Matahari. Fungsi tersebut harus mengembalikan tuple kosong jika planet1 atau planet2 bukan nama planet yang benar. Contoh:\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "Ada delapan planet di tata surya kita: yang paling dekat dengan Matahari adalah Merkurius, yang berikutnya adalah Venus, kemudian Bumi, Mars, Jupiter, Saturnus, Uranus, Neptunus. Tulis sebuah fungsi yang mengambil dua nama planet sebagai string planet1 dan planet2. Fungsi tersebut harus mengembalikan sebuah tuple yang berisi semua planet yang orbitnya terletak di antara orbit planet1 dan orbit planet2, diurutkan berdasarkan kedekatan dengan Matahari. Fungsi tersebut harus mengembalikan tuple kosong jika planet1 atau planet2 bukan nama planet yang benar. Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Sebuah program sederhana yang harus mengembalikan nilai x jika n adalah bilangan prima dan harus mengembalikan nilai y jika tidak.\n\n    Contoh:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Sebuah program sederhana yang harus mengembalikan nilai x jika n adalah bilangan prima dan harus mengembalikan nilai y jika tidak.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Diberikan sebuah daftar angka, kembalikan jumlah kuadrat dari angka-angka dalam daftar yang ganjil. Abaikan angka yang negatif atau bukan bilangan bulat.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n        Jika daftar masukan kosong, kembalikan 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Diberikan sebuah daftar angka, kembalikan jumlah kuadrat dari angka-angka dalam daftar yang ganjil. Abaikan angka yang negatif atau bukan bilangan bulat.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n        Jika daftar masukan kosong, kembalikan 0.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Anda akan diberikan nama kelas (sebuah string) dan daftar ekstensi. Ekstensi akan digunakan untuk memuat kelas tambahan ke dalam kelas. Kekuatan ekstensi dihitung sebagai berikut: Biarkan CAP menjadi jumlah huruf kapital dalam nama ekstensi, dan biarkan SM menjadi jumlah huruf kecil dalam nama ekstensi, kekuatan diberikan oleh pecahan CAP - SM. Anda harus mencari ekstensi terkuat dan mengembalikan string dalam format ini: ClassName.StrongestExtensionName. Jika ada dua atau lebih ekstensi dengan kekuatan yang sama, Anda harus memilih yang pertama dalam daftar. Sebagai contoh, jika Anda diberikan \"Slices\" sebagai kelas dan daftar ekstensi: ['SErviNGSliCes', 'Cheese', 'StuFfed'], maka Anda harus mengembalikan 'Slices.SErviNGSliCes' karena 'SErviNGSliCes' adalah ekstensi terkuat (kekuatannya adalah -1). Contoh:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Anda akan diberikan nama kelas (sebuah string) dan daftar ekstensi. Ekstensi akan digunakan untuk memuat kelas tambahan ke dalam kelas. Kekuatan ekstensi dihitung sebagai berikut: Biarkan CAP menjadi jumlah huruf kapital dalam nama ekstensi, dan biarkan SM menjadi jumlah huruf kecil dalam nama ekstensi, kekuatan diberikan oleh pecahan CAP - SM. Anda harus mencari ekstensi terkuat dan mengembalikan string dalam format ini: ClassName.StrongestExtensionName. Jika ada dua atau lebih ekstensi dengan kekuatan yang sama, Anda harus memilih yang pertama dalam daftar. Sebagai contoh, jika Anda diberikan \"Slices\" sebagai kelas dan daftar ekstensi: ['SErviNGSliCes', 'Cheese', 'StuFfed'], maka Anda harus mengembalikan 'Slices.SErviNGSliCes' karena 'SErviNGSliCes' adalah ekstensi terkuat (kekuatannya adalah -1). Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Anda diberikan 2 kata. Anda perlu mengembalikan nilai True jika kata kedua atau salah satu rotasinya adalah substring dari kata pertama.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Anda diberikan 2 kata. Anda perlu mengembalikan nilai True jika kata kedua atau salah satu rotasinya adalah substring dari kata pertama.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Diberikan sebuah bilangan bulat positif, dapatkan nilai romawi setara sebagai string, dan kembalikan dalam huruf kecil. Batasan: 1 <= num <= 1000\n\n    Contoh:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Diberikan sebuah bilangan bulat positif, dapatkan nilai romawi setara sebagai string, dan kembalikan dalam huruf kecil. Batasan: 1 <= num <= 1000\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Diberikan panjang dari tiga sisi segitiga. Kembalikan True jika ketiga sisi membentuk segitiga siku-siku, False jika tidak. Segitiga siku-siku adalah segitiga di mana salah satu sudutnya adalah sudut siku-siku atau 90 derajat. Contoh:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Diberikan panjang dari tiga sisi segitiga. Kembalikan True jika ketiga sisi membentuk segitiga siku-siku, False jika tidak. Segitiga siku-siku adalah segitiga di mana salah satu sudutnya adalah sudut siku-siku atau 90 derajat. Contoh:\n    ", "natural_language": "Indonesian"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Anda diberikan sebuah string s.\n    jika s[i] adalah huruf, balikkan kasusnya dari huruf kecil menjadi huruf besar atau sebaliknya,\n    jika tidak, biarkan seperti itu.\n    Jika string tidak mengandung huruf, balikkan string.\n    Fungsi harus mengembalikan string yang dihasilkan.\n    Contoh\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Anda diberikan sebuah string s.\n    jika s[i] adalah huruf, balikkan kasusnya dari huruf kecil menjadi huruf besar atau sebaliknya,\n    jika tidak, biarkan seperti itu.\n    Jika string tidak mengandung huruf, balikkan string.\n    Fungsi harus mengembalikan string yang dihasilkan.\n    Contoh\n    ", "natural_language": "Indonesian"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Diberikan sebuah string 'teks', kembalikan string yang setara dengan hash md5-nya.\n    Jika 'teks' adalah string kosong, kembalikan null.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Diberikan sebuah string 'teks', kembalikan string yang setara dengan hash md5-nya.\n    Jika 'teks' adalah string kosong, kembalikan null.\n    ", "natural_language": "Indonesian"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Diberikan dua bilangan bulat positif a dan b, kembalikan digit-genap antara a dan b, dalam urutan menaik.\n\n    Contoh:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Diberikan dua bilangan bulat positif a dan b, kembalikan digit-genap antara a dan b, dalam urutan menaik.\n\n    Contoh:\n    ", "natural_language": "Indonesian"}
