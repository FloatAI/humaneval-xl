{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Você recebe uma lista de operações de depósito e saque em uma conta bancária que começa com saldo zero. Sua tarefa é detectar se em algum momento o saldo da conta fica abaixo de zero e, nesse ponto, a função deve retornar True. Caso contrário, deve retornar False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Você recebe uma lista de operações de depósito e saque em uma conta bancária que começa com saldo zero. Sua tarefa é detectar se em algum momento o saldo da conta fica abaixo de zero e, nesse ponto, a função deve retornar True. Caso contrário, deve retornar False.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Para uma lista dada de inteiros, retorne uma tupla consistindo em uma soma e um produto de todos os inteiros na lista. A soma vazia deve ser igual a 0 e o produto vazio deve ser igual a 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Para uma lista dada de inteiros, retorne uma tupla consistindo em uma soma e um produto de todos os inteiros na lista. A soma vazia deve ser igual a 0 e o produto vazio deve ser igual a 1.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" A entrada são duas strings a e b compostas apenas por 1s e 0s.\n    Realize a operação XOR binária nesses inputs e retorne o resultado também como uma string.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "A entrada são duas strings a e b compostas apenas por 1s e 0s.\n    Realize a operação XOR binária nesses inputs e retorne o resultado também como uma string.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" A partir de uma lista de strings, retorne a mais longa. Retorne a primeira em caso de múltiplas strings com o mesmo comprimento. Retorne nulo caso a lista de entrada esteja vazia.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "A partir de uma lista de strings, retorne a mais longa. Retorne a primeira em caso de múltiplas strings com o mesmo comprimento. Retorne nulo caso a lista de entrada esteja vazia.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Retorna o maior divisor comum de dois números inteiros a e b.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Retorna o maior divisor comum de dois números inteiros a e b.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" A entrada é uma string separada por espaços contendo números de 'zero' a 'nove'.\n    As escolhas válidas são 'zero', 'um', 'dois', 'três', 'quatro', 'cinco', 'seis', 'sete', 'oito' e 'nove'.\n    Retorne a string com os números ordenados do menor para o maior.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "A entrada é uma string separada por espaços contendo números de 'zero' a 'nove'.\n    As escolhas válidas são 'zero', 'um', 'dois', 'três', 'quatro', 'cinco', 'seis', 'sete', 'oito' e 'nove'.\n    Retorne a string com os números ordenados do menor para o maior.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Dada uma lista de números (com pelo menos dois elementos), aplique uma transformação linear a essa lista, de modo que o menor número se torne 0 e o maior se torne 1.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Dada uma lista de números (com pelo menos dois elementos), aplique uma transformação linear a essa lista, de modo que o menor número se torne 0 e o maior se torne 1.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Para uma determinada string, inverta os caracteres minúsculos para maiúsculos e maiúsculos para minúsculos.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Para uma determinada string, inverta os caracteres minúsculos para maiúsculos e maiúsculos para minúsculos.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Retorne apenas números positivos na lista.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Retorne apenas números positivos na lista.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Retorna verdadeiro se um número dado é primo e falso caso contrário.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Retorna verdadeiro se um número dado é primo e falso caso contrário.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Retornar elementos únicos e ordenados em uma lista.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Retornar elementos únicos e ordenados em uma lista.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib retorna o número n-ésimo que é um número de Fibonacci e também é primo.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib retorna o número n-ésimo que é um número de Fibonacci e também é primo.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero recebe uma lista de inteiros como entrada.\n    Ele retorna True se houver três elementos distintos na lista que\n    somam zero e False caso contrário.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "triples_sum_to_zero recebe uma lista de inteiros como entrada.\n    Ele retorna True se houver três elementos distintos na lista que\n    somam zero e False caso contrário.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero recebe uma lista de inteiros como entrada.\n    ele retorna True se houver dois elementos distintos na lista que\n    somam zero, e False caso contrário.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "pairs_sum_to_zero recebe uma lista de inteiros como entrada.\n    ele retorna True se houver dois elementos distintos na lista que\n    somam zero, e False caso contrário.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"A sequência de números Fib4 é uma sequência semelhante à sequência de Fibonacci que é definida da seguinte forma:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Por favor, escreva uma função para calcular eficientemente o n-ésimo elemento da sequência de números Fib4. Não use recursão.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "A sequência de números Fib4 é uma sequência semelhante à sequência de Fibonacci que é definida da seguinte forma:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Por favor, escreva uma função para calcular eficientemente o n-ésimo elemento da sequência de números Fib4. Não use recursão.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Retorna a mediana dos elementos na lista l.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Retorna a mediana dos elementos na lista l.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Verifica se a string fornecida é um palíndromo.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Verifica se a string fornecida é um palíndromo.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels é uma função que recebe uma string e retorna uma string sem vogais.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels é uma função que recebe uma string e retorna uma string sem vogais.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Retorna Verdadeiro se todos os números na lista l estiverem abaixo do limite t.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Retorna Verdadeiro se todos os números na lista l estiverem abaixo do limite t.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Adicione dois números x e y.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Adicione dois números x e y.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Verifique se duas palavras possuem os mesmos caracteres.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Verifique se duas palavras possuem os mesmos caracteres.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Retorna o n-ésimo número de Fibonacci.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Retorna o n-ésimo número de Fibonacci.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Retorna os elementos comuns únicos e ordenados de duas listas.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Retorna os elementos comuns únicos e ordenados de duas listas.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Retorna o maior fator primo de n. Supõe-se que n > 1 e não é um número primo.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Retorna o maior fator primo de n. Supõe-se que n > 1 e não é um número primo.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n é uma função que soma números de 1 a n.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n é uma função que soma números de 1 a n.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs representam os coeficientes de um polinômio.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Retorne a derivada deste polinômio na mesma forma.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs representam os coeficientes de um polinômio.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Retorne a derivada deste polinômio na mesma forma.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"A sequência de números FibFib é uma sequência semelhante à sequência de Fibonacci que é definida da seguinte forma:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Por favor, escreva uma função para calcular eficientemente o n-ésimo elemento da sequência de números FibFib.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "A sequência de números FibFib é uma sequência semelhante à sequência de Fibonacci que é definida da seguinte forma:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Por favor, escreva uma função para calcular eficientemente o n-ésimo elemento da sequência de números FibFib.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Escreva uma função vowels_count que recebe uma string representando uma palavra como entrada e retorna o número de vogais na string. Vogais neste caso são 'a', 'e', 'i', 'o', 'u'. Aqui, 'y' também é uma vogal, mas apenas quando está no final da palavra dada.\n\n    Exemplo:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Escreva uma função vowels_count que recebe uma string representando uma palavra como entrada e retorna o número de vogais na string. Vogais neste caso são 'a', 'e', 'i', 'o', 'u'. Aqui, 'y' também é uma vogal, mas apenas quando está no final da palavra dada.\n\n    Exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Você recebe uma lista não vazia de inteiros positivos. Retorne o maior inteiro que é maior que zero e tem uma frequência maior ou igual ao valor do próprio inteiro. A frequência de um inteiro é o número de vezes que ele aparece na lista. Se nenhum valor assim existir, retorne -1. Exemplos:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Você recebe uma lista não vazia de inteiros positivos. Retorne o maior inteiro que é maior que zero e tem uma frequência maior ou igual ao valor do próprio inteiro. A frequência de um inteiro é o número de vezes que ele aparece na lista. Se nenhum valor assim existir, retorne -1. Exemplos:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Dado os comprimentos dos três lados de um triângulo. Retorne a área do triângulo arredondada para 2 pontos decimais se os três lados formarem um triângulo válido. Caso contrário, retorne -1. Três lados formam um triângulo válido quando a soma de quaisquer dois lados é maior que o terceiro lado. Exemplo:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Dado os comprimentos dos três lados de um triângulo. Retorne a área do triângulo arredondada para 2 pontos decimais se os três lados formarem um triângulo válido. Caso contrário, retorne -1. Três lados formam um triângulo válido quando a soma de quaisquer dois lados é maior que o terceiro lado. Exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Escreva uma função que retorne True se o objeto q voará e False caso contrário.\n    O objeto q voará se estiver equilibrado (for uma lista palindrômica) e a soma de seus elementos for menor ou igual ao peso máximo possível w.\n\n        Exemplo:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 é menor que o peso máximo possível, mas não está equilibrado.\n\n        will_it_fly([3, 2, 3], 1) ➞ False\n    # está equilibrado, mas 3+2+3 é mais que o peso máximo possível.\n\n        will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 é menor que o peso máximo possível, e está equilibrado.\n\n        will_it_fly([3], 5) ➞ True\n    # 3 é menor que o peso máximo possível, e está equilibrado.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Escreva uma função que retorne True se o objeto q voará e False caso contrário.\n    O objeto q voará se estiver equilibrado (for uma lista palindrômica) e a soma de seus elementos for menor ou igual ao peso máximo possível w.\n\n        Exemplo:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 é menor que o peso máximo possível, mas não está equilibrado.\n\n        will_it_fly([3, 2, 3], 1) ➞ False\n    # está equilibrado, mas 3+2+3 é mais que o peso máximo possível.\n\n        will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 é menor que o peso máximo possível, e está equilibrado.\n\n        will_it_fly([3], 5) ➞ True\n    # 3 é menor que o peso máximo possível, e está equilibrado.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Escreva uma função que retorna verdadeiro se o número fornecido for a multiplicação de 3 números primos\n    e falso caso contrário.\n    Sabendo que (a) é menor que 100.\n    Exemplo:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Escreva uma função que retorna verdadeiro se o número fornecido for a multiplicação de 3 números primos\n    e falso caso contrário.\n    Sabendo que (a) é menor que 100.\n    Exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Você receberá um número em forma decimal e sua tarefa é convertê-lo para formato binário. A função deve retornar uma string, com cada caractere representando um número binário. Cada caractere na string será '0' ou '1'.\n\n    Haverá um casal extra de caracteres 'db' no início e no final da string. Os caracteres extras estão lá para ajudar com o formato.\n\n    Exemplos:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Você receberá um número em forma decimal e sua tarefa é convertê-lo para formato binário. A função deve retornar uma string, com cada caractere representando um número binário. Cada caractere na string será '0' ou '1'.\n\n    Haverá um casal extra de caracteres 'db' no início e no final da string. Os caracteres extras estão lá para ajudar com o formato.\n\n    Exemplos:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Você recebe uma string s.\n    Sua tarefa é verificar se a string é feliz ou não.\n    Uma string é feliz se seu comprimento for pelo menos 3 e cada 3 letras consecutivas forem distintas.\n    Por exemplo:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Você recebe uma string s.\n    Sua tarefa é verificar se a string é feliz ou não.\n    Uma string é feliz se seu comprimento for pelo menos 3 e cada 3 letras consecutivas forem distintas.\n    Por exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"É a última semana do semestre e o professor precisa dar as notas aos alunos. O professor criou seu próprio algoritmo para classificação. O único problema é que ele perdeu o código que usou para classificar. Ele lhe deu uma lista de GPAs de alguns alunos e você deve escrever uma função que possa produzir uma lista de notas de letras usando a seguinte tabela:\n             GPA       |    Nota de letra\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Exemplo:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "É a última semana do semestre e o professor precisa dar as notas aos alunos. O professor criou seu próprio algoritmo para classificação. O único problema é que ele perdeu o código que usou para classificar. Ele lhe deu uma lista de GPAs de alguns alunos e você deve escrever uma função que possa produzir uma lista de notas de letras usando a seguinte tabela:\n             GPA       |    Nota de letra\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Escreva uma função que recebe uma string e retorna True se o comprimento da string for um número primo ou False caso contrário.\n    Exemplos\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Escreva uma função que recebe uma string e retorna True se o comprimento da string for um número primo ou False caso contrário.\n    Exemplos\n    ", "natural_language": "Portuguese"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Dado um número inteiro positivo N, retorne a soma total de seus dígitos em binário.\n\n        Exemplo\n        Para N = 1000, a soma dos dígitos será 1 e a saída deve ser \"1\".\n        Para N = 150, a soma dos dígitos será 6 e a saída deve ser \"110\".\n        Para N = 147, a soma dos dígitos será 12 e a saída deve ser \"1100\".\n    \n    Variáveis:\n        @N inteiro\n             Restrições: 0 ≤ N ≤ 10000.\n    Saída:\n         uma string de número binário.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Dado um número inteiro positivo N, retorne a soma total de seus dígitos em binário.\n\n        Exemplo\n        Para N = 1000, a soma dos dígitos será 1 e a saída deve ser \"1\".\n        Para N = 150, a soma dos dígitos será 6 e a saída deve ser \"110\".\n        Para N = 147, a soma dos dígitos será 12 e a saída deve ser \"1100\".\n    \n    Variáveis:\n        @N inteiro\n             Restrições: 0 ≤ N ≤ 10000.\n    Saída:\n         uma string de número binário.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Você recebe um conjunto de dados bidimensional, como listas aninhadas, que é semelhante a uma matriz, no entanto, ao contrário das matrizes, cada linha pode conter um número diferente de colunas. Dado lst e um inteiro x, encontre inteiros x na lista e retorne uma lista de tuplas, [(x1, y1), (x2, y2) ...] de modo que cada tupla seja uma coordenada - (linha, colunas), começando com 0. Classifique as coordenadas inicialmente por linhas em ordem crescente. Além disso, classifique as coordenadas da linha por colunas em ordem decrescente.\n\n    Exemplos:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Você recebe um conjunto de dados bidimensional, como listas aninhadas, que é semelhante a uma matriz, no entanto, ao contrário das matrizes, cada linha pode conter um número diferente de colunas. Dado lst e um inteiro x, encontre inteiros x na lista e retorne uma lista de tuplas, [(x1, y1), (x2, y2) ...] de modo que cada tupla seja uma coordenada - (linha, colunas), começando com 0. Classifique as coordenadas inicialmente por linhas em ordem crescente. Além disso, classifique as coordenadas da linha por colunas em ordem decrescente.\n\n    Exemplos:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Você recebe uma lista de inteiros.\nEscreva uma função next_smallest() que retorna o segundo menor elemento da lista.\nRetorne nulo se não houver tal elemento.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Você recebe uma lista de inteiros.\nEscreva uma função next_smallest() que retorna o segundo menor elemento da lista.\nRetorne nulo se não houver tal elemento.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Você receberá uma string de palavras e sua tarefa é contar o número de tédios. Um tédio é uma frase que começa com a palavra \"Eu\". As frases são delimitadas por '.', '?' ou '!'.\n\n    Por exemplo:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Você receberá uma string de palavras e sua tarefa é contar o número de tédios. Um tédio é uma frase que começa com a palavra \"Eu\". As frases são delimitadas por '.', '?' ou '!'.\n\n    Por exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Você recebe uma lista de inteiros.\n    Você precisa encontrar o maior valor primo e retornar a soma de seus dígitos.\n\n        Exemplos:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Você recebe uma lista de inteiros.\n    Você precisa encontrar o maior valor primo e retornar a soma de seus dígitos.\n\n        Exemplos:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Dado um dicionário, retorne True se todas as chaves forem strings em minúsculas ou todas as chaves forem strings em maiúsculas, caso contrário, retorne False. A função deve retornar False se o dicionário fornecido estiver vazio. Exemplos:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Dado um dicionário, retorne True se todas as chaves forem strings em minúsculas ou todas as chaves forem strings em maiúsculas, caso contrário, retorne False. A função deve retornar False se o dicionário fornecido estiver vazio. Exemplos:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Crie uma função que recebe um valor (string) representando um número e retorna o inteiro mais próximo. Se o número estiver equidistante de dois inteiros, arredonde-o para longe de zero.\n\n        Exemplos\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Crie uma função que recebe um valor (string) representando um número e retorna o inteiro mais próximo. Se o número estiver equidistante de dois inteiros, arredonde-o para longe de zero.\n\n        Exemplos\n    ", "natural_language": "Portuguese"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Dado um número inteiro positivo n, você deve fazer uma pilha de n níveis de pedras.\n    O primeiro nível tem n pedras.\n    O número de pedras no próximo nível é:\n        - o próximo número ímpar se n for ímpar.\n        - o próximo número par se n for par.\n    Retorne o número de pedras em cada nível em uma lista, onde o elemento no índice\n    i representa o número de pedras no nível (i+1).\n\n        Exemplos:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Dado um número inteiro positivo n, você deve fazer uma pilha de n níveis de pedras.\n    O primeiro nível tem n pedras.\n    O número de pedras no próximo nível é:\n        - o próximo número ímpar se n for ímpar.\n        - o próximo número par se n for par.\n    Retorne o número de pedras em cada nível em uma lista, onde o elemento no índice\n    i representa o número de pedras no nível (i+1).\n\n        Exemplos:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Você receberá uma string de palavras separadas por vírgulas ou espaços. Sua tarefa é dividir a string em palavras e retornar um array das palavras.\n\n    Por exemplo:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Você receberá uma string de palavras separadas por vírgulas ou espaços. Sua tarefa é dividir a string em palavras e retornar um array das palavras.\n\n    Por exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Esta função recebe dois números positivos x e y e retorna o maior número inteiro par que está no intervalo [x, y] inclusivo. Se não houver tal número, a função deve retornar -1.\n\n    Por exemplo:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Esta função recebe dois números positivos x e y e retorna o maior número inteiro par que está no intervalo [x, y] inclusivo. Se não houver tal número, a função deve retornar -1.\n\n    Por exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Você recebe dois inteiros positivos n e m e sua tarefa é calcular a média dos inteiros de n a m (incluindo n e m). Arredonde a resposta para o inteiro mais próximo e converta para binário. Se n for maior que m, retorne -1. Exemplo:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Você recebe dois inteiros positivos n e m e sua tarefa é calcular a média dos inteiros de n a m (incluindo n e m). Arredonde a resposta para o inteiro mais próximo e converta para binário. Se n for maior que m, retorne -1. Exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Implemente a função f que recebe n como parâmetro e retorna uma lista de tamanho n, tal que o valor do elemento no índice i é o fatorial de i se i for par ou a soma dos números de 1 a i caso contrário. i começa em 1. O fatorial de i é a multiplicação dos números de 1 a i (1 * 2 * ... * i). Exemplo:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Implemente a função f que recebe n como parâmetro e retorna uma lista de tamanho n, tal que o valor do elemento no índice i é o fatorial de i se i for par ou a soma dos números de 1 a i caso contrário. i começa em 1. O fatorial de i é a multiplicação dos números de 1 a i (1 * 2 * ... * i). Exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Dado um número inteiro positivo n, retorne uma tupla que contenha o número de palíndromos inteiros pares e ímpares que estão dentro do intervalo (1, n), inclusive.\n\n        Exemplo 1:\n\n            Entrada: 3\n        Saída: (1, 2)\n        Explicação:\n        Palíndromos inteiros são 1, 2, 3. Um deles é par e dois são ímpares.\n\n        Exemplo 2:\n\n            Entrada: 12\n        Saída: (4, 6)\n        Explicação:\n        Palíndromos inteiros são 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Quatro deles são pares e seis são ímpares.\n\n        Observação:\n        1. 1 <= n <= 10^3\n        2. A tupla retornada contém o número de palíndromos inteiros pares e ímpares, respectivamente.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Dado um número inteiro positivo n, retorne uma tupla que contenha o número de palíndromos inteiros pares e ímpares que estão dentro do intervalo (1, n), inclusive.\n\n        Exemplo 1:\n\n            Entrada: 3\n        Saída: (1, 2)\n        Explicação:\n        Palíndromos inteiros são 1, 2, 3. Um deles é par e dois são ímpares.\n\n        Exemplo 2:\n\n            Entrada: 12\n        Saída: (4, 6)\n        Explicação:\n        Palíndromos inteiros são 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Quatro deles são pares e seis são ímpares.\n\n        Observação:\n        1. 1 <= n <= 10^3\n        2. A tupla retornada contém o número de palíndromos inteiros pares e ímpares, respectivamente.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Temos um array 'arr' de N inteiros arr[1], arr[2], ..., arr[N]. Os números no array serão ordenados aleatoriamente. Sua tarefa é determinar se é possível obter um array ordenado em ordem não decrescente realizando a seguinte operação no array fornecido:\n        Você pode realizar a operação de deslocamento para a direita quantas vezes quiser.\n    \n    Uma operação de deslocamento para a direita significa deslocar todos os elementos do array em uma posição na direção certa. O último elemento do array será movido para a posição inicial no array, ou seja, índice 0. \n\n        Se for possível obter o array ordenado realizando a operação acima, retorne True, caso contrário, retorne False.\n    Se o array fornecido estiver vazio, retorne True.\n\n        Observação: A lista fornecida tem elementos exclusivos garantidos.\n\n        Por exemplo:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explicação: Realizando 2 operações de deslocamento para a direita, a ordem não decrescente pode ser alcançada para o array fornecido.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explicação: Não é possível obter ordem não decrescente para o array fornecido realizando qualquer número de operações de deslocamento para a direita.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Temos um array 'arr' de N inteiros arr[1], arr[2], ..., arr[N]. Os números no array serão ordenados aleatoriamente. Sua tarefa é determinar se é possível obter um array ordenado em ordem não decrescente realizando a seguinte operação no array fornecido:\n        Você pode realizar a operação de deslocamento para a direita quantas vezes quiser.\n    \n    Uma operação de deslocamento para a direita significa deslocar todos os elementos do array em uma posição na direção certa. O último elemento do array será movido para a posição inicial no array, ou seja, índice 0. \n\n        Se for possível obter o array ordenado realizando a operação acima, retorne True, caso contrário, retorne False.\n    Se o array fornecido estiver vazio, retorne True.\n\n        Observação: A lista fornecida tem elementos exclusivos garantidos.\n\n        Por exemplo:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explicação: Realizando 2 operações de deslocamento para a direita, a ordem não decrescente pode ser alcançada para o array fornecido.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explicação: Não é possível obter ordem não decrescente para o array fornecido realizando qualquer número de operações de deslocamento para a direita.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Neste problema, você implementará uma função que recebe duas listas de números e determina se é possível realizar uma troca de elementos entre elas para fazer com que lst1 seja uma lista apenas de números pares. Não há limite para o número de elementos trocados entre lst1 e lst2. Se for possível trocar elementos entre lst1 e lst2 para fazer com que todos os elementos de lst1 sejam pares, retorne \"YES\". Caso contrário, retorne \"NO\". Por exemplo: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Assume-se que as listas de entrada não estarão vazias.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "Neste problema, você implementará uma função que recebe duas listas de números e determina se é possível realizar uma troca de elementos entre elas para fazer com que lst1 seja uma lista apenas de números pares. Não há limite para o número de elementos trocados entre lst1 e lst2. Se for possível trocar elementos entre lst1 e lst2 para fazer com que todos os elementos de lst1 sejam pares, retorne \"YES\". Caso contrário, retorne \"NO\". Por exemplo: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Assume-se que as listas de entrada não estarão vazias.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Tarefa\n    São fornecidas duas strings s e c, você deve excluir todos os caracteres em s que são iguais a qualquer caractere em c\n    em seguida, verifique se a string resultante é um palíndromo.\n    Uma string é chamada de palíndromo se ela é lida da mesma forma de trás para frente.\n    Você deve retornar uma tupla contendo a string resultante e True/False para a verificação.\n    Exemplo\n    Para s = \"abcde\", c = \"ae\", o resultado deve ser ('bcd',False)\n    Para s = \"abcdef\", c = \"b\"  o resultado deve ser ('acdef',False)\n    Para s = \"abcdedcba\", c = \"ab\", o resultado deve ser ('cdedc',True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Tarefa\n    São fornecidas duas strings s e c, você deve excluir todos os caracteres em s que são iguais a qualquer caractere em c\n    em seguida, verifique se a string resultante é um palíndromo.\n    Uma string é chamada de palíndromo se ela é lida da mesma forma de trás para frente.\n    Você deve retornar uma tupla contendo a string resultante e True/False para a verificação.\n    Exemplo\n    Para s = \"abcde\", c = \"ae\", o resultado deve ser ('bcd',False)\n    Para s = \"abcdef\", c = \"b\"  o resultado deve ser ('acdef',False)\n    Para s = \"abcdedcba\", c = \"ab\", o resultado deve ser ('cdedc',True)\n    ", "natural_language": "Portuguese"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Você recebe uma grade retangular de poços. Cada linha representa um único poço e cada 1 em uma linha representa uma unidade única de água. Cada poço tem um balde correspondente que pode ser usado para extrair água dele e todos os baldes têm a mesma capacidade. Sua tarefa é usar os baldes para esvaziar os poços. Saída o número de vezes que você precisa abaixar os baldes.\n\n    Exemplo 1:\n    Entrada:\n        grade: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        capacidade_do_balde: 1\n    Saída: 6\n\n    Exemplo 2:\n    Entrada:\n        grade: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        capacidade_do_balde: 2\n    Saída: 5\n\n    Exemplo 3:\n    Entrada:\n        grade: [[0,0,0], [0,0,0]]\n        capacidade_do_balde: 5\n    Saída: 0\n\n    Restrições:\n    * todos os poços têm o mesmo comprimento\n    * 1 <= comprimento_da_grade <= 10^2\n    * 1 <= comprimento_da_grade[0] <= 10^2\n    * grade[i][j] -> 0 | 1\n    * 1 <= capacidade <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Você recebe uma grade retangular de poços. Cada linha representa um único poço e cada 1 em uma linha representa uma unidade única de água. Cada poço tem um balde correspondente que pode ser usado para extrair água dele e todos os baldes têm a mesma capacidade. Sua tarefa é usar os baldes para esvaziar os poços. Saída o número de vezes que você precisa abaixar os baldes.\n\n    Exemplo 1:\n    Entrada:\n        grade: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        capacidade_do_balde: 1\n    Saída: 6\n\n    Exemplo 2:\n    Entrada:\n        grade: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        capacidade_do_balde: 2\n    Saída: 5\n\n    Exemplo 3:\n    Entrada:\n        grade: [[0,0,0], [0,0,0]]\n        capacidade_do_balde: 5\n    Saída: 0\n\n    Restrições:\n    * todos os poços têm o mesmo comprimento\n    * 1 <= comprimento_da_grade <= 10^2\n    * 1 <= comprimento_da_grade[0] <= 10^2\n    * grade[i][j] -> 0 | 1\n    * 1 <= capacidade <= 10\n    ", "natural_language": "Portuguese"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Dado uma string s e um número natural n, você foi encarregado de implementar uma função que retorna uma lista de todas as palavras da string s que contêm exatamente n consoantes, na ordem em que essas palavras aparecem na string s. Se a string s estiver vazia, a função deve retornar uma lista vazia. Observação: você pode assumir que a string de entrada contém apenas letras e espaços. Exemplos:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Dado uma string s e um número natural n, você foi encarregado de implementar uma função que retorna uma lista de todas as palavras da string s que contêm exatamente n consoantes, na ordem em que essas palavras aparecem na string s. Se a string s estiver vazia, a função deve retornar uma lista vazia. Observação: você pode assumir que a string de entrada contém apenas letras e espaços. Exemplos:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Dado um array arr de inteiros e um inteiro positivo k, retorne uma lista ordenada de comprimento k com os k maiores números em arr.\n\n    Exemplo 1:\n\n        Entrada: arr = [-3, -4, 5], k = 3\n    Saída: [-4, -3, 5]\n\n    Exemplo 2:\n\n        Entrada: arr = [4, -4, 4], k = 2\n    Saída: [4, 4]\n\n    Exemplo 3:\n\n        Entrada: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Saída: [2]\n\n    Observação:\n    1. O comprimento do array estará no intervalo [1, 1000].\n    2. Os elementos no array estarão no intervalo de [-1000, 1000].\n    3. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Dado um array arr de inteiros e um inteiro positivo k, retorne uma lista ordenada de comprimento k com os k maiores números em arr.\n\n    Exemplo 1:\n\n        Entrada: arr = [-3, -4, 5], k = 3\n    Saída: [-4, -3, 5]\n\n    Exemplo 2:\n\n        Entrada: arr = [4, -4, 4], k = 2\n    Saída: [4, 4]\n\n    Exemplo 3:\n\n        Entrada: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Saída: [2]\n\n    Observação:\n    1. O comprimento do array estará no intervalo [1, 1000].\n    2. Os elementos no array estarão no intervalo de [-1000, 1000].\n    3. 0 <= k <= len(arr)\n    ", "natural_language": "Portuguese"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Dado um array não vazio de inteiros arr e um inteiro k, retorne a soma dos elementos com no máximo dois dígitos dos primeiros k elementos de arr.\n\n    Exemplo:\n\n        Entrada: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Saída: 24 # soma de 21 + 3\n\n    Restrições:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Dado um array não vazio de inteiros arr e um inteiro k, retorne a soma dos elementos com no máximo dois dígitos dos primeiros k elementos de arr.\n\n    Exemplo:\n\n        Entrada: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Saída: 24 # soma de 21 + 3\n\n    Restrições:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    ", "natural_language": "Portuguese"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Você recebe dois intervalos,\n    onde cada intervalo é um par de inteiros. Por exemplo, intervalo = (início, fim) = (1, 2).\n    Os intervalos dados são fechados, o que significa que o intervalo (início, fim)\n    inclui tanto o início quanto o fim.\n    Para cada intervalo dado, assume-se que o início é menor ou igual ao fim.\n    Sua tarefa é determinar se o comprimento da interseção desses dois\n    intervalos é um número primo.\n    Por exemplo, a interseção dos intervalos (1, 3), (2, 4) é (2, 3)\n    cujo comprimento é 1, que não é um número primo.\n    Se o comprimento da interseção for um número primo, retorne \"YES\",\n    caso contrário, retorne \"NO\".\n    Se os dois intervalos não se intersectarem, retorne \"NO\".\n\n    \n    Amostras de entrada/saída:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Você recebe dois intervalos,\n    onde cada intervalo é um par de inteiros. Por exemplo, intervalo = (início, fim) = (1, 2).\n    Os intervalos dados são fechados, o que significa que o intervalo (início, fim)\n    inclui tanto o início quanto o fim.\n    Para cada intervalo dado, assume-se que o início é menor ou igual ao fim.\n    Sua tarefa é determinar se o comprimento da interseção desses dois\n    intervalos é um número primo.\n    Por exemplo, a interseção dos intervalos (1, 3), (2, 4) é (2, 3)\n    cujo comprimento é 1, que não é um número primo.\n    Se o comprimento da interseção for um número primo, retorne \"YES\",\n    caso contrário, retorne \"NO\".\n    Se os dois intervalos não se intersectarem, retorne \"NO\".\n\n    \n    Amostras de entrada/saída:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Todo mundo conhece a sequência de Fibonacci, que foi estudada profundamente por matemáticos nos últimos séculos. No entanto, o que as pessoas não sabem é a sequência de Tribonacci. A sequência de Tribonacci é definida pela recorrência:\ntri(1) = 3\ntri(n) = 1 + n / 2, se n for par.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), se n for ímpar.\nPor exemplo:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nVocê recebe um número inteiro não negativo n e deve retornar uma lista dos primeiros n + 1 números da sequência de Tribonacci.\nExemplos:\ntri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Todo mundo conhece a sequência de Fibonacci, que foi estudada profundamente por matemáticos nos últimos séculos. No entanto, o que as pessoas não sabem é a sequência de Tribonacci. A sequência de Tribonacci é definida pela recorrência:\ntri(1) = 3\ntri(n) = 1 + n / 2, se n for par.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), se n for ímpar.\nPor exemplo:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nVocê recebe um número inteiro não negativo n e deve retornar uma lista dos primeiros n + 1 números da sequência de Tribonacci.\nExemplos:\ntri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Portuguese"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Dado um número inteiro positivo n, retorne o produto dos dígitos ímpares.\n    Retorne 0 se todos os dígitos forem pares.\n    Por exemplo:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Dado um número inteiro positivo n, retorne o produto dos dígitos ímpares.\n    Retorne 0 se todos os dígitos forem pares.\n    Por exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Crie uma função que recebe uma string como entrada contendo apenas colchetes.\nA função deve retornar True se e somente se houver uma subsequência válida de colchetes\nonde pelo menos um colchete na subsequência está aninhado.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Crie uma função que recebe uma string como entrada contendo apenas colchetes.\nA função deve retornar True se e somente se houver uma subsequência válida de colchetes\nonde pelo menos um colchete na subsequência está aninhado.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Você recebe uma lista de números.\n    Você precisa retornar a soma dos números ao quadrado na lista dada,\n    arredonde cada elemento na lista para o inteiro superior (teto) primeiro.\n    Exemplos:\n    Para lst = [1,2,3], a saída deve ser 14\n    Para lst = [1,4,9], a saída deve ser 98\n    Para lst = [1,3,5,7], a saída deve ser 84\n    Para lst = [1.4,4.2,0], a saída deve ser 29\n    Para lst = [-2.4,1,1], a saída deve ser 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Você recebe uma lista de números.\n    Você precisa retornar a soma dos números ao quadrado na lista dada,\n    arredonde cada elemento na lista para o inteiro superior (teto) primeiro.\n    Exemplos:\n    Para lst = [1,2,3], a saída deve ser 14\n    Para lst = [1,4,9], a saída deve ser 98\n    Para lst = [1,3,5,7], a saída deve ser 84\n    Para lst = [1.4,4.2,0], a saída deve ser 29\n    Para lst = [-2.4,1,1], a saída deve ser 6\n    ", "natural_language": "Portuguese"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Crie uma função que retorna True se o último caractere de uma string dada é um caractere alfabético e não faz parte de uma palavra, e False caso contrário. Observação: \"palavra\" é um grupo de caracteres separados por espaço.\n\n    Exemplos:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Crie uma função que retorna True se o último caractere de uma string dada é um caractere alfabético e não faz parte de uma palavra, e False caso contrário. Observação: \"palavra\" é um grupo de caracteres separados por espaço.\n\n    Exemplos:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Crie uma função que retorna o índice mais alto de um elemento que não é maior ou igual ao elemento imediatamente anterior. Se não houver tal elemento, retorne -1. O array fornecido não conterá valores duplicados.\n\n    Exemplos:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Crie uma função que retorna o índice mais alto de um elemento que não é maior ou igual ao elemento imediatamente anterior. Se não houver tal elemento, retorne -1. O array fornecido não conterá valores duplicados.\n\n    Exemplos:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Crie uma função que retorna uma tupla (a, b), onde 'a' é o maior dos inteiros negativos e 'b' é o menor dos inteiros positivos em uma lista. Se não houver inteiros negativos ou positivos, retorne-os como None.\n\n    Exemplos:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Crie uma função que retorna uma tupla (a, b), onde 'a' é o maior dos inteiros negativos e 'b' é o menor dos inteiros positivos em uma lista. Se não houver inteiros negativos ou positivos, retorne-os como None.\n\n    Exemplos:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"O fatorial brasileiro é definido como:\n    fatorial_brasileiro(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    onde n > 0\n\n        Por exemplo:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "O fatorial brasileiro é definido como:\n    fatorial_brasileiro(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    onde n > 0\n\n        Por exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Você recebe uma string representando uma frase,\n    a frase contém algumas palavras separadas por um espaço,\n    e você deve retornar uma string que contenha as palavras da frase original,\n    cujos comprimentos são números primos,\n    a ordem das palavras na nova string deve ser a mesma da original.\n\n        Exemplo 1:\n        Entrada: sentence = \"This is a test\"\n        Saída: \"is\"\n\n        Exemplo 2:\n        Entrada: sentence = \"lets go for swimming\"\n        Saída: \"go for\"\n\n        Restrições:\n        * 1 <= len(sentence) <= 100\n        * sentence contém apenas letras\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Você recebe uma string representando uma frase,\n    a frase contém algumas palavras separadas por um espaço,\n    e você deve retornar uma string que contenha as palavras da frase original,\n    cujos comprimentos são números primos,\n    a ordem das palavras na nova string deve ser a mesma da original.\n\n        Exemplo 1:\n        Entrada: sentence = \"This is a test\"\n        Saída: \"is\"\n\n        Exemplo 2:\n        Entrada: sentence = \"lets go for swimming\"\n        Saída: \"go for\"\n\n        Restrições:\n        * 1 <= len(sentence) <= 100\n        * sentence contém apenas letras\n    ", "natural_language": "Portuguese"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Sua tarefa é implementar uma função que simplificará a expressão x * n. A função retorna True se x * n avaliar para um número inteiro e False caso contrário. Tanto x quanto n são representações de string de uma fração e têm o seguinte formato, <numerador>/<denominador>, onde tanto o numerador quanto o denominador são números inteiros positivos.\n\n    Você pode assumir que x e n são frações válidas e não têm zero como denominador.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Sua tarefa é implementar uma função que simplificará a expressão x * n. A função retorna True se x * n avaliar para um número inteiro e False caso contrário. Tanto x quanto n são representações de string de uma fração e têm o seguinte formato, <numerador>/<denominador>, onde tanto o numerador quanto o denominador são números inteiros positivos.\n\n    Você pode assumir que x e n são frações válidas e não têm zero como denominador.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Escreva uma função que ordena a lista dada de inteiros em ordem crescente de acordo com a soma de seus dígitos. Observação: se houver vários itens com soma de dígitos semelhante, ordene-os com base em seu índice na lista original.\n\n    Por exemplo:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Escreva uma função que ordena a lista dada de inteiros em ordem crescente de acordo com a soma de seus dígitos. Observação: se houver vários itens com soma de dígitos semelhante, ordene-os com base em seu índice na lista original.\n\n    Por exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Escreva uma função que recebe um array de números como entrada e retorna o número de elementos no array que são maiores que 10 e ambos os primeiros e últimos dígitos de um número são ímpares (1, 3, 5, 7, 9). Por exemplo:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Escreva uma função que recebe um array de números como entrada e retorna o número de elementos no array que são maiores que 10 e ambos os primeiros e últimos dígitos de um número são ímpares (1, 3, 5, 7, 9). Por exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Você recebe um número inteiro positivo n. Você deve criar um array de inteiros a de comprimento n.\n        Para cada i (1 ≤ i ≤ n), o valor de a[i] = i * i - i + 1.\n        Retorne o número de triplas (a[i], a[j], a[k]) de a onde i < j < k, \n    e a[i] + a[j] + a[k] é um múltiplo de 3.\n\n        Exemplo:\n        Entrada: n = 5\n        Saída: 1\n        Explicação:\n        a = [1, 3, 7, 13, 21]\n        A única tripla válida é (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Você recebe um número inteiro positivo n. Você deve criar um array de inteiros a de comprimento n.\n        Para cada i (1 ≤ i ≤ n), o valor de a[i] = i * i - i + 1.\n        Retorne o número de triplas (a[i], a[j], a[k]) de a onde i < j < k, \n    e a[i] + a[j] + a[k] é um múltiplo de 3.\n\n        Exemplo:\n        Entrada: n = 5\n        Saída: 1\n        Explicação:\n        a = [1, 3, 7, 13, 21]\n        A única tripla válida é (1, 7, 13).\n    ", "natural_language": "Portuguese"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    Existem oito planetas em nosso sistema solar: o mais próximo do Sol é Mercúrio, o próximo é Vênus, depois Terra, Marte, Júpiter, Saturno, Urano e Netuno. Escreva uma função que receba dois nomes de planetas como strings, planet1 e planet2. A função deve retornar uma tupla contendo todos os planetas cujas órbitas estão localizadas entre a órbita de planet1 e a órbita de planet2, ordenados pela proximidade com o sol. A função deve retornar uma tupla vazia se planet1 ou planet2 não forem nomes corretos de planetas. Exemplos.\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "Existem oito planetas em nosso sistema solar: o mais próximo do Sol é Mercúrio, o próximo é Vênus, depois Terra, Marte, Júpiter, Saturno, Urano e Netuno. Escreva uma função que receba dois nomes de planetas como strings, planet1 e planet2. A função deve retornar uma tupla contendo todos os planetas cujas órbitas estão localizadas entre a órbita de planet1 e a órbita de planet2, ordenados pela proximidade com o sol. A função deve retornar uma tupla vazia se planet1 ou planet2 não forem nomes corretos de planetas. Exemplos.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Um programa simples que deve retornar o valor de x se n for um número primo e deve retornar o valor de y caso contrário.\n\n    Exemplos:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Um programa simples que deve retornar o valor de x se n for um número primo e deve retornar o valor de y caso contrário.\n\n    Exemplos:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Dado uma lista de números, retorne a soma dos quadrados dos números ímpares na lista. Ignore números que são negativos ou não inteiros.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n        Se a lista de entrada estiver vazia, retorne 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Dado uma lista de números, retorne a soma dos quadrados dos números ímpares na lista. Ignore números que são negativos ou não inteiros.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n        Se a lista de entrada estiver vazia, retorne 0.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Você receberá o nome de uma classe (uma string) e uma lista de extensões.\n    As extensões devem ser usadas para carregar classes adicionais para a classe. A\n    força da extensão é a seguinte: seja CAP o número de letras maiúsculas\n    no nome da extensão e seja SM o número de letras minúsculas\n    no nome da extensão, a força é dada pela fração CAP - SM.\n    Você deve encontrar a extensão mais forte e retornar uma string neste\n    formato: NomeDaClasse.NomeDaExtensãoMaisForte.\n    Se houver duas ou mais extensões com a mesma força, você deve\n    escolher aquela que aparece primeiro na lista.\n    Por exemplo, se você receber \"Slices\" como a classe e uma lista de\n    extensões: ['SErviNGSliCes', 'Cheese', 'StuFfed'], então você deve\n    retornar 'Slices.SErviNGSliCes', já que 'SErviNGSliCes' é a extensão mais forte\n    (sua força é -1).\n    Exemplo:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Você receberá o nome de uma classe (uma string) e uma lista de extensões.\n    As extensões devem ser usadas para carregar classes adicionais para a classe. A\n    força da extensão é a seguinte: seja CAP o número de letras maiúsculas\n    no nome da extensão e seja SM o número de letras minúsculas\n    no nome da extensão, a força é dada pela fração CAP - SM.\n    Você deve encontrar a extensão mais forte e retornar uma string neste\n    formato: NomeDaClasse.NomeDaExtensãoMaisForte.\n    Se houver duas ou mais extensões com a mesma força, você deve\n    escolher aquela que aparece primeiro na lista.\n    Por exemplo, se você receber \"Slices\" como a classe e uma lista de\n    extensões: ['SErviNGSliCes', 'Cheese', 'StuFfed'], então você deve\n    retornar 'Slices.SErviNGSliCes', já que 'SErviNGSliCes' é a extensão mais forte\n    (sua força é -1).\n    Exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Você recebe 2 palavras. Você precisa retornar True se a segunda palavra ou qualquer uma de suas rotações for uma substring na primeira palavra.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Você recebe 2 palavras. Você precisa retornar True se a segunda palavra ou qualquer uma de suas rotações for uma substring na primeira palavra.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Dado um número inteiro positivo, obtenha seu equivalente em numeral romano como uma string e retorne em minúsculas.\nRestrições: 1 <= num <= 1000\n\n    Exemplos:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Dado um número inteiro positivo, obtenha seu equivalente em numeral romano como uma string e retorne em minúsculas.\nRestrições: 1 <= num <= 1000\n\n    Exemplos:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Dado os comprimentos dos três lados de um triângulo. Retorne True se os três lados formarem um triângulo retângulo, False caso contrário. Um triângulo retângulo é um triângulo em que um ângulo é reto ou 90 graus. Exemplo:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Dado os comprimentos dos três lados de um triângulo. Retorne True se os três lados formarem um triângulo retângulo, False caso contrário. Um triângulo retângulo é um triângulo em que um ângulo é reto ou 90 graus. Exemplo:\n    ", "natural_language": "Portuguese"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Você recebe uma string s.\n    Se s[i] for uma letra, inverta seu caso de minúsculo para maiúsculo ou vice-versa,\n    caso contrário, mantenha-o como está.\n    Se a string não contiver letras, inverta a string.\n    A função deve retornar a string resultante.\n    Exemplos\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Você recebe uma string s.\n    Se s[i] for uma letra, inverta seu caso de minúsculo para maiúsculo ou vice-versa,\n    caso contrário, mantenha-o como está.\n    Se a string não contiver letras, inverta a string.\n    A função deve retornar a string resultante.\n    Exemplos\n    ", "natural_language": "Portuguese"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Dado uma string 'texto', retorne uma string equivalente ao hash md5 dela.\n    Se 'texto' for uma string vazia, retorne nulo.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Dado uma string 'texto', retorne uma string equivalente ao hash md5 dela.\n    Se 'texto' for uma string vazia, retorne nulo.\n    ", "natural_language": "Portuguese"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Dado dois inteiros positivos a e b, retorne os dígitos pares entre a e b, em ordem crescente.\n\n    Por exemplo:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Dado dois inteiros positivos a e b, retorne os dígitos pares entre a e b, em ordem crescente.\n\n    Por exemplo:\n    ", "natural_language": "Portuguese"}
