{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Sinulle annetaan lista talletus- ja nostotoimenpiteistä pankkitilillä, joka alkaa nollatilillä. Tehtäväsi on havaita, laskeeko tilin saldo missä tahansa vaiheessa alle nollan, ja tällöin funktion tulisi palauttaa True. Muussa tapauksessa sen tulisi palauttaa False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Sinulle annetaan lista talletus- ja nostotoimenpiteistä pankkitilillä, joka alkaa nollatilillä. Tehtäväsi on havaita, laskeeko tilin saldo missä tahansa vaiheessa alle nollan, ja tällöin funktion tulisi palauttaa True. Muussa tapauksessa sen tulisi palauttaa False.\n    ", "natural_language": "Finnish"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Annettuna kokonaislukulistalle, palauta tuple, joka koostuu summan ja kaikkien listan kokonaislukujen tulon summasta.\nTyhjä summa on yhtä suuri kuin 0 ja tyhjä tulo on yhtä suuri kuin 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Annettuna kokonaislukulistalle, palauta tuple, joka koostuu summan ja kaikkien listan kokonaislukujen tulon summasta.\nTyhjä summa on yhtä suuri kuin 0 ja tyhjä tulo on yhtä suuri kuin 1.\n    ", "natural_language": "Finnish"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Syötteet ovat kaksi merkkijonoa a ja b, jotka koostuvat vain 1:stä ja 0:sta.\n    Suorita binäärinen XOR näillä syötteillä ja palauta tulos myös merkkijonona.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "Syötteet ovat kaksi merkkijonoa a ja b, jotka koostuvat vain 1:stä ja 0:sta.\n    Suorita binäärinen XOR näillä syötteillä ja palauta tulos myös merkkijonona.\n    ", "natural_language": "Finnish"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Palauta merkkijonojen listasta pisin. Palauta ensimmäinen, jos useita merkkijonoja on saman pituisia. Palauta null, jos syötelista on tyhjä.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "Palauta merkkijonojen listasta pisin. Palauta ensimmäinen, jos useita merkkijonoja on saman pituisia. Palauta null, jos syötelista on tyhjä.\n    ", "natural_language": "Finnish"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Palauta kahden kokonaisluvun a ja b suurin yhteinen tekijä.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Palauta kahden kokonaisluvun a ja b suurin yhteinen tekijä.\n    ", "natural_language": "Finnish"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Syöte on välilyönnillä erotettu merkkijono numeroita 'nolla' ja 'yhdeksän' välillä.\n    Hyväksytyt valinnat ovat 'nolla', 'yksi', 'kaksi', 'kolme', 'neljä', 'viisi', 'kuusi', 'seitsemän', 'kahdeksan' ja 'yhdeksän'.\n    Palauta merkkijono, jossa numerot on järjestetty pienimmästä suurimpaan.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "Syöte on välilyönnillä erotettu merkkijono numeroita 'nolla' ja 'yhdeksän' välillä.\n    Hyväksytyt valinnat ovat 'nolla', 'yksi', 'kaksi', 'kolme', 'neljä', 'viisi', 'kuusi', 'seitsemän', 'kahdeksan' ja 'yhdeksän'.\n    Palauta merkkijono, jossa numerot on järjestetty pienimmästä suurimpaan.\n    ", "natural_language": "Finnish"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Annettuna on lista numeroita (vähintään kahdesta elementistä), sovelletaanko lineaarista muunnosta tähän listaan, jolloin pienin numero muuttuu 0:ksi ja suurin 1:ksi.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Annettuna on lista numeroita (vähintään kahdesta elementistä), sovelletaanko lineaarista muunnosta tähän listaan, jolloin pienin numero muuttuu 0:ksi ja suurin 1:ksi.\n    ", "natural_language": "Finnish"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Annetulle merkkijonolle käännä pienikirjaimiset merkit isoiksi kirjaimiksi ja isot kirjaimet pieniksi kirjaimiksi.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Annetulle merkkijonolle käännä pienikirjaimiset merkit isoiksi kirjaimiksi ja isot kirjaimet pieniksi kirjaimiksi.\n    ", "natural_language": "Finnish"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Palauta vain positiiviset numerot listassa.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Palauta vain positiiviset numerot listassa.\n    ", "natural_language": "Finnish"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Palauta totuusarvo, jos annettu luku on alkuluku, ja epätosi muuten.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Palauta totuusarvo, jos annettu luku on alkuluku, ja epätosi muuten.\n    ", "natural_language": "Finnish"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Palauta järjestetyt uniikit elementit listassa.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Palauta järjestetyt uniikit elementit listassa.\n    ", "natural_language": "Finnish"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib palauttaa n:nnen luvun, joka on Fibonacci-luku ja myös alkuluku.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib palauttaa n:nnen luvun, joka on Fibonacci-luku ja myös alkuluku.\n    ", "natural_language": "Finnish"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero ottaa syötteenä kokonaislukulistaa.\nSe palauttaa True, jos listassa on kolme erillistä alkiota, jotka\nsummattuna antavat nollan, ja False muussa tapauksessa.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "triples_sum_to_zero ottaa syötteenä kokonaislukulistaa.\nSe palauttaa True, jos listassa on kolme erillistä alkiota, jotka\nsummattuna antavat nollan, ja False muussa tapauksessa.\n    ", "natural_language": "Finnish"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero ottaa kokonaislukulistana syötteen.\n    Se palauttaa True, jos listassa on kaksi erillistä alkiota, jotka\n    summana ovat nolla, ja False muussa tapauksessa.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "pairs_sum_to_zero ottaa kokonaislukulistana syötteen.\n    Se palauttaa True, jos listassa on kaksi erillistä alkiota, jotka\n    summana ovat nolla, ja False muussa tapauksessa.\n    ", "natural_language": "Finnish"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Fib4-numerosarja on Fibbonacci-sarjan kaltainen sarja, joka on määritelty seuraavasti:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Kirjoita funktio, joka laskee tehokkaasti fib4-numerosarjan n:nnen alkion. Älä käytä rekursiota.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "Fib4-numerosarja on Fibbonacci-sarjan kaltainen sarja, joka on määritelty seuraavasti:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Kirjoita funktio, joka laskee tehokkaasti fib4-numerosarjan n:nnen alkion. Älä käytä rekursiota.\n    ", "natural_language": "Finnish"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Palauta listan l elementtien mediaani.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Palauta listan l elementtien mediaani.\n    ", "natural_language": "Finnish"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Tarkistaa, onko annettu merkkijono palindromi.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Tarkistaa, onko annettu merkkijono palindromi.\n    ", "natural_language": "Finnish"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels on funktio, joka ottaa merkkijonon ja palauttaa merkkijonon ilman vokaaleja.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels on funktio, joka ottaa merkkijonon ja palauttaa merkkijonon ilman vokaaleja.\n    ", "natural_language": "Finnish"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Palauta True, jos kaikki listan l numerot ovat alle kynnyksen tason t.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Palauta True, jos kaikki listan l numerot ovat alle kynnyksen tason t.\n    ", "natural_language": "Finnish"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Lisää kaksi lukua x ja y.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Lisää kaksi lukua x ja y.\n    ", "natural_language": "Finnish"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Tarkista, ovatko kahdella sanalla samat merkit.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Tarkista, ovatko kahdella sanalla samat merkit.\n    ", "natural_language": "Finnish"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Palauta n:s Fibonacci-luku.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Palauta n:s Fibonacci-luku.\n    ", "natural_language": "Finnish"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Palauta järjestetyt ja uniikit yhteiset elementit kahdelle listalle.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Palauta järjestetyt ja uniikit yhteiset elementit kahdelle listalle.\n    ", "natural_language": "Finnish"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Palauta n:n suurin alkulukutekijä. Oletetaan, että n > 1 eikä se ole alkuluku.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Palauta n:n suurin alkulukutekijä. Oletetaan, että n > 1 eikä se ole alkuluku.\n    ", "natural_language": "Finnish"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n on funktio, joka laskee lukujen summan 1:stä n:ään.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n on funktio, joka laskee lukujen summan 1:stä n:ään.\n    ", "natural_language": "Finnish"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs edustaa polynomin kertoimia.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Palauta tämän polynomin derivaatta samassa muodossa.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs edustaa polynomin kertoimia.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Palauta tämän polynomin derivaatta samassa muodossa.\n    ", "natural_language": "Finnish"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"FibFib-numerosarja on sarja, joka muistuttaa Fibonaccin sarjaa ja joka on määritelty seuraavasti:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Kirjoita funktio, joka laskee tehokkaasti FibFib-numerosarjan n:nnen alkion.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "FibFib-numerosarja on sarja, joka muistuttaa Fibonaccin sarjaa ja joka on määritelty seuraavasti:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Kirjoita funktio, joka laskee tehokkaasti FibFib-numerosarjan n:nnen alkion.\n    ", "natural_language": "Finnish"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Kirjoita funktio vowels_count, joka ottaa syötteeksi merkkijonon, joka edustaa sanaa, ja palauttaa vokaalien määrän merkkijonossa. Vokaalit tässä tapauksessa ovat 'a', 'e', 'i', 'o', 'u'. Tässä tapauksessa 'y' on myös vokaali, mutta vain kun se on annetun sanan lopussa.\n\n    Esimerkki:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Kirjoita funktio vowels_count, joka ottaa syötteeksi merkkijonon, joka edustaa sanaa, ja palauttaa vokaalien määrän merkkijonossa. Vokaalit tässä tapauksessa ovat 'a', 'e', 'i', 'o', 'u'. Tässä tapauksessa 'y' on myös vokaali, mutta vain kun se on annetun sanan lopussa.\n\n    Esimerkki:\n    ", "natural_language": "Finnish"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Sinulle annetaan ei-tyhjä lista positiivisia kokonaislukuja. Palauta suurin kokonaisluku, joka on suurempi kuin nolla ja jonka esiintymistiheys on suurempi tai yhtä suuri kuin luvun arvo. Kokonaisluvun esiintymistiheys on se, kuinka monta kertaa se esiintyy listassa. Jos tällaista arvoa ei ole, palauta -1. Esimerkkejä:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Sinulle annetaan ei-tyhjä lista positiivisia kokonaislukuja. Palauta suurin kokonaisluku, joka on suurempi kuin nolla ja jonka esiintymistiheys on suurempi tai yhtä suuri kuin luvun arvo. Kokonaisluvun esiintymistiheys on se, kuinka monta kertaa se esiintyy listassa. Jos tällaista arvoa ei ole, palauta -1. Esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Annettuna kolmen kolmion sivun pituudet. Palauta kolmion pinta-ala pyöristettynä kahteen desimaaliin, jos kolme sivua muodostavat kelvollisen kolmion. Muussa tapauksessa palauta -1. Kolme sivua muodostavat kelvollisen kolmion, kun minkä tahansa kahden sivun summa on suurempi kuin kolmas sivu. Esimerkki:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Annettuna kolmen kolmion sivun pituudet. Palauta kolmion pinta-ala pyöristettynä kahteen desimaaliin, jos kolme sivua muodostavat kelvollisen kolmion. Muussa tapauksessa palauta -1. Kolme sivua muodostavat kelvollisen kolmion, kun minkä tahansa kahden sivun summa on suurempi kuin kolmas sivu. Esimerkki:\n    ", "natural_language": "Finnish"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Kirjoita funktio, joka palauttaa True, jos kohde q lentää, ja False muuten.\nKohde q lentää, jos se on tasapainossa (se on palindrominen lista) ja sen elementtien summa on pienempi tai yhtä suuri kuin mahdollinen maksimipaino w.\n\n    Esimerkki:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 on vähemmän kuin mahdollinen maksimipaino, mutta se on epätasapainossa.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# se on tasapainossa, mutta 3+2+3 on enemmän kuin mahdollinen maksimipaino.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 on vähemmän kuin mahdollinen maksimipaino, ja se on tasapainossa.\n\n    will_it_fly([3], 5) ➞ True\n# 3 on vähemmän kuin mahdollinen maksimipaino, ja se on tasapainossa.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Kirjoita funktio, joka palauttaa True, jos kohde q lentää, ja False muuten.\nKohde q lentää, jos se on tasapainossa (se on palindrominen lista) ja sen elementtien summa on pienempi tai yhtä suuri kuin mahdollinen maksimipaino w.\n\n    Esimerkki:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 on vähemmän kuin mahdollinen maksimipaino, mutta se on epätasapainossa.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# se on tasapainossa, mutta 3+2+3 on enemmän kuin mahdollinen maksimipaino.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 on vähemmän kuin mahdollinen maksimipaino, ja se on tasapainossa.\n\n    will_it_fly([3], 5) ➞ True\n# 3 on vähemmän kuin mahdollinen maksimipaino, ja se on tasapainossa.\n    ", "natural_language": "Finnish"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Kirjoita funktio, joka palauttaa toden, jos annettu luku on kolmen alkuluvun tulo, ja väärin muuten. Tiedetään, että (a) on alle 100. Esimerkki:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Kirjoita funktio, joka palauttaa toden, jos annettu luku on kolmen alkuluvun tulo, ja väärin muuten. Tiedetään, että (a) on alle 100. Esimerkki:\n    ", "natural_language": "Finnish"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Sinulle annetaan luku desimaalimuodossa ja tehtäväsi on muuntaa se binäärimuotoon. Funktio palauttaa merkkijonon, jossa jokainen merkki edustaa binäärilukua. Jokainen merkki merkkijonossa on '0' tai '1'.\n\n    Merkkijonon alussa ja lopussa on ylimääräiset merkit 'db'. Ylimääräiset merkit auttavat muodon kanssa.\n\n    Esimerkkejä:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Sinulle annetaan luku desimaalimuodossa ja tehtäväsi on muuntaa se binäärimuotoon. Funktio palauttaa merkkijonon, jossa jokainen merkki edustaa binäärilukua. Jokainen merkki merkkijonossa on '0' tai '1'.\n\n    Merkkijonon alussa ja lopussa on ylimääräiset merkit 'db'. Ylimääräiset merkit auttavat muodon kanssa.\n\n    Esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Sinulle annetaan merkkijono s.\nTehtäväsi on tarkistaa, onko merkkijono onnellinen vai ei.\nMerkkijono on onnellinen, jos sen pituus on vähintään 3 ja jokaiset kolme peräkkäistä kirjainta ovat erilaisia.\nEsimerkiksi:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Sinulle annetaan merkkijono s.\nTehtäväsi on tarkistaa, onko merkkijono onnellinen vai ei.\nMerkkijono on onnellinen, jos sen pituus on vähintään 3 ja jokaiset kolme peräkkäistä kirjainta ovat erilaisia.\nEsimerkiksi:\n    ", "natural_language": "Finnish"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"On viimeinen viikko lukukauden lopussa ja opettajan täytyy antaa arvosanat opiskelijoille. Opettaja on kehittänyt oman algoritminsa arvosteluun, mutta hän on kadottanut käyttämänsä koodin. Hän on antanut sinulle listan opiskelijoiden GPA-arvosanoista ja sinun täytyy kirjoittaa funktio, joka voi tuottaa listan kirjainarvosanoista seuraavan taulukon mukaisesti:\n\n                 GPA       |    Kirjainarvosana\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Esimerkki:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "On viimeinen viikko lukukauden lopussa ja opettajan täytyy antaa arvosanat opiskelijoille. Opettaja on kehittänyt oman algoritminsa arvosteluun, mutta hän on kadottanut käyttämänsä koodin. Hän on antanut sinulle listan opiskelijoiden GPA-arvosanoista ja sinun täytyy kirjoittaa funktio, joka voi tuottaa listan kirjainarvosanoista seuraavan taulukon mukaisesti:\n\n                 GPA       |    Kirjainarvosana\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Esimerkki:\n    ", "natural_language": "Finnish"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Kirjoita funktio, joka ottaa merkkijonon ja palauttaa True, jos merkkijonon pituus on alkuluku, muuten False.\nEsimerkit\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Kirjoita funktio, joka ottaa merkkijonon ja palauttaa True, jos merkkijonon pituus on alkuluku, muuten False.\nEsimerkit\n    ", "natural_language": "Finnish"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Annettu positiivinen kokonaisluku N, palauta sen binääriesityksen numeroiden summa.\n    \n    Esimerkki\n        Jos N = 1000, numeroiden summa on 1 ja tuloste on \"1\".\n        Jos N = 150, numeroiden summa on 6 ja tuloste on \"110\".\n        Jos N = 147, numeroiden summa on 12 ja tuloste on \"1100\".\n    \n    Muuttujat:\n        @N kokonaisluku\n             Rajoitukset: 0 ≤ N ≤ 10000.\n    Tuloste:\n         binäärilukuna esitetty merkkijono.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Annettu positiivinen kokonaisluku N, palauta sen binääriesityksen numeroiden summa.\n    \n    Esimerkki\n        Jos N = 1000, numeroiden summa on 1 ja tuloste on \"1\".\n        Jos N = 150, numeroiden summa on 6 ja tuloste on \"110\".\n        Jos N = 147, numeroiden summa on 12 ja tuloste on \"1100\".\n    \n    Muuttujat:\n        @N kokonaisluku\n             Rajoitukset: 0 ≤ N ≤ 10000.\n    Tuloste:\n         binäärilukuna esitetty merkkijono.\n    ", "natural_language": "Finnish"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Sinulle annetaan kaksiulotteinen data, joka on sisäkkäisten listojen muodossa, mikä on samanlainen kuin matriisi, mutta toisin kuin matriiseissa, jokainen rivi voi sisältää eri määrän sarakkeita. Annetaan lst ja kokonaisluku x, etsi kokonaisluvut x listasta ja palauta tuplejen lista [(x1, y1), (x2, y2) ...], jossa jokainen tuple on koordinaatti - (rivi, sarakkeet), aloittaen 0:sta. Lajittele koordinaatit aluksi riveittäin nousevassa järjestyksessä. Lajittele myös rivin koordinaatit sarakkeittain laskevassa järjestyksessä.\n\n    Esimerkkejä:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Sinulle annetaan kaksiulotteinen data, joka on sisäkkäisten listojen muodossa, mikä on samanlainen kuin matriisi, mutta toisin kuin matriiseissa, jokainen rivi voi sisältää eri määrän sarakkeita. Annetaan lst ja kokonaisluku x, etsi kokonaisluvut x listasta ja palauta tuplejen lista [(x1, y1), (x2, y2) ...], jossa jokainen tuple on koordinaatti - (rivi, sarakkeet), aloittaen 0:sta. Lajittele koordinaatit aluksi riveittäin nousevassa järjestyksessä. Lajittele myös rivin koordinaatit sarakkeittain laskevassa järjestyksessä.\n\n    Esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Sinulle annetaan lista kokonaislukuja.\nKirjoita funktio next_smallest(), joka palauttaa listan toiseksi pienimmän elementin.\nPalauta null, jos tällaista elementtiä ei ole.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Sinulle annetaan lista kokonaislukuja.\nKirjoita funktio next_smallest(), joka palauttaa listan toiseksi pienimmän elementin.\nPalauta null, jos tällaista elementtiä ei ole.\n    ", "natural_language": "Finnish"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Sinulle annetaan merkkijono sanoja, ja tehtäväsi on laskea tylsistymisten määrä. Tylsistyminen on lause, joka alkaa sanalla \"I\". Lauseet erotellaan '.' , '?' tai '!' merkeillä.\n\n    Esimerkiksi:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Sinulle annetaan merkkijono sanoja, ja tehtäväsi on laskea tylsistymisten määrä. Tylsistyminen on lause, joka alkaa sanalla \"I\". Lauseet erotellaan '.' , '?' tai '!' merkeillä.\n\n    Esimerkiksi:\n    ", "natural_language": "Finnish"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Sinulle annetaan lista kokonaislukuja.\n    Sinun täytyy löytää suurin alkuluku ja palauttaa sen numeroiden summa.\n\n        Esimerkkejä:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Sinulle annetaan lista kokonaislukuja.\n    Sinun täytyy löytää suurin alkuluku ja palauttaa sen numeroiden summa.\n\n        Esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Annettuna sanakirjana, palauta True, jos kaikki avaimet ovat pienaakkosia tai kaikki avaimet ovat isojaakkosia, muuten palauta False. Funktio palauttaa False, jos annettu sanakirja on tyhjä. Esimerkkejä:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Annettuna sanakirjana, palauta True, jos kaikki avaimet ovat pienaakkosia tai kaikki avaimet ovat isojaakkosia, muuten palauta False. Funktio palauttaa False, jos annettu sanakirja on tyhjä. Esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Luo funktio, joka ottaa arvon (merkkijono) edustaen numeroa ja palauttaa lähimmän kokonaisluvun siihen. Jos numero on yhtä kaukana kahdesta kokonaisluvusta, pyöristä se poispäin nollasta.\n\n    Esimerkit\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Luo funktio, joka ottaa arvon (merkkijono) edustaen numeroa ja palauttaa lähimmän kokonaisluvun siihen. Jos numero on yhtä kaukana kahdesta kokonaisluvusta, pyöristä se poispäin nollasta.\n\n    Esimerkit\n    ", "natural_language": "Finnish"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Annettu positiivinen kokonaisluku n, sinun täytyy tehdä kasa n tasoa kiviä.\n    Ensimmäisellä tasolla on n kiveä.\n    Seuraavan tason kivien määrä on:\n        - seuraava pariton luku, jos n on pariton.\n        - seuraava parillinen luku, jos n on parillinen.\n    Palauta kivien määrä jokaisella tasolla listassa, jossa indeksin i elementti edustaa kivien määrää tasolla (i+1).\n\n        Esimerkkejä:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Annettu positiivinen kokonaisluku n, sinun täytyy tehdä kasa n tasoa kiviä.\n    Ensimmäisellä tasolla on n kiveä.\n    Seuraavan tason kivien määrä on:\n        - seuraava pariton luku, jos n on pariton.\n        - seuraava parillinen luku, jos n on parillinen.\n    Palauta kivien määrä jokaisella tasolla listassa, jossa indeksin i elementti edustaa kivien määrää tasolla (i+1).\n\n        Esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Sinulle annetaan merkkijono sanoja, jotka on erotettu pilkuilla tai välilyönneillä. Tehtäväsi on jakaa merkkijono sanoiksi ja palauttaa taulukko sanoista.\n\n    Esimerkiksi:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Sinulle annetaan merkkijono sanoja, jotka on erotettu pilkuilla tai välilyönneillä. Tehtäväsi on jakaa merkkijono sanoiksi ja palauttaa taulukko sanoista.\n\n    Esimerkiksi:\n    ", "natural_language": "Finnish"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Tämä funktio ottaa vastaan kaksi positiivista lukua x ja y ja palauttaa suurimman parillisen kokonaisluvun, joka on välillä [x, y] mukaan lukien. Jos tällaista lukua ei ole, funktio palauttaa -1.\n\n    Esimerkiksi:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Tämä funktio ottaa vastaan kaksi positiivista lukua x ja y ja palauttaa suurimman parillisen kokonaisluvun, joka on välillä [x, y] mukaan lukien. Jos tällaista lukua ei ole, funktio palauttaa -1.\n\n    Esimerkiksi:\n    ", "natural_language": "Finnish"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Sinulle annetaan kaksi positiivista kokonaislukua n ja m, ja tehtäväsi on laskea\n    keskiarvo kokonaisluvuista n läpi m (mukaan lukien n ja m). \n    Pyöristä vastaus lähimpään kokonaislukuun ja muunna se binääriksi.\n    Jos n on suurempi kuin m, palauta -1.\n    Esimerkki:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Sinulle annetaan kaksi positiivista kokonaislukua n ja m, ja tehtäväsi on laskea\n    keskiarvo kokonaisluvuista n läpi m (mukaan lukien n ja m). \n    Pyöristä vastaus lähimpään kokonaislukuun ja muunna se binääriksi.\n    Jos n on suurempi kuin m, palauta -1.\n    Esimerkki:\n    ", "natural_language": "Finnish"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Toteuta funktio f, joka ottaa parametrinaan n,\n    ja palauttaa n kokoisen listan, jossa indeksin i arvo on i:n kertoma, jos i on parillinen,\n    tai lukujen 1 - i summa, jos i on pariton.\n    i alkaa 1:stä.\n    i:n kertoma on lukujen 1 - i tulo (1 * 2 * ... * i).\n    Esimerkki:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Toteuta funktio f, joka ottaa parametrinaan n,\n    ja palauttaa n kokoisen listan, jossa indeksin i arvo on i:n kertoma, jos i on parillinen,\n    tai lukujen 1 - i summa, jos i on pariton.\n    i alkaa 1:stä.\n    i:n kertoma on lukujen 1 - i tulo (1 * 2 * ... * i).\n    Esimerkki:\n    ", "natural_language": "Finnish"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Annettaessa positiivinen kokonaisluku n, palauta tuple, joka sisältää parillisten ja parittomien\n    kokonaislukupalindromien määrän välillä (1, n), mukaan lukien.\n\n        Esimerkki 1:\n\n            Syöte: 3\n        Tuloste: (1, 2)\n        Selitys:\n        Kokonaislukupalindromit ovat 1, 2, 3. Yksi niistä on parillinen, ja kaksi niistä ovat parittomia.\n\n        Esimerkki 2:\n\n            Syöte: 12\n        Tuloste: (4, 6)\n        Selitys:\n        Kokonaislukupalindromit ovat 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Neljä niistä on parillisia, ja kuusi niistä on parittomia.\n\n        Huomautus:\n        1. 1 <= n <= 10^3\n        2. palautettu tuple sisältää parillisten ja parittomien kokonaislukupalindromien määrän vastaavasti.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Annettaessa positiivinen kokonaisluku n, palauta tuple, joka sisältää parillisten ja parittomien\n    kokonaislukupalindromien määrän välillä (1, n), mukaan lukien.\n\n        Esimerkki 1:\n\n            Syöte: 3\n        Tuloste: (1, 2)\n        Selitys:\n        Kokonaislukupalindromit ovat 1, 2, 3. Yksi niistä on parillinen, ja kaksi niistä ovat parittomia.\n\n        Esimerkki 2:\n\n            Syöte: 12\n        Tuloste: (4, 6)\n        Selitys:\n        Kokonaislukupalindromit ovat 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Neljä niistä on parillisia, ja kuusi niistä on parittomia.\n\n        Huomautus:\n        1. 1 <= n <= 10^3\n        2. palautettu tuple sisältää parillisten ja parittomien kokonaislukupalindromien määrän vastaavasti.\n    ", "natural_language": "Finnish"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Meillä on taulukko 'arr' N kokonaislukua arr[1], arr[2], ..., arr[N]. Taulukon numerot ovat satunnaisessa järjestyksessä. Tehtäväsi on selvittää, onko mahdollista saada taulukko järjestettyä ei-nousevaan järjestykseen suorittamalla seuraava toimenpide annetulle taulukolle:\n    Voit suorittaa oikean siirtotoiminnon minkä tahansa määrän kertoja.\n    \n    Yksi oikea siirtotoiminto tarkoittaa kaikkien taulukon elementtien siirtämistä yhden\n    paikan oikealle. Taulukon viimeinen elementti siirretään aloituspaikkaan taulukossa eli indeksiin 0. \n\n        Jos voit saada järjestetyn taulukon suorittamalla yllä olevan toimenpiteen, palauta True, muuten palauta False.\n    Jos annettu taulukko on tyhjä, palauta True.\n\n        Huomaa: Annetussa listassa on taattu olevan ainutlaatuisia elementtejä.\n\n        Esimerkiksi:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Selitys: Suorittamalla 2 oikeaa siirtotoimintoa, ei-nouseva järjestys voidaan saavuttaa annetulle taulukolle.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Selitys: Ei ole mahdollista saada ei-nousevaa järjestystä annetulle taulukolle suorittamalla mitään määrää oikeita siirtotoimintoja.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Meillä on taulukko 'arr' N kokonaislukua arr[1], arr[2], ..., arr[N]. Taulukon numerot ovat satunnaisessa järjestyksessä. Tehtäväsi on selvittää, onko mahdollista saada taulukko järjestettyä ei-nousevaan järjestykseen suorittamalla seuraava toimenpide annetulle taulukolle:\n    Voit suorittaa oikean siirtotoiminnon minkä tahansa määrän kertoja.\n    \n    Yksi oikea siirtotoiminto tarkoittaa kaikkien taulukon elementtien siirtämistä yhden\n    paikan oikealle. Taulukon viimeinen elementti siirretään aloituspaikkaan taulukossa eli indeksiin 0. \n\n        Jos voit saada järjestetyn taulukon suorittamalla yllä olevan toimenpiteen, palauta True, muuten palauta False.\n    Jos annettu taulukko on tyhjä, palauta True.\n\n        Huomaa: Annetussa listassa on taattu olevan ainutlaatuisia elementtejä.\n\n        Esimerkiksi:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Selitys: Suorittamalla 2 oikeaa siirtotoimintoa, ei-nouseva järjestys voidaan saavuttaa annetulle taulukolle.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Selitys: Ei ole mahdollista saada ei-nousevaa järjestystä annetulle taulukolle suorittamalla mitään määrää oikeita siirtotoimintoja.\n    ", "natural_language": "Finnish"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Tässä ongelmassa toteutat funktion, joka ottaa vastaan kaksi lukulistaa ja määrittää, onko mahdollista vaihtaa elementtejä niiden välillä, jotta lst1 on vain parillisia lukuja sisältävä lista. Lst1:n ja lst2:n välillä vaihdettavien elementtien määrää ei ole rajoitettu. Jos on mahdollista vaihtaa elementtejä lst1:n ja lst2:n välillä niin, että kaikki lst1:n elementit ovat parillisia, palauta \"YES\". Muussa tapauksessa palauta \"NO\". Esimerkiksi: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\" Oletetaan, että syötelistoja ei ole tyhjiä.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "Tässä ongelmassa toteutat funktion, joka ottaa vastaan kaksi lukulistaa ja määrittää, onko mahdollista vaihtaa elementtejä niiden välillä, jotta lst1 on vain parillisia lukuja sisältävä lista. Lst1:n ja lst2:n välillä vaihdettavien elementtien määrää ei ole rajoitettu. Jos on mahdollista vaihtaa elementtejä lst1:n ja lst2:n välillä niin, että kaikki lst1:n elementit ovat parillisia, palauta \"YES\". Muussa tapauksessa palauta \"NO\". Esimerkiksi: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\" Oletetaan, että syötelistoja ei ole tyhjiä.\n    ", "natural_language": "Finnish"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Tehtävä\n    Saamme kaksi merkkijonoa s ja c, jossa kaikki merkit s:stä, jotka ovat samat kuin c:ssä, poistetaan.\n    Tämän jälkeen tarkistetaan, onko lopputulosmerkkijono palindromi.\n    Merkkijono on palindromi, jos se luetaan samalla tavalla takaperin kuin eteenpäin.\n    Palauta tuple, joka sisältää lopputulosmerkkijonon ja True/False-arvon tarkistusta varten.\n    Esimerkki\n    Jos s = \"abcde\" ja c = \"ae\", tulos on ('bcd',False)\n    Jos s = \"abcdef\" ja c = \"b\", tulos on ('acdef',False)\n    Jos s = \"abcdedcba\" ja c = \"ab\", tulos on ('cdedc',True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Tehtävä\n    Saamme kaksi merkkijonoa s ja c, jossa kaikki merkit s:stä, jotka ovat samat kuin c:ssä, poistetaan.\n    Tämän jälkeen tarkistetaan, onko lopputulosmerkkijono palindromi.\n    Merkkijono on palindromi, jos se luetaan samalla tavalla takaperin kuin eteenpäin.\n    Palauta tuple, joka sisältää lopputulosmerkkijonon ja True/False-arvon tarkistusta varten.\n    Esimerkki\n    Jos s = \"abcde\" ja c = \"ae\", tulos on ('bcd',False)\n    Jos s = \"abcdef\" ja c = \"b\", tulos on ('acdef',False)\n    Jos s = \"abcdedcba\" ja c = \"ab\", tulos on ('cdedc',True)\n    ", "natural_language": "Finnish"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Sinulle annetaan suorakulmainen kaivojen ruudukko. Jokainen rivi edustaa yhtä kaivoa, ja jokainen 1 rivillä edustaa yhtä vesiyksikköä. Jokaisella kaivolla on vastaava ämpäri, jota voidaan käyttää veden poistamiseen siitä, ja kaikilla ämpäreillä on sama kapasiteetti. Tehtäväsi on käyttää ämpäreitä tyhjentääksesi kaivot. Tulosta kuinka monta kertaa sinun täytyy laskea ämpärit.\n\n    Esimerkki 1:\n    Syöte:\n        ruudukko: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        ämpärikapasiteetti: 1\n    Tuloste: 6\n\n    Esimerkki 2:\n    Syöte:\n        ruudukko: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        ämpärikapasiteetti: 2\n    Tuloste: 5\n\n    Esimerkki 3:\n    Syöte:\n        ruudukko: [[0,0,0], [0,0,0]]\n        ämpärikapasiteetti: 5\n    Tuloste: 0\n\n    Rajoitukset:\n    * kaikilla kaivoilla on sama pituus\n    * 1 <= ruudukko.pituus <= 10^2\n    * 1 <= ruudukko[:,1].pituus <= 10^2\n    * ruudukko[i][j] -> 0 | 1\n    * 1 <= kapasiteetti <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Sinulle annetaan suorakulmainen kaivojen ruudukko. Jokainen rivi edustaa yhtä kaivoa, ja jokainen 1 rivillä edustaa yhtä vesiyksikköä. Jokaisella kaivolla on vastaava ämpäri, jota voidaan käyttää veden poistamiseen siitä, ja kaikilla ämpäreillä on sama kapasiteetti. Tehtäväsi on käyttää ämpäreitä tyhjentääksesi kaivot. Tulosta kuinka monta kertaa sinun täytyy laskea ämpärit.\n\n    Esimerkki 1:\n    Syöte:\n        ruudukko: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        ämpärikapasiteetti: 1\n    Tuloste: 6\n\n    Esimerkki 2:\n    Syöte:\n        ruudukko: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        ämpärikapasiteetti: 2\n    Tuloste: 5\n\n    Esimerkki 3:\n    Syöte:\n        ruudukko: [[0,0,0], [0,0,0]]\n        ämpärikapasiteetti: 5\n    Tuloste: 0\n\n    Rajoitukset:\n    * kaikilla kaivoilla on sama pituus\n    * 1 <= ruudukko.pituus <= 10^2\n    * 1 <= ruudukko[:,1].pituus <= 10^2\n    * ruudukko[i][j] -> 0 | 1\n    * 1 <= kapasiteetti <= 10\n    ", "natural_language": "Finnish"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Annettu merkkijono s ja luonnollinen luku n, sinun on toteutettava \n    funktio, joka palauttaa listan kaikista s-merkkijonon sanoista, jotka sisältävät tarkalleen \n    n konsonanttia, järjestyksessä, jossa nämä sanat esiintyvät merkkijonossa s.\n    Jos merkkijono s on tyhjä, funktio palauttaa tyhjän listan.\n    Huomaa: voit olettaa, että syötemerkkijono sisältää vain kirjaimia ja välilyöntejä.\n    Esimerkkejä:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Annettu merkkijono s ja luonnollinen luku n, sinun on toteutettava \n    funktio, joka palauttaa listan kaikista s-merkkijonon sanoista, jotka sisältävät tarkalleen \n    n konsonanttia, järjestyksessä, jossa nämä sanat esiintyvät merkkijonossa s.\n    Jos merkkijono s on tyhjä, funktio palauttaa tyhjän listan.\n    Huomaa: voit olettaa, että syötemerkkijono sisältää vain kirjaimia ja välilyöntejä.\n    Esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Annettu taulukko arr kokonaislukuja ja positiivinen kokonaisluku k. Palauta järjestetty lista pituudeltaan k, jossa on arr:n suurimmat k lukua.\n\n        Esimerkki 1:\n\n            Syöte: arr = [-3, -4, 5], k = 3\n        Tuloste: [-4, -3, 5]\n\n        Esimerkki 2:\n\n            Syöte: arr = [4, -4, 4], k = 2\n        Tuloste: [4, 4]\n\n        Esimerkki 3:\n\n            Syöte: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Tuloste: [2]\n\n        Huomioi:\n        1. Taulukon pituus on välillä [1, 1000].\n        2. Taulukon alkiot ovat välillä [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Annettu taulukko arr kokonaislukuja ja positiivinen kokonaisluku k. Palauta järjestetty lista pituudeltaan k, jossa on arr:n suurimmat k lukua.\n\n        Esimerkki 1:\n\n            Syöte: arr = [-3, -4, 5], k = 3\n        Tuloste: [-4, -3, 5]\n\n        Esimerkki 2:\n\n            Syöte: arr = [4, -4, 4], k = 2\n        Tuloste: [4, 4]\n\n        Esimerkki 3:\n\n            Syöte: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Tuloste: [2]\n\n        Huomioi:\n        1. Taulukon pituus on välillä [1, 1000].\n        2. Taulukon alkiot ovat välillä [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    ", "natural_language": "Finnish"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Annettuna ei-tyhjä kokonaislukutaulukko arr ja kokonaisluku k, palauta ensimmäisten k arr-taulukon elementtien summa, joilla on korkeintaan kaksi numeroa.\n\n        Esimerkki:\n\n            Syöte: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Tuloste: 24 # summa 21 + 3\n\n        Rajoitukset:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Annettuna ei-tyhjä kokonaislukutaulukko arr ja kokonaisluku k, palauta ensimmäisten k arr-taulukon elementtien summa, joilla on korkeintaan kaksi numeroa.\n\n        Esimerkki:\n\n            Syöte: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Tuloste: 24 # summa 21 + 3\n\n        Rajoitukset:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    ", "natural_language": "Finnish"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Sinulle annetaan kaksi väliä,\n    joista kumpikin väli koostuu kahdesta kokonaisluvusta. Esimerkiksi väli = (alku, loppu) = (1, 2).\n    Annetut välit ovat suljettuja, mikä tarkoittaa että väli (alku, loppu)\n    sisältää sekä alun että lopun.\n    Jokaisen annetun välin oletetaan alkavan pienemmästä tai yhtäsuuresta luvusta kuin mihin se päättyy.\n    Tehtäväsi on selvittää, onko näiden kahden välin leikkausosan pituus alkuluku.\n    Esimerkiksi välien (1, 3), (2, 4) leikkausosa on (2, 3),\n    jonka pituus on 1, mikä ei ole alkuluku.\n    Jos leikkausosan pituus on alkuluku, palauta \"YES\",\n    muuten palauta \"NO\".\n    Jos kaksi väliä eivät leikkaa, palauta \"NO\".\n\n    \n    [input/output] esimerkkejä:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Sinulle annetaan kaksi väliä,\n    joista kumpikin väli koostuu kahdesta kokonaisluvusta. Esimerkiksi väli = (alku, loppu) = (1, 2).\n    Annetut välit ovat suljettuja, mikä tarkoittaa että väli (alku, loppu)\n    sisältää sekä alun että lopun.\n    Jokaisen annetun välin oletetaan alkavan pienemmästä tai yhtäsuuresta luvusta kuin mihin se päättyy.\n    Tehtäväsi on selvittää, onko näiden kahden välin leikkausosan pituus alkuluku.\n    Esimerkiksi välien (1, 3), (2, 4) leikkausosa on (2, 3),\n    jonka pituus on 1, mikä ei ole alkuluku.\n    Jos leikkausosan pituus on alkuluku, palauta \"YES\",\n    muuten palauta \"NO\".\n    Jos kaksi väliä eivät leikkaa, palauta \"NO\".\n\n    \n    [input/output] esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Jokainen tietää Fibonacci-jonon, jota on tutkittu syvällisesti viime vuosisatojen aikana. Kuitenkin ihmiset eivät tiedä Tribonacci-jonoa. Tribonacci-jono määritellään rekursiolla: tri(1) = 3 tri(n) = 1 + n / 2, jos n on parillinen. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), jos n on pariton. Esimerkiksi: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Sinulle annetaan ei-negatiivinen kokonaisluku n, sinun on palautettava lista Tribonacci-jonon ensimmäisistä n + 1 numerosta. Esimerkkejä: tri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Jokainen tietää Fibonacci-jonon, jota on tutkittu syvällisesti viime vuosisatojen aikana. Kuitenkin ihmiset eivät tiedä Tribonacci-jonoa. Tribonacci-jono määritellään rekursiolla: tri(1) = 3 tri(n) = 1 + n / 2, jos n on parillinen. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), jos n on pariton. Esimerkiksi: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Sinulle annetaan ei-negatiivinen kokonaisluku n, sinun on palautettava lista Tribonacci-jonon ensimmäisistä n + 1 numerosta. Esimerkkejä: tri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Finnish"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Annettu positiivinen kokonaisluku n, palauta parittomien numeroiden tulo.\n    Palauta 0, jos kaikki numerot ovat parillisia.\n    Esimerkiksi:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Annettu positiivinen kokonaisluku n, palauta parittomien numeroiden tulo.\n    Palauta 0, jos kaikki numerot ovat parillisia.\n    Esimerkiksi:\n    ", "natural_language": "Finnish"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Luo funktio, joka ottaa syötteeksi merkkijonon, joka sisältää vain neliö sulkeita. \nFunktion tulisi palauttaa True vain, jos on olemassa kelvollinen sulkeiden alijono, \njossa vähintään yksi sulkeista on sisäkkäin.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Luo funktio, joka ottaa syötteeksi merkkijonon, joka sisältää vain neliö sulkeita. \nFunktion tulisi palauttaa True vain, jos on olemassa kelvollinen sulkeiden alijono, \njossa vähintään yksi sulkeista on sisäkkäin.\n    ", "natural_language": "Finnish"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Sinulle annetaan lista numeroita.\nSinun tulee palauttaa annetun listan neliöityjen numeroiden summa,\npyöristä jokainen lista-alkio ylöspäin lähimpään kokonaislukuun.\nEsimerkkejä:\nJos lst = [1,2,3], tulostus on 14\nJos lst = [1,4,9], tulostus on 98\nJos lst = [1,3,5,7], tulostus on 84\nJos lst = [1.4,4.2,0], tulostus on 29\nJos lst = [-2.4,1,1], tulostus on 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Sinulle annetaan lista numeroita.\nSinun tulee palauttaa annetun listan neliöityjen numeroiden summa,\npyöristä jokainen lista-alkio ylöspäin lähimpään kokonaislukuun.\nEsimerkkejä:\nJos lst = [1,2,3], tulostus on 14\nJos lst = [1,4,9], tulostus on 98\nJos lst = [1,3,5,7], tulostus on 84\nJos lst = [1.4,4.2,0], tulostus on 29\nJos lst = [-2.4,1,1], tulostus on 6\n    ", "natural_language": "Finnish"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Luo funktio, joka palauttaa True, jos annetun merkkijonon viimeinen merkki on aakkosellinen merkki eikä ole osa sanaa, ja False muuten. Huomaa: \"sana\" on merkkijono, joka koostuu merkeistä, jotka on erotettu välilyönnillä.\n\n    Esimerkkejä:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Luo funktio, joka palauttaa True, jos annetun merkkijonon viimeinen merkki on aakkosellinen merkki eikä ole osa sanaa, ja False muuten. Huomaa: \"sana\" on merkkijono, joka koostuu merkeistä, jotka on erotettu välilyönnillä.\n\n    Esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Luo funktio, joka palauttaa suurimman indeksin elementistä, joka ei ole suurempi tai yhtä suuri kuin sen välittömästi edeltävä elementti. Jos tällaista elementtiä ei ole, palauta -1. Annettu taulukko ei sisällä kaksoisarvoja.\n\n    Esimerkkejä:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Luo funktio, joka palauttaa suurimman indeksin elementistä, joka ei ole suurempi tai yhtä suuri kuin sen välittömästi edeltävä elementti. Jos tällaista elementtiä ei ole, palauta -1. Annettu taulukko ei sisällä kaksoisarvoja.\n\n    Esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Luo funktio, joka palauttaa tuple-muuttujan (a, b), jossa 'a' on negatiivisten kokonaislukujen suurin arvo ja 'b' on positiivisten kokonaislukujen pienin arvo listassa. Jos negatiivisia tai positiivisia kokonaislukuja ei ole, palauta ne arvona None.\n\n    Esimerkkejä:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Luo funktio, joka palauttaa tuple-muuttujan (a, b), jossa 'a' on negatiivisten kokonaislukujen suurin arvo ja 'b' on positiivisten kokonaislukujen pienin arvo listassa. Jos negatiivisia tai positiivisia kokonaislukuja ei ole, palauta ne arvona None.\n\n    Esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"Brasilialainen kertoma määritellään seuraavasti:\n    brasilialainen_kertoma(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    missä n > 0\n\n        Esimerkiksi:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "Brasilialainen kertoma määritellään seuraavasti:\n    brasilialainen_kertoma(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    missä n > 0\n\n        Esimerkiksi:\n    ", "natural_language": "Finnish"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Sinulle annetaan merkkijono, joka edustaa lausetta. Lause sisältää joitakin sanoja, jotka on erotettu välilyönnillä, ja sinun on palautettava merkkijono, joka sisältää alkuperäisestä lauseesta sanat, joiden pituudet ovat alkulukuja. Uuden merkkijonon sanajärjestyksen on oltava sama kuin alkuperäisessä lauseessa.\n\n        Esimerkki 1:\n        Syöte: lause = \"Tämä on testi\"\n        Tuloste: \"on\"\n\n        Esimerkki 2:\n        Syöte: lause = \"lähdetään uimaan\"\n        Tuloste: \"lähdetään uimaan\"\n\n        Rajoitukset:\n        * 1 <= len(lause) <= 100\n        * Lause sisältää vain kirjaimia.\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Sinulle annetaan merkkijono, joka edustaa lausetta. Lause sisältää joitakin sanoja, jotka on erotettu välilyönnillä, ja sinun on palautettava merkkijono, joka sisältää alkuperäisestä lauseesta sanat, joiden pituudet ovat alkulukuja. Uuden merkkijonon sanajärjestyksen on oltava sama kuin alkuperäisessä lauseessa.\n\n        Esimerkki 1:\n        Syöte: lause = \"Tämä on testi\"\n        Tuloste: \"on\"\n\n        Esimerkki 2:\n        Syöte: lause = \"lähdetään uimaan\"\n        Tuloste: \"lähdetään uimaan\"\n\n        Rajoitukset:\n        * 1 <= len(lause) <= 100\n        * Lause sisältää vain kirjaimia.\n    ", "natural_language": "Finnish"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Tehtäväsi on toteuttaa funktio, joka yksinkertaistaa lausekkeen x * n. Funktio palauttaa True, jos x * n arvioidaan kokonaisluvuksi, ja False muuten. Sekä x että n ovat murtolukujen merkkijonoesityksiä, ja niillä on seuraava muoto, <osoittaja>/<nimittäjä>, jossa sekä osoittaja että nimittäjä ovat positiivisia kokonaislukuja.\n\n    Voit olettaa, että x ja n ovat kelvollisia murtolukuja eivätkä niillä ole nollaa nimittäjänä.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Tehtäväsi on toteuttaa funktio, joka yksinkertaistaa lausekkeen x * n. Funktio palauttaa True, jos x * n arvioidaan kokonaisluvuksi, ja False muuten. Sekä x että n ovat murtolukujen merkkijonoesityksiä, ja niillä on seuraava muoto, <osoittaja>/<nimittäjä>, jossa sekä osoittaja että nimittäjä ovat positiivisia kokonaislukuja.\n\n    Voit olettaa, että x ja n ovat kelvollisia murtolukuja eivätkä niillä ole nollaa nimittäjänä.\n    ", "natural_language": "Finnish"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Kirjoita funktio, joka järjestää annetun kokonaislukulistauksen nousevaan järjestykseen niiden numeroiden summan perusteella. Huomaa: jos useilla kohteilla on samanlainen numeroiden summa, järjestä ne alkuperäisen listan indeksin perusteella.\n\n    Esimerkiksi:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Kirjoita funktio, joka järjestää annetun kokonaislukulistauksen nousevaan järjestykseen niiden numeroiden summan perusteella. Huomaa: jos useilla kohteilla on samanlainen numeroiden summa, järjestä ne alkuperäisen listan indeksin perusteella.\n\n    Esimerkiksi:\n    ", "natural_language": "Finnish"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Kirjoita funktio, joka ottaa numerotaulukon syötteenä ja palauttaa taulukon alkioiden määrän, jotka ovat suurempia kuin 10 ja joiden numeron ensimmäinen ja viimeinen numero ovat molemmat parittomia (1, 3, 5, 7, 9). Esimerkiksi:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Kirjoita funktio, joka ottaa numerotaulukon syötteenä ja palauttaa taulukon alkioiden määrän, jotka ovat suurempia kuin 10 ja joiden numeron ensimmäinen ja viimeinen numero ovat molemmat parittomia (1, 3, 5, 7, 9). Esimerkiksi:\n    ", "natural_language": "Finnish"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Sinulle annetaan positiivinen kokonaisluku n. Sinun on luotava kokonaislukutaulukko a pituudeltaan n.\n        Jokaiselle i:lle (1 ≤ i ≤ n), a[i]:n arvo = i * i - i + 1.\n        Palauta kolmikoiden (a[i], a[j], a[k]) määrä a: ssa, jossa i <j <k, \n    ja a[i] + a[j] + a[k] on monikertainen 3: lla.\n\n        Esimerkki:\n        Syöte: n = 5\n        Lähtö: 1\n        Selitys:\n        a = [1, 3, 7, 13, 21]\n        Ainoa kelvollinen kolmikko on (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Sinulle annetaan positiivinen kokonaisluku n. Sinun on luotava kokonaislukutaulukko a pituudeltaan n.\n        Jokaiselle i:lle (1 ≤ i ≤ n), a[i]:n arvo = i * i - i + 1.\n        Palauta kolmikoiden (a[i], a[j], a[k]) määrä a: ssa, jossa i <j <k, \n    ja a[i] + a[j] + a[k] on monikertainen 3: lla.\n\n        Esimerkki:\n        Syöte: n = 5\n        Lähtö: 1\n        Selitys:\n        a = [1, 3, 7, 13, 21]\n        Ainoa kelvollinen kolmikko on (1, 7, 13).\n    ", "natural_language": "Finnish"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    Aurinkokunnassamme on kahdeksan planeettaa: lähimpänä Aurinkoa on Merkurius, \nseuraava on Venus, sitten Maapallo, Mars, Jupiter, Saturnus, Uranus ja Neptunus. \nKirjoita funktio, joka ottaa kaksi planeetan nimeä merkkijonoina planet1 ja planet2. \nFunktio palauttaa tuplen, joka sisältää kaikki planeetat, joiden radat sijaitsevat \nplaneetta1:n ja planeetta2:n radan välissä, järjestettynä lähimpänä Aurinkoon. \nFunktio palauttaa tyhjän tuplen, jos planet1 tai planet2 eivät ole oikeita planeettojen nimiä. \nEsimerkit:\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "Aurinkokunnassamme on kahdeksan planeettaa: lähimpänä Aurinkoa on Merkurius, \nseuraava on Venus, sitten Maapallo, Mars, Jupiter, Saturnus, Uranus ja Neptunus. \nKirjoita funktio, joka ottaa kaksi planeetan nimeä merkkijonoina planet1 ja planet2. \nFunktio palauttaa tuplen, joka sisältää kaikki planeetat, joiden radat sijaitsevat \nplaneetta1:n ja planeetta2:n radan välissä, järjestettynä lähimpänä Aurinkoon. \nFunktio palauttaa tyhjän tuplen, jos planet1 tai planet2 eivät ole oikeita planeettojen nimiä. \nEsimerkit:\n    ", "natural_language": "Finnish"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Yksinkertainen ohjelma, joka palauttaa x:n arvon, jos n on alkuluku, ja palauttaa y:n arvon muussa tapauksessa.\n\n    Esimerkkejä:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Yksinkertainen ohjelma, joka palauttaa x:n arvon, jos n on alkuluku, ja palauttaa y:n arvon muussa tapauksessa.\n\n    Esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Annettuna listana numeroita, palauta listan parittomien lukujen neliöiden summa. Ohita negatiiviset tai ei-kokonaislukuluvut.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n    \n    Jos syötelista on tyhjä, palauta 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Annettuna listana numeroita, palauta listan parittomien lukujen neliöiden summa. Ohita negatiiviset tai ei-kokonaislukuluvut.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n    \n    Jos syötelista on tyhjä, palauta 0.\n    ", "natural_language": "Finnish"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Sinulle annetaan luokan nimi (merkkijono) ja lista laajennuksista. Laajennukset on tarkoitettu lisäluokkien lataamiseen luokkaan. Laajennuksen vahvuus määritellään seuraavasti: Olkoon CAP laajennuksen nimiin sisältyvien isojen kirjainten määrä ja SM laajennuksen nimiin sisältyvien pienten kirjainten määrä. Vahvuus annetaan murto-osana CAP - SM. Sinun tulee löytää vahvin laajennus ja palauttaa merkkijono muodossa: LuokanNimi.VahvinLaajennusNimi. Jos kahdella tai useammalla laajennuksella on sama vahvuus, sinun tulee valita ensimmäinen listaan kirjoitettu laajennus. Esimerkiksi, jos annetaan luokka \"Slices\" ja lista laajennuksista: ['SErviNGSliCes', 'Cheese', 'StuFfed'], sinun tulee palauttaa 'Slices.SErviNGSliCes', koska 'SErviNGSliCes' on vahvin laajennus (sen vahvuus on -1). Esimerkki:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Sinulle annetaan luokan nimi (merkkijono) ja lista laajennuksista. Laajennukset on tarkoitettu lisäluokkien lataamiseen luokkaan. Laajennuksen vahvuus määritellään seuraavasti: Olkoon CAP laajennuksen nimiin sisältyvien isojen kirjainten määrä ja SM laajennuksen nimiin sisältyvien pienten kirjainten määrä. Vahvuus annetaan murto-osana CAP - SM. Sinun tulee löytää vahvin laajennus ja palauttaa merkkijono muodossa: LuokanNimi.VahvinLaajennusNimi. Jos kahdella tai useammalla laajennuksella on sama vahvuus, sinun tulee valita ensimmäinen listaan kirjoitettu laajennus. Esimerkiksi, jos annetaan luokka \"Slices\" ja lista laajennuksista: ['SErviNGSliCes', 'Cheese', 'StuFfed'], sinun tulee palauttaa 'Slices.SErviNGSliCes', koska 'SErviNGSliCes' on vahvin laajennus (sen vahvuus on -1). Esimerkki:\n    ", "natural_language": "Finnish"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Sinulle annetaan 2 sanaa. Sinun täytyy palauttaa True, jos toinen sana tai sen mikä tahansa kiertäminen on alimerkkijono ensimmäisessä sanassa.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Sinulle annetaan 2 sanaa. Sinun täytyy palauttaa True, jos toinen sana tai sen mikä tahansa kiertäminen on alimerkkijono ensimmäisessä sanassa.\n    ", "natural_language": "Finnish"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Annettuna positiivinen kokonaisluku, muunna se roomalaiseksi numeroksi merkkijonona ja palauta se pienillä kirjaimilla.\nRajoitukset: 1 <= num <= 1000\n\n    Esimerkkejä:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Annettuna positiivinen kokonaisluku, muunna se roomalaiseksi numeroksi merkkijonona ja palauta se pienillä kirjaimilla.\nRajoitukset: 1 <= num <= 1000\n\n    Esimerkkejä:\n    ", "natural_language": "Finnish"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Annettuna kolmen kolmion sivun pituudet. Palauta True, jos kolme sivua muodostavat suorakulmaisen kolmion, muuten False. Suorakulmainen kolmio on kolmio, jossa yksi kulma on suora kulma tai 90 astetta. Esimerkki:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Annettuna kolmen kolmion sivun pituudet. Palauta True, jos kolme sivua muodostavat suorakulmaisen kolmion, muuten False. Suorakulmainen kolmio on kolmio, jossa yksi kulma on suora kulma tai 90 astetta. Esimerkki:\n    ", "natural_language": "Finnish"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Sinulle annetaan merkkijono s.\n    Jos s[i] on kirjain, käännä sen kirjainkoko ylös- tai alaspäin, \n    muuten pidä se sellaisenaan.\n    Jos merkkijono ei sisällä kirjaimia, käännä merkkijono ympäri.\n    Funktio palauttaa tuloksena saadun merkkijonon.\n    Esimerkit\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Sinulle annetaan merkkijono s.\n    Jos s[i] on kirjain, käännä sen kirjainkoko ylös- tai alaspäin, \n    muuten pidä se sellaisenaan.\n    Jos merkkijono ei sisällä kirjaimia, käännä merkkijono ympäri.\n    Funktio palauttaa tuloksena saadun merkkijonon.\n    Esimerkit\n    ", "natural_language": "Finnish"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Annettuna merkkijono 'text', palauta sen md5-tiivisteeksi muunnettu merkkijono.\nJos 'text' on tyhjä merkkijono, palauta null.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Annettuna merkkijono 'text', palauta sen md5-tiivisteeksi muunnettu merkkijono.\nJos 'text' on tyhjä merkkijono, palauta null.\n    ", "natural_language": "Finnish"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Annettujen kahden positiivisen kokonaisluvun a ja b väliltä palautetaan parilliset numerot nousevassa järjestyksessä.\n\n    Esimerkiksi:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Annettujen kahden positiivisen kokonaisluvun a ja b väliltä palautetaan parilliset numerot nousevassa järjestyksessä.\n\n    Esimerkiksi:\n    ", "natural_language": "Finnish"}
