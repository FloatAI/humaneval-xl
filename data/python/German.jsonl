{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Sie erhalten eine Liste von Einzahlungs- und Abhebungsvorgängen auf einem Bankkonto, das mit einem Nullsaldo beginnt. Ihre Aufgabe besteht darin, festzustellen, ob zu irgendeinem Zeitpunkt das Guthaben des Kontos unter Null fällt, und an diesem Punkt sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Sie erhalten eine Liste von Einzahlungs- und Abhebungsvorgängen auf einem Bankkonto, das mit einem Nullsaldo beginnt. Ihre Aufgabe besteht darin, festzustellen, ob zu irgendeinem Zeitpunkt das Guthaben des Kontos unter Null fällt, und an diesem Punkt sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n    ", "natural_language": "German"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Für eine gegebene Liste von ganzen Zahlen soll ein Tupel zurückgegeben werden, das aus der Summe und dem Produkt aller Zahlen in der Liste besteht.\nEine leere Summe soll gleich 0 und ein leeres Produkt gleich 1 sein.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Für eine gegebene Liste von ganzen Zahlen soll ein Tupel zurückgegeben werden, das aus der Summe und dem Produkt aller Zahlen in der Liste besteht.\nEine leere Summe soll gleich 0 und ein leeres Produkt gleich 1 sein.\n    ", "natural_language": "German"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Die Eingabe sind zwei Zeichenketten a und b, die nur aus 1en und 0en bestehen.\nFühren Sie eine binäre XOR-Operation auf diesen Eingaben aus und geben Sie das Ergebnis ebenfalls als Zeichenkette zurück.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "Die Eingabe sind zwei Zeichenketten a und b, die nur aus 1en und 0en bestehen.\nFühren Sie eine binäre XOR-Operation auf diesen Eingaben aus und geben Sie das Ergebnis ebenfalls als Zeichenkette zurück.\n    ", "natural_language": "German"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Aus einer Liste von Zeichenketten soll die längste zurückgegeben werden. Im Falle von mehreren Zeichenketten mit gleicher Länge soll die erste zurückgegeben werden. Falls die Eingabeliste leer ist, soll null zurückgegeben werden.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "Aus einer Liste von Zeichenketten soll die längste zurückgegeben werden. Im Falle von mehreren Zeichenketten mit gleicher Länge soll die erste zurückgegeben werden. Falls die Eingabeliste leer ist, soll null zurückgegeben werden.\n    ", "natural_language": "German"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Gib den größten gemeinsamen Teiler von zwei ganzen Zahlen a und b zurück.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Gib den größten gemeinsamen Teiler von zwei ganzen Zahlen a und b zurück.\n    ", "natural_language": "German"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Die Eingabe ist ein durch Leerzeichen getrennter String von Ziffern von 'null' bis 'neun'.\n    Gültige Optionen sind 'null', 'eins', 'zwei', 'drei', 'vier', 'fünf', 'sechs', 'sieben', 'acht' und 'neun'.\n    Gib den String mit den Zahlen sortiert von klein nach groß zurück.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "Die Eingabe ist ein durch Leerzeichen getrennter String von Ziffern von 'null' bis 'neun'.\n    Gültige Optionen sind 'null', 'eins', 'zwei', 'drei', 'vier', 'fünf', 'sechs', 'sieben', 'acht' und 'neun'.\n    Gib den String mit den Zahlen sortiert von klein nach groß zurück.\n    ", "natural_language": "German"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Gegeben sei eine Liste von Zahlen (mit mindestens zwei Elementen). Wenden Sie eine lineare Transformation auf diese Liste an, so dass die kleinste Zahl zu 0 und die größte zu 1 wird.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Gegeben sei eine Liste von Zahlen (mit mindestens zwei Elementen). Wenden Sie eine lineare Transformation auf diese Liste an, so dass die kleinste Zahl zu 0 und die größte zu 1 wird.\n    ", "natural_language": "German"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Für einen gegebenen String, tausche Kleinbuchstaben in Großbuchstaben und Großbuchstaben in Kleinbuchstaben um.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Für einen gegebenen String, tausche Kleinbuchstaben in Großbuchstaben und Großbuchstaben in Kleinbuchstaben um.\n    ", "natural_language": "German"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Gib nur positive Zahlen in der Liste zurück.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Gib nur positive Zahlen in der Liste zurück.\n    ", "natural_language": "German"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Gib \"true\" zurück, wenn eine gegebene Zahl eine Primzahl ist, andernfalls gib \"false\" zurück.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Gib \"true\" zurück, wenn eine gegebene Zahl eine Primzahl ist, andernfalls gib \"false\" zurück.\n    ", "natural_language": "German"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Gib sortierte eindeutige Elemente in einer Liste zurück.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Gib sortierte eindeutige Elemente in einer Liste zurück.\n    ", "natural_language": "German"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib gibt die n-te Zahl zurück, die sowohl eine Fibonacci-Zahl als auch eine Primzahl ist.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib gibt die n-te Zahl zurück, die sowohl eine Fibonacci-Zahl als auch eine Primzahl ist.\n    ", "natural_language": "German"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero nimmt eine Liste von ganzen Zahlen als Eingabe.\nEs gibt True zurück, wenn es drei verschiedene Elemente in der Liste gibt, die zu Null addieren, andernfalls gibt es False zurück.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "triples_sum_to_zero nimmt eine Liste von ganzen Zahlen als Eingabe.\nEs gibt True zurück, wenn es drei verschiedene Elemente in der Liste gibt, die zu Null addieren, andernfalls gibt es False zurück.\n    ", "natural_language": "German"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero nimmt eine Liste von ganzen Zahlen als Eingabe.\nEs gibt True zurück, wenn es zwei unterschiedliche Elemente in der Liste gibt, die sich zu Null addieren, andernfalls gibt es False zurück.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "pairs_sum_to_zero nimmt eine Liste von ganzen Zahlen als Eingabe.\nEs gibt True zurück, wenn es zwei unterschiedliche Elemente in der Liste gibt, die sich zu Null addieren, andernfalls gibt es False zurück.\n    ", "natural_language": "German"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Die Fib4-Zahlenfolge ist eine Folge ähnlich der Fibonacci-Folge, die wie folgt definiert ist:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Bitte schreiben Sie eine Funktion, um das n-te Element der Fib4-Zahlenfolge effizient zu berechnen. Verwenden Sie keine Rekursion.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "Die Fib4-Zahlenfolge ist eine Folge ähnlich der Fibonacci-Folge, die wie folgt definiert ist:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Bitte schreiben Sie eine Funktion, um das n-te Element der Fib4-Zahlenfolge effizient zu berechnen. Verwenden Sie keine Rekursion.\n    ", "natural_language": "German"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Gib den Median der Elemente in der Liste l zurück.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Gib den Median der Elemente in der Liste l zurück.\n    ", "natural_language": "German"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Überprüft, ob der gegebene String ein Palindrom ist.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Überprüft, ob der gegebene String ein Palindrom ist.\n    ", "natural_language": "German"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels ist eine Funktion, die einen String entgegennimmt und einen String ohne Vokale zurückgibt.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels ist eine Funktion, die einen String entgegennimmt und einen String ohne Vokale zurückgibt.\n    ", "natural_language": "German"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Gib True zurück, wenn alle Zahlen in der Liste l unterhalb des Schwellenwerts t liegen.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Gib True zurück, wenn alle Zahlen in der Liste l unterhalb des Schwellenwerts t liegen.\n    ", "natural_language": "German"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Addiere zwei Zahlen x und y.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Addiere zwei Zahlen x und y.\n    ", "natural_language": "German"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Überprüfen Sie, ob zwei Wörter dieselben Zeichen enthalten.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Überprüfen Sie, ob zwei Wörter dieselben Zeichen enthalten.\n    ", "natural_language": "German"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Gib die n-te Fibonacci-Zahl zurück.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Gib die n-te Fibonacci-Zahl zurück.\n    ", "natural_language": "German"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Gib sortierte eindeutige gemeinsame Elemente für zwei Listen zurück.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Gib sortierte eindeutige gemeinsame Elemente für zwei Listen zurück.\n    ", "natural_language": "German"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Gib den größten Primfaktor von n zurück. Gehe davon aus, dass n > 1 und keine Primzahl ist.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Gib den größten Primfaktor von n zurück. Gehe davon aus, dass n > 1 und keine Primzahl ist.\n    ", "natural_language": "German"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n ist eine Funktion, die Zahlen von 1 bis n summiert.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n ist eine Funktion, die Zahlen von 1 bis n summiert.\n    ", "natural_language": "German"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs repräsentieren die Koeffizienten eines Polynoms.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Gib die Ableitung dieses Polynoms in derselben Form zurück.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs repräsentieren die Koeffizienten eines Polynoms.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Gib die Ableitung dieses Polynoms in derselben Form zurück.\n    ", "natural_language": "German"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"Die FibFib-Zahlenfolge ist eine Folge ähnlich der Fibonacci-Folge, die wie folgt definiert ist:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Bitte schreiben Sie eine Funktion, um das n-te Element der FibFib-Zahlenfolge effizient zu berechnen.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "Die FibFib-Zahlenfolge ist eine Folge ähnlich der Fibonacci-Folge, die wie folgt definiert ist:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Bitte schreiben Sie eine Funktion, um das n-te Element der FibFib-Zahlenfolge effizient zu berechnen.\n    ", "natural_language": "German"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Schreiben Sie eine Funktion vowels_count, die einen String, der ein Wort repräsentiert, als Eingabe erhält und die Anzahl der Vokale im String zurückgibt. Vokale sind in diesem Fall 'a', 'e', 'i', 'o', 'u'. Hierbei ist 'y' auch ein Vokal, aber nur wenn es am Ende des gegebenen Wortes steht.\n\n    Beispiel:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Schreiben Sie eine Funktion vowels_count, die einen String, der ein Wort repräsentiert, als Eingabe erhält und die Anzahl der Vokale im String zurückgibt. Vokale sind in diesem Fall 'a', 'e', 'i', 'o', 'u'. Hierbei ist 'y' auch ein Vokal, aber nur wenn es am Ende des gegebenen Wortes steht.\n\n    Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Sie erhalten eine nicht-leere Liste von positiven Ganzzahlen. Geben Sie die größte Ganzzahl zurück, die größer als Null ist und eine Häufigkeit hat, die größer oder gleich dem Wert der Ganzzahl selbst ist. Die Häufigkeit einer Ganzzahl ist die Anzahl der Male, die sie in der Liste vorkommt. Wenn kein solcher Wert existiert, geben Sie -1 zurück. Beispiele:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Sie erhalten eine nicht-leere Liste von positiven Ganzzahlen. Geben Sie die größte Ganzzahl zurück, die größer als Null ist und eine Häufigkeit hat, die größer oder gleich dem Wert der Ganzzahl selbst ist. Die Häufigkeit einer Ganzzahl ist die Anzahl der Male, die sie in der Liste vorkommt. Wenn kein solcher Wert existiert, geben Sie -1 zurück. Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Gegeben sind die Längen der drei Seiten eines Dreiecks. Gib die Fläche des Dreiecks auf 2 Dezimalstellen gerundet zurück, wenn die drei Seiten ein gültiges Dreieck bilden. Andernfalls gib -1 zurück. Drei Seiten bilden ein gültiges Dreieck, wenn die Summe von zwei Seiten größer ist als die dritte Seite. Beispiel:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Gegeben sind die Längen der drei Seiten eines Dreiecks. Gib die Fläche des Dreiecks auf 2 Dezimalstellen gerundet zurück, wenn die drei Seiten ein gültiges Dreieck bilden. Andernfalls gib -1 zurück. Drei Seiten bilden ein gültiges Dreieck, wenn die Summe von zwei Seiten größer ist als die dritte Seite. Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Schreiben Sie eine Funktion, die True zurückgibt, wenn das Objekt q fliegen wird, und False sonst. Das Objekt q wird fliegen, wenn es ausbalanciert ist (es ist eine palindromische Liste) und die Summe seiner Elemente kleiner oder gleich dem maximal möglichen Gewicht w ist.\n\n        Beispiel:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 ist kleiner als das maximal mögliche Gewicht, aber es ist unausgeglichen.\n\n        will_it_fly([3, 2, 3], 1) ➞ False\n    # es ist ausbalanciert, aber 3+2+3 ist mehr als das maximal mögliche Gewicht.\n\n        will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 ist kleiner als das maximal mögliche Gewicht, und es ist ausbalanciert.\n\n        will_it_fly([3], 5) ➞ True\n    # 3 ist kleiner als das maximal mögliche Gewicht, und es ist ausbalanciert.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Schreiben Sie eine Funktion, die True zurückgibt, wenn das Objekt q fliegen wird, und False sonst. Das Objekt q wird fliegen, wenn es ausbalanciert ist (es ist eine palindromische Liste) und die Summe seiner Elemente kleiner oder gleich dem maximal möglichen Gewicht w ist.\n\n        Beispiel:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 ist kleiner als das maximal mögliche Gewicht, aber es ist unausgeglichen.\n\n        will_it_fly([3, 2, 3], 1) ➞ False\n    # es ist ausbalanciert, aber 3+2+3 ist mehr als das maximal mögliche Gewicht.\n\n        will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 ist kleiner als das maximal mögliche Gewicht, und es ist ausbalanciert.\n\n        will_it_fly([3], 5) ➞ True\n    # 3 ist kleiner als das maximal mögliche Gewicht, und es ist ausbalanciert.\n    ", "natural_language": "German"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Schreiben Sie eine Funktion, die true zurückgibt, wenn die gegebene Zahl das Produkt von 3 Primzahlen ist, und false sonst. Dabei ist bekannt, dass (a) kleiner als 100 ist. Beispiel:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Schreiben Sie eine Funktion, die true zurückgibt, wenn die gegebene Zahl das Produkt von 3 Primzahlen ist, und false sonst. Dabei ist bekannt, dass (a) kleiner als 100 ist. Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Sie erhalten eine Zahl in Dezimalform und Ihre Aufgabe besteht darin, sie in das Binärformat umzuwandeln. Die Funktion sollte einen String zurückgeben, wobei jedes Zeichen eine Binärzahl darstellt. Jedes Zeichen im String wird '0' oder '1' sein.\n\n    Es wird ein zusätzliches Paar von Zeichen 'db' am Anfang und am Ende des Strings geben. Die zusätzlichen Zeichen dienen zur Formatierungshilfe.\n\n    Beispiele:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Sie erhalten eine Zahl in Dezimalform und Ihre Aufgabe besteht darin, sie in das Binärformat umzuwandeln. Die Funktion sollte einen String zurückgeben, wobei jedes Zeichen eine Binärzahl darstellt. Jedes Zeichen im String wird '0' oder '1' sein.\n\n    Es wird ein zusätzliches Paar von Zeichen 'db' am Anfang und am Ende des Strings geben. Die zusätzlichen Zeichen dienen zur Formatierungshilfe.\n\n    Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Du erhältst einen String s.\nDeine Aufgabe ist es zu überprüfen, ob der String glücklich ist oder nicht.\nEin String ist glücklich, wenn seine Länge mindestens 3 beträgt und jede Gruppe von 3 aufeinanderfolgenden Buchstaben unterschiedlich ist.\nZum Beispiel:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Du erhältst einen String s.\nDeine Aufgabe ist es zu überprüfen, ob der String glücklich ist oder nicht.\nEin String ist glücklich, wenn seine Länge mindestens 3 beträgt und jede Gruppe von 3 aufeinanderfolgenden Buchstaben unterschiedlich ist.\nZum Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Es ist die letzte Woche des Semesters und der Lehrer muss die Noten an die Schüler verteilen. Der Lehrer hat seinen eigenen Algorithmus zur Bewertung entwickelt. Das einzige Problem ist, dass er den Code, den er zur Bewertung verwendet hat, verloren hat. Er hat Ihnen eine Liste von GPAs für einige Schüler gegeben und Sie müssen eine Funktion schreiben, die eine Liste von Buchstabennoten gemäß der folgenden Tabelle ausgeben kann:\n\n                 GPA       |    Buchstaben Note\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Beispiel:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "Es ist die letzte Woche des Semesters und der Lehrer muss die Noten an die Schüler verteilen. Der Lehrer hat seinen eigenen Algorithmus zur Bewertung entwickelt. Das einzige Problem ist, dass er den Code, den er zur Bewertung verwendet hat, verloren hat. Er hat Ihnen eine Liste von GPAs für einige Schüler gegeben und Sie müssen eine Funktion schreiben, die eine Liste von Buchstabennoten gemäß der folgenden Tabelle ausgeben kann:\n\n                 GPA       |    Buchstaben Note\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Schreiben Sie eine Funktion, die einen String entgegennimmt und True zurückgibt, wenn die Länge des Strings eine Primzahl ist, andernfalls False.\n    Beispiele\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Schreiben Sie eine Funktion, die einen String entgegennimmt und True zurückgibt, wenn die Länge des Strings eine Primzahl ist, andernfalls False.\n    Beispiele\n    ", "natural_language": "German"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Gegeben eine positive Ganzzahl N, gib die Gesamtsumme ihrer Ziffern in binärer Form zurück.\n\n        Beispiel\n        Für N = 1000 ist die Summe der Ziffern 1, die Ausgabe sollte \"1\" sein.\n        Für N = 150 ist die Summe der Ziffern 6, die Ausgabe sollte \"110\" sein.\n        Für N = 147 ist die Summe der Ziffern 12, die Ausgabe sollte \"1100\" sein.\n    \n    Variablen:\n        @N Ganzzahl\n             Einschränkungen: 0 ≤ N ≤ 10000.\n    Ausgabe:\n         eine Zeichenkette mit der binären Zahl.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Gegeben eine positive Ganzzahl N, gib die Gesamtsumme ihrer Ziffern in binärer Form zurück.\n\n        Beispiel\n        Für N = 1000 ist die Summe der Ziffern 1, die Ausgabe sollte \"1\" sein.\n        Für N = 150 ist die Summe der Ziffern 6, die Ausgabe sollte \"110\" sein.\n        Für N = 147 ist die Summe der Ziffern 12, die Ausgabe sollte \"1100\" sein.\n    \n    Variablen:\n        @N Ganzzahl\n             Einschränkungen: 0 ≤ N ≤ 10000.\n    Ausgabe:\n         eine Zeichenkette mit der binären Zahl.\n    ", "natural_language": "German"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Sie erhalten eine zweidimensionale Datenstruktur als verschachtelte Listen, die einer Matrix ähnelt, jedoch können im Gegensatz zu Matrizen unterschiedlich viele Spalten in jeder Zeile vorhanden sein. Gegeben sei eine Liste \"lst\" und eine ganze Zahl \"x\". Finden Sie die Zahlen \"x\" in der Liste und geben Sie eine Liste von Tupeln zurück, [(x1, y1), (x2, y2) ...], wobei jedes Tupel eine Koordinate (Zeile, Spalte) darstellt, beginnend bei 0. Sortieren Sie die Koordinaten zunächst nach Zeilen in aufsteigender Reihenfolge. Sortieren Sie auch die Koordinaten der Zeile nach Spalten in absteigender Reihenfolge.\n\n    Beispiele:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Sie erhalten eine zweidimensionale Datenstruktur als verschachtelte Listen, die einer Matrix ähnelt, jedoch können im Gegensatz zu Matrizen unterschiedlich viele Spalten in jeder Zeile vorhanden sein. Gegeben sei eine Liste \"lst\" und eine ganze Zahl \"x\". Finden Sie die Zahlen \"x\" in der Liste und geben Sie eine Liste von Tupeln zurück, [(x1, y1), (x2, y2) ...], wobei jedes Tupel eine Koordinate (Zeile, Spalte) darstellt, beginnend bei 0. Sortieren Sie die Koordinaten zunächst nach Zeilen in aufsteigender Reihenfolge. Sortieren Sie auch die Koordinaten der Zeile nach Spalten in absteigender Reihenfolge.\n\n    Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Sie erhalten eine Liste von ganzen Zahlen.\nSchreiben Sie eine Funktion next_smallest(), die das zweitkleinste Element der Liste zurückgibt.\nGeben Sie null zurück, wenn es kein solches Element gibt.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Sie erhalten eine Liste von ganzen Zahlen.\nSchreiben Sie eine Funktion next_smallest(), die das zweitkleinste Element der Liste zurückgibt.\nGeben Sie null zurück, wenn es kein solches Element gibt.\n    ", "natural_language": "German"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Du bekommst einen String von Wörtern und deine Aufgabe ist es, die Anzahl der Langeweilen zu zählen. Eine Langeweile ist ein Satz, der mit dem Wort \"Ich\" beginnt. Sätze werden durch '.', '?' oder '!' begrenzt.\n\n    Zum Beispiel:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Du bekommst einen String von Wörtern und deine Aufgabe ist es, die Anzahl der Langeweilen zu zählen. Eine Langeweile ist ein Satz, der mit dem Wort \"Ich\" beginnt. Sätze werden durch '.', '?' oder '!' begrenzt.\n\n    Zum Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Sie erhalten eine Liste von ganzen Zahlen.\n    Sie müssen den größten Primzahlwert finden und die Summe seiner Ziffern zurückgeben.\n\n        Beispiele:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Sie erhalten eine Liste von ganzen Zahlen.\n    Sie müssen den größten Primzahlwert finden und die Summe seiner Ziffern zurückgeben.\n\n        Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Gegeben ein Wörterbuch, gibt True zurück, wenn alle Schlüssel Strings in Kleinbuchstaben oder alle Schlüssel Strings in Großbuchstaben sind, sonst gibt es False zurück. Die Funktion sollte False zurückgeben, wenn das gegebene Wörterbuch leer ist. Beispiele:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Gegeben ein Wörterbuch, gibt True zurück, wenn alle Schlüssel Strings in Kleinbuchstaben oder alle Schlüssel Strings in Großbuchstaben sind, sonst gibt es False zurück. Die Funktion sollte False zurückgeben, wenn das gegebene Wörterbuch leer ist. Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Erstellen Sie eine Funktion, die einen Wert (String) annimmt, der eine Zahl darstellt, und gibt die nächstgelegene Ganzzahl zurück. Wenn die Zahl gleich weit von zwei Ganzzahlen entfernt ist, runden Sie sie weg von Null.\n\n        Beispiele\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Erstellen Sie eine Funktion, die einen Wert (String) annimmt, der eine Zahl darstellt, und gibt die nächstgelegene Ganzzahl zurück. Wenn die Zahl gleich weit von zwei Ganzzahlen entfernt ist, runden Sie sie weg von Null.\n\n        Beispiele\n    ", "natural_language": "German"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Gegeben eine positive ganze Zahl n, müssen Sie einen Haufen von n Ebenen von Steinen machen.\n    Die erste Ebene hat n Steine.\n    Die Anzahl der Steine in der nächsten Ebene ist:\n        - die nächste ungerade Zahl, wenn n ungerade ist.\n        - die nächste gerade Zahl, wenn n gerade ist.\n    Geben Sie die Anzahl der Steine in jeder Ebene in einer Liste zurück, wobei das Element an Index\n    i die Anzahl der Steine in der Ebene (i+1) darstellt.\n\n        Beispiele:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Gegeben eine positive ganze Zahl n, müssen Sie einen Haufen von n Ebenen von Steinen machen.\n    Die erste Ebene hat n Steine.\n    Die Anzahl der Steine in der nächsten Ebene ist:\n        - die nächste ungerade Zahl, wenn n ungerade ist.\n        - die nächste gerade Zahl, wenn n gerade ist.\n    Geben Sie die Anzahl der Steine in jeder Ebene in einer Liste zurück, wobei das Element an Index\n    i die Anzahl der Steine in der Ebene (i+1) darstellt.\n\n        Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Sie erhalten einen String von Wörtern, die durch Kommas oder Leerzeichen getrennt sind. Ihre Aufgabe ist es, den String in Wörter aufzuteilen und ein Array der Wörter zurückzugeben.\n\n    Zum Beispiel:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Sie erhalten einen String von Wörtern, die durch Kommas oder Leerzeichen getrennt sind. Ihre Aufgabe ist es, den String in Wörter aufzuteilen und ein Array der Wörter zurückzugeben.\n\n    Zum Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Diese Funktion nimmt zwei positive Zahlen x und y entgegen und gibt die größte gerade Zahl zurück, die im Bereich [x, y] enthalten ist. Wenn es keine solche Zahl gibt, sollte die Funktion -1 zurückgeben.\n\n    Zum Beispiel:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Diese Funktion nimmt zwei positive Zahlen x und y entgegen und gibt die größte gerade Zahl zurück, die im Bereich [x, y] enthalten ist. Wenn es keine solche Zahl gibt, sollte die Funktion -1 zurückgeben.\n\n    Zum Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Sie erhalten zwei positive Ganzzahlen n und m. Ihre Aufgabe besteht darin, den Durchschnitt der Ganzzahlen von n bis m (einschließlich n und m) zu berechnen. Runden Sie die Antwort auf die nächste Ganzzahl und konvertieren Sie diese in binär. Wenn n größer als m ist, geben Sie -1 zurück. Beispiel:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Sie erhalten zwei positive Ganzzahlen n und m. Ihre Aufgabe besteht darin, den Durchschnitt der Ganzzahlen von n bis m (einschließlich n und m) zu berechnen. Runden Sie die Antwort auf die nächste Ganzzahl und konvertieren Sie diese in binär. Wenn n größer als m ist, geben Sie -1 zurück. Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Implementieren Sie die Funktion f, die n als Parameter annimmt und eine Liste der Größe n zurückgibt, wobei der Wert des Elements an der Stelle i das Fakultät von i ist, wenn i gerade ist, oder die Summe der Zahlen von 1 bis i, wenn i ungerade ist. i beginnt bei 1. Die Fakultät von i ist das Produkt der Zahlen von 1 bis i (1 * 2 * ... * i). Beispiel:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Implementieren Sie die Funktion f, die n als Parameter annimmt und eine Liste der Größe n zurückgibt, wobei der Wert des Elements an der Stelle i das Fakultät von i ist, wenn i gerade ist, oder die Summe der Zahlen von 1 bis i, wenn i ungerade ist. i beginnt bei 1. Die Fakultät von i ist das Produkt der Zahlen von 1 bis i (1 * 2 * ... * i). Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Gegeben eine positive ganze Zahl n, gibt eine Tupel zurück, das die Anzahl der geraden und ungeraden ganzen Palindrome enthält, die im Bereich (1, n) einschließlich liegen.\n\n        Beispiel 1:\n\n            Eingabe: 3\n        Ausgabe: (1, 2)\n        Erklärung:\n        Ganze Palindrome sind 1, 2, 3. Eines davon ist gerade und zwei davon sind ungerade.\n\n        Beispiel 2:\n\n            Eingabe: 12\n        Ausgabe: (4, 6)\n        Erklärung:\n        Ganze Palindrome sind 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier davon sind gerade und sechs davon sind ungerade.\n\n        Hinweis:\n        1. 1 <= n <= 10^3\n        2. Das zurückgegebene Tupel enthält die Anzahl der geraden und ungeraden ganzen Palindrome.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Gegeben eine positive ganze Zahl n, gibt eine Tupel zurück, das die Anzahl der geraden und ungeraden ganzen Palindrome enthält, die im Bereich (1, n) einschließlich liegen.\n\n        Beispiel 1:\n\n            Eingabe: 3\n        Ausgabe: (1, 2)\n        Erklärung:\n        Ganze Palindrome sind 1, 2, 3. Eines davon ist gerade und zwei davon sind ungerade.\n\n        Beispiel 2:\n\n            Eingabe: 12\n        Ausgabe: (4, 6)\n        Erklärung:\n        Ganze Palindrome sind 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier davon sind gerade und sechs davon sind ungerade.\n\n        Hinweis:\n        1. 1 <= n <= 10^3\n        2. Das zurückgegebene Tupel enthält die Anzahl der geraden und ungeraden ganzen Palindrome.\n    ", "natural_language": "German"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Wir haben ein Array 'arr' mit N ganzen Zahlen arr[1], arr[2], ..., arr[N]. Die Zahlen im Array werden zufällig angeordnet sein. Deine Aufgabe besteht darin zu bestimmen, ob es möglich ist, ein Array in nicht abnehmender Reihenfolge zu sortieren, indem du die folgende Operation auf das gegebene Array anwendest:\nDu darfst beliebig oft eine Rechtsschiebeoperation durchführen.\nEine Rechtsschiebeoperation bedeutet, dass alle Elemente des Arrays um eine Position in Richtung rechts verschoben werden. Das letzte Element des Arrays wird an die Startposition im Array verschoben, d.h. an den Index 0.\n\n    Wenn es möglich ist, das sortierte Array durch Ausführen der oben genannten Operation zu erhalten, gib True zurück, sonst gib False zurück.\nWenn das gegebene Array leer ist, gib True zurück.\n\n    Hinweis: Die gegebene Liste hat garantiert eindeutige Elemente.\n\n    Zum Beispiel:\n\n    move_one_ball([3, 4, 5, 1, 2])==>True\nErklärung: Durch Ausführen von 2 Rechtsschiebeoperationen kann die nicht abnehmende Reihenfolge für das gegebene Array erreicht werden.\nmove_one_ball([3, 5, 4, 1, 2])==>False\nErklärung: Es ist nicht möglich, die nicht abnehmende Reihenfolge für das gegebene Array durch Ausführen beliebiger Anzahl von Rechtsschiebeoperationen zu erhalten.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Wir haben ein Array 'arr' mit N ganzen Zahlen arr[1], arr[2], ..., arr[N]. Die Zahlen im Array werden zufällig angeordnet sein. Deine Aufgabe besteht darin zu bestimmen, ob es möglich ist, ein Array in nicht abnehmender Reihenfolge zu sortieren, indem du die folgende Operation auf das gegebene Array anwendest:\nDu darfst beliebig oft eine Rechtsschiebeoperation durchführen.\nEine Rechtsschiebeoperation bedeutet, dass alle Elemente des Arrays um eine Position in Richtung rechts verschoben werden. Das letzte Element des Arrays wird an die Startposition im Array verschoben, d.h. an den Index 0.\n\n    Wenn es möglich ist, das sortierte Array durch Ausführen der oben genannten Operation zu erhalten, gib True zurück, sonst gib False zurück.\nWenn das gegebene Array leer ist, gib True zurück.\n\n    Hinweis: Die gegebene Liste hat garantiert eindeutige Elemente.\n\n    Zum Beispiel:\n\n    move_one_ball([3, 4, 5, 1, 2])==>True\nErklärung: Durch Ausführen von 2 Rechtsschiebeoperationen kann die nicht abnehmende Reihenfolge für das gegebene Array erreicht werden.\nmove_one_ball([3, 5, 4, 1, 2])==>False\nErklärung: Es ist nicht möglich, die nicht abnehmende Reihenfolge für das gegebene Array durch Ausführen beliebiger Anzahl von Rechtsschiebeoperationen zu erhalten.\n    ", "natural_language": "German"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"In diesem Problem implementieren Sie eine Funktion, die zwei Listen von Zahlen entgegennimmt und bestimmt, ob es möglich ist, einen Austausch von Elementen zwischen ihnen durchzuführen, um lst1 zu einer Liste nur mit geraden Zahlen zu machen. Es gibt keine Begrenzung für die Anzahl der ausgetauschten Elemente zwischen lst1 und lst2. Wenn es möglich ist, Elemente zwischen lst1 und lst2 auszutauschen, um alle Elemente von lst1 gerade zu machen, geben Sie \"YES\" zurück. Andernfalls geben Sie \"NO\" zurück. Zum Beispiel: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Es wird angenommen, dass die Eingabelisten nicht leer sein werden.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "In diesem Problem implementieren Sie eine Funktion, die zwei Listen von Zahlen entgegennimmt und bestimmt, ob es möglich ist, einen Austausch von Elementen zwischen ihnen durchzuführen, um lst1 zu einer Liste nur mit geraden Zahlen zu machen. Es gibt keine Begrenzung für die Anzahl der ausgetauschten Elemente zwischen lst1 und lst2. Wenn es möglich ist, Elemente zwischen lst1 und lst2 auszutauschen, um alle Elemente von lst1 gerade zu machen, geben Sie \"YES\" zurück. Andernfalls geben Sie \"NO\" zurück. Zum Beispiel: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Es wird angenommen, dass die Eingabelisten nicht leer sein werden.\n    ", "natural_language": "German"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Aufgabe\n    Wir haben zwei Zeichenketten s und c. Du musst alle Zeichen in s löschen, die einem Zeichen in c entsprechen.\n    Dann musst du überprüfen, ob die resultierende Zeichenkette ein Palindrom ist.\n    Eine Zeichenkette ist ein Palindrom, wenn sie rückwärts gelesen genauso aussieht wie vorwärts.\n    Du solltest ein Tupel zurückgeben, das die resultierende Zeichenkette und True/False für die Überprüfung enthält.\n    Beispiel\n    Für s = \"abcde\", c = \"ae\" sollte das Ergebnis ('bcd',False) sein.\n    Für s = \"abcdef\", c = \"b\" sollte das Ergebnis ('acdef',False) sein.\n    Für s = \"abcdedcba\", c = \"ab\" sollte das Ergebnis ('cdedc',True) sein.\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Aufgabe\n    Wir haben zwei Zeichenketten s und c. Du musst alle Zeichen in s löschen, die einem Zeichen in c entsprechen.\n    Dann musst du überprüfen, ob die resultierende Zeichenkette ein Palindrom ist.\n    Eine Zeichenkette ist ein Palindrom, wenn sie rückwärts gelesen genauso aussieht wie vorwärts.\n    Du solltest ein Tupel zurückgeben, das die resultierende Zeichenkette und True/False für die Überprüfung enthält.\n    Beispiel\n    Für s = \"abcde\", c = \"ae\" sollte das Ergebnis ('bcd',False) sein.\n    Für s = \"abcdef\", c = \"b\" sollte das Ergebnis ('acdef',False) sein.\n    Für s = \"abcdedcba\", c = \"ab\" sollte das Ergebnis ('cdedc',True) sein.\n    ", "natural_language": "German"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Sie erhalten ein rechteckiges Gitter von Brunnen. Jede Zeile repräsentiert einen einzelnen Brunnen, und jede 1 in einer Zeile repräsentiert eine einzelne Einheit Wasser. Jeder Brunnen hat einen entsprechenden Eimer, der verwendet werden kann, um Wasser daraus zu extrahieren, und alle Eimer haben die gleiche Kapazität. Ihre Aufgabe ist es, die Eimer zu verwenden, um die Brunnen zu leeren. Geben Sie die Anzahl der Male aus, die Sie die Eimer senken müssen.\n\n    Beispiel 1:\n    Eingabe:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        Eimerkapazität: 1\n    Ausgabe: 6\n\n    Beispiel 2:\n    Eingabe:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        Eimerkapazität: 2\n    Ausgabe: 5\n\n    Beispiel 3:\n    Eingabe:\n        grid: [[0,0,0], [0,0,0]]\n        Eimerkapazität: 5\n    Ausgabe: 0\n\n    Einschränkungen:\n    * alle Brunnen haben die gleiche Länge\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid[:,1].length <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= Kapazität <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Sie erhalten ein rechteckiges Gitter von Brunnen. Jede Zeile repräsentiert einen einzelnen Brunnen, und jede 1 in einer Zeile repräsentiert eine einzelne Einheit Wasser. Jeder Brunnen hat einen entsprechenden Eimer, der verwendet werden kann, um Wasser daraus zu extrahieren, und alle Eimer haben die gleiche Kapazität. Ihre Aufgabe ist es, die Eimer zu verwenden, um die Brunnen zu leeren. Geben Sie die Anzahl der Male aus, die Sie die Eimer senken müssen.\n\n    Beispiel 1:\n    Eingabe:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        Eimerkapazität: 1\n    Ausgabe: 6\n\n    Beispiel 2:\n    Eingabe:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        Eimerkapazität: 2\n    Ausgabe: 5\n\n    Beispiel 3:\n    Eingabe:\n        grid: [[0,0,0], [0,0,0]]\n        Eimerkapazität: 5\n    Ausgabe: 0\n\n    Einschränkungen:\n    * alle Brunnen haben die gleiche Länge\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid[:,1].length <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= Kapazität <= 10\n    ", "natural_language": "German"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Gegeben eine Zeichenkette s und eine natürliche Zahl n, wurde Ihnen die Aufgabe zugewiesen, eine Funktion zu implementieren, die eine Liste aller Wörter aus der Zeichenkette s zurückgibt, die genau n Konsonanten enthalten, in der Reihenfolge, in der diese Wörter in der Zeichenkette s erscheinen. Wenn die Zeichenkette s leer ist, sollte die Funktion eine leere Liste zurückgeben. Hinweis: Sie können davon ausgehen, dass die Eingabezeichenkette nur Buchstaben und Leerzeichen enthält. Beispiele:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Gegeben eine Zeichenkette s und eine natürliche Zahl n, wurde Ihnen die Aufgabe zugewiesen, eine Funktion zu implementieren, die eine Liste aller Wörter aus der Zeichenkette s zurückgibt, die genau n Konsonanten enthalten, in der Reihenfolge, in der diese Wörter in der Zeichenkette s erscheinen. Wenn die Zeichenkette s leer ist, sollte die Funktion eine leere Liste zurückgeben. Hinweis: Sie können davon ausgehen, dass die Eingabezeichenkette nur Buchstaben und Leerzeichen enthält. Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Gegeben sei ein Array arr von ganzen Zahlen und eine positive ganze Zahl k. Gib eine sortierte Liste der Länge k zurück, die die k größten Zahlen in arr enthält.\n\n        Beispiel 1:\n\n            Eingabe: arr = [-3, -4, 5], k = 3\n        Ausgabe: [-4, -3, 5]\n\n        Beispiel 2:\n\n            Eingabe: arr = [4, -4, 4], k = 2\n        Ausgabe: [4, 4]\n\n        Beispiel 3:\n\n            Eingabe: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Ausgabe: [2]\n\n        Hinweis:\n        1. Die Länge des Arrays wird im Bereich von [1, 1000] liegen.\n        2. Die Elemente im Array werden im Bereich von [-1000, 1000] liegen.\n        3. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Gegeben sei ein Array arr von ganzen Zahlen und eine positive ganze Zahl k. Gib eine sortierte Liste der Länge k zurück, die die k größten Zahlen in arr enthält.\n\n        Beispiel 1:\n\n            Eingabe: arr = [-3, -4, 5], k = 3\n        Ausgabe: [-4, -3, 5]\n\n        Beispiel 2:\n\n            Eingabe: arr = [4, -4, 4], k = 2\n        Ausgabe: [4, 4]\n\n        Beispiel 3:\n\n            Eingabe: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Ausgabe: [2]\n\n        Hinweis:\n        1. Die Länge des Arrays wird im Bereich von [1, 1000] liegen.\n        2. Die Elemente im Array werden im Bereich von [-1000, 1000] liegen.\n        3. 0 <= k <= len(arr)\n    ", "natural_language": "German"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Gegeben sei ein nicht-leeres Array von ganzen Zahlen arr und eine ganze Zahl k. Gib die Summe der Elemente mit höchstens zwei Ziffern aus den ersten k Elementen von arr zurück.\n\n        Beispiel:\n\n            Eingabe: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Ausgabe: 24 # Summe von 21 + 3\n\n        Einschränkungen:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Gegeben sei ein nicht-leeres Array von ganzen Zahlen arr und eine ganze Zahl k. Gib die Summe der Elemente mit höchstens zwei Ziffern aus den ersten k Elementen von arr zurück.\n\n        Beispiel:\n\n            Eingabe: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Ausgabe: 24 # Summe von 21 + 3\n\n        Einschränkungen:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    ", "natural_language": "German"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Sie erhalten zwei Intervalle,\n    wobei jedes Intervall ein Paar von ganzen Zahlen ist. Zum Beispiel, Intervall = (start, end) = (1, 2).\n    Die gegebenen Intervalle sind geschlossen, was bedeutet, dass das Intervall (start, end)\n    sowohl start als auch end einschließt.\n    Für jedes gegebene Intervall wird angenommen, dass sein Start kleiner oder gleich seinem Ende ist.\n    Ihre Aufgabe ist es zu bestimmen, ob die Länge des Schnitts dieser beiden\n    Intervalle eine Primzahl ist.\n    Zum Beispiel ist der Schnitt der Intervalle (1, 3), (2, 4) (2, 3),\n    dessen Länge 1 ist, was keine Primzahl ist.\n    Wenn die Länge des Schnitts eine Primzahl ist, geben Sie \"YES\" zurück,\n    andernfalls geben Sie \"NO\" zurück.\n    Wenn sich die beiden Intervalle nicht überschneiden, geben Sie \"NO\" zurück.\n\n    \n    [Eingabe/Ausgabe] Beispiele:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Sie erhalten zwei Intervalle,\n    wobei jedes Intervall ein Paar von ganzen Zahlen ist. Zum Beispiel, Intervall = (start, end) = (1, 2).\n    Die gegebenen Intervalle sind geschlossen, was bedeutet, dass das Intervall (start, end)\n    sowohl start als auch end einschließt.\n    Für jedes gegebene Intervall wird angenommen, dass sein Start kleiner oder gleich seinem Ende ist.\n    Ihre Aufgabe ist es zu bestimmen, ob die Länge des Schnitts dieser beiden\n    Intervalle eine Primzahl ist.\n    Zum Beispiel ist der Schnitt der Intervalle (1, 3), (2, 4) (2, 3),\n    dessen Länge 1 ist, was keine Primzahl ist.\n    Wenn die Länge des Schnitts eine Primzahl ist, geben Sie \"YES\" zurück,\n    andernfalls geben Sie \"NO\" zurück.\n    Wenn sich die beiden Intervalle nicht überschneiden, geben Sie \"NO\" zurück.\n\n    \n    [Eingabe/Ausgabe] Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Jeder kennt die Fibonacci-Folge, die in den letzten Jahrhunderten von Mathematikern tiefgehend untersucht wurde. Was die meisten Menschen jedoch nicht wissen, ist die Tribonacci-Folge. Die Tribonacci-Folge wird durch die Rekursion definiert: tri(1) = 3 tri(n) = 1 + n / 2, wenn n gerade ist. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), wenn n ungerade ist. Zum Beispiel: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Sie erhalten eine nicht-negative ganze Zahl n und müssen eine Liste der ersten n + 1 Zahlen der Tribonacci-Folge zurückgeben. Beispiele: tri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Jeder kennt die Fibonacci-Folge, die in den letzten Jahrhunderten von Mathematikern tiefgehend untersucht wurde. Was die meisten Menschen jedoch nicht wissen, ist die Tribonacci-Folge. Die Tribonacci-Folge wird durch die Rekursion definiert: tri(1) = 3 tri(n) = 1 + n / 2, wenn n gerade ist. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), wenn n ungerade ist. Zum Beispiel: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Sie erhalten eine nicht-negative ganze Zahl n und müssen eine Liste der ersten n + 1 Zahlen der Tribonacci-Folge zurückgeben. Beispiele: tri(3) = [1, 3, 2, 8]\n    ", "natural_language": "German"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Gegeben eine positive ganze Zahl n, gib das Produkt der ungeraden Ziffern zurück.\n    Gib 0 zurück, wenn alle Ziffern gerade sind.\n    Zum Beispiel:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Gegeben eine positive ganze Zahl n, gib das Produkt der ungeraden Ziffern zurück.\n    Gib 0 zurück, wenn alle Ziffern gerade sind.\n    Zum Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Erstellen Sie eine Funktion, die einen String als Eingabe erhält, der nur eckige Klammern enthält. Die Funktion sollte True zurückgeben, wenn und nur wenn es eine gültige Teilfolge von Klammern gibt, bei der mindestens eine Klammer in der Teilfolge verschachtelt ist.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Erstellen Sie eine Funktion, die einen String als Eingabe erhält, der nur eckige Klammern enthält. Die Funktion sollte True zurückgeben, wenn und nur wenn es eine gültige Teilfolge von Klammern gibt, bei der mindestens eine Klammer in der Teilfolge verschachtelt ist.\n    ", "natural_language": "German"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Sie erhalten eine Liste von Zahlen.\nSie müssen die Summe der quadrierten Zahlen in der gegebenen Liste zurückgeben,\nrunden Sie jedes Element in der Liste zuerst auf die nächste Ganzzahl (Ceiling).\nBeispiele:\nFür lst = [1,2,3] sollte die Ausgabe 14 sein\nFür lst = [1,4,9] sollte die Ausgabe 98 sein\nFür lst = [1,3,5,7] sollte die Ausgabe 84 sein\nFür lst = [1.4,4.2,0] sollte die Ausgabe 29 sein\nFür lst = [-2.4,1,1] sollte die Ausgabe 6 sein\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Sie erhalten eine Liste von Zahlen.\nSie müssen die Summe der quadrierten Zahlen in der gegebenen Liste zurückgeben,\nrunden Sie jedes Element in der Liste zuerst auf die nächste Ganzzahl (Ceiling).\nBeispiele:\nFür lst = [1,2,3] sollte die Ausgabe 14 sein\nFür lst = [1,4,9] sollte die Ausgabe 98 sein\nFür lst = [1,3,5,7] sollte die Ausgabe 84 sein\nFür lst = [1.4,4.2,0] sollte die Ausgabe 29 sein\nFür lst = [-2.4,1,1] sollte die Ausgabe 6 sein\n    ", "natural_language": "German"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Erstellen Sie eine Funktion, die True zurückgibt, wenn das letzte Zeichen eines gegebenen Strings ein alphabetisches Zeichen ist und nicht Teil eines Wortes ist, und False sonst.\nHinweis: \"Wort\" ist eine Gruppe von Zeichen, die durch Leerzeichen getrennt sind.\n\n    Beispiele:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Erstellen Sie eine Funktion, die True zurückgibt, wenn das letzte Zeichen eines gegebenen Strings ein alphabetisches Zeichen ist und nicht Teil eines Wortes ist, und False sonst.\nHinweis: \"Wort\" ist eine Gruppe von Zeichen, die durch Leerzeichen getrennt sind.\n\n    Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Erstellen Sie eine Funktion, die den größten Index eines Elements zurückgibt, das nicht größer oder gleich dem unmittelbar vorhergehenden Element ist. Wenn kein solches Element vorhanden ist, geben Sie -1 zurück. Das gegebene Array enthält keine doppelten Werte.\n\n    Beispiele:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Erstellen Sie eine Funktion, die den größten Index eines Elements zurückgibt, das nicht größer oder gleich dem unmittelbar vorhergehenden Element ist. Wenn kein solches Element vorhanden ist, geben Sie -1 zurück. Das gegebene Array enthält keine doppelten Werte.\n\n    Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Erstellen Sie eine Funktion, die ein Tupel (a, b) zurückgibt, wobei 'a' die größte negative Ganzzahl und 'b' die kleinste positive Ganzzahl in einer Liste ist. Wenn es keine negativen oder positiven Ganzzahlen gibt, geben Sie sie als None zurück.\n\n    Beispiele:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Erstellen Sie eine Funktion, die ein Tupel (a, b) zurückgibt, wobei 'a' die größte negative Ganzzahl und 'b' die kleinste positive Ganzzahl in einer Liste ist. Wenn es keine negativen oder positiven Ganzzahlen gibt, geben Sie sie als None zurück.\n\n    Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"Das brasilianische Fakultät ist definiert als:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    wobei n > 0\n\n        Zum Beispiel:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "Das brasilianische Fakultät ist definiert als:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    wobei n > 0\n\n        Zum Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Du erhältst einen String, der einen Satz repräsentiert. Der Satz enthält einige Wörter, die durch ein Leerzeichen getrennt sind. Du musst einen String zurückgeben, der die Wörter aus dem ursprünglichen Satz enthält, deren Längen Primzahlen sind. Die Reihenfolge der Wörter im neuen String sollte dieselbe wie im Original sein.\n\n        Beispiel 1:\n        Eingabe: sentence = \"This is a test\"\n        Ausgabe: \"is\"\n\n        Beispiel 2:\n        Eingabe: sentence = \"lets go for swimming\"\n        Ausgabe: \"go for\"\n\n        Einschränkungen:\n        * 1 <= len(sentence) <= 100\n        * Der Satz enthält nur Buchstaben.\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Du erhältst einen String, der einen Satz repräsentiert. Der Satz enthält einige Wörter, die durch ein Leerzeichen getrennt sind. Du musst einen String zurückgeben, der die Wörter aus dem ursprünglichen Satz enthält, deren Längen Primzahlen sind. Die Reihenfolge der Wörter im neuen String sollte dieselbe wie im Original sein.\n\n        Beispiel 1:\n        Eingabe: sentence = \"This is a test\"\n        Ausgabe: \"is\"\n\n        Beispiel 2:\n        Eingabe: sentence = \"lets go for swimming\"\n        Ausgabe: \"go for\"\n\n        Einschränkungen:\n        * 1 <= len(sentence) <= 100\n        * Der Satz enthält nur Buchstaben.\n    ", "natural_language": "German"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Deine Aufgabe ist es, eine Funktion zu implementieren, die den Ausdruck x * n vereinfacht. Die Funktion gibt True zurück, wenn x * n zu einer ganzen Zahl ausgewertet wird, andernfalls False. Sowohl x als auch n sind Zeichenketten, die eine Bruchzahl darstellen und das folgende Format haben: <Zähler>/<Nenner>, wobei sowohl Zähler als auch Nenner positive ganze Zahlen sind.\n\n    Du kannst davon ausgehen, dass x und n gültige Bruchzahlen sind und keinen Nenner von Null haben.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Deine Aufgabe ist es, eine Funktion zu implementieren, die den Ausdruck x * n vereinfacht. Die Funktion gibt True zurück, wenn x * n zu einer ganzen Zahl ausgewertet wird, andernfalls False. Sowohl x als auch n sind Zeichenketten, die eine Bruchzahl darstellen und das folgende Format haben: <Zähler>/<Nenner>, wobei sowohl Zähler als auch Nenner positive ganze Zahlen sind.\n\n    Du kannst davon ausgehen, dass x und n gültige Bruchzahlen sind und keinen Nenner von Null haben.\n    ", "natural_language": "German"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Schreiben Sie eine Funktion, die die gegebene Liste von Ganzzahlen\n    in aufsteigender Reihenfolge nach der Summe ihrer Ziffern sortiert.\n    Hinweis: Wenn es mehrere Elemente mit ähnlicher Summe ihrer Ziffern gibt,\n    ordnen Sie sie basierend auf ihrem Index in der Originalliste.\n\n        Zum Beispiel:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Schreiben Sie eine Funktion, die die gegebene Liste von Ganzzahlen\n    in aufsteigender Reihenfolge nach der Summe ihrer Ziffern sortiert.\n    Hinweis: Wenn es mehrere Elemente mit ähnlicher Summe ihrer Ziffern gibt,\n    ordnen Sie sie basierend auf ihrem Index in der Originalliste.\n\n        Zum Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Schreiben Sie eine Funktion, die ein Array von Zahlen als Eingabe erhält und die Anzahl der Elemente im Array zurückgibt, die größer als 10 sind und bei denen sowohl die erste als auch die letzte Ziffer der Zahl ungerade sind (1, 3, 5, 7, 9). Zum Beispiel:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Schreiben Sie eine Funktion, die ein Array von Zahlen als Eingabe erhält und die Anzahl der Elemente im Array zurückgibt, die größer als 10 sind und bei denen sowohl die erste als auch die letzte Ziffer der Zahl ungerade sind (1, 3, 5, 7, 9). Zum Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Sie erhalten eine positive ganze Zahl n. Sie müssen ein Integer-Array a der Länge n erstellen.\n        Für jedes i (1 ≤ i ≤ n) gilt: a[i] = i * i - i + 1.\n        Geben Sie die Anzahl der Tripel (a[i], a[j], a[k]) von a zurück, bei denen i < j < k gilt und a[i] + a[j] + a[k] ein Vielfaches von 3 ist.\n\n        Beispiel:\n        Eingabe: n = 5\n        Ausgabe: 1\n        Erklärung:\n        a = [1, 3, 7, 13, 21]\n        Das einzige gültige Tripel ist (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Sie erhalten eine positive ganze Zahl n. Sie müssen ein Integer-Array a der Länge n erstellen.\n        Für jedes i (1 ≤ i ≤ n) gilt: a[i] = i * i - i + 1.\n        Geben Sie die Anzahl der Tripel (a[i], a[j], a[k]) von a zurück, bei denen i < j < k gilt und a[i] + a[j] + a[k] ein Vielfaches von 3 ist.\n\n        Beispiel:\n        Eingabe: n = 5\n        Ausgabe: 1\n        Erklärung:\n        a = [1, 3, 7, 13, 21]\n        Das einzige gültige Tripel ist (1, 7, 13).\n    ", "natural_language": "German"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    Es gibt acht Planeten in unserem Sonnensystem: Der Sonne am nächsten ist Merkur, dann folgen Venus, die Erde, Mars, Jupiter, Saturn, Uranus und Neptun. Schreiben Sie eine Funktion, die zwei Planetennamen als Zeichenketten planet1 und planet2 annimmt. Die Funktion sollte ein Tupel zurückgeben, das alle Planeten enthält, deren Umlaufbahnen zwischen der Umlaufbahn von Planet1 und der Umlaufbahn von Planet2 liegen und nach Nähe zur Sonne sortiert sind. Die Funktion sollte ein leeres Tupel zurückgeben, wenn planet1 oder planet2 keine korrekten Planetennamen sind. Beispiele:\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "Es gibt acht Planeten in unserem Sonnensystem: Der Sonne am nächsten ist Merkur, dann folgen Venus, die Erde, Mars, Jupiter, Saturn, Uranus und Neptun. Schreiben Sie eine Funktion, die zwei Planetennamen als Zeichenketten planet1 und planet2 annimmt. Die Funktion sollte ein Tupel zurückgeben, das alle Planeten enthält, deren Umlaufbahnen zwischen der Umlaufbahn von Planet1 und der Umlaufbahn von Planet2 liegen und nach Nähe zur Sonne sortiert sind. Die Funktion sollte ein leeres Tupel zurückgeben, wenn planet1 oder planet2 keine korrekten Planetennamen sind. Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Ein einfaches Programm, das den Wert von x zurückgeben sollte, wenn n eine Primzahl ist, und den Wert von y zurückgeben sollte, wenn nicht.\n\n    Beispiele:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Ein einfaches Programm, das den Wert von x zurückgeben sollte, wenn n eine Primzahl ist, und den Wert von y zurückgeben sollte, wenn nicht.\n\n    Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Gegeben eine Liste von Zahlen, gib die Summe der Quadrate der Zahlen in der Liste zurück, die ungerade sind. Ignoriere Zahlen, die negativ oder keine ganzen Zahlen sind.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    Wenn die Eingangsliste leer ist, gib 0 zurück.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Gegeben eine Liste von Zahlen, gib die Summe der Quadrate der Zahlen in der Liste zurück, die ungerade sind. Ignoriere Zahlen, die negativ oder keine ganzen Zahlen sind.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    Wenn die Eingangsliste leer ist, gib 0 zurück.\n    ", "natural_language": "German"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Sie erhalten den Namen einer Klasse (einen String) und eine Liste von Erweiterungen. Die Erweiterungen sollen verwendet werden, um zusätzliche Klassen zur Klasse zu laden. Die Stärke der Erweiterung wird wie folgt definiert: Sei CAP die Anzahl der Großbuchstaben im Namen der Erweiterung und SM die Anzahl der Kleinbuchstaben im Namen der Erweiterung. Die Stärke wird durch den Bruch CAP - SM gegeben. Sie sollten die stärkste Erweiterung finden und einen String in diesem Format zurückgeben: ClassName.StrongestExtensionName. Wenn es zwei oder mehr Erweiterungen mit der gleichen Stärke gibt, sollten Sie die wählen, die zuerst in der Liste steht. Zum Beispiel, wenn Sie \"Slices\" als Klasse und eine Liste von Erweiterungen erhalten: ['SErviNGSliCes', 'Cheese', 'StuFfed'], sollten Sie 'Slices.SErviNGSliCes' zurückgeben, da 'SErviNGSliCes' die stärkste Erweiterung ist (ihre Stärke ist -1). Beispiel:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Sie erhalten den Namen einer Klasse (einen String) und eine Liste von Erweiterungen. Die Erweiterungen sollen verwendet werden, um zusätzliche Klassen zur Klasse zu laden. Die Stärke der Erweiterung wird wie folgt definiert: Sei CAP die Anzahl der Großbuchstaben im Namen der Erweiterung und SM die Anzahl der Kleinbuchstaben im Namen der Erweiterung. Die Stärke wird durch den Bruch CAP - SM gegeben. Sie sollten die stärkste Erweiterung finden und einen String in diesem Format zurückgeben: ClassName.StrongestExtensionName. Wenn es zwei oder mehr Erweiterungen mit der gleichen Stärke gibt, sollten Sie die wählen, die zuerst in der Liste steht. Zum Beispiel, wenn Sie \"Slices\" als Klasse und eine Liste von Erweiterungen erhalten: ['SErviNGSliCes', 'Cheese', 'StuFfed'], sollten Sie 'Slices.SErviNGSliCes' zurückgeben, da 'SErviNGSliCes' die stärkste Erweiterung ist (ihre Stärke ist -1). Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Du bekommst 2 Wörter. Du musst True zurückgeben, wenn das zweite Wort oder eine seiner Rotationen ein Teilstring im ersten Wort ist.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Du bekommst 2 Wörter. Du musst True zurückgeben, wenn das zweite Wort oder eine seiner Rotationen ein Teilstring im ersten Wort ist.\n    ", "natural_language": "German"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Gegeben eine positive Ganzzahl, erhalte ihre römische Numeral-Äquivalenz als Zeichenkette und gib sie in Kleinbuchstaben zurück.\nEinschränkungen: 1 <= num <= 1000\n\n    Beispiele:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Gegeben eine positive Ganzzahl, erhalte ihre römische Numeral-Äquivalenz als Zeichenkette und gib sie in Kleinbuchstaben zurück.\nEinschränkungen: 1 <= num <= 1000\n\n    Beispiele:\n    ", "natural_language": "German"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Gegeben sind die Längen der drei Seiten eines Dreiecks. Gib True zurück, wenn die drei Seiten ein rechtwinkliges Dreieck bilden, ansonsten False. Ein rechtwinkliges Dreieck ist ein Dreieck, bei dem ein Winkel ein rechter Winkel oder 90 Grad ist. Beispiel:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Gegeben sind die Längen der drei Seiten eines Dreiecks. Gib True zurück, wenn die drei Seiten ein rechtwinkliges Dreieck bilden, ansonsten False. Ein rechtwinkliges Dreieck ist ein Dreieck, bei dem ein Winkel ein rechter Winkel oder 90 Grad ist. Beispiel:\n    ", "natural_language": "German"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Du erhältst einen String s.\n    Wenn s[i] ein Buchstabe ist, kehre seine Groß- und Kleinschreibung um, oder umgekehrt,\n    ansonsten belasse es so wie es ist.\n    Wenn der String keine Buchstaben enthält, kehre den String um.\n    Die Funktion sollte den resultierenden String zurückgeben.\n    Beispiele\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Du erhältst einen String s.\n    Wenn s[i] ein Buchstabe ist, kehre seine Groß- und Kleinschreibung um, oder umgekehrt,\n    ansonsten belasse es so wie es ist.\n    Wenn der String keine Buchstaben enthält, kehre den String um.\n    Die Funktion sollte den resultierenden String zurückgeben.\n    Beispiele\n    ", "natural_language": "German"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Gegeben eine Zeichenkette 'text', gibt seine md5-Hash-Äquivalent-Zeichenkette zurück.\n    Wenn 'text' eine leere Zeichenkette ist, gib null zurück.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Gegeben eine Zeichenkette 'text', gibt seine md5-Hash-Äquivalent-Zeichenkette zurück.\n    Wenn 'text' eine leere Zeichenkette ist, gib null zurück.\n    ", "natural_language": "German"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Gegeben sind zwei positive ganze Zahlen a und b. Gib die geraden Ziffern zwischen a und b in aufsteigender Reihenfolge zurück.\n\n    Zum Beispiel:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Gegeben sind zwei positive ganze Zahlen a und b. Gib die geraden Ziffern zwischen a und b in aufsteigender Reihenfolge zurück.\n\n    Zum Beispiel:\n    ", "natural_language": "German"}
