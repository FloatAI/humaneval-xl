{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Binigyan ka ng listahan ng mga operasyon sa pagdedeposito at pagwiwithdraw sa isang bank account na nagsisimula sa zero balance. Ang iyong tungkulin ay upang malaman kung sa anumang punto ay bumaba ang balance ng account sa ilalim ng zero, at sa puntong iyon ay dapat na magbalik ng True ang function. Kung hindi naman, dapat itong magbalik ng False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Binigyan ka ng listahan ng mga operasyon sa pagdedeposito at pagwiwithdraw sa isang bank account na nagsisimula sa zero balance. Ang iyong tungkulin ay upang malaman kung sa anumang punto ay bumaba ang balance ng account sa ilalim ng zero, at sa puntong iyon ay dapat na magbalik ng True ang function. Kung hindi naman, dapat itong magbalik ng False.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Para sa isang ibinigay na listahan ng mga integer, ibalik ang isang tuple na binubuo ng kabuuan at produkto ng lahat ng mga integer sa listahan.\n    Ang walang laman na kabuuan ay dapat na magkatulad sa 0 at ang walang laman na produkto ay dapat na magkatulad sa 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Para sa isang ibinigay na listahan ng mga integer, ibalik ang isang tuple na binubuo ng kabuuan at produkto ng lahat ng mga integer sa listahan.\n    Ang walang laman na kabuuan ay dapat na magkatulad sa 0 at ang walang laman na produkto ay dapat na magkatulad sa 1.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Ang input ay dalawang string na binubuo lamang ng mga 1 at 0.\nGawin ang binary XOR sa mga input na ito at ibalik ang resulta bilang isang string.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "Ang input ay dalawang string na binubuo lamang ng mga 1 at 0.\nGawin ang binary XOR sa mga input na ito at ibalik ang resulta bilang isang string.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Mula sa listahan ng mga string, ibalik ang pinakamahabang isa. Ibalik ang unang isa kung mayroong maraming mga string na pareho ang haba. Ibalik ang null kung ang input list ay walang laman.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "Mula sa listahan ng mga string, ibalik ang pinakamahabang isa. Ibalik ang unang isa kung mayroong maraming mga string na pareho ang haba. Ibalik ang null kung ang input list ay walang laman.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Ibalik ang pinakamalaking pangkaraniwang divisor ng dalawang integer na a at b.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Ibalik ang pinakamalaking pangkaraniwang divisor ng dalawang integer na a at b.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Ang input ay isang string ng mga numero mula sa 'zero' hanggang 'nine' na may mga space sa pagitan.\n    Ang mga tamang pagpipilian ay 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' at 'nine'.\n    Ibalik ang string na may mga numero na nakaayos mula sa pinakamaliit hanggang sa pinakamalaki.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "Ang input ay isang string ng mga numero mula sa 'zero' hanggang 'nine' na may mga space sa pagitan.\n    Ang mga tamang pagpipilian ay 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' at 'nine'.\n    Ibalik ang string na may mga numero na nakaayos mula sa pinakamaliit hanggang sa pinakamalaki.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Bigyan ng listahan ng mga numero (ng hindi bababa sa dalawang elemento), mag-apply ng linear transform sa listahan na iyon, sa ganitong paraan: ang pinakamaliit na numero ay magiging 0 at ang pinakamalaki ay magiging 1.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Bigyan ng listahan ng mga numero (ng hindi bababa sa dalawang elemento), mag-apply ng linear transform sa listahan na iyon, sa ganitong paraan: ang pinakamaliit na numero ay magiging 0 at ang pinakamalaki ay magiging 1.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Para sa isang ibinigay na string, baligtarin ang mga maliit na titik patungo sa malalaking titik at ang malalaking titik patungo sa maliit na titik.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Para sa isang ibinigay na string, baligtarin ang mga maliit na titik patungo sa malalaking titik at ang malalaking titik patungo sa maliit na titik.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Ibalik lamang ang mga positibong numero sa listahan.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Ibalik lamang ang mga positibong numero sa listahan.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Ibalik ang true kung ang ibinigay na numero ay prime, at false kung hindi.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Ibalik ang true kung ang ibinigay na numero ay prime, at false kung hindi.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Ibalik ang mga nakaayos at natatanging elemento sa isang listahan.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Ibalik ang mga nakaayos at natatanging elemento sa isang listahan.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    Ang prime_fib ay nagbabalik ng n-th numero na isang bilang ng Fibonacci at ito rin ay isang bilang na prime.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "Ang prime_fib ay nagbabalik ng n-th numero na isang bilang ng Fibonacci at ito rin ay isang bilang na prime.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    Ang triples_sum_to_zero ay kumukuha ng isang listahan ng mga integer bilang input.\nIto ay nagbabalik ng True kung may tatlong magkakaibang elemento sa listahan na nagbibigay ng kabuuang halaga na zero, at False kung hindi.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "Ang triples_sum_to_zero ay kumukuha ng isang listahan ng mga integer bilang input.\nIto ay nagbabalik ng True kung may tatlong magkakaibang elemento sa listahan na nagbibigay ng kabuuang halaga na zero, at False kung hindi.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    Ang pairs_sum_to_zero ay tumatanggap ng isang listahan ng mga integer bilang input. Ito ay nagbabalik ng True kung mayroong dalawang magkaibang elemento sa listahan na nagbibigay ng kabuuan na zero, at False naman kung wala.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "Ang pairs_sum_to_zero ay tumatanggap ng isang listahan ng mga integer bilang input. Ito ay nagbabalik ng True kung mayroong dalawang magkaibang elemento sa listahan na nagbibigay ng kabuuan na zero, at False naman kung wala.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Ang Fib4 number sequence ay isang pagkakasunod-sunod ng mga numero na katulad ng Fibbonacci sequence na itinatadhana sa ganitong paraan:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Mangyaring sumulat ng isang function upang mabilis na maikompyuta ang n-th element ng Fib4 number sequence. Huwag gumamit ng recursion.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "Ang Fib4 number sequence ay isang pagkakasunod-sunod ng mga numero na katulad ng Fibbonacci sequence na itinatadhana sa ganitong paraan:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Mangyaring sumulat ng isang function upang mabilis na maikompyuta ang n-th element ng Fib4 number sequence. Huwag gumamit ng recursion.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Ibalik ang median ng mga elemento sa listahan na l.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Ibalik ang median ng mga elemento sa listahan na l.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Tinitingnan kung ang ibinigay na string ay palindrome.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Tinitingnan kung ang ibinigay na string ay palindrome.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    Ang remove_vowels ay isang function na kumukuha ng string at nagbabalik ng string na walang mga patinig.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "Ang remove_vowels ay isang function na kumukuha ng string at nagbabalik ng string na walang mga patinig.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Ibalik ang True kung lahat ng mga numero sa listahan na l ay nasa ilalim ng threshold na t.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Ibalik ang True kung lahat ng mga numero sa listahan na l ay nasa ilalim ng threshold na t.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Magdagdag ng dalawang numero x at y.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Magdagdag ng dalawang numero x at y.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Suriin kung pareho ang mga karakter ng dalawang salita.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Suriin kung pareho ang mga karakter ng dalawang salita.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Ibalik ang n-th bilang ng Fibonacci.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Ibalik ang n-th bilang ng Fibonacci.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Ibalik ang mga nakaayos at natatanging kahit na anong elemento para sa dalawang listahan.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Ibalik ang mga nakaayos at natatanging kahit na anong elemento para sa dalawang listahan.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Ibalik ang pinakamalaking pangunahing salik ng n. Ituring na n > 1 at hindi isang pangunahing bilang.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Ibalik ang pinakamalaking pangunahing salik ng n. Ituring na n > 1 at hindi isang pangunahing bilang.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"Ang sum_to_n ay isang function na nag-aadd ng mga numero mula 1 hanggang n.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "Ang sum_to_n ay isang function na nag-aadd ng mga numero mula 1 hanggang n.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" Ang xs ay nagpapakita ng mga kusog ng isang polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Ibabalik ang derivative ng polynomial na ito sa parehong anyo.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "Ang xs ay nagpapakita ng mga kusog ng isang polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Ibabalik ang derivative ng polynomial na ito sa parehong anyo.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"Ang FibFib number sequence ay isang sunud-sunod na katulad ng Fibbonacci sequence na itinatadhana sa mga sumusunod:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Mangyaring sumulat ng isang function upang mabilis na maikompyuta ang n-th element ng FibFib number sequence.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "Ang FibFib number sequence ay isang sunud-sunod na katulad ng Fibbonacci sequence na itinatadhana sa mga sumusunod:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Mangyaring sumulat ng isang function upang mabilis na maikompyuta ang n-th element ng FibFib number sequence.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Isulat ang isang function na vowels_count na kukuha ng isang string na nagrerepresenta ng isang salita bilang input at magrereport ng bilang ng mga vowels sa string. Ang mga vowels sa kaso na ito ay 'a', 'e', 'i', 'o', 'u'. Dito, ang 'y' ay isang vowel din, ngunit kung ito ay nasa dulo lamang ng binigay na salita.\n\n    Halimbawa:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Isulat ang isang function na vowels_count na kukuha ng isang string na nagrerepresenta ng isang salita bilang input at magrereport ng bilang ng mga vowels sa string. Ang mga vowels sa kaso na ito ay 'a', 'e', 'i', 'o', 'u'. Dito, ang 'y' ay isang vowel din, ngunit kung ito ay nasa dulo lamang ng binigay na salita.\n\n    Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Binigyan ka ng isang hindi walang laman na listahan ng mga positibong integer. Ibabalik ang pinakamalaking integer na mas malaki sa zero, at mayroong frequency na mas malaki o pantay sa halaga ng integer mismo. Ang frequency ng isang integer ay ang bilang ng beses na ito lumitaw sa listahan. Kung walang ganitong halaga, ibalik ang -1. Mga Halimbawa:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Binigyan ka ng isang hindi walang laman na listahan ng mga positibong integer. Ibabalik ang pinakamalaking integer na mas malaki sa zero, at mayroong frequency na mas malaki o pantay sa halaga ng integer mismo. Ang frequency ng isang integer ay ang bilang ng beses na ito lumitaw sa listahan. Kung walang ganitong halaga, ibalik ang -1. Mga Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Bigay ang haba ng tatlong gilid ng isang triangle. Ibabalik ang lawak ng triangle na naka-ikot sa 2 desimal na puntos kung ang tatlong gilid ay bumubuo ng isang wastong triangle. Kung hindi, ibabalik ang -1. Tatlong gilid ay bumubuo ng wastong triangle kung ang kabuuan ng dalawang gilid ay mas malaki kaysa sa ikatlong gilid. Halimbawa:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Bigay ang haba ng tatlong gilid ng isang triangle. Ibabalik ang lawak ng triangle na naka-ikot sa 2 desimal na puntos kung ang tatlong gilid ay bumubuo ng isang wastong triangle. Kung hindi, ibabalik ang -1. Tatlong gilid ay bumubuo ng wastong triangle kung ang kabuuan ng dalawang gilid ay mas malaki kaysa sa ikatlong gilid. Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Isulat ang isang function na magbabalik ng True kung ang object na q ay lalipad, at False kung hindi. Ang object na q ay lalipad kung ito ay balanse (palindromic list) at ang kabuuang halaga ng mga elemento nito ay mas mababa o pantay sa maximum na bigat na pwedeng dalhin na w.\n\n    Halimbawa:\nwill_it_fly([1, 2], 5) ➞ False \n# 1+2 ay mas mababa sa maximum na bigat, pero hindi ito balanse.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# ito ay balanse, pero 3+2+3 ay mas mataas sa maximum na bigat.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 ay mas mababa sa maximum na bigat, at ito ay balanse.\n\n    will_it_fly([3], 5) ➞ True\n# 3 ay mas mababa sa maximum na bigat, at ito ay balanse.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Isulat ang isang function na magbabalik ng True kung ang object na q ay lalipad, at False kung hindi. Ang object na q ay lalipad kung ito ay balanse (palindromic list) at ang kabuuang halaga ng mga elemento nito ay mas mababa o pantay sa maximum na bigat na pwedeng dalhin na w.\n\n    Halimbawa:\nwill_it_fly([1, 2], 5) ➞ False \n# 1+2 ay mas mababa sa maximum na bigat, pero hindi ito balanse.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# ito ay balanse, pero 3+2+3 ay mas mataas sa maximum na bigat.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 ay mas mababa sa maximum na bigat, at ito ay balanse.\n\n    will_it_fly([3], 5) ➞ True\n# 3 ay mas mababa sa maximum na bigat, at ito ay balanse.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Isulat ang isang function na magbabalik ng true kung ang ibinigay na numero ay ang resulta ng pagkakalat ng 3 prime numbers\nat false kung hindi. Alam na (a) ay mas mababa sa 100.\nHalimbawa:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Isulat ang isang function na magbabalik ng true kung ang ibinigay na numero ay ang resulta ng pagkakalat ng 3 prime numbers\nat false kung hindi. Alam na (a) ay mas mababa sa 100.\nHalimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Ibibigay sa iyo ang isang bilang sa decimal form at ang iyong gawain ay i-convert ito sa binary format. Ang function ay dapat magbalik ng isang string, kung saan bawat character ay kumakatawan sa isang binary number. Ang bawat character sa string ay magiging '0' o '1'.\n\n    Mayroong karagdagang ilang characters na 'db' sa simula at sa dulo ng string. Ang mga karagdagang characters ay nandoon upang makatulong sa format.\n\n    Mga Halimbawa:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Ibibigay sa iyo ang isang bilang sa decimal form at ang iyong gawain ay i-convert ito sa binary format. Ang function ay dapat magbalik ng isang string, kung saan bawat character ay kumakatawan sa isang binary number. Ang bawat character sa string ay magiging '0' o '1'.\n\n    Mayroong karagdagang ilang characters na 'db' sa simula at sa dulo ng string. Ang mga karagdagang characters ay nandoon upang makatulong sa format.\n\n    Mga Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Binigyan ka ng isang string na s.\nAng iyong tungkulin ay upang suriin kung ang string ay masaya o hindi.\nAng isang string ay masaya kung ang haba nito ay hindi bababa sa 3 at bawat 3 sunud-sunod na titik ay magkaiba.\nHalimbawa:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Binigyan ka ng isang string na s.\nAng iyong tungkulin ay upang suriin kung ang string ay masaya o hindi.\nAng isang string ay masaya kung ang haba nito ay hindi bababa sa 3 at bawat 3 sunud-sunod na titik ay magkaiba.\nHalimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Ito ay ang huling linggo ng semestre at kailangan ng guro na magbigay ng mga marka sa mga mag-aaral. Gumawa ang guro ng sariling algorithm para sa pagmamarka. Ang tanging problema ay nawala niya ang code na ginamit niya para sa pagmamarka. Binigyan ka niya ng listahan ng GPAs ng ilang mga mag-aaral at kailangan mong sumulat ng isang function na makakapaglabas ng listahan ng mga letra ng marka gamit ang sumusunod na talahanayan:\n\n                 GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Halimbawa:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "Ito ay ang huling linggo ng semestre at kailangan ng guro na magbigay ng mga marka sa mga mag-aaral. Gumawa ang guro ng sariling algorithm para sa pagmamarka. Ang tanging problema ay nawala niya ang code na ginamit niya para sa pagmamarka. Binigyan ka niya ng listahan ng GPAs ng ilang mga mag-aaral at kailangan mong sumulat ng isang function na makakapaglabas ng listahan ng mga letra ng marka gamit ang sumusunod na talahanayan:\n\n                 GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Isulat ang isang function na kumukuha ng isang string at nagbabalik ng True kung ang haba ng string ay isang bilang na pang-primo o False kung hindi. Mga Halimbawa\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Isulat ang isang function na kumukuha ng isang string at nagbabalik ng True kung ang haba ng string ay isang bilang na pang-primo o False kung hindi. Mga Halimbawa\n    ", "natural_language": "Tagalog"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Bigyan ng isang positibong integer N, ibalik ang kabuuang halaga ng mga digit nito sa binary.\n    \n    Halimbawa\n        Para sa N = 1000, ang kabuuang halaga ng mga digit ay 1 ang output ay dapat na \"1\".\n        Para sa N = 150, ang kabuuang halaga ng mga digit ay 6 ang output ay dapat na \"110\".\n        Para sa N = 147, ang kabuuang halaga ng mga digit ay 12 ang output ay dapat na \"1100\".\n    \n    Mga Variable:\n        @N integer\n             Mga Limitasyon: 0 ≤ N ≤ 10000.\n    Output:\n         isang string ng bilang na binaryo\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Bigyan ng isang positibong integer N, ibalik ang kabuuang halaga ng mga digit nito sa binary.\n    \n    Halimbawa\n        Para sa N = 1000, ang kabuuang halaga ng mga digit ay 1 ang output ay dapat na \"1\".\n        Para sa N = 150, ang kabuuang halaga ng mga digit ay 6 ang output ay dapat na \"110\".\n        Para sa N = 147, ang kabuuang halaga ng mga digit ay 12 ang output ay dapat na \"1100\".\n    \n    Mga Variable:\n        @N integer\n             Mga Limitasyon: 0 ≤ N ≤ 10000.\n    Output:\n         isang string ng bilang na binaryo\n    ", "natural_language": "Tagalog"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Ibinigay sa iyo ang isang 2-dimensyonal na data, bilang mga nested list, na katulad ng matrix, ngunit hindi katulad ng mga matrix, bawat hilera ay maaaring maglaman ng iba't ibang bilang ng mga haligi. Binigyan ng lst at integer x, hanapin ang mga integer x sa list, at ibalik ang list ng tuples, [(x1, y1), (x2, y2) ...] kung saan bawat tuple ay isang coordinate - (row, columns), na nagsisimula sa 0. I-sort ang mga coordinate sa simula sa mga hilera sa ascending order. Gayundin, i-sort ang mga coordinate ng row sa descending order.\n\n    Mga Halimbawa:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Ibinigay sa iyo ang isang 2-dimensyonal na data, bilang mga nested list, na katulad ng matrix, ngunit hindi katulad ng mga matrix, bawat hilera ay maaaring maglaman ng iba't ibang bilang ng mga haligi. Binigyan ng lst at integer x, hanapin ang mga integer x sa list, at ibalik ang list ng tuples, [(x1, y1), (x2, y2) ...] kung saan bawat tuple ay isang coordinate - (row, columns), na nagsisimula sa 0. I-sort ang mga coordinate sa simula sa mga hilera sa ascending order. Gayundin, i-sort ang mga coordinate ng row sa descending order.\n\n    Mga Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Binigyan ka ng listahan ng mga integer.\n    Isulat ang isang function na next_smallest() na nagbabalik ng pangalawang pinakamaliit na elemento ng listahan.\n    Ibaling ang null kung walang ganitong elemento.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Binigyan ka ng listahan ng mga integer.\n    Isulat ang isang function na next_smallest() na nagbabalik ng pangalawang pinakamaliit na elemento ng listahan.\n    Ibaling ang null kung walang ganitong elemento.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Ibibigay sa iyo ang isang string ng mga salita, at ang iyong tungkulin ay bilangin ang bilang ng mga nakakabagot. Ang nakakabagot ay isang pangungusap na nagsisimula sa salitang \"Ako\". Ang mga pangungusap ay nakadisenyo sa pamamagitan ng '.', '?' o '!'.\n\n    Halimbawa:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Ibibigay sa iyo ang isang string ng mga salita, at ang iyong tungkulin ay bilangin ang bilang ng mga nakakabagot. Ang nakakabagot ay isang pangungusap na nagsisimula sa salitang \"Ako\". Ang mga pangungusap ay nakadisenyo sa pamamagitan ng '.', '?' o '!'.\n\n    Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Binigyan ka ng listahan ng mga integer.\n    Kailangan mong hanapin ang pinakamalaking prime na halaga at ibalik ang kabuuan ng mga digit nito.\n\n        Halimbawa:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Binigyan ka ng listahan ng mga integer.\n    Kailangan mong hanapin ang pinakamalaking prime na halaga at ibalik ang kabuuan ng mga digit nito.\n\n        Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Bigay ang isang diksiyonaryo, magbalik ng True kung lahat ng mga susi ay mga string sa mababang kaso o lahat ng mga susi ay mga string sa mataas na kaso, kundi magbalik ng False. Ang function ay dapat magbalik ng False kung ang ibinigay na diksiyonaryo ay walang laman. Mga halimbawa:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Bigay ang isang diksiyonaryo, magbalik ng True kung lahat ng mga susi ay mga string sa mababang kaso o lahat ng mga susi ay mga string sa mataas na kaso, kundi magbalik ng False. Ang function ay dapat magbalik ng False kung ang ibinigay na diksiyonaryo ay walang laman. Mga halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Lumikha ng isang function na kumukuha ng halaga (string) na nagpapakita ng isang numero at nagbabalik ng pinakamalapit na integer dito. Kung ang numero ay parehong layo sa dalawang integers, ito ay iro-round pataas mula sa zero.\n\n        Halimbawa\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Lumikha ng isang function na kumukuha ng halaga (string) na nagpapakita ng isang numero at nagbabalik ng pinakamalapit na integer dito. Kung ang numero ay parehong layo sa dalawang integers, ito ay iro-round pataas mula sa zero.\n\n        Halimbawa\n    ", "natural_language": "Tagalog"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Bigyan ng isang positibong integer n, kailangan mong gumawa ng isang bunton ng n antas ng mga bato.\n    Ang unang antas ay may n na mga bato.\n    Ang bilang ng mga bato sa susunod na antas ay:\n        - ang susunod na odd number kung n ay odd.\n        - ang susunod na even number kung n ay even.\n    Ibalik ang bilang ng mga bato sa bawat antas sa isang listahan, kung saan ang elemento sa index\n    i ay nagpapakita ng bilang ng mga bato sa antas (i+1).\n\n        Halimbawa:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Bigyan ng isang positibong integer n, kailangan mong gumawa ng isang bunton ng n antas ng mga bato.\n    Ang unang antas ay may n na mga bato.\n    Ang bilang ng mga bato sa susunod na antas ay:\n        - ang susunod na odd number kung n ay odd.\n        - ang susunod na even number kung n ay even.\n    Ibalik ang bilang ng mga bato sa bawat antas sa isang listahan, kung saan ang elemento sa index\n    i ay nagpapakita ng bilang ng mga bato sa antas (i+1).\n\n        Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Ibibigay sa iyo ang isang string ng mga salita na hiwalay sa pamamagitan ng mga koma o espasyo. Ang iyong gawain ay upang hatiin ang string sa mga salita at ibalik ang isang array ng mga salita.\n\n    Halimbawa:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Ibibigay sa iyo ang isang string ng mga salita na hiwalay sa pamamagitan ng mga koma o espasyo. Ang iyong gawain ay upang hatiin ang string sa mga salita at ibalik ang isang array ng mga salita.\n\n    Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Ang function na ito ay kumukuha ng dalawang positibong bilang x at y at nagbabalik ng pinakamalaking even integer number na nasa range [x, y] kasama. Kung walang ganyang bilang, ang function ay dapat magbalik ng -1.\n\n    Halimbawa:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Ang function na ito ay kumukuha ng dalawang positibong bilang x at y at nagbabalik ng pinakamalaking even integer number na nasa range [x, y] kasama. Kung walang ganyang bilang, ang function ay dapat magbalik ng -1.\n\n    Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Binibigyan ka ng dalawang positibong integer na n at m, at ang iyong tungkulin ay upang kalkulahin ang average ng mga integer mula sa n hanggang m (kasama ang n at m). I-round ang sagot sa pinakamalapit na integer at i-convert ito sa binary. Kung ang n ay mas malaki kaysa sa m, ibalik ang -1. Halimbawa:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Binibigyan ka ng dalawang positibong integer na n at m, at ang iyong tungkulin ay upang kalkulahin ang average ng mga integer mula sa n hanggang m (kasama ang n at m). I-round ang sagot sa pinakamalapit na integer at i-convert ito sa binary. Kung ang n ay mas malaki kaysa sa m, ibalik ang -1. Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Ipakita ang function na f na may parameter na n,\n    at bumabalik ng isang listahan ng laki n, kung saan ang halaga ng elemento sa index i ay ang factorial ng i kung i ay patas\n    o ang kabuuan ng mga numero mula 1 hanggang i kung hindi.\n    Nag-uumpisa si i mula sa 1.\n    Ang factorial ng i ay ang pagmumultiplica ng mga numero mula 1 hanggang i (1 * 2 * ... * i).\n    Halimbawa:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Ipakita ang function na f na may parameter na n,\n    at bumabalik ng isang listahan ng laki n, kung saan ang halaga ng elemento sa index i ay ang factorial ng i kung i ay patas\n    o ang kabuuan ng mga numero mula 1 hanggang i kung hindi.\n    Nag-uumpisa si i mula sa 1.\n    Ang factorial ng i ay ang pagmumultiplica ng mga numero mula 1 hanggang i (1 * 2 * ... * i).\n    Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Sa ibinigay na positibong integer n, ibalik ang isang tuple na naglalaman ng bilang ng mga even at odd integer palindromes na nasa loob ng sakop ng (1, n), kasama ang n.\n\n        Halimbawa 1:\n\n            Input: 3\n        Output: (1, 2)\n        Paliwanag:\n        Ang mga integer palindrome ay 1, 2, 3. Isa sa kanila ay even, at dalawa sa kanila ay odd.\n\n        Halimbawa 2:\n\n            Input: 12\n        Output: (4, 6)\n        Paliwanag:\n        Ang mga integer palindrome ay 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Apat sa kanila ay even, at anim sa kanila ay odd.\n\n        Tandaan:\n        1. 1 <= n <= 10^3\n        2. Ang ibinalik na tuple ay naglalaman ng bilang ng mga even at odd integer palindromes.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Sa ibinigay na positibong integer n, ibalik ang isang tuple na naglalaman ng bilang ng mga even at odd integer palindromes na nasa loob ng sakop ng (1, n), kasama ang n.\n\n        Halimbawa 1:\n\n            Input: 3\n        Output: (1, 2)\n        Paliwanag:\n        Ang mga integer palindrome ay 1, 2, 3. Isa sa kanila ay even, at dalawa sa kanila ay odd.\n\n        Halimbawa 2:\n\n            Input: 12\n        Output: (4, 6)\n        Paliwanag:\n        Ang mga integer palindrome ay 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Apat sa kanila ay even, at anim sa kanila ay odd.\n\n        Tandaan:\n        1. 1 <= n <= 10^3\n        2. Ang ibinalik na tuple ay naglalaman ng bilang ng mga even at odd integer palindromes.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Mayroon tayong isang array na 'arr' ng N integers arr[1], arr[2], ..., arr[N]. Ang mga numerong nasa array ay magiging random na nakalagay. Ang iyong tungkulin ay malaman kung posible bang magkaroon ng isang array na nakaayos sa hindi bumababang order sa pamamagitan ng pagpapatakbo ng sumusunod na operasyon sa ibinigay na array:\n\n        Pinapayagan kang magpatupad ng operasyong right shift anumang bilang ng beses.\n\n    Ang isang operasyon ng right shift ay nangangahulugan ng paglipat ng lahat ng mga elemento ng array ng isang posisyon sa kanan. Ang huling elemento ng array ay ililipat sa pagsisimula ng posisyon sa array, ibig sabihin sa 0th index.\n\n    Kung posible na makakuha ng nakaayos na array sa pamamagitan ng pagpapatupad ng mga naunang operasyon, kung gayon magbalik ng True kundi magbalik ng False. Kung ang ibinigay na array ay walang laman, magbalik ng True.\n\n    Tandaan: Ang ibinigay na listahan ay garantisadong mayroong mga unique na elemento.\n\n    Halimbawa:\n\n        move_one_ball([3, 4, 5, 1, 2])==>True\n    Paliwanag: Sa pamamagitan ng pagpapatupad ng 2 na operasyon ng right shift, maaaring makamit ang hindi bumababang order para sa ibinigay na array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Paliwanag: Hindi posible na magkaroon ng hindi bumababang order para sa ibinigay na array sa pamamagitan ng anumang bilang ng operasyon ng right shift.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Mayroon tayong isang array na 'arr' ng N integers arr[1], arr[2], ..., arr[N]. Ang mga numerong nasa array ay magiging random na nakalagay. Ang iyong tungkulin ay malaman kung posible bang magkaroon ng isang array na nakaayos sa hindi bumababang order sa pamamagitan ng pagpapatakbo ng sumusunod na operasyon sa ibinigay na array:\n\n        Pinapayagan kang magpatupad ng operasyong right shift anumang bilang ng beses.\n\n    Ang isang operasyon ng right shift ay nangangahulugan ng paglipat ng lahat ng mga elemento ng array ng isang posisyon sa kanan. Ang huling elemento ng array ay ililipat sa pagsisimula ng posisyon sa array, ibig sabihin sa 0th index.\n\n    Kung posible na makakuha ng nakaayos na array sa pamamagitan ng pagpapatupad ng mga naunang operasyon, kung gayon magbalik ng True kundi magbalik ng False. Kung ang ibinigay na array ay walang laman, magbalik ng True.\n\n    Tandaan: Ang ibinigay na listahan ay garantisadong mayroong mga unique na elemento.\n\n    Halimbawa:\n\n        move_one_ball([3, 4, 5, 1, 2])==>True\n    Paliwanag: Sa pamamagitan ng pagpapatupad ng 2 na operasyon ng right shift, maaaring makamit ang hindi bumababang order para sa ibinigay na array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Paliwanag: Hindi posible na magkaroon ng hindi bumababang order para sa ibinigay na array sa pamamagitan ng anumang bilang ng operasyon ng right shift.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Sa problemang ito, gagawa ka ng isang function na kukuha ng dalawang listahan ng mga numero,\nat magdedetermine kung posible bang mag-exchange ng mga elemento\nsa pagitan ng dalawang listahan upang gawing listahan ng lst1 ay puro even numbers.\nWalang limitasyon sa bilang ng mga elemento na pwedeng i-exchange sa lst1 at lst2.\nKung posible na mag-exchange ng mga elemento sa lst1 at lst2 upang gawing\nlahat ng elemento ng lst1 ay even, ibalik ang \"YES\".\nKung hindi naman, ibalik ang \"NO\".\nHalimbawa:\nexchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\nexchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\nInaasahan na ang mga input list ay hindi magiging empty.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "Sa problemang ito, gagawa ka ng isang function na kukuha ng dalawang listahan ng mga numero,\nat magdedetermine kung posible bang mag-exchange ng mga elemento\nsa pagitan ng dalawang listahan upang gawing listahan ng lst1 ay puro even numbers.\nWalang limitasyon sa bilang ng mga elemento na pwedeng i-exchange sa lst1 at lst2.\nKung posible na mag-exchange ng mga elemento sa lst1 at lst2 upang gawing\nlahat ng elemento ng lst1 ay even, ibalik ang \"YES\".\nKung hindi naman, ibalik ang \"NO\".\nHalimbawa:\nexchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\nexchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\nInaasahan na ang mga input list ay hindi magiging empty.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Gawain\n    Binibigyan tayo ng dalawang mga string na s at c, kailangan mong burahin ang lahat ng mga character sa s na pareho sa anumang character sa c\n    pagkatapos ay suriin kung ang result string ay palindrome.\n    Ang isang string ay tinatawag na palindrome kung ito ay parehong mababasa mula sa likod at harap.\n    Dapat kang magbalik ng isang tuple na naglalaman ng result string at True/False para sa pagsusuri.\n    Halimbawa\n    Para sa s = \"abcde\", c = \"ae\", ang resulta ay dapat ('bcd',False)\n    Para sa s = \"abcdef\", c = \"b\" ang resulta ay dapat ('acdef',False)\n    Para sa s = \"abcdedcba\", c = \"ab\", ang resulta ay dapat ('cdedc',True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Gawain\n    Binibigyan tayo ng dalawang mga string na s at c, kailangan mong burahin ang lahat ng mga character sa s na pareho sa anumang character sa c\n    pagkatapos ay suriin kung ang result string ay palindrome.\n    Ang isang string ay tinatawag na palindrome kung ito ay parehong mababasa mula sa likod at harap.\n    Dapat kang magbalik ng isang tuple na naglalaman ng result string at True/False para sa pagsusuri.\n    Halimbawa\n    Para sa s = \"abcde\", c = \"ae\", ang resulta ay dapat ('bcd',False)\n    Para sa s = \"abcdef\", c = \"b\" ang resulta ay dapat ('acdef',False)\n    Para sa s = \"abcdedcba\", c = \"ab\", ang resulta ay dapat ('cdedc',True)\n    ", "natural_language": "Tagalog"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Binigyan ka ng isang rektangular na grid ng mga balon. Ang bawat hilera ay kumakatawan sa isang solong balon, at bawat 1 sa isang hilera ay kumakatawan sa isang solong yunit ng tubig. Ang bawat balon ay may katumbas na timba na maaaring gamitin upang kumuha ng tubig mula dito, at lahat ng timba ay may parehong kapasidad. Ang iyong tungkulin ay gamitin ang mga timba upang ilipat ang tubig mula sa mga balon. Ilabas ang bilang ng mga beses na kailangan mong ibaba ang mga timba.\n\n    Halimbawa 1:\n    Input:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        bucket_capacity: 1\n    Output: 6\n\n    Halimbawa 2:\n    Input:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        bucket_capacity: 2\n    Output: 5\n\n    Halimbawa 3:\n    Input:\n        grid: [[0,0,0], [0,0,0]]\n        bucket_capacity: 5\n    Output: 0\n\n    Mga limitasyon:\n    * pareho ang haba ng lahat ng mga balon\n    * 1 <= haba ng grid <= 10^2\n    * 1 <= haba ng grid[:,1] <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= kapasidad <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Binigyan ka ng isang rektangular na grid ng mga balon. Ang bawat hilera ay kumakatawan sa isang solong balon, at bawat 1 sa isang hilera ay kumakatawan sa isang solong yunit ng tubig. Ang bawat balon ay may katumbas na timba na maaaring gamitin upang kumuha ng tubig mula dito, at lahat ng timba ay may parehong kapasidad. Ang iyong tungkulin ay gamitin ang mga timba upang ilipat ang tubig mula sa mga balon. Ilabas ang bilang ng mga beses na kailangan mong ibaba ang mga timba.\n\n    Halimbawa 1:\n    Input:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        bucket_capacity: 1\n    Output: 6\n\n    Halimbawa 2:\n    Input:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        bucket_capacity: 2\n    Output: 5\n\n    Halimbawa 3:\n    Input:\n        grid: [[0,0,0], [0,0,0]]\n        bucket_capacity: 5\n    Output: 0\n\n    Mga limitasyon:\n    * pareho ang haba ng lahat ng mga balon\n    * 1 <= haba ng grid <= 10^2\n    * 1 <= haba ng grid[:,1] <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= kapasidad <= 10\n    ", "natural_language": "Tagalog"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Ibinigay ang isang string s at isang natural na bilang n, ikaw ay pinag-utos na magpatupad ng isang function na nagbabalik ng isang listahan ng lahat ng mga salita mula sa string s na naglalaman ng eksaktong n consonants, sa pagkakasunod-sunod na lumitaw ang mga salita sa string s. Kung ang string s ay walang laman, ang function ay dapat na magbalik ng isang walang laman na listahan. Tandaan: maaari mong ipagpalagay na ang input string ay naglalaman lamang ng mga titik at espasyo. Mga Halimbawa:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Ibinigay ang isang string s at isang natural na bilang n, ikaw ay pinag-utos na magpatupad ng isang function na nagbabalik ng isang listahan ng lahat ng mga salita mula sa string s na naglalaman ng eksaktong n consonants, sa pagkakasunod-sunod na lumitaw ang mga salita sa string s. Kung ang string s ay walang laman, ang function ay dapat na magbalik ng isang walang laman na listahan. Tandaan: maaari mong ipagpalagay na ang input string ay naglalaman lamang ng mga titik at espasyo. Mga Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Bigyan ng isang array na may mga integer na arr at isang positibong integer na k, ibalik ang isang nakaayos na listahan ng haba k na may maximum na k numerong nasa arr.\n\n    Halimbawa 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n    Output: [-4, -3, 5]\n\n    Halimbawa 2:\n\n        Input: arr = [4, -4, 4], k = 2\n    Output: [4, 4]\n\n    Halimbawa 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Output: [2]\n\n    Tandaan:\n    1. Ang haba ng array ay nasa saklaw ng [1, 1000].\n    2. Ang mga elemento sa array ay nasa saklaw ng [-1000, 1000].\n    3. 0 <= k <= haba ng arr.\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Bigyan ng isang array na may mga integer na arr at isang positibong integer na k, ibalik ang isang nakaayos na listahan ng haba k na may maximum na k numerong nasa arr.\n\n    Halimbawa 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n    Output: [-4, -3, 5]\n\n    Halimbawa 2:\n\n        Input: arr = [4, -4, 4], k = 2\n    Output: [4, 4]\n\n    Halimbawa 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Output: [2]\n\n    Tandaan:\n    1. Ang haba ng array ay nasa saklaw ng [1, 1000].\n    2. Ang mga elemento sa array ay nasa saklaw ng [-1000, 1000].\n    3. 0 <= k <= haba ng arr.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Bigay ang isang hindi-walang laman na array ng mga integer na arr at isang integer na k, ibalik ang kabuuan ng mga elemento na may hindi hihigit sa dalawang digit mula sa unang k na elemento ng arr.\n\n    Halimbawa:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Output: 24 # kabuuan ng 21 + 3\n\n    Mga Limitasyon:\n    1. 1 <= haba(arr) <= 100\n    2. 1 <= k <= haba(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Bigay ang isang hindi-walang laman na array ng mga integer na arr at isang integer na k, ibalik ang kabuuan ng mga elemento na may hindi hihigit sa dalawang digit mula sa unang k na elemento ng arr.\n\n    Halimbawa:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Output: 24 # kabuuan ng 21 + 3\n\n    Mga Limitasyon:\n    1. 1 <= haba(arr) <= 100\n    2. 1 <= k <= haba(arr)\n    ", "natural_language": "Tagalog"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Binigyan ka ng dalawang interval,\n    kung saan bawat interval ay binubuo ng mga integer. Halimbawa, interval = (start, end) = (1, 2).\n    Ang mga binigay na interval ay sarado kaya kasama ang start at end sa interval (start, end).\n    Para sa bawat binigay na interval, inaasahan na ang start nito ay mas mababa o pantay sa end.\n    Ang iyong tungkulin ay malaman kung ang haba ng pagtutugma ng dalawang interval na ito ay isang bilang na pang-primo.\n    Halimbawa, ang pagtutugma ng mga interval (1, 3), (2, 4) ay (2, 3)\n    kung saan ang haba nito ay 1, na hindi pang-primo.\n    Kung ang haba ng pagtutugma ay isang bilang na pang-primo, ibalik ang \"YES\",\n    kung hindi, ibalik ang \"NO\".\n    Kung hindi nagtutugma ang dalawang interval, ibalik ang \"NO\".\n\n    \n    [input/output] mga halimbawa:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Binigyan ka ng dalawang interval,\n    kung saan bawat interval ay binubuo ng mga integer. Halimbawa, interval = (start, end) = (1, 2).\n    Ang mga binigay na interval ay sarado kaya kasama ang start at end sa interval (start, end).\n    Para sa bawat binigay na interval, inaasahan na ang start nito ay mas mababa o pantay sa end.\n    Ang iyong tungkulin ay malaman kung ang haba ng pagtutugma ng dalawang interval na ito ay isang bilang na pang-primo.\n    Halimbawa, ang pagtutugma ng mga interval (1, 3), (2, 4) ay (2, 3)\n    kung saan ang haba nito ay 1, na hindi pang-primo.\n    Kung ang haba ng pagtutugma ay isang bilang na pang-primo, ibalik ang \"YES\",\n    kung hindi, ibalik ang \"NO\".\n    Kung hindi nagtutugma ang dalawang interval, ibalik ang \"NO\".\n\n    \n    [input/output] mga halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Lahat ay alam ang Fibonacci sequence, ito ay malalim na pinag-aralan ng mga matematiko sa nakaraang mga siglo. Gayunpaman, ang hindi alam ng mga tao ay ang Tribonacci sequence. Ang Tribonacci sequence ay binubuo ng recurrence na ito: tri(1) = 3 tri(n) = 1 + n / 2, kung n ay pati. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), kung n ay hindi pati. Halimbawa: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Binigyan ka ng isang hindi-negatibong bilang na integer n, kailangan mong bumalik ng isang listahan ng unang n + 1 mga numero ng Tribonacci sequence. Halimbawa: tri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Lahat ay alam ang Fibonacci sequence, ito ay malalim na pinag-aralan ng mga matematiko sa nakaraang mga siglo. Gayunpaman, ang hindi alam ng mga tao ay ang Tribonacci sequence. Ang Tribonacci sequence ay binubuo ng recurrence na ito: tri(1) = 3 tri(n) = 1 + n / 2, kung n ay pati. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), kung n ay hindi pati. Halimbawa: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Binigyan ka ng isang hindi-negatibong bilang na integer n, kailangan mong bumalik ng isang listahan ng unang n + 1 mga numero ng Tribonacci sequence. Halimbawa: tri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Tagalog"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Bigyan ng isang positibong integer n, ibalik ang produkto ng mga odd digit.\n    Ibalik ang 0 kung lahat ng digit ay even.\n    Halimbawa:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Bigyan ng isang positibong integer n, ibalik ang produkto ng mga odd digit.\n    Ibalik ang 0 kung lahat ng digit ay even.\n    Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Lumikha ng isang function na kumukuha ng string bilang input na naglalaman lamang ng mga square bracket. Ang function ay dapat na magbalik ng True kung mayroong wastong subsequence ng mga bracket kung saan hindi bababa sa isa sa mga bracket sa subsequence ay naka-nest.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Lumikha ng isang function na kumukuha ng string bilang input na naglalaman lamang ng mga square bracket. Ang function ay dapat na magbalik ng True kung mayroong wastong subsequence ng mga bracket kung saan hindi bababa sa isa sa mga bracket sa subsequence ay naka-nest.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Binigyan ka ng listahan ng mga numero.\n    Kailangan mong ibalik ang kabuuang halaga ng mga numero na naka-kuwadrado sa listahan,\n    i-round ang bawat elemento sa listahan sa pinakamalapit na buong bilang (Ceiling) muna.\n    Halimbawa:\n    Para sa lst = [1,2,3] ang output ay dapat na 14\n    Para sa lst = [1,4,9] ang output ay dapat na 98\n    Para sa lst = [1,3,5,7] ang output ay dapat na 84\n    Para sa lst = [1.4,4.2,0] ang output ay dapat na 29\n    Para sa lst = [-2.4,1,1] ang output ay dapat na 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Binigyan ka ng listahan ng mga numero.\n    Kailangan mong ibalik ang kabuuang halaga ng mga numero na naka-kuwadrado sa listahan,\n    i-round ang bawat elemento sa listahan sa pinakamalapit na buong bilang (Ceiling) muna.\n    Halimbawa:\n    Para sa lst = [1,2,3] ang output ay dapat na 14\n    Para sa lst = [1,4,9] ang output ay dapat na 98\n    Para sa lst = [1,3,5,7] ang output ay dapat na 84\n    Para sa lst = [1.4,4.2,0] ang output ay dapat na 29\n    Para sa lst = [-2.4,1,1] ang output ay dapat na 6\n    ", "natural_language": "Tagalog"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Lumikha ng isang function na nagbabalik ng True kung ang huling karakter ng ibinigay na string ay isang alpabetikong karakter at hindi bahagi ng isang salita, at False kung hindi. Tandaan: \"salita\" ay isang grupo ng mga karakter na hiwalay sa pamamagitan ng espasyo.\n\n    Mga Halimbawa:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Lumikha ng isang function na nagbabalik ng True kung ang huling karakter ng ibinigay na string ay isang alpabetikong karakter at hindi bahagi ng isang salita, at False kung hindi. Tandaan: \"salita\" ay isang grupo ng mga karakter na hiwalay sa pamamagitan ng espasyo.\n\n    Mga Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Lumikha ng isang function na nagbabalik ng pinakamalaking index ng isang elemento na hindi mas malaki o pantay sa elemento na nasa unahan nito. Kung walang ganitong elemento, ibalik ang -1. Ang ibinigay na array ay hindi maglalaman ng mga parehong halaga.\n\n    Mga Halimbawa:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Lumikha ng isang function na nagbabalik ng pinakamalaking index ng isang elemento na hindi mas malaki o pantay sa elemento na nasa unahan nito. Kung walang ganitong elemento, ibalik ang -1. Ang ibinigay na array ay hindi maglalaman ng mga parehong halaga.\n\n    Mga Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Lumikha ng isang function na nagbabalik ng tuple (a, b), kung saan 'a' ang pinakamalaking negatibong integer, at 'b' ang pinakamaliit na positibong integer sa isang listahan. Kung walang negatibong o positibong integer, ibalik ang mga ito bilang None.\n\n    Mga Halimbawa:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Lumikha ng isang function na nagbabalik ng tuple (a, b), kung saan 'a' ang pinakamalaking negatibong integer, at 'b' ang pinakamaliit na positibong integer sa isang listahan. Kung walang negatibong o positibong integer, ibalik ang mga ito bilang None.\n\n    Mga Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"Ang Brazilian factorial ay tinutukoy bilang:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    kung saan n > 0\n\n        Halimbawa:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "Ang Brazilian factorial ay tinutukoy bilang:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    kung saan n > 0\n\n        Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Binibigyan ka ng isang string na kumakatawan sa isang pangungusap,\n    ang pangungusap ay naglalaman ng ilang mga salita na hiwalay sa pamamagitan ng isang puwang,\n    at kailangan mong bumalik ng isang string na naglalaman ng mga salita mula sa orihinal na pangungusap,\n    na ang haba ay mga bilang na pang-primo,\n    ang pagkakasunod-sunod ng mga salita sa bagong string ay dapat pareho sa orihinal.\n\n        Halimbawa 1:\n        Input: pangungusap = \"Ito ay isang pagsusulit\"\n        Output: \"ay\"\n\n        Halimbawa 2:\n        Input: pangungusap = \"tayo na sa beach\"\n        Output: \"na sa\"\n\n        Mga Limitasyon:\n        * 1 <= haba(pangungusap) <= 100\n        * ang pangungusap ay naglalaman lamang ng mga titik\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Binibigyan ka ng isang string na kumakatawan sa isang pangungusap,\n    ang pangungusap ay naglalaman ng ilang mga salita na hiwalay sa pamamagitan ng isang puwang,\n    at kailangan mong bumalik ng isang string na naglalaman ng mga salita mula sa orihinal na pangungusap,\n    na ang haba ay mga bilang na pang-primo,\n    ang pagkakasunod-sunod ng mga salita sa bagong string ay dapat pareho sa orihinal.\n\n        Halimbawa 1:\n        Input: pangungusap = \"Ito ay isang pagsusulit\"\n        Output: \"ay\"\n\n        Halimbawa 2:\n        Input: pangungusap = \"tayo na sa beach\"\n        Output: \"na sa\"\n\n        Mga Limitasyon:\n        * 1 <= haba(pangungusap) <= 100\n        * ang pangungusap ay naglalaman lamang ng mga titik\n    ", "natural_language": "Tagalog"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Ang iyong gawain ay upang ipatupad ang isang function na magpapadali sa ekspresyon na x * n. Ang function ay magbabalik ng True kung ang x * n ay nagtataya sa isang buong bilang at False kung hindi. Pareho ang x at n, ay mga representasyon ng string ng isang fraction, at mayroong sumusunod na format, <numerator>/<denominator> kung saan pareho ang numerator at denominator ay positibong buong bilang.\n\n    Maaari mong ipagpalagay na ang x at n ay mga wastong fractions, at hindi naglalaman ng zero bilang denominator.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Ang iyong gawain ay upang ipatupad ang isang function na magpapadali sa ekspresyon na x * n. Ang function ay magbabalik ng True kung ang x * n ay nagtataya sa isang buong bilang at False kung hindi. Pareho ang x at n, ay mga representasyon ng string ng isang fraction, at mayroong sumusunod na format, <numerator>/<denominator> kung saan pareho ang numerator at denominator ay positibong buong bilang.\n\n    Maaari mong ipagpalagay na ang x at n ay mga wastong fractions, at hindi naglalaman ng zero bilang denominator.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Isulat ang isang function na nag-aayos ng listahan ng mga integer na ibinigay\n    sa pataas na ayos ayon sa kabuuang halaga ng kanilang mga digit.\n    Tandaan: kung mayroong ilang mga item na may parehong halaga ng kanilang mga digit,\n    ayusin sila batay sa kanilang index sa orihinal na listahan.\n\n        Halimbawa:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Isulat ang isang function na nag-aayos ng listahan ng mga integer na ibinigay\n    sa pataas na ayos ayon sa kabuuang halaga ng kanilang mga digit.\n    Tandaan: kung mayroong ilang mga item na may parehong halaga ng kanilang mga digit,\n    ayusin sila batay sa kanilang index sa orihinal na listahan.\n\n        Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Isulat ang isang function na kukuha ng isang array ng mga numero bilang input at magreresulta ng bilang ng mga elemento sa array na mas malaki sa 10 at parehong unang at huling digit ng isang numero ay odd (1, 3, 5, 7, 9). Halimbawa:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Isulat ang isang function na kukuha ng isang array ng mga numero bilang input at magreresulta ng bilang ng mga elemento sa array na mas malaki sa 10 at parehong unang at huling digit ng isang numero ay odd (1, 3, 5, 7, 9). Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Ibinigay sa iyo ang isang positibong integer n. Kailangan mong lumikha ng isang integer array a ng haba n. Para sa bawat i (1 ≤ i ≤ n), ang halaga ng a[i] = i * i - i + 1. Ibalik ang bilang ng mga triples (a[i], a[j], a[k]) ng a kung saan i < j < k, at a[i] + a[j] + a[k] ay isang multiple ng 3.\n\n    Halimbawa:\n    Input: n = 5\n    Output: 1\n    Paliwanag:\n    a = [1, 3, 7, 13, 21]\n    Ang tanging wastong triple ay (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Ibinigay sa iyo ang isang positibong integer n. Kailangan mong lumikha ng isang integer array a ng haba n. Para sa bawat i (1 ≤ i ≤ n), ang halaga ng a[i] = i * i - i + 1. Ibalik ang bilang ng mga triples (a[i], a[j], a[k]) ng a kung saan i < j < k, at a[i] + a[j] + a[k] ay isang multiple ng 3.\n\n    Halimbawa:\n    Input: n = 5\n    Output: 1\n    Paliwanag:\n    a = [1, 3, 7, 13, 21]\n    Ang tanging wastong triple ay (1, 7, 13).\n    ", "natural_language": "Tagalog"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    May walong planeta sa ating solar system: ang pinakamalapit sa araw ay Mercury, \n    ang susunod ay Venus, pagkatapos ay Earth, Mars, Jupiter, Saturn, Uranus, Neptune.\n    Isulat ang isang function na kukuha ng dalawang pangalan ng planeta bilang mga string na planet1 at planet2. \n    Ang function ay dapat magbalik ng isang tuple na naglalaman ng lahat ng mga planeta na ang mga orbita ay nasa pagitan ng orbita ng planet1 at planet2, na nakaayos ayon sa kalapitan sa araw. \n    Ang function ay dapat magbalik ng isang walang laman na tuple kung ang planet1 o planet2 ay hindi tamang pangalan ng planeta. \n    Mga Halimbawa\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "May walong planeta sa ating solar system: ang pinakamalapit sa araw ay Mercury, \n    ang susunod ay Venus, pagkatapos ay Earth, Mars, Jupiter, Saturn, Uranus, Neptune.\n    Isulat ang isang function na kukuha ng dalawang pangalan ng planeta bilang mga string na planet1 at planet2. \n    Ang function ay dapat magbalik ng isang tuple na naglalaman ng lahat ng mga planeta na ang mga orbita ay nasa pagitan ng orbita ng planet1 at planet2, na nakaayos ayon sa kalapitan sa araw. \n    Ang function ay dapat magbalik ng isang walang laman na tuple kung ang planet1 o planet2 ay hindi tamang pangalan ng planeta. \n    Mga Halimbawa\n    ", "natural_language": "Tagalog"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Isang simpleng programa na dapat magbalik ng halaga ng x kung ang n ay isang bilang pang-primo at dapat magbalik ng halaga ng y kung hindi.\n\n    Mga Halimbawa:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Isang simpleng programa na dapat magbalik ng halaga ng x kung ang n ay isang bilang pang-primo at dapat magbalik ng halaga ng y kung hindi.\n\n    Mga Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Bigay ang isang listahan ng mga numero, ibalik ang kabuuang halaga ng mga kuwadrado ng mga numero sa listahan na mga odd. Hindi kasama ang mga numero na negatibo o hindi mga integer.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    Kung ang input list ay walang laman, ibalik ang 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Bigay ang isang listahan ng mga numero, ibalik ang kabuuang halaga ng mga kuwadrado ng mga numero sa listahan na mga odd. Hindi kasama ang mga numero na negatibo o hindi mga integer.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    Kung ang input list ay walang laman, ibalik ang 0.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Ibibigay sa iyo ang pangalan ng isang klase (isang string) at isang listahan ng mga extension. Ang mga extension ay gagamitin upang mag-load ng karagdagang mga klase sa klase. Ang lakas ng extension ay base sa sumusunod: Tawaging CAP ang bilang ng mga uppercase na titik sa pangalan ng extension, at tawaging SM ang bilang ng mga lowercase na titik sa pangalan ng extension, ang lakas ay ibinibigay ng fraction na CAP - SM. Dapat mong hanapin ang pinakamalakas na extension at ibalik ang isang string sa format na ito: ClassName.StrongestExtensionName. Kung mayroong dalawang o higit pang mga extension na may parehong lakas, dapat mong piliin ang isa na unang lumitaw sa listahan. Halimbawa, kung ibinigay sa iyo ang \"Slices\" bilang klase at isang listahan ng mga extension: ['SErviNGSliCes', 'Cheese', 'StuFfed'] kailangan mong ibalik ang 'Slices.SErviNGSliCes' dahil ang 'SErviNGSliCes' ang pinakamalakas na extension (ang lakas nito ay -1). Halimbawa:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Ibibigay sa iyo ang pangalan ng isang klase (isang string) at isang listahan ng mga extension. Ang mga extension ay gagamitin upang mag-load ng karagdagang mga klase sa klase. Ang lakas ng extension ay base sa sumusunod: Tawaging CAP ang bilang ng mga uppercase na titik sa pangalan ng extension, at tawaging SM ang bilang ng mga lowercase na titik sa pangalan ng extension, ang lakas ay ibinibigay ng fraction na CAP - SM. Dapat mong hanapin ang pinakamalakas na extension at ibalik ang isang string sa format na ito: ClassName.StrongestExtensionName. Kung mayroong dalawang o higit pang mga extension na may parehong lakas, dapat mong piliin ang isa na unang lumitaw sa listahan. Halimbawa, kung ibinigay sa iyo ang \"Slices\" bilang klase at isang listahan ng mga extension: ['SErviNGSliCes', 'Cheese', 'StuFfed'] kailangan mong ibalik ang 'Slices.SErviNGSliCes' dahil ang 'SErviNGSliCes' ang pinakamalakas na extension (ang lakas nito ay -1). Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Binigyan ka ng 2 mga salita. Kailangan mong bumalik ng Tama kung ang pangalawang salita o anumang ng mga pag-ikot nito ay isang substring sa unang salita.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Binigyan ka ng 2 mga salita. Kailangan mong bumalik ng Tama kung ang pangalawang salita o anumang ng mga pag-ikot nito ay isang substring sa unang salita.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Bigyan ng isang positibong integer, kunin ang kanyang katumbas na roman numeral bilang isang string, at ibalik ito sa mababang kaso. Mga paghihigpit: 1 <= num <= 1000\n\n    Mga Halimbawa:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Bigyan ng isang positibong integer, kunin ang kanyang katumbas na roman numeral bilang isang string, at ibalik ito sa mababang kaso. Mga paghihigpit: 1 <= num <= 1000\n\n    Mga Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Bigay ang mga haba ng tatlong gilid ng isang triangle. Ibabalik ang True kung ang tatlong gilid ay bumubuo ng isang right-angled triangle, False kung hindi. Ang right-angled triangle ay isang triangle kung saan isa sa mga anggulo ay right angle o 90 degree. Halimbawa:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Bigay ang mga haba ng tatlong gilid ng isang triangle. Ibabalik ang True kung ang tatlong gilid ay bumubuo ng isang right-angled triangle, False kung hindi. Ang right-angled triangle ay isang triangle kung saan isa sa mga anggulo ay right angle o 90 degree. Halimbawa:\n    ", "natural_language": "Tagalog"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Ibinigay sa iyo ang isang string na s.\n    kung ang s[i] ay isang letra, baligtarin ang kanyang kaso mula sa mababa hanggang sa mataas o kabaligtaran nito,\n    kung hindi man, panatilihin itong gaya ng dati.\n    Kung walang mga letra sa string, baligtarin ang string.\n    Ang function ay dapat magbalik ng resultang string.\n    Mga Halimbawa\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Ibinigay sa iyo ang isang string na s.\n    kung ang s[i] ay isang letra, baligtarin ang kanyang kaso mula sa mababa hanggang sa mataas o kabaligtaran nito,\n    kung hindi man, panatilihin itong gaya ng dati.\n    Kung walang mga letra sa string, baligtarin ang string.\n    Ang function ay dapat magbalik ng resultang string.\n    Mga Halimbawa\n    ", "natural_language": "Tagalog"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Bigay ang isang string na 'text', ibalik ang katumbas nitong string na md5 hash. Kung ang 'text' ay isang walang laman na string, ibalik ang null.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Bigay ang isang string na 'text', ibalik ang katumbas nitong string na md5 hash. Kung ang 'text' ay isang walang laman na string, ibalik ang null.\n    ", "natural_language": "Tagalog"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Bigyan ng dalawang positibong integers na a at b, ibalik ang mga even digits sa pagitan ng a at b, sa pagsunod-sunod na ayos.\n\n    Halimbawa:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Bigyan ng dalawang positibong integers na a at b, ibalik ang mga even digits sa pagitan ng a at b, sa pagsunod-sunod na ayos.\n\n    Halimbawa:\n    ", "natural_language": "Tagalog"}
