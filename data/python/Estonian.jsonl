{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Sul on antud nimekiri pangakonto sissemaksetest ja väljamaksetest, mis algab nulljäägiga. Sinu ülesanne on tuvastada, kas mingil hetkel langeb kontoseis alla nulli ning sel juhul peaks funktsioon tagastama True. Vastasel juhul peaks see tagastama False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Sul on antud nimekiri pangakonto sissemaksetest ja väljamaksetest, mis algab nulljäägiga. Sinu ülesanne on tuvastada, kas mingil hetkel langeb kontoseis alla nulli ning sel juhul peaks funktsioon tagastama True. Vastasel juhul peaks see tagastama False.\n    ", "natural_language": "Estonian"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Antud täisarvude loendi korral tagastage tuple, mis koosneb loendi kõigi täisarvude summat ja korrutist. Tühi summa peaks olema võrdne 0-ga ja tühi korrutis peaks olema võrdne 1-ga.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Antud täisarvude loendi korral tagastage tuple, mis koosneb loendi kõigi täisarvude summat ja korrutist. Tühi summa peaks olema võrdne 0-ga ja tühi korrutis peaks olema võrdne 1-ga.\n    ", "natural_language": "Estonian"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Sisendiks on kaks stringi a ja b, mis koosnevad ainult 1-dest ja 0-dest.\nTehke nende sisenditega binaarne XOR ja tagastage tulemus ka stringina.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "Sisendiks on kaks stringi a ja b, mis koosnevad ainult 1-dest ja 0-dest.\nTehke nende sisenditega binaarne XOR ja tagastage tulemus ka stringina.\n    ", "natural_language": "Estonian"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Tagasta stringide nimekirjast kõige pikem. Mitme sama pikkuse korral tagasta esimene. Tühja nimekirja korral tagasta null.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "Tagasta stringide nimekirjast kõige pikem. Mitme sama pikkuse korral tagasta esimene. Tühja nimekirja korral tagasta null.\n    ", "natural_language": "Estonian"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Tagasta kahe täisarvu a ja b suurim ühistegur.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Tagasta kahe täisarvu a ja b suurim ühistegur.\n    ", "natural_language": "Estonian"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Sisendiks on tühikutega eraldatud numbrite string 'null' kuni 'üheksa'.\nKehtivad valikud on 'null', 'üks', 'kaks', 'kolm', 'neli', 'viis', 'kuus', 'seitse', 'kaheksa' ja 'üheksa'.\nTagastage string, kus numbrid on väikseimast suurimani sorteeritud.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "Sisendiks on tühikutega eraldatud numbrite string 'null' kuni 'üheksa'.\nKehtivad valikud on 'null', 'üks', 'kaks', 'kolm', 'neli', 'viis', 'kuus', 'seitse', 'kaheksa' ja 'üheksa'.\nTagastage string, kus numbrid on väikseimast suurimani sorteeritud.\n    ", "natural_language": "Estonian"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Antud arvude nimekirja (vähemalt kahest elemendist) korral rakendage sellele nimekirjale lineaarset transformatsiooni, nii et väikseim number muutuks 0-ks ja suurim 1-ks.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Antud arvude nimekirja (vähemalt kahest elemendist) korral rakendage sellele nimekirjale lineaarset transformatsiooni, nii et väikseim number muutuks 0-ks ja suurim 1-ks.\n    ", "natural_language": "Estonian"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Antud stringi puhul pööra väiketähed suurtähtedeks ja suurtähed väiketähtedeks.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Antud stringi puhul pööra väiketähed suurtähtedeks ja suurtähed väiketähtedeks.\n    ", "natural_language": "Estonian"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Tagasta ainult positiivsed numbrid nimekirjas.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Tagasta ainult positiivsed numbrid nimekirjas.\n    ", "natural_language": "Estonian"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Tagasta tõene, kui antud arv on algarv, ja väär muidu.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Tagasta tõene, kui antud arv on algarv, ja väär muidu.\n    ", "natural_language": "Estonian"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Tagasta sorteeritud unikaalsed elemendid nimekirjas.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Tagasta sorteeritud unikaalsed elemendid nimekirjas.\n    ", "natural_language": "Estonian"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib tagastab n-nda numbri, mis on Fibonacci jada liige ja samuti algarv.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib tagastab n-nda numbri, mis on Fibonacci jada liige ja samuti algarv.\n    ", "natural_language": "Estonian"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero võtab sisendiks täisarvude loendi.\nSee tagastab True, kui loendis on kolm erinevat elementi, mis summeerituna annavad nulli, ja False vastasel juhul.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "triples_sum_to_zero võtab sisendiks täisarvude loendi.\nSee tagastab True, kui loendis on kolm erinevat elementi, mis summeerituna annavad nulli, ja False vastasel juhul.\n    ", "natural_language": "Estonian"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero võtab sisendiks täisarvude loendi.\nSee tagastab True, kui loendis on kaks erinevat elementi, mis summeerituna annavad nulli, ja False vastasel juhul.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "pairs_sum_to_zero võtab sisendiks täisarvude loendi.\nSee tagastab True, kui loendis on kaks erinevat elementi, mis summeerituna annavad nulli, ja False vastasel juhul.\n    ", "natural_language": "Estonian"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Fib4 numbrite jada on jada, mis sarnaneb Fibbonacci jadale ja määratletakse järgmiselt:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Palun kirjutage funktsioon, mis arvutab tõhusalt fib4 numbrite jada n-nda elemendi. Ärge kasutage rekursiooni.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "Fib4 numbrite jada on jada, mis sarnaneb Fibbonacci jadale ja määratletakse järgmiselt:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Palun kirjutage funktsioon, mis arvutab tõhusalt fib4 numbrite jada n-nda elemendi. Ärge kasutage rekursiooni.\n    ", "natural_language": "Estonian"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Tagasta elementide l listi mediaan.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Tagasta elementide l listi mediaan.\n    ", "natural_language": "Estonian"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Kontrollib, kas antud string on palindroom.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Kontrollib, kas antud string on palindroom.\n    ", "natural_language": "Estonian"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels on funktsioon, mis võtab sisse stringi ja tagastab stringi ilma vokaalideta.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels on funktsioon, mis võtab sisse stringi ja tagastab stringi ilma vokaalideta.\n    ", "natural_language": "Estonian"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Tagasta tõene, kui kõik nimekirjas l olevad arvud on läve t all.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Tagasta tõene, kui kõik nimekirjas l olevad arvud on läve t all.\n    ", "natural_language": "Estonian"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Liida kaks arvu x ja y.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Liida kaks arvu x ja y.\n    ", "natural_language": "Estonian"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Kontrolli, kas kahe sõna tähemärgid on samad.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Kontrolli, kas kahe sõna tähemärgid on samad.\n    ", "natural_language": "Estonian"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Tagasta n-nes Fibonacci arv.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Tagasta n-nes Fibonacci arv.\n    ", "natural_language": "Estonian"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Tagastab kahe loendi jaoks sorteeritud unikaalsed ühised elemendid.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Tagastab kahe loendi jaoks sorteeritud unikaalsed ühised elemendid.\n    ", "natural_language": "Estonian"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Tagasta arvu n suurim algarvuline tegur. Eeldada, et n > 1 ja see ei ole algarv.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Tagasta arvu n suurim algarvuline tegur. Eeldada, et n > 1 ja see ei ole algarv.\n    ", "natural_language": "Estonian"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n on funktsioon, mis summeerib arvud 1-st n-ni.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n on funktsioon, mis summeerib arvud 1-st n-ni.\n    ", "natural_language": "Estonian"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs esindavad polünoomi koefitsiente.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Tagasta selle polünoomi tuletis samas vormis.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs esindavad polünoomi koefitsiente.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Tagasta selle polünoomi tuletis samas vormis.\n    ", "natural_language": "Estonian"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"FibFib numbrite jada on jada, mis sarnaneb Fibbonacci jadale ja on defineeritud järgmiselt:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Palun kirjutage funktsioon, mis arvutab tõhusalt FibFib numbrite jada n-nda elemendi.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "FibFib numbrite jada on jada, mis sarnaneb Fibbonacci jadale ja on defineeritud järgmiselt:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Palun kirjutage funktsioon, mis arvutab tõhusalt FibFib numbrite jada n-nda elemendi.\n    ", "natural_language": "Estonian"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Kirjutage funktsioon vowels_count, mis võtab sisendiks sõna esindava stringi ja tagastab stringis olevate täishäälikute arvu. Täishäälikud selles juhul on 'a', 'e', 'i', 'o', 'u'. Siin on 'y' ka täishäälik, kuid ainult siis, kui see on antud sõna lõpus.\n\n    Näide:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Kirjutage funktsioon vowels_count, mis võtab sisendiks sõna esindava stringi ja tagastab stringis olevate täishäälikute arvu. Täishäälikud selles juhul on 'a', 'e', 'i', 'o', 'u'. Siin on 'y' ka täishäälik, kuid ainult siis, kui see on antud sõna lõpus.\n\n    Näide:\n    ", "natural_language": "Estonian"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Sul on antud mittetühi nimekiri positiivsetest täisarvudest. Tagasta suurim täisarv, mis on suurem kui null ja mille sagedus on suurem või võrdne täisarvu endaga. Täisarvu sagedus on selle esinemiste arv nimekirjas. Kui sellist väärtust ei eksisteeri, tagasta -1. Näited:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Sul on antud mittetühi nimekiri positiivsetest täisarvudest. Tagasta suurim täisarv, mis on suurem kui null ja mille sagedus on suurem või võrdne täisarvu endaga. Täisarvu sagedus on selle esinemiste arv nimekirjas. Kui sellist väärtust ei eksisteeri, tagasta -1. Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Antud on kolmnurga kolme külje pikkused. Tagasta kolmnurga pindala, ümardatuna kahe kümnendkohani, kui kolm külge moodustavad kehtiva kolmnurga. Vastasel juhul tagasta -1. Kolm külge moodustavad kehtiva kolmnurga, kui kahe külje summa on suurem kui kolmas külg. Näide:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Antud on kolmnurga kolme külje pikkused. Tagasta kolmnurga pindala, ümardatuna kahe kümnendkohani, kui kolm külge moodustavad kehtiva kolmnurga. Vastasel juhul tagasta -1. Kolm külge moodustavad kehtiva kolmnurga, kui kahe külje summa on suurem kui kolmas külg. Näide:\n    ", "natural_language": "Estonian"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Kirjutage funktsioon, mis tagastab True, kui objekt q lendab, ja False vastasel juhul.\nObjekt q lendab, kui see on tasakaalustatud (see on palindroomne loend) ja selle elementide summa on väiksem või võrdne maksimaalse võimaliku kaaluga w.\n\n    Näide:\nwill_it_fly([1, 2], 5) ➞ False\n# 1 + 2 on maksimaalse võimaliku kaaluga võrreldes väiksem, kuid see on tasakaalustamata.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# see on tasakaalustatud, kuid 3 + 2 + 3 on maksimaalse võimaliku kaaluga võrreldes rohkem.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3 + 2 + 3 on maksimaalse võimaliku kaaluga võrreldes väiksem, ja see on tasakaalustatud.\n\n    will_it_fly([3], 5) ➞ True\n# 3 on maksimaalse võimaliku kaaluga võrreldes väiksem, ja see on tasakaalustatud.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Kirjutage funktsioon, mis tagastab True, kui objekt q lendab, ja False vastasel juhul.\nObjekt q lendab, kui see on tasakaalustatud (see on palindroomne loend) ja selle elementide summa on väiksem või võrdne maksimaalse võimaliku kaaluga w.\n\n    Näide:\nwill_it_fly([1, 2], 5) ➞ False\n# 1 + 2 on maksimaalse võimaliku kaaluga võrreldes väiksem, kuid see on tasakaalustamata.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# see on tasakaalustatud, kuid 3 + 2 + 3 on maksimaalse võimaliku kaaluga võrreldes rohkem.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3 + 2 + 3 on maksimaalse võimaliku kaaluga võrreldes väiksem, ja see on tasakaalustatud.\n\n    will_it_fly([3], 5) ➞ True\n# 3 on maksimaalse võimaliku kaaluga võrreldes väiksem, ja see on tasakaalustatud.\n    ", "natural_language": "Estonian"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Kirjutage funktsioon, mis tagastab tõese, kui antud arv on 3 algarvu korrutis, ja väär muidu. Teades, et (a) on väiksem kui 100. Näide:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Kirjutage funktsioon, mis tagastab tõese, kui antud arv on 3 algarvu korrutis, ja väär muidu. Teades, et (a) on väiksem kui 100. Näide:\n    ", "natural_language": "Estonian"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Sulle antakse arv kümnendarvuna ja sinu ülesanne on see teisendada\nbinarformaati. Funktsioon peaks tagastama stringi, kus iga sümbol esindab binararvu.\nIga stringi sümbol on '0' või '1'.\n\n    Stringi alguses ja lõpus on paar lisasümbolit 'db'. Need on seal formaadi abistamiseks.\n\n    Näited:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Sulle antakse arv kümnendarvuna ja sinu ülesanne on see teisendada\nbinarformaati. Funktsioon peaks tagastama stringi, kus iga sümbol esindab binararvu.\nIga stringi sümbol on '0' või '1'.\n\n    Stringi alguses ja lõpus on paar lisasümbolit 'db'. Need on seal formaadi abistamiseks.\n\n    Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Sulle antakse string s.\nSinu ülesanne on kontrollida, kas string on õnnelik või mitte.\nString on õnnelik, kui selle pikkus on vähemalt 3 ja igad 3 järjestikust tähte on erinevad.\nNäiteks:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Sulle antakse string s.\nSinu ülesanne on kontrollida, kas string on õnnelik või mitte.\nString on õnnelik, kui selle pikkus on vähemalt 3 ja igad 3 järjestikust tähte on erinevad.\nNäiteks:\n    ", "natural_language": "Estonian"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"See on semestri viimane nädal ja õpetaja peab andma õpilastele hinded. Õpetaja on loonud oma algoritmi hinnete määramiseks. Ainus probleem on see, et ta on kaotanud koodi, mida ta hindeid määramisel kasutas. Ta on andnud teile mõne õpilase GPA-de nimekirja ja peate kirjutama funktsiooni, mis saab väljundina kasutada järgmist tabelit kasutades tähtede hindeid:\n             GPA       |    Tähthinne\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Näide:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "See on semestri viimane nädal ja õpetaja peab andma õpilastele hinded. Õpetaja on loonud oma algoritmi hinnete määramiseks. Ainus probleem on see, et ta on kaotanud koodi, mida ta hindeid määramisel kasutas. Ta on andnud teile mõne õpilase GPA-de nimekirja ja peate kirjutama funktsiooni, mis saab väljundina kasutada järgmist tabelit kasutades tähtede hindeid:\n             GPA       |    Tähthinne\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Näide:\n    ", "natural_language": "Estonian"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Kirjutage funktsioon, mis võtab stringi ja tagastab True, kui stringi pikkus on algarv või False vastasel juhul. Näited.\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Kirjutage funktsioon, mis võtab stringi ja tagastab True, kui stringi pikkus on algarv või False vastasel juhul. Näited.\n    ", "natural_language": "Estonian"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Antud positiivsele täisarvule N tagastatakse selle binaarsüsteemis olevate numbrite summa.\n    \n    Näide:\n        Kui N = 1000, siis numbrite summa on 1 ja väljundiks on \"1\".\n        Kui N = 150, siis numbrite summa on 6 ja väljundiks on \"110\".\n        Kui N = 147, siis numbrite summa on 12 ja väljundiks on \"1100\".\n    \n    Muutujad:\n        @N täisarv\n             Piirangud: 0 ≤ N ≤ 10000.\n    Väljund:\n         binaararvuna esitatud string.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Antud positiivsele täisarvule N tagastatakse selle binaarsüsteemis olevate numbrite summa.\n    \n    Näide:\n        Kui N = 1000, siis numbrite summa on 1 ja väljundiks on \"1\".\n        Kui N = 150, siis numbrite summa on 6 ja väljundiks on \"110\".\n        Kui N = 147, siis numbrite summa on 12 ja väljundiks on \"1100\".\n    \n    Muutujad:\n        @N täisarv\n             Piirangud: 0 ≤ N ≤ 10000.\n    Väljund:\n         binaararvuna esitatud string.\n    ", "natural_language": "Estonian"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Sulle antakse 2-dimensionaalne andmestik, mis on pesastatud listidena, mis sarnaneb maatriksiga, kuid erinevalt maatriksitest võib igal real olla erinev arv veerge. Antud lst ja täisarv x, leia listis x täisarvud ja tagasta tuplede list [(x1, y1), (x2, y2) ...], kus iga tuple on koordinaat - (rida, veerud), alustades 0-st. Koordinaadid sorteeri alguses ridade järgi kasvavas järjekorras. Samuti sorteeri rea koordinaadid veergude järgi kahanevas järjekorras.\n\n    Näited:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Sulle antakse 2-dimensionaalne andmestik, mis on pesastatud listidena, mis sarnaneb maatriksiga, kuid erinevalt maatriksitest võib igal real olla erinev arv veerge. Antud lst ja täisarv x, leia listis x täisarvud ja tagasta tuplede list [(x1, y1), (x2, y2) ...], kus iga tuple on koordinaat - (rida, veerud), alustades 0-st. Koordinaadid sorteeri alguses ridade järgi kasvavas järjekorras. Samuti sorteeri rea koordinaadid veergude järgi kahanevas järjekorras.\n\n    Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Sul on antud täisarvude nimekiri.\nKirjuta funktsioon next_smallest(), mis tagastab nimekirja teise kõige väiksema elemendi.\nKui sellist elementi pole, tagasta null.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Sul on antud täisarvude nimekiri.\nKirjuta funktsioon next_smallest(), mis tagastab nimekirja teise kõige väiksema elemendi.\nKui sellist elementi pole, tagasta null.\n    ", "natural_language": "Estonian"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Teile antakse sõnade jada ja teie ülesanne on loendada igavusi. Igavus on lause, mis algab sõnaga \"Ma\". Lauseid eraldavad '.', '?' või '!'.\n\n    Näiteks:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Teile antakse sõnade jada ja teie ülesanne on loendada igavusi. Igavus on lause, mis algab sõnaga \"Ma\". Lauseid eraldavad '.', '?' või '!'.\n\n    Näiteks:\n    ", "natural_language": "Estonian"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Sul on antud täisarvude nimekiri.\n    Sa pead leidma suurima algarvu ja tagastama selle numbrite summa.\n\n        Näited:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Sul on antud täisarvude nimekiri.\n    Sa pead leidma suurima algarvu ja tagastama selle numbrite summa.\n\n        Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Antud sõnastiku korral tagastage True, kui kõik võtmed on väiketähtedega stringid või kõik võtmed on suurtähtedega stringid, vastasel juhul tagastage False. Funktsioon peaks tagastama False, kui antud sõnastik on tühi. Näited:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Antud sõnastiku korral tagastage True, kui kõik võtmed on väiketähtedega stringid või kõik võtmed on suurtähtedega stringid, vastasel juhul tagastage False. Funktsioon peaks tagastama False, kui antud sõnastik on tühi. Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Loo funktsioon, mis võtab väärtuse (string), mis esindab numbrit\nja tagastab sellele lähima täisarvu. Kui number on kahe täisarvu vahel võrdne kaugusega, ümarda see nullist eemale.\n\n    Näited:\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Loo funktsioon, mis võtab väärtuse (string), mis esindab numbrit\nja tagastab sellele lähima täisarvu. Kui number on kahe täisarvu vahel võrdne kaugusega, ümarda see nullist eemale.\n\n    Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Antud positiivsele täisarvule n tuleb luua n korrust kivide virna.\n    Esimesel korrusel on n kivi.\n    Järgmise korruse kivide arv on:\n        - järgmine paaritu arv, kui n on paaritu.\n        - järgmine paarisarv, kui n on paaris.\n    Tagasta kivide arv igal korrusel listina, kus elemendi indeks i esindab korruse (i+1) kivide arvu.\n\n        Näited:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Antud positiivsele täisarvule n tuleb luua n korrust kivide virna.\n    Esimesel korrusel on n kivi.\n    Järgmise korruse kivide arv on:\n        - järgmine paaritu arv, kui n on paaritu.\n        - järgmine paarisarv, kui n on paaris.\n    Tagasta kivide arv igal korrusel listina, kus elemendi indeks i esindab korruse (i+1) kivide arvu.\n\n        Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Teile antakse sõnade jada, mis on eraldatud komade või tühikutega. Teie ülesanne on jagada sõnad jadaks ja tagastada sõnade massiiv.\n\n    Näiteks:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Teile antakse sõnade jada, mis on eraldatud komade või tühikutega. Teie ülesanne on jagada sõnad jadaks ja tagastada sõnade massiiv.\n\n    Näiteks:\n    ", "natural_language": "Estonian"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"See funktsioon võtab kaks positiivset arvu x ja y ning tagastab suurima paarisarvu, mis jääb vahemikku [x, y] kaasa arvatud. Kui sellist arvu pole, siis peaks funktsioon tagastama -1.\n\n    Näiteks:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "See funktsioon võtab kaks positiivset arvu x ja y ning tagastab suurima paarisarvu, mis jääb vahemikku [x, y] kaasa arvatud. Kui sellist arvu pole, siis peaks funktsioon tagastama -1.\n\n    Näiteks:\n    ", "natural_language": "Estonian"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Sul on antud kaks positiivset täisarvu n ja m ning sinu ülesanne on arvutada n ja m vahemikus olevate täisarvude keskmine (kaasa arvatud n ja m). Ümarda vastus lähima täisarvuni ja teisenda see binararvuks. Kui n on suurem kui m, tagasta -1. Näide:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Sul on antud kaks positiivset täisarvu n ja m ning sinu ülesanne on arvutada n ja m vahemikus olevate täisarvude keskmine (kaasa arvatud n ja m). Ümarda vastus lähima täisarvuni ja teisenda see binararvuks. Kui n on suurem kui m, tagasta -1. Näide:\n    ", "natural_language": "Estonian"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Rakendage funktsioon f, mis võtab parameetrina n,\n    ja tagastab nimekirja suurusega n, nii et elemendi väärtus indeksil i on i faktoriaal, kui i on paarisarv\n    või arvude summa 1-st i-ni muul juhul.\n    i algab 1-st.\n    i faktoriaal on arvude korrutis 1-st i-ni (1 * 2 * ... * i).\n    Näide:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Rakendage funktsioon f, mis võtab parameetrina n,\n    ja tagastab nimekirja suurusega n, nii et elemendi väärtus indeksil i on i faktoriaal, kui i on paarisarv\n    või arvude summa 1-st i-ni muul juhul.\n    i algab 1-st.\n    i faktoriaal on arvude korrutis 1-st i-ni (1 * 2 * ... * i).\n    Näide:\n    ", "natural_language": "Estonian"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Antud positiivsele täisarvule n tagastage tuple, mis sisaldab paaris- ja paaritute täisarvuliste palindroomide arvu vahemikus (1, n), kaasa arvatud.\n\n        Näide 1:\n\n            Sisend: 3\n        Väljund: (1, 2)\n        Selgitus:\n        Täisarvulised palindroomid on 1, 2, 3. Üks neist on paarisarv ja kaks neist on paarituarvulised.\n\n        Näide 2:\n\n            Sisend: 12\n        Väljund: (4, 6)\n        Selgitus:\n        Täisarvulised palindroomid on 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Neli neist on paarisarvud ja kuus neist on paarituarvulised.\n\n        Märkus:\n        1. 1 <= n <= 10^3\n        2. tagastatud tuple sisaldab vastavalt paaris- ja paaritute täisarvuliste palindroomide arvu.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Antud positiivsele täisarvule n tagastage tuple, mis sisaldab paaris- ja paaritute täisarvuliste palindroomide arvu vahemikus (1, n), kaasa arvatud.\n\n        Näide 1:\n\n            Sisend: 3\n        Väljund: (1, 2)\n        Selgitus:\n        Täisarvulised palindroomid on 1, 2, 3. Üks neist on paarisarv ja kaks neist on paarituarvulised.\n\n        Näide 2:\n\n            Sisend: 12\n        Väljund: (4, 6)\n        Selgitus:\n        Täisarvulised palindroomid on 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Neli neist on paarisarvud ja kuus neist on paarituarvulised.\n\n        Märkus:\n        1. 1 <= n <= 10^3\n        2. tagastatud tuple sisaldab vastavalt paaris- ja paaritute täisarvuliste palindroomide arvu.\n    ", "natural_language": "Estonian"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Meil on massiiv 'arr' N tervet arvu arr[1], arr[2], ..., arr[N]. Massiivi numbrid on juhuslikus järjekorras. Sinu ülesanne on kindlaks teha, kas on võimalik saada massiiv, mis on sorteeritud mittekahanevas järjekorras, tehes järgmise toimingu antud massiivil:\n        Sul on lubatud teha parempööret ükskõik mitu korda.\n    \n    Üks parempööre tähendab kõigi massiivi elementide nihutamist ühe positsiooni võrra paremale. Massiivi viimane element liigutatakse alguspositsioonile massiivi 0. indeksis.\n\n        Kui on võimalik saada sorteeritud massiiv, tehes ülaltoodud toimingu, siis tagasta True, vastasel juhul tagasta False.\n    Kui antud massiiv on tühi, siis tagasta True.\n\n        Märkus: antud loendis on tagatud unikaalsed elemendid.\n\n        Näiteks:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Selgitus: kahe parempöörde tegemisega saab antud massiivi jaoks saavutada mittekahaneva järjestuse.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Selgitus: antud massiivi jaoks ei ole võimalik ühegi parempöörde tegemisega saavutada mittekahanevat järjestust.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Meil on massiiv 'arr' N tervet arvu arr[1], arr[2], ..., arr[N]. Massiivi numbrid on juhuslikus järjekorras. Sinu ülesanne on kindlaks teha, kas on võimalik saada massiiv, mis on sorteeritud mittekahanevas järjekorras, tehes järgmise toimingu antud massiivil:\n        Sul on lubatud teha parempööret ükskõik mitu korda.\n    \n    Üks parempööre tähendab kõigi massiivi elementide nihutamist ühe positsiooni võrra paremale. Massiivi viimane element liigutatakse alguspositsioonile massiivi 0. indeksis.\n\n        Kui on võimalik saada sorteeritud massiiv, tehes ülaltoodud toimingu, siis tagasta True, vastasel juhul tagasta False.\n    Kui antud massiiv on tühi, siis tagasta True.\n\n        Märkus: antud loendis on tagatud unikaalsed elemendid.\n\n        Näiteks:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Selgitus: kahe parempöörde tegemisega saab antud massiivi jaoks saavutada mittekahaneva järjestuse.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Selgitus: antud massiivi jaoks ei ole võimalik ühegi parempöörde tegemisega saavutada mittekahanevat järjestust.\n    ", "natural_language": "Estonian"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Selles ülesandes implementeerite funktsiooni, mis võtab vastu kaks arvude loendit ja otsustab, kas on võimalik nende vahel elemente vahetada, et muuta lst1 ainult paarisarvude loendiks. Vahetatud elementide arvul lst1 ja lst2 vahel pole piiranguid. Kui on võimalik vahetada elemente lst1 ja lst2 vahel, et muuta kõik lst1 elemendid paarisarvudeks, tagastage \"YES\". Vastasel juhul tagastage \"NO\". Näiteks: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Eeldame, et sisendloendid ei ole tühjad.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "Selles ülesandes implementeerite funktsiooni, mis võtab vastu kaks arvude loendit ja otsustab, kas on võimalik nende vahel elemente vahetada, et muuta lst1 ainult paarisarvude loendiks. Vahetatud elementide arvul lst1 ja lst2 vahel pole piiranguid. Kui on võimalik vahetada elemente lst1 ja lst2 vahel, et muuta kõik lst1 elemendid paarisarvudeks, tagastage \"YES\". Vastasel juhul tagastage \"NO\". Näiteks: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Eeldame, et sisendloendid ei ole tühjad.\n    ", "natural_language": "Estonian"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Ülesanne\nAntakse kaks stringi s ja c, peate kõik s-s olevad tähed, mis on võrdsed mis tahes tähemärgiga c-s, kustutama\nsiis kontrollige, kas tulemuse string on palindroom.\nStringi nimetatakse palindroomiks, kui see loeb tagurpidi sama kui edasi.\nPeate tagastama tuple, mis sisaldab tulemuse stringi ja True / False kontrollimiseks.\nNäide\nS = \"abcde\", c = \"ae\" korral peaks tulemus olema ('bcd', False)\nS = \"abcdef\", c = \"b\" korral peaks tulemus olema ('acdef', False)\nS = \"abcdedcba\", c = \"ab\" korral peaks tulemus olema ('cdedc', True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Ülesanne\nAntakse kaks stringi s ja c, peate kõik s-s olevad tähed, mis on võrdsed mis tahes tähemärgiga c-s, kustutama\nsiis kontrollige, kas tulemuse string on palindroom.\nStringi nimetatakse palindroomiks, kui see loeb tagurpidi sama kui edasi.\nPeate tagastama tuple, mis sisaldab tulemuse stringi ja True / False kontrollimiseks.\nNäide\nS = \"abcde\", c = \"ae\" korral peaks tulemus olema ('bcd', False)\nS = \"abcdef\", c = \"b\" korral peaks tulemus olema ('acdef', False)\nS = \"abcdedcba\", c = \"ab\" korral peaks tulemus olema ('cdedc', True)\n    ", "natural_language": "Estonian"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Teile antakse ruudukujuline kaevude võrgustik. Iga rida esindab ühte kaevu ja iga 1 reas esindab ühte ühikut vett. Igal kaevul on vastav ämber, mida saab kasutada vee eraldamiseks ja kõigil ämbritel on sama mahutavus. Teie ülesanne on kasutada ämbreid kaevude tühjendamiseks. Väljundage ämbrite langetamise arv.\n\n    Näide 1:\n    Sisend:\n        võrk: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        ämbri maht: 1\n    Väljund: 6\n\n    Näide 2:\n    Sisend:\n        võrk: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        ämbri maht: 2\n    Väljund: 5\n\n    Näide 3:\n    Sisend:\n        võrk: [[0,0,0], [0,0,0]]\n        ämbri maht: 5\n    Väljund: 0\n\n    Piirangud:\n    * kõik kaevud on sama pikkusega\n    * 1 <= võrgu pikkus <= 10^2\n    * 1 <= grid[:,1].length <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= maht <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Teile antakse ruudukujuline kaevude võrgustik. Iga rida esindab ühte kaevu ja iga 1 reas esindab ühte ühikut vett. Igal kaevul on vastav ämber, mida saab kasutada vee eraldamiseks ja kõigil ämbritel on sama mahutavus. Teie ülesanne on kasutada ämbreid kaevude tühjendamiseks. Väljundage ämbrite langetamise arv.\n\n    Näide 1:\n    Sisend:\n        võrk: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        ämbri maht: 1\n    Väljund: 6\n\n    Näide 2:\n    Sisend:\n        võrk: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        ämbri maht: 2\n    Väljund: 5\n\n    Näide 3:\n    Sisend:\n        võrk: [[0,0,0], [0,0,0]]\n        ämbri maht: 5\n    Väljund: 0\n\n    Piirangud:\n    * kõik kaevud on sama pikkusega\n    * 1 <= võrgu pikkus <= 10^2\n    * 1 <= grid[:,1].length <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= maht <= 10\n    ", "natural_language": "Estonian"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Antud on string s ja naturaalne number n. Sinu ülesandeks on implementeerida funktsioon, mis tagastab listi kõigist sõnadest stringis s, mis sisaldavad täpselt n konsonanti, järjekorras, milles need sõnad stringis s esinevad. Kui string s on tühi, siis peaks funktsioon tagastama tühja listi. Märkus: võid eeldada, et sisendstring sisaldab ainult tähti ja tühikuid. Näited:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Antud on string s ja naturaalne number n. Sinu ülesandeks on implementeerida funktsioon, mis tagastab listi kõigist sõnadest stringis s, mis sisaldavad täpselt n konsonanti, järjekorras, milles need sõnad stringis s esinevad. Kui string s on tühi, siis peaks funktsioon tagastama tühja listi. Märkus: võid eeldada, et sisendstring sisaldab ainult tähti ja tühikuid. Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Antud on täisarvude massiiv arr ja positiivne täisarv k. Tagasta sorteeritud nimekiri pikkusega k, mis sisaldab arr maksimaalseid k arve.\n\n    Näide 1:\n\n    Sisend: arr = [-3, -4, 5], k = 3\nVäljund: [-4, -3, 5]\n\n    Näide 2:\n\n    Sisend: arr = [4, -4, 4], k = 2\nVäljund: [4, 4]\n\n    Näide 3:\n\n    Sisend: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\nVäljund: [2]\n\n    Märkus:\n1. Massiivi pikkus on vahemikus [1, 1000].\n2. Massiivi elemendid on vahemikus [-1000, 1000].\n3. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Antud on täisarvude massiiv arr ja positiivne täisarv k. Tagasta sorteeritud nimekiri pikkusega k, mis sisaldab arr maksimaalseid k arve.\n\n    Näide 1:\n\n    Sisend: arr = [-3, -4, 5], k = 3\nVäljund: [-4, -3, 5]\n\n    Näide 2:\n\n    Sisend: arr = [4, -4, 4], k = 2\nVäljund: [4, 4]\n\n    Näide 3:\n\n    Sisend: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\nVäljund: [2]\n\n    Märkus:\n1. Massiivi pikkus on vahemikus [1, 1000].\n2. Massiivi elemendid on vahemikus [-1000, 1000].\n3. 0 <= k <= len(arr)\n    ", "natural_language": "Estonian"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Antud mittetühi täisarvude massiiv arr ja täisarv k, tagastatakse elementide summa, millel on kuni kahesed numbrid esimestest k arr elemendist.\n\n    Näide:\n\n    Sisend: arr = [111,21,3,4000,5,6,7,8,9], k = 4\nVäljund: 24 # summa 21 + 3\n\n    Piirangud:\n1. 1 <= len(arr) <= 100\n2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Antud mittetühi täisarvude massiiv arr ja täisarv k, tagastatakse elementide summa, millel on kuni kahesed numbrid esimestest k arr elemendist.\n\n    Näide:\n\n    Sisend: arr = [111,21,3,4000,5,6,7,8,9], k = 4\nVäljund: 24 # summa 21 + 3\n\n    Piirangud:\n1. 1 <= len(arr) <= 100\n2. 1 <= k <= len(arr)\n    ", "natural_language": "Estonian"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Sul on kaks intervalli, kus iga intervall koosneb kahest täisarvust. Näiteks intervall = (algus, lõpp) = (1, 2). Antud intervallid on suletud, mis tähendab, et intervall (algus, lõpp) sisaldab nii algust kui ka lõppu. Iga antud intervalli puhul eeldatakse, et selle algus on väiksem või võrdne selle lõpuga. Sinu ülesanne on määrata, kas nende kahe intervalli lõikepikkus on algarv. Näiteks intervallide (1, 3), (2, 4) lõik on (2, 3), mille pikkus on 1, mis ei ole algarv. Kui lõikepikkus on algarv, tagasta \"YES\", vastasel juhul tagasta \"NO\". Kui kaks intervalli ei lõiku, tagasta \"NO\".\n\n    Sisend/väljund näited:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Sul on kaks intervalli, kus iga intervall koosneb kahest täisarvust. Näiteks intervall = (algus, lõpp) = (1, 2). Antud intervallid on suletud, mis tähendab, et intervall (algus, lõpp) sisaldab nii algust kui ka lõppu. Iga antud intervalli puhul eeldatakse, et selle algus on väiksem või võrdne selle lõpuga. Sinu ülesanne on määrata, kas nende kahe intervalli lõikepikkus on algarv. Näiteks intervallide (1, 3), (2, 4) lõik on (2, 3), mille pikkus on 1, mis ei ole algarv. Kui lõikepikkus on algarv, tagasta \"YES\", vastasel juhul tagasta \"NO\". Kui kaks intervalli ei lõiku, tagasta \"NO\".\n\n    Sisend/väljund näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Igaüks teab Fibonacci jada, mida on viimase paari sajandi jooksul põhjalikult uuritud matemaatikute poolt. Kuid see, mida inimesed ei tea, on Tribonacci jada. Tribonacci jada on määratletud korduvusega:\ntri(1) = 3\ntri(n) = 1 + n / 2, kui n on paarisarv.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), kui n on paaritu.\nNäiteks:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nTeile antakse mitte-negatiivne täisarv n, peate tagastama Tribonacci jada esimese n + 1 numbri loendi.\nNäited:\ntri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Igaüks teab Fibonacci jada, mida on viimase paari sajandi jooksul põhjalikult uuritud matemaatikute poolt. Kuid see, mida inimesed ei tea, on Tribonacci jada. Tribonacci jada on määratletud korduvusega:\ntri(1) = 3\ntri(n) = 1 + n / 2, kui n on paarisarv.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), kui n on paaritu.\nNäiteks:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nTeile antakse mitte-negatiivne täisarv n, peate tagastama Tribonacci jada esimese n + 1 numbri loendi.\nNäited:\ntri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Estonian"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Antud positiivse täisarvu n korral tagastatakse paaritute numbrite korrutis.\nTagastatakse 0, kui kõik numbrid on paarisarvud.\nNäiteks:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Antud positiivse täisarvu n korral tagastatakse paaritute numbrite korrutis.\nTagastatakse 0, kui kõik numbrid on paarisarvud.\nNäiteks:\n    ", "natural_language": "Estonian"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Loo funktsioon, mis võtab sisendiks stringi, mis sisaldab ainult ruutklambreid.\nFunktsioon peaks tagastama True ainult siis, kui on olemas kehtiv sulgude alamsõne, \nkus vähemalt üks sulg alamsõnes on pesastatud.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Loo funktsioon, mis võtab sisendiks stringi, mis sisaldab ainult ruutklambreid.\nFunktsioon peaks tagastama True ainult siis, kui on olemas kehtiv sulgude alamsõne, \nkus vähemalt üks sulg alamsõnes on pesastatud.\n    ", "natural_language": "Estonian"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Sul on antud arvude nimekiri.\nSa pead tagastama antud nimekirjas olevate ruutude summa,\nümardama iga element nimekirjas esimesena ülemiseks täisarvuks (Ceiling).\nNäited:\nKui lst = [1,2,3], siis väljund peaks olema 14\nKui lst = [1,4,9], siis väljund peaks olema 98\nKui lst = [1,3,5,7], siis väljund peaks olema 84\nKui lst = [1.4,4.2,0], siis väljund peaks olema 29\nKui lst = [-2.4,1,1], siis väljund peaks olema 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Sul on antud arvude nimekiri.\nSa pead tagastama antud nimekirjas olevate ruutude summa,\nümardama iga element nimekirjas esimesena ülemiseks täisarvuks (Ceiling).\nNäited:\nKui lst = [1,2,3], siis väljund peaks olema 14\nKui lst = [1,4,9], siis väljund peaks olema 98\nKui lst = [1,3,5,7], siis väljund peaks olema 84\nKui lst = [1.4,4.2,0], siis väljund peaks olema 29\nKui lst = [-2.4,1,1], siis väljund peaks olema 6\n    ", "natural_language": "Estonian"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Loo funktsioon, mis tagastab True, kui antud stringi viimane tähemärk on täht ja ei ole osa sõnast ning False vastasel juhul. Märkus: \"sõna\" on tähemärkide rühm, mis on eraldatud tühikuga.\n\n    Näited:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Loo funktsioon, mis tagastab True, kui antud stringi viimane tähemärk on täht ja ei ole osa sõnast ning False vastasel juhul. Märkus: \"sõna\" on tähemärkide rühm, mis on eraldatud tühikuga.\n\n    Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Loo funktsioon, mis tagastab suurima indeksi elemendist, mis ei ole suurem ega võrdne sellele kohe eelneva elemendiga. Kui sellist elementi pole, tagasta -1. Antud massiiv ei sisalda korduvaid väärtusi.\n\n    Näited:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Loo funktsioon, mis tagastab suurima indeksi elemendist, mis ei ole suurem ega võrdne sellele kohe eelneva elemendiga. Kui sellist elementi pole, tagasta -1. Antud massiiv ei sisalda korduvaid väärtusi.\n\n    Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Loo funktsioon, mis tagastab tuple (a, b), kus 'a' on negatiivsete täisarvude suurim ja 'b' on positiivsete täisarvude väikseim element antud listis. Kui negatiivseid või positiivseid täisarve ei ole, tagasta None.\n\n    Näited:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Loo funktsioon, mis tagastab tuple (a, b), kus 'a' on negatiivsete täisarvude suurim ja 'b' on positiivsete täisarvude väikseim element antud listis. Kui negatiivseid või positiivseid täisarve ei ole, tagasta None.\n\n    Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"Brasiilia faktoriaal on defineeritud kui:\n    brasiilia_faktoriaal(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    kus n > 0\n\n        Näiteks:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "Brasiilia faktoriaal on defineeritud kui:\n    brasiilia_faktoriaal(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    kus n > 0\n\n        Näiteks:\n    ", "natural_language": "Estonian"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Sul on antud string, mis esindab lauset,\n    lauses on mõned sõnad, mis on eraldatud tühikuga,\n    ja sa pead tagastama stringi, mis sisaldab sõnu algsest lausest,\n    mille pikkused on algarvud,\n    uue stringi sõnade järjekord peaks olema sama kui algse lause oma.\n\n        Näide 1:\n        Sisend: lause = \"This is a test\"\n        Väljund: \"is\"\n\n        Näide 2:\n        Sisend: lause = \"lets go for swimming\"\n        Väljund: \"go for\"\n\n        Piirangud:\n        * 1 <= len(lause) <= 100\n        * lause sisaldab ainult tähti\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Sul on antud string, mis esindab lauset,\n    lauses on mõned sõnad, mis on eraldatud tühikuga,\n    ja sa pead tagastama stringi, mis sisaldab sõnu algsest lausest,\n    mille pikkused on algarvud,\n    uue stringi sõnade järjekord peaks olema sama kui algse lause oma.\n\n        Näide 1:\n        Sisend: lause = \"This is a test\"\n        Väljund: \"is\"\n\n        Näide 2:\n        Sisend: lause = \"lets go for swimming\"\n        Väljund: \"go for\"\n\n        Piirangud:\n        * 1 <= len(lause) <= 100\n        * lause sisaldab ainult tähti\n    ", "natural_language": "Estonian"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Teie ülesanne on rakendada funktsiooni, mis lihtsustab avaldist x * n. Funktsioon tagastab True, kui x * n hindab täisarvuks, ja False vastasel juhul. Nii x kui ka n on murru stringiesitus, millel on järgmine vorming, <loendaja>/<nimetaja>, kus mõlemad loendaja ja nimetaja on positiivsed täisarvud.\n\n    Võite eeldada, et x ja n on kehtivad murdude esitused ja neil pole null nimetajat.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Teie ülesanne on rakendada funktsiooni, mis lihtsustab avaldist x * n. Funktsioon tagastab True, kui x * n hindab täisarvuks, ja False vastasel juhul. Nii x kui ka n on murru stringiesitus, millel on järgmine vorming, <loendaja>/<nimetaja>, kus mõlemad loendaja ja nimetaja on positiivsed täisarvud.\n\n    Võite eeldada, et x ja n on kehtivad murdude esitused ja neil pole null nimetajat.\n    ", "natural_language": "Estonian"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Kirjutage funktsioon, mis sorteerib antud täisarvude loendi kasvavas järjekorras vastavalt nende numbrite summale. Märkus: kui on mitu elementi, mille numbrite summa on sarnane, sorteeritakse need nende indeksi järgi algse loendi järgi.\n\n    Näiteks:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Kirjutage funktsioon, mis sorteerib antud täisarvude loendi kasvavas järjekorras vastavalt nende numbrite summale. Märkus: kui on mitu elementi, mille numbrite summa on sarnane, sorteeritakse need nende indeksi järgi algse loendi järgi.\n\n    Näiteks:\n    ", "natural_language": "Estonian"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Kirjutage funktsioon, mis võtab sisendiks arvude massiivi ja tagastab massiivi elementide arvu, mis on suuremad kui 10 ja mille arvu esimene ja viimane number on paaritud (1, 3, 5, 7, 9). Näiteks:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Kirjutage funktsioon, mis võtab sisendiks arvude massiivi ja tagastab massiivi elementide arvu, mis on suuremad kui 10 ja mille arvu esimene ja viimane number on paaritud (1, 3, 5, 7, 9). Näiteks:\n    ", "natural_language": "Estonian"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Antakse positiivne täisarv n. Tuleb luua pikkusega n täisarvude massiiv a.\n        Iga i (1 ≤ i ≤ n) korral on a[i] väärtus = i * i - i + 1.\n        Tagasta kolmikute (a[i], a[j], a[k]) arv massiivis a, kus i < j < k ja a[i] + a[j] + a[k] on 3 kordne.\n\n        Näide:\n        Sisend: n = 5\n        Väljund: 1\n        Selgitus:\n        a = [1, 3, 7, 13, 21]\n        Ainuke kehtiv kolmik on (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Antakse positiivne täisarv n. Tuleb luua pikkusega n täisarvude massiiv a.\n        Iga i (1 ≤ i ≤ n) korral on a[i] väärtus = i * i - i + 1.\n        Tagasta kolmikute (a[i], a[j], a[k]) arv massiivis a, kus i < j < k ja a[i] + a[j] + a[k] on 3 kordne.\n\n        Näide:\n        Sisend: n = 5\n        Väljund: 1\n        Selgitus:\n        a = [1, 3, 7, 13, 21]\n        Ainuke kehtiv kolmik on (1, 7, 13).\n    ", "natural_language": "Estonian"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    Meie päikesesüsteemis on kaheksa planeeti: päikesele kõige lähemal on Merkuur, \njärgmine on Veenus, siis Maa, Mars, Jupiter, Saturn, Uraan ja Neptuun. \nKirjutage funktsioon, mis võtab kahe planeedi nime stringidena planet1 ja planet2. \nFunktsioon peaks tagastama tuple, mis sisaldab kõiki planeete, kelle orbiidid asuvad \nplaneet1 ja planeet2 orbiitide vahel, päikesele läheduse järgi sorteerituna. \nFunktsioon peaks tagastama tühja tuple, kui planet1 või planet2 pole õiged planeedi nimed. \nNäited:\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "Meie päikesesüsteemis on kaheksa planeeti: päikesele kõige lähemal on Merkuur, \njärgmine on Veenus, siis Maa, Mars, Jupiter, Saturn, Uraan ja Neptuun. \nKirjutage funktsioon, mis võtab kahe planeedi nime stringidena planet1 ja planet2. \nFunktsioon peaks tagastama tuple, mis sisaldab kõiki planeete, kelle orbiidid asuvad \nplaneet1 ja planeet2 orbiitide vahel, päikesele läheduse järgi sorteerituna. \nFunktsioon peaks tagastama tühja tuple, kui planet1 või planet2 pole õiged planeedi nimed. \nNäited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Lihtne programm, mis peaks tagastama x-i väärtuse, kui n on algarv, ja peaks tagastama y väärtuse muul juhul.\n\n    Näited:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Lihtne programm, mis peaks tagastama x-i väärtuse, kui n on algarv, ja peaks tagastama y väärtuse muul juhul.\n\n    Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Antud on arvude nimekiri, tagasta nende arvude ruutude summa, mis on paaritud. Eira negatiivseid arve ja mittetäisarve.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    Kui sisendnimekiri on tühi, tagasta 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Antud on arvude nimekiri, tagasta nende arvude ruutude summa, mis on paaritud. Eira negatiivseid arve ja mittetäisarve.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    Kui sisendnimekiri on tühi, tagasta 0.\n    ", "natural_language": "Estonian"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Teile antakse klassi nimi (string) ja laienduste loend.\nLaiendusi kasutatakse täiendavate klasside laadimiseks klassi. Laienduse tugevus on järgmine: olgu CAP laienduse nimes olevate suurtähtede arv ja SM laienduse nimes olevate väiketähtede arv, tugevus antakse murdosa CAP - SM järgi. Peate leidma tugevaima laienduse ja tagastama selle stringina järgmises vormingus: ClassName.StrongestExtensionName.\nKui on kaks või enam laiendust sama tugevusega, peaksite valima selle, mis on loendis esimene.\nNäiteks kui antakse klass \"Slices\" ja laienduste loend: ['SErviNGSliCes', 'Cheese', 'StuFfed'], siis peaksite tagastama 'Slices.SErviNGSliCes', kuna 'SErviNGSliCes' on tugevaim laiendus (selle tugevus on -1).\nNäide:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Teile antakse klassi nimi (string) ja laienduste loend.\nLaiendusi kasutatakse täiendavate klasside laadimiseks klassi. Laienduse tugevus on järgmine: olgu CAP laienduse nimes olevate suurtähtede arv ja SM laienduse nimes olevate väiketähtede arv, tugevus antakse murdosa CAP - SM järgi. Peate leidma tugevaima laienduse ja tagastama selle stringina järgmises vormingus: ClassName.StrongestExtensionName.\nKui on kaks või enam laiendust sama tugevusega, peaksite valima selle, mis on loendis esimene.\nNäiteks kui antakse klass \"Slices\" ja laienduste loend: ['SErviNGSliCes', 'Cheese', 'StuFfed'], siis peaksite tagastama 'Slices.SErviNGSliCes', kuna 'SErviNGSliCes' on tugevaim laiendus (selle tugevus on -1).\nNäide:\n    ", "natural_language": "Estonian"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Sulle antakse 2 sõna. Kui teine sõna või mõni selle rotatsioonidest on esimeses sõnas alamsõnaks, siis tuleb tagastada True.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Sulle antakse 2 sõna. Kui teine sõna või mõni selle rotatsioonidest on esimeses sõnas alamsõnaks, siis tuleb tagastada True.\n    ", "natural_language": "Estonian"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Antud positiivsele täisarvule leida selle rooma numbri ekvivalent stringina ning tagastada see väiketähtedega.\nPiirangud: 1 <= num <= 1000\n\n    Näited:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Antud positiivsele täisarvule leida selle rooma numbri ekvivalent stringina ning tagastada see väiketähtedega.\nPiirangud: 1 <= num <= 1000\n\n    Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Antud on kolme kolmnurga külje pikkused. Tagasta True, kui kolm külge moodustavad ristkülikukolmnurga, vastasel juhul False. Ristkülikukolmnurk on kolmnurk, mille üks nurk on ristnurk ehk 90 kraadi. Näide:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Antud on kolme kolmnurga külje pikkused. Tagasta True, kui kolm külge moodustavad ristkülikukolmnurga, vastasel juhul False. Ristkülikukolmnurk on kolmnurk, mille üks nurk on ristnurk ehk 90 kraadi. Näide:\n    ", "natural_language": "Estonian"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Sulle antakse string s.\n    Kui s[i] on täht, pööra selle kord ümber suurtähest väiketähel või vastupidi,\n    vastasel juhul jäta see samaks.\n    Kui stringis pole ühtegi tähte, pööra string ümber.\n    Funktsioon peaks tagastama tulemuseks saadud stringi.\n    Näited:\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Sulle antakse string s.\n    Kui s[i] on täht, pööra selle kord ümber suurtähest väiketähel või vastupidi,\n    vastasel juhul jäta see samaks.\n    Kui stringis pole ühtegi tähte, pööra string ümber.\n    Funktsioon peaks tagastama tulemuseks saadud stringi.\n    Näited:\n    ", "natural_language": "Estonian"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Antud stringi 'text' korral tagasta selle md5 räsiväärtusega string. Kui 'text' on tühi string, tagasta null.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Antud stringi 'text' korral tagasta selle md5 räsiväärtusega string. Kui 'text' on tühi string, tagasta null.\n    ", "natural_language": "Estonian"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Antud on kaks positiivset täisarvu a ja b. Tagasta a ja b vahel olevad paarisarvulised numbrid kasvavas järjekorras.\n\n    Näiteks:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Antud on kaks positiivset täisarvu a ja b. Tagasta a ja b vahel olevad paarisarvulised numbrid kasvavas järjekorras.\n\n    Näiteks:\n    ", "natural_language": "Estonian"}
