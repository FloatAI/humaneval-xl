{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Jy kry 'n lys van deposito en onttrekking operasies op 'n bankrekening wat begin met 'n nul balans. Jou taak is om te bepaal of die balans van die rekening op enige punt onder nul val, en op daardie punt moet die funksie True teruggee. Anders moet dit False teruggee.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Jy kry 'n lys van deposito en onttrekking operasies op 'n bankrekening wat begin met 'n nul balans. Jou taak is om te bepaal of die balans van die rekening op enige punt onder nul val, en op daardie punt moet die funksie True teruggee. Anders moet dit False teruggee.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Vir 'n gegewe lys van heelgetalle, gee 'n tuple terug wat bestaan uit 'n som en 'n produk van al die heelgetalle in die lys.\n    Leë som moet gelyk wees aan 0 en leë produk moet gelyk wees aan 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Vir 'n gegewe lys van heelgetalle, gee 'n tuple terug wat bestaan uit 'n som en 'n produk van al die heelgetalle in die lys.\n    Leë som moet gelyk wees aan 0 en leë produk moet gelyk wees aan 1.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Die insette is twee reekse a en b wat slegs uit 1's en 0's bestaan.\nVoer binêre XOR op hierdie insette uit en gee die resultaat ook terug as 'n string.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "Die insette is twee reekse a en b wat slegs uit 1's en 0's bestaan.\nVoer binêre XOR op hierdie insette uit en gee die resultaat ook terug as 'n string.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Uit 'n lys van strings, gee die langste een terug. Gee die eerste een terug in die geval van meerdere strings van dieselfde lengte. Gee null terug in die geval dat die invoerlys leeg is.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "Uit 'n lys van strings, gee die langste een terug. Gee die eerste een terug in die geval van meerdere strings van dieselfde lengte. Gee null terug in die geval dat die invoerlys leeg is.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Gee die grootste gemeenskaplike deler van twee heelgetalle a en b terug.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Gee die grootste gemeenskaplike deler van twee heelgetalle a en b terug.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Die inset is 'n spasie-gedeelde string van getalle van 'nul' tot 'nege'.\n    Geldige keuses is 'nul', 'een', 'twee', 'drie', 'vier', 'vyf', 'ses', 'sewe', 'agt' en 'nege'.\n    Gee die string terug met die getalle gesorteer van die kleinste tot die grootste.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "Die inset is 'n spasie-gedeelde string van getalle van 'nul' tot 'nege'.\n    Geldige keuses is 'nul', 'een', 'twee', 'drie', 'vier', 'vyf', 'ses', 'sewe', 'agt' en 'nege'.\n    Gee die string terug met die getalle gesorteer van die kleinste tot die grootste.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Gegee 'n lys van getalle (van ten minste twee elemente), pas 'n lineêre transformasie toe op daardie lys,\nsodat die kleinste getal 0 sal word en die grootste 1 sal word.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Gegee 'n lys van getalle (van ten minste twee elemente), pas 'n lineêre transformasie toe op daardie lys,\nsodat die kleinste getal 0 sal word en die grootste 1 sal word.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Vir 'n gegewe string, draai kleinletters na hoofletters en hoofletters na kleinletters.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Vir 'n gegewe string, draai kleinletters na hoofletters en hoofletters na kleinletters.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Gee slegs positiewe getalle terug in die lys.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Gee slegs positiewe getalle terug in die lys.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Gee waar terug as 'n gegewe nommer 'n priemgetal is, en vals andersins.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Gee waar terug as 'n gegewe nommer 'n priemgetal is, en vals andersins.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Gee gesorteerde unieke elemente terug in 'n lys.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Gee gesorteerde unieke elemente terug in 'n lys.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib gee terug die n-de nommer wat 'n Fibonacci-nommer is en ook 'n priemgetal is.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib gee terug die n-de nommer wat 'n Fibonacci-nommer is en ook 'n priemgetal is.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero neem 'n lys van heelgetalle as 'n inset en gee 'n waarde van Waar terug as daar drie onderskeie elemente in die lys is wat saam tot nul optel, en vals andersins.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "triples_sum_to_zero neem 'n lys van heelgetalle as 'n inset en gee 'n waarde van Waar terug as daar drie onderskeie elemente in die lys is wat saam tot nul optel, en vals andersins.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero neem 'n lys van heelgetalle as 'n inset en gee True terug as daar twee onderskeie elemente in die lys is wat tot nul optel, en False andersins.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "pairs_sum_to_zero neem 'n lys van heelgetalle as 'n inset en gee True terug as daar twee onderskeie elemente in die lys is wat tot nul optel, en False andersins.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Die Fib4-getalreeks is 'n reeks soortgelyk aan die Fibbonacci-reeks wat as volg gedefinieer word:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Skryf asseblief 'n funksie om die n-de element van die fib4-getalreeks doeltreffend te bereken. Moenie herhaling gebruik nie.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "Die Fib4-getalreeks is 'n reeks soortgelyk aan die Fibbonacci-reeks wat as volg gedefinieer word:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Skryf asseblief 'n funksie om die n-de element van die fib4-getalreeks doeltreffend te bereken. Moenie herhaling gebruik nie.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Gee die mediaan van elemente in die lys l terug.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Gee die mediaan van elemente in die lys l terug.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Kyk of die gegewe string 'n palindroom is.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Kyk of die gegewe string 'n palindroom is.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    \"remove_vowels\" is 'n funksie wat 'n string neem en 'n string sonder klinkers teruggee.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "\"remove_vowels\" is 'n funksie wat 'n string neem en 'n string sonder klinkers teruggee.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Gee Waar terug as alle getalle in die lys l onder die drempelwaarde t is.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Gee Waar terug as alle getalle in die lys l onder die drempelwaarde t is.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Voeg twee getalle x en y by.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Voeg twee getalle x en y by.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Kyk of twee woorde dieselfde karakters het.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Kyk of twee woorde dieselfde karakters het.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Gee die n-de Fibonacci-getal terug.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Gee die n-de Fibonacci-getal terug.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Gee gesorteerde unieke gemeenskaplike elemente vir twee lys.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Gee gesorteerde unieke gemeenskaplike elemente vir twee lys.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Gee die grootste priemfaktor van n terug. Aanvaar dat n > 1 en nie 'n priemgetal is nie.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Gee die grootste priemfaktor van n terug. Aanvaar dat n > 1 en nie 'n priemgetal is nie.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n is 'n funksie wat getalle van 1 tot n optel.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n is 'n funksie wat getalle van 1 tot n optel.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs verteenwoordig koëffisiënte van 'n polinoom.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Gee die afgeleide van hierdie polinoom terug in dieselfde vorm.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs verteenwoordig koëffisiënte van 'n polinoom.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Gee die afgeleide van hierdie polinoom terug in dieselfde vorm.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"Die FibFib getalreeks is 'n reeks soortgelyk aan die Fibbonacci-reeks wat as volg gedefinieer word:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Skryf asseblief 'n funksie om die n-de element van die fibfib getalreeks effektief te bereken.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "Die FibFib getalreeks is 'n reeks soortgelyk aan die Fibbonacci-reeks wat as volg gedefinieer word:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Skryf asseblief 'n funksie om die n-de element van die fibfib getalreeks effektief te bereken.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Skryf 'n funksie vowels_count wat 'n string wat 'n woord voorstel as inset neem en die aantal klinkers in die string teruggee. Klinkers in hierdie geval is 'a', 'e', 'i', 'o', 'u'. Hier is 'y' ook 'n klinker, maar slegs as dit aan die einde van die gegewe woord is.\n\n    Voorbeeld:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Skryf 'n funksie vowels_count wat 'n string wat 'n woord voorstel as inset neem en die aantal klinkers in die string teruggee. Klinkers in hierdie geval is 'a', 'e', 'i', 'o', 'u'. Hier is 'y' ook 'n klinker, maar slegs as dit aan die einde van die gegewe woord is.\n\n    Voorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Jy kry 'n nie-leë lys van positiewe heelgetalle. Gee die grootste heelgetal terug wat groter is as nul en 'n frekwensie het wat groter is as of gelyk is aan die waarde van die heelgetal self. Die frekwensie van 'n heelgetal is die aantal kere wat dit in die lys voorkom. As daar geen sulke waarde bestaan nie, gee -1 terug. Voorbeelde:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Jy kry 'n nie-leë lys van positiewe heelgetalle. Gee die grootste heelgetal terug wat groter is as nul en 'n frekwensie het wat groter is as of gelyk is aan die waarde van die heelgetal self. Die frekwensie van 'n heelgetal is die aantal kere wat dit in die lys voorkom. As daar geen sulke waarde bestaan nie, gee -1 terug. Voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Gegee die lengtes van die drie sye van 'n driehoek. Gee die oppervlakte van die driehoek terug afgerond tot 2 desimale punte as die drie sye 'n geldige driehoek vorm. Anders gee -1 terug. Drie sye maak 'n geldige driehoek wanneer die som van enige twee sye groter is as die derde sy. Voorbeeld:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Gegee die lengtes van die drie sye van 'n driehoek. Gee die oppervlakte van die driehoek terug afgerond tot 2 desimale punte as die drie sye 'n geldige driehoek vorm. Anders gee -1 terug. Drie sye maak 'n geldige driehoek wanneer die som van enige twee sye groter is as die derde sy. Voorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Skryf 'n funksie wat True teruggee as die voorwerp q sal vlieg, en andersins False.\nDie voorwerp q sal vlieg as dit gebalanseerd is (dit is 'n palindromiese lys) en die som van sy elemente minder as of gelyk aan die maksimum moontlike gewig w is.\n\n    Voorbeeld:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 is minder as die maksimum moontlike gewig, maar dit is ongebalanseerd.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# dit is gebalanseerd, maar 3+2+3 is meer as die maksimum moontlike gewig.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 is minder as die maksimum moontlike gewig, en dit is gebalanseerd.\n\n    will_it_fly([3], 5) ➞ True\n# 3 is minder as die maksimum moontlike gewig, en dit is gebalanseerd.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Skryf 'n funksie wat True teruggee as die voorwerp q sal vlieg, en andersins False.\nDie voorwerp q sal vlieg as dit gebalanseerd is (dit is 'n palindromiese lys) en die som van sy elemente minder as of gelyk aan die maksimum moontlike gewig w is.\n\n    Voorbeeld:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 is minder as die maksimum moontlike gewig, maar dit is ongebalanseerd.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n# dit is gebalanseerd, maar 3+2+3 is meer as die maksimum moontlike gewig.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 is minder as die maksimum moontlike gewig, en dit is gebalanseerd.\n\n    will_it_fly([3], 5) ➞ True\n# 3 is minder as die maksimum moontlike gewig, en dit is gebalanseerd.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Skryf 'n funksie wat waar teruggee as die gegewe getal die vermenigvuldiging van 3 priemgetalle is en vals andersins. Wetende dat (a) minder as 100 is. Voorbeeld:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Skryf 'n funksie wat waar teruggee as die gegewe getal die vermenigvuldiging van 3 priemgetalle is en vals andersins. Wetende dat (a) minder as 100 is. Voorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Jy sal 'n nommer in desimale vorm ontvang en jou taak is om dit na binêre formaat te omskep. Die funksie moet 'n string teruggee, met elke karakter wat 'n binêre nommer voorstel. Elke karakter in die string sal 'n '0' of '1' wees.\n\n    Daar sal 'n paar ekstra karakters 'db' aan die begin en einde van die string wees. Die ekstra karakters is daar om met die formaat te help.\n\n    Voorbeelde:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Jy sal 'n nommer in desimale vorm ontvang en jou taak is om dit na binêre formaat te omskep. Die funksie moet 'n string teruggee, met elke karakter wat 'n binêre nommer voorstel. Elke karakter in die string sal 'n '0' of '1' wees.\n\n    Daar sal 'n paar ekstra karakters 'db' aan die begin en einde van die string wees. Die ekstra karakters is daar om met die formaat te help.\n\n    Voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Jy kry 'n string s.\n    Jou taak is om te kyk of die string gelukkig is of nie.\n    'n String is gelukkig as sy lengte ten minste 3 is en elke 3 opeenvolgende letters verskillend is.\n    Byvoorbeeld:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Jy kry 'n string s.\n    Jou taak is om te kyk of die string gelukkig is of nie.\n    'n String is gelukkig as sy lengte ten minste 3 is en elke 3 opeenvolgende letters verskillend is.\n    Byvoorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Dit is die laaste week van die semester en die onderwyser moet die punte aan die studente gee. Die onderwyser het haar eie algoritme vir gradering gemaak. Die enigste probleem is dat sy die kode wat sy vir gradering gebruik het, verloor het. Sy het 'n lys van GPAs vir sommige studente gegee en jy moet 'n funksie skryf wat 'n lys van lettergrade kan uitvoer deur die volgende tabel te gebruik: \n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n    Voorbeeld:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "Dit is die laaste week van die semester en die onderwyser moet die punte aan die studente gee. Die onderwyser het haar eie algoritme vir gradering gemaak. Die enigste probleem is dat sy die kode wat sy vir gradering gebruik het, verloor het. Sy het 'n lys van GPAs vir sommige studente gegee en jy moet 'n funksie skryf wat 'n lys van lettergrade kan uitvoer deur die volgende tabel te gebruik: \n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n    Voorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Skryf 'n funksie wat 'n string neem en True teruggee as die stringlengte 'n priemgetal is of andersins vals teruggee\n    Voorbeelde\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Skryf 'n funksie wat 'n string neem en True teruggee as die stringlengte 'n priemgetal is of andersins vals teruggee\n    Voorbeelde\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Gegee 'n positiewe heelgetal N, gee die totale som van sy syfers in binêre vorm terug.\n\n        Voorbeeld\n        Vir N = 1000, sal die som van syfers 1 wees en die uitset moet \"1\" wees.\n        Vir N = 150, sal die som van syfers 6 wees en die uitset moet \"110\" wees.\n        Vir N = 147, sal die som van syfers 12 wees en die uitset moet \"1100\" wees.\n    \n    Veranderlikes:\n        @N heelgetal\n             Beperkings: 0 ≤ N ≤ 10000.\n    Uitset:\n         'n string van binêre nommer.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Gegee 'n positiewe heelgetal N, gee die totale som van sy syfers in binêre vorm terug.\n\n        Voorbeeld\n        Vir N = 1000, sal die som van syfers 1 wees en die uitset moet \"1\" wees.\n        Vir N = 150, sal die som van syfers 6 wees en die uitset moet \"110\" wees.\n        Vir N = 147, sal die som van syfers 12 wees en die uitset moet \"1100\" wees.\n    \n    Veranderlikes:\n        @N heelgetal\n             Beperkings: 0 ≤ N ≤ 10000.\n    Uitset:\n         'n string van binêre nommer.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Jy kry 'n 2-dimensionele data, as 'n geneste lys,\nwat soortgelyk is aan 'n matriks, maar anders as matrikse,\nkan elke ry 'n ander aantal kolomme bevat.\nGegee lst en 'n heelgetal x, vind heelgetalle x in die lys,\nen gee 'n lys van tuples terug, [(x1, y1), (x2, y2) ...] sodat\nelke tuple 'n koördinaat is - (ry, kolomme), beginnende met 0.\nSorteer koördinate aanvanklik volgens rye in oplopende volgorde.\nSorteer ook koördinate van die ry volgens kolomme in aflopende volgorde.\n\n    Voorbeelde:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Jy kry 'n 2-dimensionele data, as 'n geneste lys,\nwat soortgelyk is aan 'n matriks, maar anders as matrikse,\nkan elke ry 'n ander aantal kolomme bevat.\nGegee lst en 'n heelgetal x, vind heelgetalle x in die lys,\nen gee 'n lys van tuples terug, [(x1, y1), (x2, y2) ...] sodat\nelke tuple 'n koördinaat is - (ry, kolomme), beginnende met 0.\nSorteer koördinate aanvanklik volgens rye in oplopende volgorde.\nSorteer ook koördinate van die ry volgens kolomme in aflopende volgorde.\n\n    Voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Jy kry 'n lys van heelgetalle.\n    Skryf 'n funksie next_smallest() wat die tweede kleinste element van die lys teruggee.\n    Gee null terug as daar geen sulke element is nie.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Jy kry 'n lys van heelgetalle.\n    Skryf 'n funksie next_smallest() wat die tweede kleinste element van die lys teruggee.\n    Gee null terug as daar geen sulke element is nie.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Jy sal 'n string van woorde gegee word, en jou taak is om die aantal vervelings te tel. 'n Verveling is 'n sin wat met die woord \"Ek\" begin. Sinne word afgebaken deur '.', '?' of '!'. \n\n    Byvoorbeeld:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Jy sal 'n string van woorde gegee word, en jou taak is om die aantal vervelings te tel. 'n Verveling is 'n sin wat met die woord \"Ek\" begin. Sinne word afgebaken deur '.', '?' of '!'. \n\n    Byvoorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Jy kry 'n lys van heelgetalle.\n    Jy moet die grootste priemgetal vind en die som van sy syfers teruggee.\n\n        Voorbeelde:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Jy kry 'n lys van heelgetalle.\n    Jy moet die grootste priemgetal vind en die som van sy syfers teruggee.\n\n        Voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Gegee 'n woordeboek, gee waar as alle sleutels strings in kleinletters is of alle sleutels strings in hoofletters is, anders gee vals terug. Die funksie moet vals teruggee as die gegee woordeboek leeg is. Voorbeelde:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Gegee 'n woordeboek, gee waar as alle sleutels strings in kleinletters is of alle sleutels strings in hoofletters is, anders gee vals terug. Die funksie moet vals teruggee as die gegee woordeboek leeg is. Voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Skep 'n funksie wat 'n waarde (string) wat 'n nommer voorstel, aanvaar en die naaste heelgetal daaraan teruggee. As die nommer ewe ver van twee heelgetalle af is, rond dit weg van nul af.\n\n    Voorbeelde\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Skep 'n funksie wat 'n waarde (string) wat 'n nommer voorstel, aanvaar en die naaste heelgetal daaraan teruggee. As die nommer ewe ver van twee heelgetalle af is, rond dit weg van nul af.\n\n    Voorbeelde\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Gegee 'n positiewe heelgetal n, moet jy 'n hoop van n vlakke klippe maak.\n    Die eerste vlak het n klippe.\n    Die aantal klippe in die volgende vlak is:\n        - die volgende onewe getal as n onewe is.\n        - die volgende ewe getal as n ewe is.\n    Gee die aantal klippe in elke vlak terug in 'n lys, waar die element by indeks\n    i die aantal klippe in vlak (i+1) verteenwoordig.\n\n        Voorbeelde:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Gegee 'n positiewe heelgetal n, moet jy 'n hoop van n vlakke klippe maak.\n    Die eerste vlak het n klippe.\n    Die aantal klippe in die volgende vlak is:\n        - die volgende onewe getal as n onewe is.\n        - die volgende ewe getal as n ewe is.\n    Gee die aantal klippe in elke vlak terug in 'n lys, waar die element by indeks\n    i die aantal klippe in vlak (i+1) verteenwoordig.\n\n        Voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Jy sal 'n string van woorde gekommaseer of geskei deur spasies ontvang. Jou taak is om die string in woorde te verdeel en 'n array van die woorde terug te gee.\n\n    Byvoorbeeld:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Jy sal 'n string van woorde gekommaseer of geskei deur spasies ontvang. Jou taak is om die string in woorde te verdeel en 'n array van die woorde terug te gee.\n\n    Byvoorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Hierdie funksie neem twee positiewe getalle, x en y, en gee die grootste ewe heelgetal terug wat in die interval [x, y] insluitend is. As daar geen sulke getal is nie, moet die funksie -1 teruggee.\n\n    Byvoorbeeld:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Hierdie funksie neem twee positiewe getalle, x en y, en gee die grootste ewe heelgetal terug wat in die interval [x, y] insluitend is. As daar geen sulke getal is nie, moet die funksie -1 teruggee.\n\n    Byvoorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Jy kry twee positiewe heelgetalle n en m, en jou taak is om die gemiddelde van die heelgetalle vanaf n tot m (insluitend n en m) te bereken. Rond die antwoord af na die naaste heelgetal en omskep dit na binêre. As n groter is as m, gee -1 terug. Voorbeeld:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Jy kry twee positiewe heelgetalle n en m, en jou taak is om die gemiddelde van die heelgetalle vanaf n tot m (insluitend n en m) te bereken. Rond die antwoord af na die naaste heelgetal en omskep dit na binêre. As n groter is as m, gee -1 terug. Voorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Implementeer die funksie f wat n as 'n parameter neem,\nen 'n lys van grootte n teruggee, sodat die waarde van die element by indeks i die faktoriaal van i is as i ewe is,\nof die som van getalle van 1 tot i andersins.\ni begin by 1.\nDie faktoriaal van i is die vermenigvuldiging van die getalle van 1 tot i (1 * 2 * ... * i).\nVoorbeeld:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Implementeer die funksie f wat n as 'n parameter neem,\nen 'n lys van grootte n teruggee, sodat die waarde van die element by indeks i die faktoriaal van i is as i ewe is,\nof die som van getalle van 1 tot i andersins.\ni begin by 1.\nDie faktoriaal van i is die vermenigvuldiging van die getalle van 1 tot i (1 * 2 * ... * i).\nVoorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Gegee 'n positiewe heelgetal n, gee 'n tuple terug wat die aantal ewe en onewe heelgetal palindromes bevat wat binne die reeks (1, n) val, insluitend.\n\n    Voorbeeld 1:\n\n        Inset: 3\n    Uitset: (1, 2)\n    Verduideliking:\n    Heelgetal palindroom is 1, 2, 3. Een van hulle is ewe, en twee van hulle is onewe.\n\n    Voorbeeld 2:\n\n        Inset: 12\n    Uitset: (4, 6)\n    Verduideliking:\n    Heelgetal palindroom is 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier van hulle is ewe, en 6 van hulle is onewe.\n\n    Nota:\n    1. 1 <= n <= 10^3\n    2. Die teruggekeerde tuple het onderskeidelik die aantal ewe en onewe heelgetal palindromes.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Gegee 'n positiewe heelgetal n, gee 'n tuple terug wat die aantal ewe en onewe heelgetal palindromes bevat wat binne die reeks (1, n) val, insluitend.\n\n    Voorbeeld 1:\n\n        Inset: 3\n    Uitset: (1, 2)\n    Verduideliking:\n    Heelgetal palindroom is 1, 2, 3. Een van hulle is ewe, en twee van hulle is onewe.\n\n    Voorbeeld 2:\n\n        Inset: 12\n    Uitset: (4, 6)\n    Verduideliking:\n    Heelgetal palindroom is 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier van hulle is ewe, en 6 van hulle is onewe.\n\n    Nota:\n    1. 1 <= n <= 10^3\n    2. Die teruggekeerde tuple het onderskeidelik die aantal ewe en onewe heelgetal palindromes.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Ons het 'n reeks 'arr' van N heelgetalle arr[1], arr[2], ..., arr[N]. Die getalle in die reeks sal willekeurig wees. Jou taak is om te bepaal of dit moontlik is om 'n reeks gesorteer in nie-afnemende volgorde te kry deur die volgende operasie op die gegewe reeks uit te voer:\n        Jy mag enige aantal regsverskuiwingsoperasies uitvoer.\n    \n    Een regsverskuiwingsoperasie beteken dat alle elemente van die reeks een posisie regs verskuif word. Die laaste element van die reeks sal na die beginposisie in die reeks geskuif word, d.w.s. na die 0-indeks.\n\n        As dit moontlik is om die gesorteerde reeks te verkry deur die bogenoemde operasie uit te voer, gee dan True terug, anders gee False terug. As die gegewe reeks leeg is, gee dan True terug.\n\n        Let wel: Daar word gewaarborg dat die gegewe lys unieke elemente bevat.\n\n        Byvoorbeeld:\n\n        move_one_ball([3, 4, 5, 1, 2])==>True\n    Verduideliking: Deur 2 regsverskuiwingsoperasies uit te voer, kan nie-afnemende volgorde vir die gegewe reeks bereik word.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Verduideliking: Dit is nie moontlik om nie-afnemende volgorde vir die gegewe reeks te kry deur enige aantal regsverskuiwingsoperasies uit te voer nie.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Ons het 'n reeks 'arr' van N heelgetalle arr[1], arr[2], ..., arr[N]. Die getalle in die reeks sal willekeurig wees. Jou taak is om te bepaal of dit moontlik is om 'n reeks gesorteer in nie-afnemende volgorde te kry deur die volgende operasie op die gegewe reeks uit te voer:\n        Jy mag enige aantal regsverskuiwingsoperasies uitvoer.\n    \n    Een regsverskuiwingsoperasie beteken dat alle elemente van die reeks een posisie regs verskuif word. Die laaste element van die reeks sal na die beginposisie in die reeks geskuif word, d.w.s. na die 0-indeks.\n\n        As dit moontlik is om die gesorteerde reeks te verkry deur die bogenoemde operasie uit te voer, gee dan True terug, anders gee False terug. As die gegewe reeks leeg is, gee dan True terug.\n\n        Let wel: Daar word gewaarborg dat die gegewe lys unieke elemente bevat.\n\n        Byvoorbeeld:\n\n        move_one_ball([3, 4, 5, 1, 2])==>True\n    Verduideliking: Deur 2 regsverskuiwingsoperasies uit te voer, kan nie-afnemende volgorde vir die gegewe reeks bereik word.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Verduideliking: Dit is nie moontlik om nie-afnemende volgorde vir die gegewe reeks te kry deur enige aantal regsverskuiwingsoperasies uit te voer nie.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"In hierdie probleem, sal jy 'n funksie implementeer wat twee lyste van getalle neem,\nen bepaal of dit moontlik is om 'n uitruiling van elemente tussen hulle te doen om lst1 'n lys van net ewe getalle te maak.\nDaar is geen limiet op die aantal uitgeruilde elemente tussen lst1 en lst2 nie.\nAs dit moontlik is om elemente tussen lst1 en lst2 uit te ruil om\nalle elemente van lst1 ewe te maak, gee \"JA\" terug.\nAndersins, gee \"NEE\" terug.\nByvoorbeeld:\nuitruil([1, 2, 3, 4], [1, 2, 3, 4]) => \"JA\"\nuitruil([1, 2, 3, 4], [1, 5, 3, 4]) => \"NEE\"\nDaar word aanvaar dat die insetlyste nie leeg sal wees nie.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "In hierdie probleem, sal jy 'n funksie implementeer wat twee lyste van getalle neem,\nen bepaal of dit moontlik is om 'n uitruiling van elemente tussen hulle te doen om lst1 'n lys van net ewe getalle te maak.\nDaar is geen limiet op die aantal uitgeruilde elemente tussen lst1 en lst2 nie.\nAs dit moontlik is om elemente tussen lst1 en lst2 uit te ruil om\nalle elemente van lst1 ewe te maak, gee \"JA\" terug.\nAndersins, gee \"NEE\" terug.\nByvoorbeeld:\nuitruil([1, 2, 3, 4], [1, 2, 3, 4]) => \"JA\"\nuitruil([1, 2, 3, 4], [1, 5, 3, 4]) => \"NEE\"\nDaar word aanvaar dat die insetlyste nie leeg sal wees nie.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Taak\n    Ons het twee strings s en c gekry, jy moet alle karakters in s wat gelyk is aan enige karakter in c verwyder\n    en dan moet jy kyk of die resultaat string 'n palindroom is.\n    'n String word 'n palindroom genoem as dit dieselfde agteruit as vorentoe lees.\n    Jy moet 'n tuple teruggee wat die resultaat string en True/False vir die toets bevat.\n    Voorbeeld\n    Vir s = \"abcde\", c = \"ae\", moet die resultaat wees ('bcd',False)\n    Vir s = \"abcdef\", c = \"b\" moet die resultaat wees ('acdef',False)\n    Vir s = \"abcdedcba\", c = \"ab\", moet die resultaat wees ('cdedc',True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Taak\n    Ons het twee strings s en c gekry, jy moet alle karakters in s wat gelyk is aan enige karakter in c verwyder\n    en dan moet jy kyk of die resultaat string 'n palindroom is.\n    'n String word 'n palindroom genoem as dit dieselfde agteruit as vorentoe lees.\n    Jy moet 'n tuple teruggee wat die resultaat string en True/False vir die toets bevat.\n    Voorbeeld\n    Vir s = \"abcde\", c = \"ae\", moet die resultaat wees ('bcd',False)\n    Vir s = \"abcdef\", c = \"b\" moet die resultaat wees ('acdef',False)\n    Vir s = \"abcdedcba\", c = \"ab\", moet die resultaat wees ('cdedc',True)\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Jy kry 'n reghoekige rooster van putte. Elke ry verteenwoordig 'n enkele put, en elke 1 in 'n ry verteenwoordig 'n enkele eenheid water. Elke put het 'n ooreenstemmende emmer wat gebruik kan word om water daaruit te onttrek, en alle emmers het dieselfde kapasiteit. Jou taak is om die emmers te gebruik om die putte leeg te maak. Gee as uitset die aantal kere wat jy die emmers moet laat sak. \n\n    Voorbeeld 1:\n    Insette:\n        rooster: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        emmer_kapasiteit: 1\n    Uitset: 6\n\n    Voorbeeld 2:\n    Insette:\n        rooster: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        emmer_kapasiteit: 2\n    Uitset: 5\n\n    Voorbeeld 3:\n    Insette:\n        rooster: [[0,0,0], [0,0,0]]\n        emmer_kapasiteit: 5\n    Uitset: 0\n\n    Beperkings:\n    * alle putte het dieselfde lengte\n    * 1 <= rooster.lengte <= 10^2\n    * 1 <= rooster[:,1].lengte <= 10^2\n    * rooster[i][j] -> 0 | 1\n    * 1 <= kapasiteit <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Jy kry 'n reghoekige rooster van putte. Elke ry verteenwoordig 'n enkele put, en elke 1 in 'n ry verteenwoordig 'n enkele eenheid water. Elke put het 'n ooreenstemmende emmer wat gebruik kan word om water daaruit te onttrek, en alle emmers het dieselfde kapasiteit. Jou taak is om die emmers te gebruik om die putte leeg te maak. Gee as uitset die aantal kere wat jy die emmers moet laat sak. \n\n    Voorbeeld 1:\n    Insette:\n        rooster: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        emmer_kapasiteit: 1\n    Uitset: 6\n\n    Voorbeeld 2:\n    Insette:\n        rooster: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        emmer_kapasiteit: 2\n    Uitset: 5\n\n    Voorbeeld 3:\n    Insette:\n        rooster: [[0,0,0], [0,0,0]]\n        emmer_kapasiteit: 5\n    Uitset: 0\n\n    Beperkings:\n    * alle putte het dieselfde lengte\n    * 1 <= rooster.lengte <= 10^2\n    * 1 <= rooster[:,1].lengte <= 10^2\n    * rooster[i][j] -> 0 | 1\n    * 1 <= kapasiteit <= 10\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Gegee 'n string s en 'n natuurlike getal n, is jy opdrag gegee om 'n funksie te implementeer wat 'n lys van alle woorde uit string s teruggee wat presies n medeklinkers bevat, in die volgorde waarin hierdie woorde in string s voorkom. As die string s leeg is, moet die funksie 'n leë lys teruggee. Let daarop: jy mag aanvaar dat die invoerstring slegs letters en spasies bevat. Voorbeelde:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Gegee 'n string s en 'n natuurlike getal n, is jy opdrag gegee om 'n funksie te implementeer wat 'n lys van alle woorde uit string s teruggee wat presies n medeklinkers bevat, in die volgorde waarin hierdie woorde in string s voorkom. As die string s leeg is, moet die funksie 'n leë lys teruggee. Let daarop: jy mag aanvaar dat die invoerstring slegs letters en spasies bevat. Voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Gegee 'n reeks arr van heelgetalle en 'n positiewe heelgetal k, gee 'n gesorteerde lys terug van lengte k met die maksimum k getalle in arr.\n\n    Voorbeeld 1:\n\n        Inset: arr = [-3, -4, 5], k = 3\n    Uitset: [-4, -3, 5]\n\n    Voorbeeld 2:\n\n        Inset: arr = [4, -4, 4], k = 2\n    Uitset: [4, 4]\n\n    Voorbeeld 3:\n\n        Inset: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Uitset: [2]\n\n    Nota:\n    1. Die lengte van die reeks sal in die omvang van [1, 1000] wees.\n    2. Die elemente in die reeks sal in die omvang van [-1000, 1000] wees.\n    3. 0 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Gegee 'n reeks arr van heelgetalle en 'n positiewe heelgetal k, gee 'n gesorteerde lys terug van lengte k met die maksimum k getalle in arr.\n\n    Voorbeeld 1:\n\n        Inset: arr = [-3, -4, 5], k = 3\n    Uitset: [-4, -3, 5]\n\n    Voorbeeld 2:\n\n        Inset: arr = [4, -4, 4], k = 2\n    Uitset: [4, 4]\n\n    Voorbeeld 3:\n\n        Inset: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Uitset: [2]\n\n    Nota:\n    1. Die lengte van die reeks sal in die omvang van [1, 1000] wees.\n    2. Die elemente in die reeks sal in die omvang van [-1000, 1000] wees.\n    3. 0 <= k <= len(arr)\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Gegee 'n nie-leë reeks van heelgetalle arr en 'n heelgetal k, gee terug die som van die elemente met hoogstens twee syfers van die eerste k elemente van arr.\n\n    Voorbeeld:\n\n        Inset: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Uitset: 24 # som van 21 + 3\n\n    Beperkings:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Gegee 'n nie-leë reeks van heelgetalle arr en 'n heelgetal k, gee terug die som van die elemente met hoogstens twee syfers van die eerste k elemente van arr.\n\n    Voorbeeld:\n\n        Inset: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Uitset: 24 # som van 21 + 3\n\n    Beperkings:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Jy kry twee intervalle,\n    waar elke interval 'n paar van heelgetalle is. Byvoorbeeld, interval = (begin, einde) = (1, 2).\n    Die gegee intervalle is geslote wat beteken dat die interval (begin, einde)\n    beide begin en einde insluit.\n    Vir elke gegee interval word aanvaar dat sy begin minder of gelyk aan sy einde is.\n    Jou taak is om te bepaal of die lengte van die kruising van hierdie twee\n    intervalle 'n priemgetal is.\n    Byvoorbeeld, die kruising van die intervalle (1, 3), (2, 4) is (2, 3)\n    wat 'n lengte van 1 het, wat nie 'n priemgetal is nie.\n    As die lengte van die kruising 'n priemgetal is, gee \"JA\" terug,\n    anders, gee \"NEE\" terug.\n    As die twee intervalle nie kruis nie, gee \"NEE\" terug.\n\n    \n    [invoer/uitvoer] voorbeelde:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Jy kry twee intervalle,\n    waar elke interval 'n paar van heelgetalle is. Byvoorbeeld, interval = (begin, einde) = (1, 2).\n    Die gegee intervalle is geslote wat beteken dat die interval (begin, einde)\n    beide begin en einde insluit.\n    Vir elke gegee interval word aanvaar dat sy begin minder of gelyk aan sy einde is.\n    Jou taak is om te bepaal of die lengte van die kruising van hierdie twee\n    intervalle 'n priemgetal is.\n    Byvoorbeeld, die kruising van die intervalle (1, 3), (2, 4) is (2, 3)\n    wat 'n lengte van 1 het, wat nie 'n priemgetal is nie.\n    As die lengte van die kruising 'n priemgetal is, gee \"JA\" terug,\n    anders, gee \"NEE\" terug.\n    As die twee intervalle nie kruis nie, gee \"NEE\" terug.\n\n    \n    [invoer/uitvoer] voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Almal weet van die Fibonacci-reeks, dit is diep bestudeer deur wiskundiges in die laaste paar eeue. Wat mense egter nie weet nie, is die Tribonacci-reeks. Die Tribonacci-reeks word gedefinieer deur die herhaling:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, as n ewe is.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), as n onewe is.\n    Byvoorbeeld:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    Jy kry 'n nie-negatiewe heelgetal n, jy moet 'n lys van die eerste n + 1 getalle van die Tribonacci-reeks teruggee.\n    Voorbeelde:\n    tri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Almal weet van die Fibonacci-reeks, dit is diep bestudeer deur wiskundiges in die laaste paar eeue. Wat mense egter nie weet nie, is die Tribonacci-reeks. Die Tribonacci-reeks word gedefinieer deur die herhaling:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, as n ewe is.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), as n onewe is.\n    Byvoorbeeld:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    Jy kry 'n nie-negatiewe heelgetal n, jy moet 'n lys van die eerste n + 1 getalle van die Tribonacci-reeks teruggee.\n    Voorbeelde:\n    tri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Gegee 'n positiewe heelgetal n, gee die produk van die onewe syfers terug.\nGee 0 terug as al die syfers ewe is.\nByvoorbeeld:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Gegee 'n positiewe heelgetal n, gee die produk van die onewe syfers terug.\nGee 0 terug as al die syfers ewe is.\nByvoorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Skep 'n funksie wat 'n string as inset neem wat slegs vierkantige hakies bevat.\nDie funksie moet waar wees as en slegs as daar 'n geldige subsekvens van hakies is waar ten minste een hakie in die subsekvens genestel is.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Skep 'n funksie wat 'n string as inset neem wat slegs vierkantige hakies bevat.\nDie funksie moet waar wees as en slegs as daar 'n geldige subsekvens van hakies is waar ten minste een hakie in die subsekvens genestel is.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Jy kry 'n lys van getalle.\n    Jy moet die som van die gekwadreerde getalle in die lys gee,\n    rond elke element in die lys af na die naaste heelgetal (Ceiling).\n    Voorbeelde:\n    Vir lst = [1,2,3] moet die uitvoer 14 wees\n    Vir lst = [1,4,9] moet die uitvoer 98 wees\n    Vir lst = [1,3,5,7] moet die uitvoer 84 wees\n    Vir lst = [1.4,4.2,0] moet die uitvoer 29 wees\n    Vir lst = [-2.4,1,1] moet die uitvoer 6 wees\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Jy kry 'n lys van getalle.\n    Jy moet die som van die gekwadreerde getalle in die lys gee,\n    rond elke element in die lys af na die naaste heelgetal (Ceiling).\n    Voorbeelde:\n    Vir lst = [1,2,3] moet die uitvoer 14 wees\n    Vir lst = [1,4,9] moet die uitvoer 98 wees\n    Vir lst = [1,3,5,7] moet die uitvoer 84 wees\n    Vir lst = [1.4,4.2,0] moet die uitvoer 29 wees\n    Vir lst = [-2.4,1,1] moet die uitvoer 6 wees\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Skep 'n funksie wat True teruggee as die laaste karakter van 'n gegewe string 'n alfabetiese karakter is en nie deel is van 'n woord nie, en andersins vals is. Let wel: \"woord\" is 'n groep karakters wat deur spasies geskei word.\n\n    Voorbeelde:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Skep 'n funksie wat True teruggee as die laaste karakter van 'n gegewe string 'n alfabetiese karakter is en nie deel is van 'n woord nie, en andersins vals is. Let wel: \"woord\" is 'n groep karakters wat deur spasies geskei word.\n\n    Voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Skep 'n funksie wat die grootste indeks van 'n element teruggee wat nie groter as of gelyk aan die element onmiddellik voor dit is nie. As daar geen sodanige element bestaan nie, gee dan -1 terug. Die gegewe reeks sal nie duplikaat waardes bevat nie.\n\n    Voorbeelde:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Skep 'n funksie wat die grootste indeks van 'n element teruggee wat nie groter as of gelyk aan die element onmiddellik voor dit is nie. As daar geen sodanige element bestaan nie, gee dan -1 terug. Die gegewe reeks sal nie duplikaat waardes bevat nie.\n\n    Voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Skep 'n funksie wat 'n tuple (a, b) teruggee, waar 'a' die grootste van negatiewe heelgetalle is, en 'b' die kleinste van positiewe heelgetalle in 'n lys is. As daar geen negatiewe of positiewe heelgetalle is nie, gee hulle as None terug.\n\n    Voorbeelde:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Skep 'n funksie wat 'n tuple (a, b) teruggee, waar 'a' die grootste van negatiewe heelgetalle is, en 'b' die kleinste van positiewe heelgetalle in 'n lys is. As daar geen negatiewe of positiewe heelgetalle is nie, gee hulle as None terug.\n\n    Voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"Die Brasiliaanse faktoriaal word gedefinieer as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    waar n > 0\n\n        Byvoorbeeld:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "Die Brasiliaanse faktoriaal word gedefinieer as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    waar n > 0\n\n        Byvoorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Jy kry 'n string wat 'n sin verteenwoordig,\n    die sin bevat sommige woorde geskei deur 'n spasie,\n    en jy moet 'n string teruggee wat die woorde van die oorspronklike sin bevat,\n    waarvan die lengtes primgetalle is,\n    die volgorde van die woorde in die nuwe string moet dieselfde wees as die oorspronklike een.\n\n        Voorbeeld 1:\n        Inset: sin = \"This is a test\"\n        Uitset: \"is\"\n\n        Voorbeeld 2:\n        Inset: sin = \"lets go for swimming\"\n        Uitset: \"go for\"\n\n        Beperkings:\n        * 1 <= len(sin) <= 100\n        * sin bevat slegs letters\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Jy kry 'n string wat 'n sin verteenwoordig,\n    die sin bevat sommige woorde geskei deur 'n spasie,\n    en jy moet 'n string teruggee wat die woorde van die oorspronklike sin bevat,\n    waarvan die lengtes primgetalle is,\n    die volgorde van die woorde in die nuwe string moet dieselfde wees as die oorspronklike een.\n\n        Voorbeeld 1:\n        Inset: sin = \"This is a test\"\n        Uitset: \"is\"\n\n        Voorbeeld 2:\n        Inset: sin = \"lets go for swimming\"\n        Uitset: \"go for\"\n\n        Beperkings:\n        * 1 <= len(sin) <= 100\n        * sin bevat slegs letters\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Jou taak is om 'n funksie te implementeer wat die uitdrukking vereenvoudig x * n. Die funksie gee True terug as x * n evalueer tot 'n heelgetal en False andersins. Beide x en n is 'n string verteenwoordiging van 'n breuk, en het die volgende formaat, <teller>/<noemer> waar beide teller en noemer positiewe heelgetalle is.\n\n    Jy kan aanvaar dat x en n geldige breuke is en nie nul as noemer het nie.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Jou taak is om 'n funksie te implementeer wat die uitdrukking vereenvoudig x * n. Die funksie gee True terug as x * n evalueer tot 'n heelgetal en False andersins. Beide x en n is 'n string verteenwoordiging van 'n breuk, en het die volgende formaat, <teller>/<noemer> waar beide teller en noemer positiewe heelgetalle is.\n\n    Jy kan aanvaar dat x en n geldige breuke is en nie nul as noemer het nie.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Skryf 'n funksie wat die gegewe lys van heelgetalle in opklimmende volgorde sorteert volgens die som van hul syfers. Let daarop: as daar verskeie items met soortgelyke som van hul syfers is, sorteer hulle volgens hul indeks in die oorspronklike lys.\n\n    Byvoorbeeld:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Skryf 'n funksie wat die gegewe lys van heelgetalle in opklimmende volgorde sorteert volgens die som van hul syfers. Let daarop: as daar verskeie items met soortgelyke som van hul syfers is, sorteer hulle volgens hul indeks in die oorspronklike lys.\n\n    Byvoorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Skryf 'n funksie wat 'n reeks van getalle as inset neem en die aantal elemente in die reeks teruggee wat groter as 10 is en waarvan die eerste en laaste syfers van 'n getal beide onewe is (1, 3, 5, 7, 9). Byvoorbeeld:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Skryf 'n funksie wat 'n reeks van getalle as inset neem en die aantal elemente in die reeks teruggee wat groter as 10 is en waarvan die eerste en laaste syfers van 'n getal beide onewe is (1, 3, 5, 7, 9). Byvoorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Jy kry 'n positiewe heelgetal n. Jy moet 'n heelgetal array a van lengte n skep. Vir elke i (1 ≤ i ≤ n), is die waarde van a[i] = i * i - i + 1. Gee die aantal drietalle (a[i], a[j], a[k]) van a terug waar i < j < k, en a[i] + a[j] + a[k] 'n veelvoud van 3 is.\n\n    Voorbeeld:\n    Inset: n = 5\n    Uitset: 1\n    Verduideliking:\n    a = [1, 3, 7, 13, 21]\n    Die enigste geldige drietal is (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Jy kry 'n positiewe heelgetal n. Jy moet 'n heelgetal array a van lengte n skep. Vir elke i (1 ≤ i ≤ n), is die waarde van a[i] = i * i - i + 1. Gee die aantal drietalle (a[i], a[j], a[k]) van a terug waar i < j < k, en a[i] + a[j] + a[k] 'n veelvoud van 3 is.\n\n    Voorbeeld:\n    Inset: n = 5\n    Uitset: 1\n    Verduideliking:\n    a = [1, 3, 7, 13, 21]\n    Die enigste geldige drietal is (1, 7, 13).\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    Daar is agt planete in ons sonnestelsel: die naaste aan die Son is Mercurius, die volgende een is Venus, dan Aarde, Mars, Jupiter, Saturnus, Uranus, Neptunus. Skryf 'n funksie wat twee planeetname as strings, planet1 en planet2, neem. Die funksie moet 'n tuple teruggee wat al die planete bevat waarvan die omwentelinge tussen die omwenteling van planet1 en die omwenteling van planet2 geleë is, gesorteer volgens die nabyheid aan die son. Die funksie moet 'n leë tuple teruggee as planet1 of planet2 nie korrekte planeetname is nie. Voorbeelde.\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "Daar is agt planete in ons sonnestelsel: die naaste aan die Son is Mercurius, die volgende een is Venus, dan Aarde, Mars, Jupiter, Saturnus, Uranus, Neptunus. Skryf 'n funksie wat twee planeetname as strings, planet1 en planet2, neem. Die funksie moet 'n tuple teruggee wat al die planete bevat waarvan die omwentelinge tussen die omwenteling van planet1 en die omwenteling van planet2 geleë is, gesorteer volgens die nabyheid aan die son. Die funksie moet 'n leë tuple teruggee as planet1 of planet2 nie korrekte planeetname is nie. Voorbeelde.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"'n Eenvoudige program wat die waarde van x moet teruggee as n 'n priemgetal is en die waarde van y moet teruggee as dit nie die geval is nie.\n\n    Voorbeelde:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "'n Eenvoudige program wat die waarde van x moet teruggee as n 'n priemgetal is en die waarde van y moet teruggee as dit nie die geval is nie.\n\n    Voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Gegee 'n lys van getalle, gee terug die som van die kwadrate van die getalle in die lys wat oneweredig is. Ignoreer getalle wat negatief is of nie heelgetalle is nie.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n        As die insetlys leeg is, gee 0 terug.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Gegee 'n lys van getalle, gee terug die som van die kwadrate van die getalle in die lys wat oneweredig is. Ignoreer getalle wat negatief is of nie heelgetalle is nie.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n        As die insetlys leeg is, gee 0 terug.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Jy sal die naam van 'n klas ( 'n string) en 'n lys van uitbreidings gegee word. Die uitbreidings moet gebruik word om addisionele klasse na die klas te laai. Die sterkte van die uitbreiding is as volg: Laat CAP die nommer van die hoofletters in die uitbreiding se naam wees, en laat SM die nommer van die kleinletters in die uitbreiding se naam wees, die sterkte word gegee deur die breuk CAP - SM. Jy moet die sterkste uitbreiding vind en 'n string in hierdie formaat teruggee: ClassName.StrongestExtensionName. As daar twee of meer uitbreidings met dieselfde sterkte is, moet jy die een kies wat eerste in die lys voorkom. Byvoorbeeld, as jy \"Slices\" as die klas en 'n lys van die uitbreidings: ['SErviNGSliCes', 'Cheese', 'StuFfed'] gegee word, moet jy 'Slices.SErviNGSliCes' teruggee omdat 'SErviNGSliCes' die sterkste uitbreiding is (sy sterkte is -1). Voorbeeld:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Jy sal die naam van 'n klas ( 'n string) en 'n lys van uitbreidings gegee word. Die uitbreidings moet gebruik word om addisionele klasse na die klas te laai. Die sterkte van die uitbreiding is as volg: Laat CAP die nommer van die hoofletters in die uitbreiding se naam wees, en laat SM die nommer van die kleinletters in die uitbreiding se naam wees, die sterkte word gegee deur die breuk CAP - SM. Jy moet die sterkste uitbreiding vind en 'n string in hierdie formaat teruggee: ClassName.StrongestExtensionName. As daar twee of meer uitbreidings met dieselfde sterkte is, moet jy die een kies wat eerste in die lys voorkom. Byvoorbeeld, as jy \"Slices\" as die klas en 'n lys van die uitbreidings: ['SErviNGSliCes', 'Cheese', 'StuFfed'] gegee word, moet jy 'Slices.SErviNGSliCes' teruggee omdat 'SErviNGSliCes' die sterkste uitbreiding is (sy sterkte is -1). Voorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Jy kry 2 woorde. Jy moet True teruggee as die tweede woord of enige van sy rotasies 'n substring is in die eerste woord.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Jy kry 2 woorde. Jy moet True teruggee as die tweede woord of enige van sy rotasies 'n substring is in die eerste woord.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Gegee 'n positiewe heelgetal, verkry sy Romeinse numeriese ekwivalent as 'n string,\nen gee dit terug in kleinletters.\nBeperkings: 1 <= num <= 1000\n\n    Voorbeelde:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Gegee 'n positiewe heelgetal, verkry sy Romeinse numeriese ekwivalent as 'n string,\nen gee dit terug in kleinletters.\nBeperkings: 1 <= num <= 1000\n\n    Voorbeelde:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Gegee die lengtes van die drie sye van 'n driehoek. Gee Waar terug as die drie sye 'n reguit driehoek vorm, vals andersins. 'n Reguit driehoek is 'n driehoek waarin een hoek 'n regte hoek of 90 grade is. Voorbeeld:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Gegee die lengtes van die drie sye van 'n driehoek. Gee Waar terug as die drie sye 'n reguit driehoek vorm, vals andersins. 'n Reguit driehoek is 'n driehoek waarin een hoek 'n regte hoek of 90 grade is. Voorbeeld:\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Jy kry 'n string s.\n    as s[i] 'n letter is, keer sy geval om van klein na groot of andersom,\n    anders hou dit soos dit is.\n    As die string geen letters bevat nie, keer die string om.\n    Die funksie moet die verkryde string teruggee.\n    Voorbeelde\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Jy kry 'n string s.\n    as s[i] 'n letter is, keer sy geval om van klein na groot of andersom,\n    anders hou dit soos dit is.\n    As die string geen letters bevat nie, keer die string om.\n    Die funksie moet die verkryde string teruggee.\n    Voorbeelde\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Gegee 'n string 'text', gee sy md5 hash ekwivalent string terug.\nAs 'text' 'n leë string is, gee null terug.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Gegee 'n string 'text', gee sy md5 hash ekwivalent string terug.\nAs 'text' 'n leë string is, gee null terug.\n    ", "natural_language": "Afrikaans"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Gegee twee positiewe heelgetalle a en b, gee die ewe syfers tussen a en b terug, in opklimmende volgorde.\n\n    Byvoorbeeld:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Gegee twee positiewe heelgetalle a en b, gee die ewe syfers tussen a en b terug, in opklimmende volgorde.\n\n    Byvoorbeeld:\n    ", "natural_language": "Afrikaans"}
