{"task_id": "python/0", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Bạn được cung cấp một danh sách các hoạt động gửi và rút tiền trên tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ điểm nào số dư của tài khoản có giảm xuống dưới không và tại điểm đó, hàm sẽ trả về True. Nếu không, nó sẽ trả về False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "language": "python", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "description": "Bạn được cung cấp một danh sách các hoạt động gửi và rút tiền trên tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ điểm nào số dư của tài khoản có giảm xuống dưới không và tại điểm đó, hàm sẽ trả về True. Nếu không, nó sẽ trả về False.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/1", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Cho một danh sách số nguyên, trả về một tuple bao gồm tổng và tích của tất cả các số nguyên trong danh sách.\n    Tổng rỗng phải bằng 0 và tích rỗng phải bằng 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "language": "python", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "description": "Cho một danh sách số nguyên, trả về một tuple bao gồm tổng và tích của tất cả các số nguyên trong danh sách.\n    Tổng rỗng phải bằng 0 và tích rỗng phải bằng 1.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/2", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Đầu vào là hai chuỗi a và b chỉ gồm các số 1 và 0.\n    Thực hiện phép XOR nhị phân trên hai đầu vào này và trả kết quả dưới dạng chuỗi.\n    \n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "language": "python", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "description": "Đầu vào là hai chuỗi a và b chỉ gồm các số 1 và 0.\n    Thực hiện phép XOR nhị phân trên hai đầu vào này và trả kết quả dưới dạng chuỗi.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/3", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Trong danh sách các chuỗi, trả về chuỗi dài nhất. Trả về chuỗi đầu tiên trong trường hợp có nhiều chuỗi cùng độ dài. Trả về null nếu danh sách đầu vào rỗng.\n    \n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "language": "python", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "description": "Trong danh sách các chuỗi, trả về chuỗi dài nhất. Trả về chuỗi đầu tiên trong trường hợp có nhiều chuỗi cùng độ dài. Trả về null nếu danh sách đầu vào rỗng.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/4", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Trả về ước số chung lớn nhất của hai số nguyên a và b.\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "language": "python", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "description": "Trả về ước số chung lớn nhất của hai số nguyên a và b.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/5", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Đầu vào là một chuỗi các số được phân tách bằng khoảng trắng từ 'zero' đến 'nine'.\n    Các lựa chọn hợp lệ là 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' và 'nine'.\n    Trả về chuỗi với các số được sắp xếp từ nhỏ đến lớn.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "language": "python", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "description": "Đầu vào là một chuỗi các số được phân tách bằng khoảng trắng từ 'zero' đến 'nine'.\n    Các lựa chọn hợp lệ là 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' và 'nine'.\n    Trả về chuỗi với các số được sắp xếp từ nhỏ đến lớn.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/6", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Cho một danh sách các số (ít nhất hai phần tử), áp dụng một phép biến đổi tuyến tính cho danh sách đó, sao cho số nhỏ nhất sẽ trở thành 0 và số lớn nhất sẽ trở thành 1.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "language": "python", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "description": "Cho một danh sách các số (ít nhất hai phần tử), áp dụng một phép biến đổi tuyến tính cho danh sách đó, sao cho số nhỏ nhất sẽ trở thành 0 và số lớn nhất sẽ trở thành 1.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/7", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Đối với một chuỗi đã cho, đảo ngược các ký tự viết thường thành viết hoa và viết hoa thành viết thường.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "language": "python", "canonical_solution": "    return string.swapcase()\n", "description": "Đối với một chuỗi đã cho, đảo ngược các ký tự viết thường thành viết hoa và viết hoa thành viết thường.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/8", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Trả về chỉ các số dương trong danh sách.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "language": "python", "canonical_solution": "    return [e for e in l if e > 0]\n", "description": "Trả về chỉ các số dương trong danh sách.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/9", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Trả về giá trị đúng nếu một số được cho là số nguyên tố, và sai nếu không phải.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "language": "python", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "description": "Trả về giá trị đúng nếu một số được cho là số nguyên tố, và sai nếu không phải.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/10", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Trả về các phần tử duy nhất đã được sắp xếp trong một danh sách.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "language": "python", "canonical_solution": "    return sorted(list(set(l)))\n", "description": "Trả về các phần tử duy nhất đã được sắp xếp trong một danh sách.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/11", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib trả về số thứ n trong dãy Fibonacci và cũng là số nguyên tố.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "language": "python", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "description": "prime_fib trả về số thứ n trong dãy Fibonacci và cũng là số nguyên tố.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/12", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    Hàm triples_sum_to_zero nhận vào một danh sách số nguyên.\nNó trả về True nếu có ba phần tử khác nhau trong danh sách mà tổng của chúng bằng 0, và False trong trường hợp ngược lại.\n    \n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "description": "Hàm triples_sum_to_zero nhận vào một danh sách số nguyên.\nNó trả về True nếu có ba phần tử khác nhau trong danh sách mà tổng của chúng bằng 0, và False trong trường hợp ngược lại.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/13", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    Hàm pairs_sum_to_zero nhận vào một danh sách các số nguyên.\nNó sẽ trả về True nếu có hai phần tử khác nhau trong danh sách có tổng bằng 0, ngược lại trả về False.\n    \n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "language": "python", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "description": "Hàm pairs_sum_to_zero nhận vào một danh sách các số nguyên.\nNó sẽ trả về True nếu có hai phần tử khác nhau trong danh sách có tổng bằng 0, ngược lại trả về False.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/14", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Dãy số Fib4 là một dãy số tương tự như dãy số Fibonacci được định nghĩa như sau:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Vui lòng viết một hàm để tính toán hiệu quả phần tử thứ n của dãy số Fib4. Không sử dụng đệ quy.\n    \n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "language": "python", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "description": "Dãy số Fib4 là một dãy số tương tự như dãy số Fibonacci được định nghĩa như sau:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Vui lòng viết một hàm để tính toán hiệu quả phần tử thứ n của dãy số Fib4. Không sử dụng đệ quy.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/15", "prompt": "\n\ndef median(l: list):\n    \"\"\"Trả về giá trị trung vị của các phần tử trong danh sách l.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "language": "python", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "description": "Trả về giá trị trung vị của các phần tử trong danh sách l.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/16", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Kiểm tra xem chuỗi cho trước có phải là chuỗi đối xứng hay không.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "language": "python", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "description": "Kiểm tra xem chuỗi cho trước có phải là chuỗi đối xứng hay không.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/17", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels là một hàm nhận vào một chuỗi và trả về chuỗi không có nguyên âm.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "language": "python", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "description": "remove_vowels là một hàm nhận vào một chuỗi và trả về chuỗi không có nguyên âm.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/18", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Trả về True nếu tất cả các số trong danh sách l đều nhỏ hơn ngưỡng t.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "language": "python", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "description": "Trả về True nếu tất cả các số trong danh sách l đều nhỏ hơn ngưỡng t.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/19", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Thêm hai số x và y.\n    \n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "language": "python", "canonical_solution": "    return x + y\n", "description": "Thêm hai số x và y.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/20", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Kiểm tra xem hai từ có cùng các ký tự hay không.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "language": "python", "canonical_solution": "    return set(s0) == set(s1)\n", "description": "Kiểm tra xem hai từ có cùng các ký tự hay không.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/21", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Trả về số Fibonacci thứ n.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "description": "Trả về số Fibonacci thứ n.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/22", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Trả về các phần tử chung duy nhất đã được sắp xếp cho hai danh sách.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "language": "python", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "description": "Trả về các phần tử chung duy nhất đã được sắp xếp cho hai danh sách.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/23", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Trả về ước số nguyên tố lớn nhất của n. Giả sử n > 1 và không phải là số nguyên tố.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "language": "python", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "description": "Trả về ước số nguyên tố lớn nhất của n. Giả sử n > 1 và không phải là số nguyên tố.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/24", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n là một hàm tính tổng các số từ 1 đến n.\n    \n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "language": "python", "canonical_solution": "    return sum(range(n + 1))\n", "description": "sum_to_n là một hàm tính tổng các số từ 1 đến n.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/25", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs đại diện cho các hệ số của một đa thức.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Trả về đạo hàm của đa thức này dưới cùng dạng.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "language": "python", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "description": "xs đại diện cho các hệ số của một đa thức.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Trả về đạo hàm của đa thức này dưới cùng dạng.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/26", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"Dãy số FibFib là một dãy số tương tự như dãy số Fibonacci được định nghĩa như sau:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Vui lòng viết một hàm để tính toán hiệu quả phần tử thứ n của dãy số FibFib.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "language": "python", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "description": "Dãy số FibFib là một dãy số tương tự như dãy số Fibonacci được định nghĩa như sau:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Vui lòng viết một hàm để tính toán hiệu quả phần tử thứ n của dãy số FibFib.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/27", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Viết một hàm vowels_count nhận vào một chuỗi đại diện cho một từ và trả về số lượng nguyên âm trong chuỗi. Nguyên âm trong trường hợp này là 'a', 'e', 'i', 'o', 'u'. Ở đây, 'y' cũng là một nguyên âm, nhưng chỉ khi nó ở cuối từ đã cho.\n\n    Ví dụ:\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "description": "Viết một hàm vowels_count nhận vào một chuỗi đại diện cho một từ và trả về số lượng nguyên âm trong chuỗi. Nguyên âm trong trường hợp này là 'a', 'e', 'i', 'o', 'u'. Ở đây, 'y' cũng là một nguyên âm, nhưng chỉ khi nó ở cuối từ đã cho.\n\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/28", "prompt": "\ndef search(lst):\n    '''\n    Bạn được cho một danh sách không rỗng các số nguyên dương. Trả về số nguyên lớn nhất mà lớn hơn 0 và có tần suất xuất hiện lớn hơn hoặc bằng giá trị của số đó. Tần suất của một số nguyên là số lần nó xuất hiện trong danh sách. Nếu không có giá trị như vậy tồn tại, trả về -1. Ví dụ:\n    \n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "language": "python", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "description": "Bạn được cho một danh sách không rỗng các số nguyên dương. Trả về số nguyên lớn nhất mà lớn hơn 0 và có tần suất xuất hiện lớn hơn hoặc bằng giá trị của số đó. Tần suất của một số nguyên là số lần nó xuất hiện trong danh sách. Nếu không có giá trị như vậy tồn tại, trả về -1. Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/29", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Cho độ dài của ba cạnh của một tam giác. Trả về diện tích của tam giác được làm tròn đến 2 chữ số thập phân nếu ba cạnh tạo thành một tam giác hợp lệ. Nếu không, trả về -1. Ba cạnh tạo thành một tam giác hợp lệ khi tổng của hai cạnh bất kỳ lớn hơn cạnh thứ ba. Ví dụ:\n    \n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "language": "python", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "description": "Cho độ dài của ba cạnh của một tam giác. Trả về diện tích của tam giác được làm tròn đến 2 chữ số thập phân nếu ba cạnh tạo thành một tam giác hợp lệ. Nếu không, trả về -1. Ba cạnh tạo thành một tam giác hợp lệ khi tổng của hai cạnh bất kỳ lớn hơn cạnh thứ ba. Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/30", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Viết một hàm trả về True nếu đối tượng q có thể bay, và False nếu không thể bay.\n    Đối tượng q có thể bay nếu nó cân bằng (là một danh sách đối xứng) và tổng các phần tử của nó nhỏ hơn hoặc bằng trọng lượng tối đa có thể.\n\n        Ví dụ:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 nhỏ hơn trọng lượng tối đa có thể, nhưng không cân bằng.\n\n        will_it_fly([3, 2, 3], 1) ➞ False\n    # nó cân bằng, nhưng 3+2+3 lớn hơn trọng lượng tối đa có thể.\n\n        will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 nhỏ hơn trọng lượng tối đa có thể, và nó cân bằng.\n\n        will_it_fly([3], 5) ➞ True\n    # 3 nhỏ hơn trọng lượng tối đa có thể, và nó cân bằng.\n    \n    '''\n", "entry_point": "will_it_fly", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "language": "python", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "description": "Viết một hàm trả về True nếu đối tượng q có thể bay, và False nếu không thể bay.\n    Đối tượng q có thể bay nếu nó cân bằng (là một danh sách đối xứng) và tổng các phần tử của nó nhỏ hơn hoặc bằng trọng lượng tối đa có thể.\n\n        Ví dụ:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 nhỏ hơn trọng lượng tối đa có thể, nhưng không cân bằng.\n\n        will_it_fly([3, 2, 3], 1) ➞ False\n    # nó cân bằng, nhưng 3+2+3 lớn hơn trọng lượng tối đa có thể.\n\n        will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 nhỏ hơn trọng lượng tối đa có thể, và nó cân bằng.\n\n        will_it_fly([3], 5) ➞ True\n    # 3 nhỏ hơn trọng lượng tối đa có thể, và nó cân bằng.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/31", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Viết một hàm trả về giá trị true nếu số được cho là tích của 3 số nguyên tố và false trong trường hợp ngược lại. Biết rằng (a) nhỏ hơn 100. Ví dụ:\n    \n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "language": "python", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "description": "Viết một hàm trả về giá trị true nếu số được cho là tích của 3 số nguyên tố và false trong trường hợp ngược lại. Biết rằng (a) nhỏ hơn 100. Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/32", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Bạn sẽ được cung cấp một số dưới dạng thập phân và nhiệm vụ của bạn là chuyển đổi nó sang định dạng nhị phân. Hàm sẽ trả về một chuỗi, với mỗi ký tự đại diện cho một số nhị phân. Mỗi ký tự trong chuỗi sẽ là '0' hoặc '1'.\n\n    Sẽ có một vài ký tự bổ sung 'db' ở đầu và cuối chuỗi. Các ký tự bổ sung này được sử dụng để giúp định dạng.\n\n    Ví dụ:\n    \n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "description": "Bạn sẽ được cung cấp một số dưới dạng thập phân và nhiệm vụ của bạn là chuyển đổi nó sang định dạng nhị phân. Hàm sẽ trả về một chuỗi, với mỗi ký tự đại diện cho một số nhị phân. Mỗi ký tự trong chuỗi sẽ là '0' hoặc '1'.\n\n    Sẽ có một vài ký tự bổ sung 'db' ở đầu và cuối chuỗi. Các ký tự bổ sung này được sử dụng để giúp định dạng.\n\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/33", "prompt": "\ndef is_happy(s):\n    \"\"\"Bạn được cho một chuỗi s.\nNhiệm vụ của bạn là kiểm tra xem chuỗi đó có hạnh phúc hay không.\nMột chuỗi được coi là hạnh phúc nếu độ dài của nó ít nhất là 3 và mỗi 3 chữ cái liên tiếp đều khác nhau.\nVí dụ:\n    \n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "language": "python", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "description": "Bạn được cho một chuỗi s.\nNhiệm vụ của bạn là kiểm tra xem chuỗi đó có hạnh phúc hay không.\nMột chuỗi được coi là hạnh phúc nếu độ dài của nó ít nhất là 3 và mỗi 3 chữ cái liên tiếp đều khác nhau.\nVí dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/34", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Đó là tuần cuối cùng của kỳ học và giáo viên phải đưa điểm cho học sinh. Giáo viên đã tạo thuật toán riêng của mình để đánh giá điểm. Vấn đề duy nhất là cô ấy đã mất mã mà cô ấy đã sử dụng để đánh giá điểm. Cô ấy đã cung cấp cho bạn một danh sách GPA của một số học sinh và bạn phải viết một chức năng có thể đưa ra một danh sách các điểm chữ sử dụng bảng sau:\n             GPA       |    Điểm chữ\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Ví dụ:\n    \n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "description": "Đó là tuần cuối cùng của kỳ học và giáo viên phải đưa điểm cho học sinh. Giáo viên đã tạo thuật toán riêng của mình để đánh giá điểm. Vấn đề duy nhất là cô ấy đã mất mã mà cô ấy đã sử dụng để đánh giá điểm. Cô ấy đã cung cấp cho bạn một danh sách GPA của một số học sinh và bạn phải viết một chức năng có thể đưa ra một danh sách các điểm chữ sử dụng bảng sau:\n             GPA       |    Điểm chữ\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n        Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/35", "prompt": "\ndef prime_length(string):\n    \"\"\"Viết một hàm nhận vào một chuỗi và trả về True nếu độ dài của chuỗi là số nguyên tố hoặc False nếu không phải. Ví dụ:\n    \n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "language": "python", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "description": "Viết một hàm nhận vào một chuỗi và trả về True nếu độ dài của chuỗi là số nguyên tố hoặc False nếu không phải. Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/36", "prompt": "\ndef solve(N):\n    \"\"\"Cho một số nguyên dương N, trả về tổng các chữ số của N ở hệ nhị phân.\n\n        Ví dụ\n        Với N = 1000, tổng các chữ số sẽ là 1, đầu ra sẽ là \"1\".\n        Với N = 150, tổng các chữ số sẽ là 6, đầu ra sẽ là \"110\".\n        Với N = 147, tổng các chữ số sẽ là 12, đầu ra sẽ là \"1100\".\n    \n    Biến:\n        @N số nguyên\n             Ràng buộc: 0 ≤ N ≤ 10000.\n    Đầu ra:\n         một chuỗi số nhị phân.\n    \n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "language": "python", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "description": "Cho một số nguyên dương N, trả về tổng các chữ số của N ở hệ nhị phân.\n\n        Ví dụ\n        Với N = 1000, tổng các chữ số sẽ là 1, đầu ra sẽ là \"1\".\n        Với N = 150, tổng các chữ số sẽ là 6, đầu ra sẽ là \"110\".\n        Với N = 147, tổng các chữ số sẽ là 12, đầu ra sẽ là \"1100\".\n    \n    Biến:\n        @N số nguyên\n             Ràng buộc: 0 ≤ N ≤ 10000.\n    Đầu ra:\n         một chuỗi số nhị phân.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/37", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    Bạn được cung cấp một dữ liệu 2 chiều dưới dạng danh sách lồng nhau, tương tự như ma trận, tuy nhiên, khác với ma trận, mỗi hàng có thể chứa một số lượng cột khác nhau. Cho lst và số nguyên x, tìm các số nguyên x trong danh sách và trả về danh sách các bộ, [(x1, y1), (x2, y2) ...] sao cho mỗi bộ là một tọa độ - (hàng, cột), bắt đầu từ 0. Sắp xếp các tọa độ ban đầu theo hàng theo thứ tự tăng dần. Ngoài ra, sắp xếp các tọa độ của hàng theo cột theo thứ tự giảm dần.\n\n    Ví dụ:\n    \n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "description": "Bạn được cung cấp một dữ liệu 2 chiều dưới dạng danh sách lồng nhau, tương tự như ma trận, tuy nhiên, khác với ma trận, mỗi hàng có thể chứa một số lượng cột khác nhau. Cho lst và số nguyên x, tìm các số nguyên x trong danh sách và trả về danh sách các bộ, [(x1, y1), (x2, y2) ...] sao cho mỗi bộ là một tọa độ - (hàng, cột), bắt đầu từ 0. Sắp xếp các tọa độ ban đầu theo hàng theo thứ tự tăng dần. Ngoài ra, sắp xếp các tọa độ của hàng theo cột theo thứ tự giảm dần.\n\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/38", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    Bạn được cung cấp một danh sách các số nguyên.\nViết một hàm next_smallest() trả về phần tử thứ hai nhỏ nhất của danh sách.\nTrả về null nếu không có phần tử như vậy.\n    \n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "description": "Bạn được cung cấp một danh sách các số nguyên.\nViết một hàm next_smallest() trả về phần tử thứ hai nhỏ nhất của danh sách.\nTrả về null nếu không có phần tử như vậy.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/39", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    Bạn sẽ được cung cấp một chuỗi các từ, và nhiệm vụ của bạn là đếm số lần chán nản. Một câu chán nản là một câu bắt đầu bằng từ \"I\". Các câu được phân cách bởi dấu '.', '?' hoặc '!'.\n\n    Ví dụ:\n    \n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "description": "Bạn sẽ được cung cấp một chuỗi các từ, và nhiệm vụ của bạn là đếm số lần chán nản. Một câu chán nản là một câu bắt đầu bằng từ \"I\". Các câu được phân cách bởi dấu '.', '?' hoặc '!'.\n\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/40", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Bạn được cho một danh sách các số nguyên.\n    Bạn cần tìm giá trị nguyên tố lớn nhất và trả về tổng các chữ số của nó.\n\n        Ví dụ:\n    \n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "language": "python", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "description": "Bạn được cho một danh sách các số nguyên.\n    Bạn cần tìm giá trị nguyên tố lớn nhất và trả về tổng các chữ số của nó.\n\n        Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/41", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Cho một từ điển, trả về True nếu tất cả các khóa là chuỗi in thường hoặc tất cả các khóa là chuỗi in hoa, ngược lại trả về False. Hàm sẽ trả về False nếu từ điển trống. Ví dụ:\n    \n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "language": "python", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "description": "Cho một từ điển, trả về True nếu tất cả các khóa là chuỗi in thường hoặc tất cả các khóa là chuỗi in hoa, ngược lại trả về False. Hàm sẽ trả về False nếu từ điển trống. Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/42", "prompt": "\ndef closest_integer(value):\n    '''\n    Tạo một hàm nhận giá trị (chuỗi) đại diện cho một số và trả về số nguyên gần nhất. Nếu số đó cách đều hai số nguyên, làm tròn nó ra khỏi số 0.\n\n        Ví dụ:\n    \n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "language": "python", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "description": "Tạo một hàm nhận giá trị (chuỗi) đại diện cho một số và trả về số nguyên gần nhất. Nếu số đó cách đều hai số nguyên, làm tròn nó ra khỏi số 0.\n\n        Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/43", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Cho một số nguyên dương n, bạn phải xếp một đống đá có n tầng.\n    Tầng đầu tiên có n viên đá.\n    Số lượng đá trong tầng tiếp theo là:\n        - số lẻ tiếp theo nếu n là số lẻ.\n        - số chẵn tiếp theo nếu n là số chẵn.\n    Trả về số lượng đá trong mỗi tầng dưới dạng danh sách, trong đó phần tử tại chỉ số\n    i đại diện cho số lượng đá trong tầng (i+1).\n\n        Ví dụ:\n    \n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "description": "Cho một số nguyên dương n, bạn phải xếp một đống đá có n tầng.\n    Tầng đầu tiên có n viên đá.\n    Số lượng đá trong tầng tiếp theo là:\n        - số lẻ tiếp theo nếu n là số lẻ.\n        - số chẵn tiếp theo nếu n là số chẵn.\n    Trả về số lượng đá trong mỗi tầng dưới dạng danh sách, trong đó phần tử tại chỉ số\n    i đại diện cho số lượng đá trong tầng (i+1).\n\n        Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/44", "prompt": "\ndef words_string(s):\n    \"\"\"\n    Bạn sẽ được cung cấp một chuỗi các từ được phân tách bằng dấu phẩy hoặc khoảng trắng. Nhiệm vụ của bạn là tách chuỗi thành các từ và trả về một mảng các từ.\n\n    Ví dụ:\n    \n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "language": "python", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "description": "Bạn sẽ được cung cấp một chuỗi các từ được phân tách bằng dấu phẩy hoặc khoảng trắng. Nhiệm vụ của bạn là tách chuỗi thành các từ và trả về một mảng các từ.\n\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/45", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Hàm này nhận hai số dương x và y và trả về số nguyên chẵn lớn nhất trong khoảng [x, y] bao gồm cả x và y. Nếu không có số như vậy, thì hàm sẽ trả về -1.\n\n    Ví dụ:\n    \n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "language": "python", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "description": "Hàm này nhận hai số dương x và y và trả về số nguyên chẵn lớn nhất trong khoảng [x, y] bao gồm cả x và y. Nếu không có số như vậy, thì hàm sẽ trả về -1.\n\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/46", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Bạn được cho hai số nguyên dương n và m, và nhiệm vụ của bạn là tính trung bình cộng của các số nguyên từ n đến m (bao gồm cả n và m). Làm tròn kết quả đến số nguyên gần nhất và chuyển đổi thành số nhị phân. Nếu n lớn hơn m, trả về -1. Ví dụ:\n    \n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "language": "python", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "description": "Bạn được cho hai số nguyên dương n và m, và nhiệm vụ của bạn là tính trung bình cộng của các số nguyên từ n đến m (bao gồm cả n và m). Làm tròn kết quả đến số nguyên gần nhất và chuyển đổi thành số nhị phân. Nếu n lớn hơn m, trả về -1. Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/47", "prompt": "\ndef f(n):\n    \"\"\" Thực hiện hàm f nhận tham số n,\n    và trả về một danh sách có kích thước n, sao cho giá trị của phần tử tại chỉ số i là giai thừa của i nếu i là số chẵn\n    hoặc tổng của các số từ 1 đến i nếu không phải.\n    i bắt đầu từ 1.\n    Giai thừa của i là tích của các số từ 1 đến i (1 * 2 * ... * i).\n    Ví dụ:\n    \n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "language": "python", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "description": "Thực hiện hàm f nhận tham số n,\n    và trả về một danh sách có kích thước n, sao cho giá trị của phần tử tại chỉ số i là giai thừa của i nếu i là số chẵn\n    hoặc tổng của các số từ 1 đến i nếu không phải.\n    i bắt đầu từ 1.\n    Giai thừa của i là tích của các số từ 1 đến i (1 * 2 * ... * i).\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/48", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Cho một số nguyên dương n, trả về một tuple chứa số lượng số đối xứng chẵn và lẻ trong khoảng từ 1 đến n, bao gồm cả n.\n\n        Ví dụ 1:\n\n            Input: 3\n        Output: (1, 2)\n        Giải thích:\n        Các số đối xứng là 1, 2, 3. Một số chẵn và hai số lẻ.\n\n        Ví dụ 2:\n\n            Input: 12\n        Output: (4, 6)\n        Giải thích:\n        Các số đối xứng là 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Bốn số chẵn và sáu số lẻ.\n\n        Chú ý:\n        1. 1 <= n <= 10^3\n        2. Tuple trả về chứa số lượng số đối xứng chẵn và lẻ tương ứng.\n    \n    \"\"\"\n", "entry_point": "even_odd_palindrome", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "description": "Cho một số nguyên dương n, trả về một tuple chứa số lượng số đối xứng chẵn và lẻ trong khoảng từ 1 đến n, bao gồm cả n.\n\n        Ví dụ 1:\n\n            Input: 3\n        Output: (1, 2)\n        Giải thích:\n        Các số đối xứng là 1, 2, 3. Một số chẵn và hai số lẻ.\n\n        Ví dụ 2:\n\n            Input: 12\n        Output: (4, 6)\n        Giải thích:\n        Các số đối xứng là 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Bốn số chẵn và sáu số lẻ.\n\n        Chú ý:\n        1. 1 <= n <= 10^3\n        2. Tuple trả về chứa số lượng số đối xứng chẵn và lẻ tương ứng.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/49", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Chúng ta có một mảng 'arr' gồm N số nguyên arr[1], arr[2], ..., arr[N]. Các số trong mảng sẽ được sắp xếp ngẫu nhiên. Nhiệm vụ của bạn là xác định xem có thể có được một mảng được sắp xếp theo thứ tự không giảm bằng cách thực hiện thao tác sau trên mảng đã cho:\n    Bạn được phép thực hiện thao tác dịch phải bất kỳ số lần nào.\n    \n    Một thao tác dịch phải có nghĩa là dịch tất cả các phần tử của mảng sang phải một vị trí. Phần tử cuối cùng của mảng sẽ được di chuyển đến vị trí bắt đầu trong mảng, tức là vị trí 0.\n\n        Nếu có thể thu được mảng được sắp xếp bằng cách thực hiện thao tác trên thì trả về True, ngược lại trả về False.\n    Nếu mảng đã cho là trống thì trả về True.\n\n        Lưu ý: Danh sách đã cho được đảm bảo có các phần tử duy nhất.\n\n        Ví dụ:\n\n        move_one_ball([3, 4, 5, 1, 2])==>True\n    Giải thích: Bằng cách thực hiện 2 thao tác dịch phải, ta có thể đạt được thứ tự không giảm cho mảng đã cho.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Giải thích: Không thể thu được thứ tự không giảm cho mảng đã cho bằng cách thực hiện bất kỳ số lần dịch phải nào.\n    \n                \n    \"\"\"\n", "entry_point": "move_one_ball", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "language": "python", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "description": "Chúng ta có một mảng 'arr' gồm N số nguyên arr[1], arr[2], ..., arr[N]. Các số trong mảng sẽ được sắp xếp ngẫu nhiên. Nhiệm vụ của bạn là xác định xem có thể có được một mảng được sắp xếp theo thứ tự không giảm bằng cách thực hiện thao tác sau trên mảng đã cho:\n    Bạn được phép thực hiện thao tác dịch phải bất kỳ số lần nào.\n    \n    Một thao tác dịch phải có nghĩa là dịch tất cả các phần tử của mảng sang phải một vị trí. Phần tử cuối cùng của mảng sẽ được di chuyển đến vị trí bắt đầu trong mảng, tức là vị trí 0.\n\n        Nếu có thể thu được mảng được sắp xếp bằng cách thực hiện thao tác trên thì trả về True, ngược lại trả về False.\n    Nếu mảng đã cho là trống thì trả về True.\n\n        Lưu ý: Danh sách đã cho được đảm bảo có các phần tử duy nhất.\n\n        Ví dụ:\n\n        move_one_ball([3, 4, 5, 1, 2])==>True\n    Giải thích: Bằng cách thực hiện 2 thao tác dịch phải, ta có thể đạt được thứ tự không giảm cho mảng đã cho.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Giải thích: Không thể thu được thứ tự không giảm cho mảng đã cho bằng cách thực hiện bất kỳ số lần dịch phải nào.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/50", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Trong bài toán này, bạn sẽ thực hiện một hàm nhận vào hai danh sách số và xác định liệu có thể thực hiện một trao đổi các phần tử giữa chúng để biến lst1 thành một danh sách chỉ chứa các số chẵn hay không. Không có giới hạn về số lượng các phần tử được trao đổi giữa lst1 và lst2. Nếu có thể trao đổi các phần tử giữa lst1 và lst2 để biến tất cả các phần tử của lst1 thành số chẵn, trả về \"YES\". Ngược lại, trả về \"NO\". Ví dụ: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Được cho rằng danh sách đầu vào sẽ không rỗng.\n    \n    \"\"\"\n", "entry_point": "exchange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "language": "python", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "description": "Trong bài toán này, bạn sẽ thực hiện một hàm nhận vào hai danh sách số và xác định liệu có thể thực hiện một trao đổi các phần tử giữa chúng để biến lst1 thành một danh sách chỉ chứa các số chẵn hay không. Không có giới hạn về số lượng các phần tử được trao đổi giữa lst1 và lst2. Nếu có thể trao đổi các phần tử giữa lst1 và lst2 để biến tất cả các phần tử của lst1 thành số chẵn, trả về \"YES\". Ngược lại, trả về \"NO\". Ví dụ: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Được cho rằng danh sách đầu vào sẽ không rỗng.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/51", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Nhiệm vụ\n    Chúng ta được cho hai chuỗi s và c, bạn phải xóa tất cả các ký tự trong s mà bằng với bất kỳ ký tự nào trong c\n    sau đó kiểm tra xem chuỗi kết quả có phải là chuỗi đối xứng hay không.\n    Một chuỗi được gọi là đối xứng nếu nó đọc ngược lại giống như đọc xuôi.\n    Bạn nên trả về một bộ chứa chuỗi kết quả và True/False cho kiểm tra.\n    Ví dụ\n    Với s = \"abcde\", c = \"ae\", kết quả sẽ là ('bcd',False)\n    Với s = \"abcdef\", c = \"b\" kết quả sẽ là ('acdef',False)\n    Với s = \"abcdedcba\", c = \"ab\", kết quả sẽ là ('cdedc',True)\n    \n    \"\"\"\n", "entry_point": "reverse_delete", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "language": "python", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "description": "Nhiệm vụ\n    Chúng ta được cho hai chuỗi s và c, bạn phải xóa tất cả các ký tự trong s mà bằng với bất kỳ ký tự nào trong c\n    sau đó kiểm tra xem chuỗi kết quả có phải là chuỗi đối xứng hay không.\n    Một chuỗi được gọi là đối xứng nếu nó đọc ngược lại giống như đọc xuôi.\n    Bạn nên trả về một bộ chứa chuỗi kết quả và True/False cho kiểm tra.\n    Ví dụ\n    Với s = \"abcde\", c = \"ae\", kết quả sẽ là ('bcd',False)\n    Với s = \"abcdef\", c = \"b\" kết quả sẽ là ('acdef',False)\n    Với s = \"abcdedcba\", c = \"ab\", kết quả sẽ là ('cdedc',True)\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/52", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Bạn được cho một lưới hình chữ nhật các giếng. Mỗi hàng đại diện cho một giếng đơn, và mỗi số 1 trong một hàng đại diện cho một đơn vị nước. Mỗi giếng có một thùng tương ứng có thể được sử dụng để rút nước từ đó, và tất cả các thùng đều có cùng dung tích. Nhiệm vụ của bạn là sử dụng các thùng để rút hết nước từ các giếng. Đưa ra số lần bạn cần hạ thùng.\n\n        Ví dụ 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n        Ví dụ 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Ví dụ 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n        Ràng buộc:\n        * tất cả các giếng có cùng độ dài\n        * 1 <= độ dài của grid <= 10^2\n        * 1 <= độ dài của grid[:,1] <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= dung tích <= 10\n    \n    \"\"\"\n", "entry_point": "max_fill", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "language": "python", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "description": "Bạn được cho một lưới hình chữ nhật các giếng. Mỗi hàng đại diện cho một giếng đơn, và mỗi số 1 trong một hàng đại diện cho một đơn vị nước. Mỗi giếng có một thùng tương ứng có thể được sử dụng để rút nước từ đó, và tất cả các thùng đều có cùng dung tích. Nhiệm vụ của bạn là sử dụng các thùng để rút hết nước từ các giếng. Đưa ra số lần bạn cần hạ thùng.\n\n        Ví dụ 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n        Ví dụ 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Ví dụ 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n        Ràng buộc:\n        * tất cả các giếng có cùng độ dài\n        * 1 <= độ dài của grid <= 10^2\n        * 1 <= độ dài của grid[:,1] <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= dung tích <= 10\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/53", "prompt": "\ndef select_words(s, n):\n    \"\"\"Cho một chuỗi s và một số tự nhiên n, bạn được giao nhiệm vụ thực hiện một hàm trả về một danh sách các từ từ chuỗi s chứa chính xác n phụ âm, theo thứ tự các từ xuất hiện trong chuỗi s. Nếu chuỗi s rỗng thì hàm sẽ trả về một danh sách rỗng. Lưu ý: bạn có thể giả định chuỗi đầu vào chỉ chứa chữ cái và khoảng trắng.\n    Ví dụ:\n    \n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "language": "python", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "description": "Cho một chuỗi s và một số tự nhiên n, bạn được giao nhiệm vụ thực hiện một hàm trả về một danh sách các từ từ chuỗi s chứa chính xác n phụ âm, theo thứ tự các từ xuất hiện trong chuỗi s. Nếu chuỗi s rỗng thì hàm sẽ trả về một danh sách rỗng. Lưu ý: bạn có thể giả định chuỗi đầu vào chỉ chứa chữ cái và khoảng trắng.\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/54", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Cho một mảng arr gồm các số nguyên và một số nguyên dương k, trả về một danh sách đã sắp xếp có độ dài k với k số lớn nhất trong arr.\n\n        Ví dụ 1:\n\n            Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n        Ví dụ 2:\n\n            Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n        Ví dụ 3:\n\n            Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n        Lưu ý:\n        1. Độ dài của mảng sẽ nằm trong khoảng [1, 1000].\n        2. Các phần tử trong mảng sẽ nằm trong khoảng [-1000, 1000].\n        3. 0 <= k <= độ dài của arr.\n    \n    \"\"\"\n", "entry_point": "maximum", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "language": "python", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "description": "Cho một mảng arr gồm các số nguyên và một số nguyên dương k, trả về một danh sách đã sắp xếp có độ dài k với k số lớn nhất trong arr.\n\n        Ví dụ 1:\n\n            Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n        Ví dụ 2:\n\n            Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n        Ví dụ 3:\n\n            Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n        Lưu ý:\n        1. Độ dài của mảng sẽ nằm trong khoảng [1, 1000].\n        2. Các phần tử trong mảng sẽ nằm trong khoảng [-1000, 1000].\n        3. 0 <= k <= độ dài của arr.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/55", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Cho một mảng số nguyên không rỗng arr và một số nguyên k, trả về tổng các phần tử có tối đa hai chữ số từ k phần tử đầu tiên của arr.\n\n        Ví dụ:\n\n            Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # tổng của 21 + 3\n\n        Ràng buộc:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \n    \"\"\"\n", "entry_point": "add_elements", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "description": "Cho một mảng số nguyên không rỗng arr và một số nguyên k, trả về tổng các phần tử có tối đa hai chữ số từ k phần tử đầu tiên của arr.\n\n        Ví dụ:\n\n            Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # tổng của 21 + 3\n\n        Ràng buộc:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/56", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Bạn được cho hai khoảng,\n    trong đó mỗi khoảng là một cặp số nguyên. Ví dụ, khoảng = (bắt đầu, kết thúc) = (1, 2).\n    Các khoảng được cho là đóng nghĩa là khoảng (bắt đầu, kết thúc)\n    bao gồm cả bắt đầu và kết thúc.\n    Đối với mỗi khoảng được cho, giả định rằng bắt đầu của nó nhỏ hơn hoặc bằng kết thúc của nó.\n    Nhiệm vụ của bạn là xác định xem độ dài giao của hai khoảng này\n    có phải là một số nguyên tố hay không.\n    Ví dụ, giao của các khoảng (1, 3), (2, 4) là (2, 3)\n    có độ dài là 1, không phải là số nguyên tố.\n    Nếu độ dài của giao là một số nguyên tố, trả về \"YES\",\n    nếu không, trả về \"NO\".\n    Nếu hai khoảng không giao nhau, trả về \"NO\".\n\n    \n    [input/output] samples:\n    \n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "language": "python", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "description": "Bạn được cho hai khoảng,\n    trong đó mỗi khoảng là một cặp số nguyên. Ví dụ, khoảng = (bắt đầu, kết thúc) = (1, 2).\n    Các khoảng được cho là đóng nghĩa là khoảng (bắt đầu, kết thúc)\n    bao gồm cả bắt đầu và kết thúc.\n    Đối với mỗi khoảng được cho, giả định rằng bắt đầu của nó nhỏ hơn hoặc bằng kết thúc của nó.\n    Nhiệm vụ của bạn là xác định xem độ dài giao của hai khoảng này\n    có phải là một số nguyên tố hay không.\n    Ví dụ, giao của các khoảng (1, 3), (2, 4) là (2, 3)\n    có độ dài là 1, không phải là số nguyên tố.\n    Nếu độ dài của giao là một số nguyên tố, trả về \"YES\",\n    nếu không, trả về \"NO\".\n    Nếu hai khoảng không giao nhau, trả về \"NO\".\n\n    \n    [input/output] samples:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/57", "prompt": "\ndef tri(n):\n    \"\"\"Mọi người đều biết dãy Fibonacci, nó đã được nghiên cứu sâu rộng bởi các nhà toán học trong vài thế kỷ qua. Tuy nhiên, điều mà mọi người không biết là dãy Tribonacci. Dãy Tribonacci được định nghĩa bởi sự lặp lại:\ntri(1) = 3\ntri(n) = 1 + n / 2, nếu n là số chẵn.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), nếu n là số lẻ.\nVí dụ:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nBạn được cho một số nguyên không âm n, bạn phải trả về một danh sách gồm n + 1 số đầu tiên của dãy Tribonacci.\nVí dụ:\ntri(3) = [1, 3, 2, 8]\n    \n    \"\"\"\n", "entry_point": "tri", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "language": "python", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "description": "Mọi người đều biết dãy Fibonacci, nó đã được nghiên cứu sâu rộng bởi các nhà toán học trong vài thế kỷ qua. Tuy nhiên, điều mà mọi người không biết là dãy Tribonacci. Dãy Tribonacci được định nghĩa bởi sự lặp lại:\ntri(1) = 3\ntri(n) = 1 + n / 2, nếu n là số chẵn.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), nếu n là số lẻ.\nVí dụ:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nBạn được cho một số nguyên không âm n, bạn phải trả về một danh sách gồm n + 1 số đầu tiên của dãy Tribonacci.\nVí dụ:\ntri(3) = [1, 3, 2, 8]\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/58", "prompt": "\ndef digits(n):\n    \"\"\"Cho một số nguyên dương n, trả về tích của các chữ số lẻ.\n    Trả về 0 nếu tất cả các chữ số đều là chẵn.\n    Ví dụ:\n    \n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "language": "python", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "description": "Cho một số nguyên dương n, trả về tích của các chữ số lẻ.\n    Trả về 0 nếu tất cả các chữ số đều là chẵn.\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/59", "prompt": "\ndef is_nested(string):\n    '''\n    Tạo một hàm nhận một chuỗi làm đầu vào chỉ chứa các dấu ngoặc vuông.\nHàm nên trả về True nếu và chỉ nếu có một chuỗi con hợp lệ của các dấu ngoặc vuông, trong đó ít nhất một dấu ngoặc trong chuỗi con được lồng vào.\n    \n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n", "entry_point": "is_nested", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "language": "python", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "description": "Tạo một hàm nhận một chuỗi làm đầu vào chỉ chứa các dấu ngoặc vuông.\nHàm nên trả về True nếu và chỉ nếu có một chuỗi con hợp lệ của các dấu ngoặc vuông, trong đó ít nhất một dấu ngoặc trong chuỗi con được lồng vào.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/60", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Bạn được cho một danh sách các số.\n    Bạn cần trả về tổng các số bình phương trong danh sách đã cho,\n    làm tròn mỗi phần tử trong danh sách lên đến số nguyên trên (Ceiling) trước.\n    Ví dụ:\n    Với lst = [1,2,3], đầu ra sẽ là 14\n    Với lst = [1,4,9], đầu ra sẽ là 98\n    Với lst = [1,3,5,7], đầu ra sẽ là 84\n    Với lst = [1.4,4.2,0], đầu ra sẽ là 29\n    Với lst = [-2.4,1,1], đầu ra sẽ là 6\n    \n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "description": "Bạn được cho một danh sách các số.\n    Bạn cần trả về tổng các số bình phương trong danh sách đã cho,\n    làm tròn mỗi phần tử trong danh sách lên đến số nguyên trên (Ceiling) trước.\n    Ví dụ:\n    Với lst = [1,2,3], đầu ra sẽ là 14\n    Với lst = [1,4,9], đầu ra sẽ là 98\n    Với lst = [1,3,5,7], đầu ra sẽ là 84\n    Với lst = [1.4,4.2,0], đầu ra sẽ là 29\n    Với lst = [-2.4,1,1], đầu ra sẽ là 6\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/61", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Tạo một hàm trả về True nếu ký tự cuối cùng của chuỗi đã cho là một ký tự chữ cái và không phải là một phần của một từ, và False trong trường hợp khác. Lưu ý: \"từ\" là một nhóm ký tự được tách ra bằng khoảng trắng.\n\n        Ví dụ:\n    \n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "description": "Tạo một hàm trả về True nếu ký tự cuối cùng của chuỗi đã cho là một ký tự chữ cái và không phải là một phần của một từ, và False trong trường hợp khác. Lưu ý: \"từ\" là một nhóm ký tự được tách ra bằng khoảng trắng.\n\n        Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/62", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Tạo một hàm trả về chỉ số lớn nhất của một phần tử không lớn hơn hoặc bằng phần tử ngay trước nó. Nếu không có phần tử như vậy thì trả về -1. Mảng được cung cấp sẽ không chứa các giá trị trùng lặp.\n\n    Ví dụ:\n    \n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "language": "python", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "description": "Tạo một hàm trả về chỉ số lớn nhất của một phần tử không lớn hơn hoặc bằng phần tử ngay trước nó. Nếu không có phần tử như vậy thì trả về -1. Mảng được cung cấp sẽ không chứa các giá trị trùng lặp.\n\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/63", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Tạo một hàm trả về một tuple (a, b), trong đó 'a' là số nguyên âm lớn nhất và 'b' là số nguyên dương nhỏ nhất trong danh sách. Nếu không có số nguyên âm hoặc dương, trả về chúng là None.\n\n    Ví dụ:\n    \n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "language": "python", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "description": "Tạo một hàm trả về một tuple (a, b), trong đó 'a' là số nguyên âm lớn nhất và 'b' là số nguyên dương nhỏ nhất trong danh sách. Nếu không có số nguyên âm hoặc dương, trả về chúng là None.\n\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/64", "prompt": "\ndef special_factorial(n):\n    \"\"\"Phép tính giai thừa Brazil được định nghĩa như sau:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    với n > 0\n\n        Ví dụ:\n    \n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "language": "python", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "description": "Phép tính giai thừa Brazil được định nghĩa như sau:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    với n > 0\n\n        Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/65", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    Bạn được cho một chuỗi đại diện cho một câu,\n    câu đó chứa một số từ được phân tách bởi khoảng trắng,\n    và bạn phải trả về một chuỗi chứa các từ từ câu ban đầu,\n    có độ dài là số nguyên tố,\n    thứ tự các từ trong chuỗi mới phải giống như ban đầu.\n\n        Ví dụ 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n        Ví dụ 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n        Ràng buộc:\n        * 1 <= len(sentence) <= 100\n        * sentence chỉ chứa các chữ cái.\n    \n    \"\"\"\n", "entry_point": "words_in_sentence", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "language": "python", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "description": "Bạn được cho một chuỗi đại diện cho một câu,\n    câu đó chứa một số từ được phân tách bởi khoảng trắng,\n    và bạn phải trả về một chuỗi chứa các từ từ câu ban đầu,\n    có độ dài là số nguyên tố,\n    thứ tự các từ trong chuỗi mới phải giống như ban đầu.\n\n        Ví dụ 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n        Ví dụ 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n        Ràng buộc:\n        * 1 <= len(sentence) <= 100\n        * sentence chỉ chứa các chữ cái.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/66", "prompt": "\ndef simplify(x, n):\n    \"\"\"Nhiệm vụ của bạn là triển khai một hàm để đơn giản hóa biểu thức x * n. Hàm trả về True nếu x * n đánh giá thành một số nguyên và False nếu không phải. Cả x và n đều là biểu diễn chuỗi của một phân số và có định dạng sau đây, <tử số>/<mẫu số> trong đó cả tử số và mẫu số đều là số nguyên dương.\n\n    Bạn có thể giả định rằng x và n là các phân số hợp lệ và không có số 0 làm mẫu số.\n    \n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "language": "python", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "description": "Nhiệm vụ của bạn là triển khai một hàm để đơn giản hóa biểu thức x * n. Hàm trả về True nếu x * n đánh giá thành một số nguyên và False nếu không phải. Cả x và n đều là biểu diễn chuỗi của một phân số và có định dạng sau đây, <tử số>/<mẫu số> trong đó cả tử số và mẫu số đều là số nguyên dương.\n\n    Bạn có thể giả định rằng x và n là các phân số hợp lệ và không có số 0 làm mẫu số.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/67", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Viết một hàm sắp xếp danh sách số nguyên được cung cấp theo thứ tự tăng dần dựa trên tổng các chữ số của chúng. Lưu ý: nếu có nhiều mục có tổng số chữ số tương tự, sắp xếp chúng dựa trên chỉ số trong danh sách gốc.\n\n    Ví dụ:\n    \n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "description": "Viết một hàm sắp xếp danh sách số nguyên được cung cấp theo thứ tự tăng dần dựa trên tổng các chữ số của chúng. Lưu ý: nếu có nhiều mục có tổng số chữ số tương tự, sắp xếp chúng dựa trên chỉ số trong danh sách gốc.\n\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/68", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Viết một hàm nhận một mảng số làm đầu vào và trả về số lượng phần tử trong mảng lớn hơn 10 và cả hai chữ số đầu và cuối của một số đều là số lẻ (1, 3, 5, 7, 9). Ví dụ:\n    \n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "language": "python", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "description": "Viết một hàm nhận một mảng số làm đầu vào và trả về số lượng phần tử trong mảng lớn hơn 10 và cả hai chữ số đầu và cuối của một số đều là số lẻ (1, 3, 5, 7, 9). Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/69", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    Bạn được cho một số nguyên dương n. Bạn phải tạo ra một mảng số nguyên a có độ dài n.\n        Đối với mỗi i (1 ≤ i ≤ n), giá trị của a[i] = i * i - i + 1.\n        Trả về số lượng bộ ba (a[i], a[j], a[k]) của a trong đó i < j < k, \n    và a[i] + a[j] + a[k] là bội số của 3.\n\n        Ví dụ :\n        Input: n = 5\n        Output: 1\n        Giải thích: \n        a = [1, 3, 7, 13, 21]\n        Chỉ có một bộ ba hợp lệ là (1, 7, 13).\n    \n    \"\"\"\n", "entry_point": "get_max_triples", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "language": "python", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "description": "Bạn được cho một số nguyên dương n. Bạn phải tạo ra một mảng số nguyên a có độ dài n.\n        Đối với mỗi i (1 ≤ i ≤ n), giá trị của a[i] = i * i - i + 1.\n        Trả về số lượng bộ ba (a[i], a[j], a[k]) của a trong đó i < j < k, \n    và a[i] + a[j] + a[k] là bội số của 3.\n\n        Ví dụ :\n        Input: n = 5\n        Output: 1\n        Giải thích: \n        a = [1, 3, 7, 13, 21]\n        Chỉ có một bộ ba hợp lệ là (1, 7, 13).\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/70", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    Trong hệ mặt trời của chúng ta có tám hành tinh: hành tinh gần nhất với Mặt Trời là Sao Thủy, tiếp theo là Sao Kim, sau đó là Trái đất, Sao Hỏa, Sao Mộc, Sao Thổ, Sao Thiên Vương và Sao Hải Vương. Viết một hàm nhận hai tên hành tinh dưới dạng chuỗi planet1 và planet2. Hàm này sẽ trả về một tuple chứa tất cả các hành tinh có quỹ đạo nằm giữa quỹ đạo của planet1 và planet2, được sắp xếp theo khoảng cách đến Mặt Trời. Hàm sẽ trả về một tuple rỗng nếu planet1 hoặc planet2 không phải là tên hành tinh đúng. Ví dụ.\n    \n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "language": "python", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "description": "Trong hệ mặt trời của chúng ta có tám hành tinh: hành tinh gần nhất với Mặt Trời là Sao Thủy, tiếp theo là Sao Kim, sau đó là Trái đất, Sao Hỏa, Sao Mộc, Sao Thổ, Sao Thiên Vương và Sao Hải Vương. Viết một hàm nhận hai tên hành tinh dưới dạng chuỗi planet1 và planet2. Hàm này sẽ trả về một tuple chứa tất cả các hành tinh có quỹ đạo nằm giữa quỹ đạo của planet1 và planet2, được sắp xếp theo khoảng cách đến Mặt Trời. Hàm sẽ trả về một tuple rỗng nếu planet1 hoặc planet2 không phải là tên hành tinh đúng. Ví dụ.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/71", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Một chương trình đơn giản sẽ trả về giá trị của x nếu n là số nguyên tố và sẽ trả về giá trị của y trong trường hợp khác.\n\n    Ví dụ:\n    \n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "language": "python", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "description": "Một chương trình đơn giản sẽ trả về giá trị của x nếu n là số nguyên tố và sẽ trả về giá trị của y trong trường hợp khác.\n\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/72", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Cho một danh sách các số, trả về tổng bình phương của các số trong danh sách là số lẻ. Bỏ qua các số âm hoặc không phải số nguyên.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    Nếu danh sách đầu vào là rỗng, trả về 0.\n    \n    '''\n", "entry_point": "double_the_difference", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "description": "Cho một danh sách các số, trả về tổng bình phương của các số trong danh sách là số lẻ. Bỏ qua các số âm hoặc không phải số nguyên.\n\n        double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    Nếu danh sách đầu vào là rỗng, trả về 0.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/73", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Bạn sẽ được cung cấp tên của một lớp (một chuỗi) và một danh sách các phần mở rộng. Các phần mở rộng được sử dụng để tải thêm các lớp vào lớp. Sức mạnh của phần mở rộng được tính như sau: Cho CAP là số chữ cái in hoa trong tên phần mở rộng và cho SM là số chữ cái thường trong tên phần mở rộng, sức mạnh được cho bởi phân số CAP - SM. Bạn nên tìm phần mở rộng mạnh nhất và trả về một chuỗi theo định dạng sau: ClassName.StrongestExtensionName. Nếu có hai hoặc nhiều phần mở rộng có cùng sức mạnh, bạn nên chọn phần mở rộng đầu tiên trong danh sách. Ví dụ, nếu bạn được cung cấp \"Slices\" làm lớp và một danh sách các phần mở rộng: ['SErviNGSliCes', 'Cheese', 'StuFfed'] thì bạn nên trả về 'Slices.SErviNGSliCes' vì 'SErviNGSliCes' là phần mở rộng mạnh nhất (sức mạnh của nó là -1). Ví dụ:\n    \n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "language": "python", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "description": "Bạn sẽ được cung cấp tên của một lớp (một chuỗi) và một danh sách các phần mở rộng. Các phần mở rộng được sử dụng để tải thêm các lớp vào lớp. Sức mạnh của phần mở rộng được tính như sau: Cho CAP là số chữ cái in hoa trong tên phần mở rộng và cho SM là số chữ cái thường trong tên phần mở rộng, sức mạnh được cho bởi phân số CAP - SM. Bạn nên tìm phần mở rộng mạnh nhất và trả về một chuỗi theo định dạng sau: ClassName.StrongestExtensionName. Nếu có hai hoặc nhiều phần mở rộng có cùng sức mạnh, bạn nên chọn phần mở rộng đầu tiên trong danh sách. Ví dụ, nếu bạn được cung cấp \"Slices\" làm lớp và một danh sách các phần mở rộng: ['SErviNGSliCes', 'Cheese', 'StuFfed'] thì bạn nên trả về 'Slices.SErviNGSliCes' vì 'SErviNGSliCes' là phần mở rộng mạnh nhất (sức mạnh của nó là -1). Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/74", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Bạn được cho 2 từ. Bạn cần trả về True nếu từ thứ hai hoặc bất kỳ phép xoay nào của nó là một chuỗi con trong từ đầu tiên.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "language": "python", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "description": "Bạn được cho 2 từ. Bạn cần trả về True nếu từ thứ hai hoặc bất kỳ phép xoay nào của nó là một chuỗi con trong từ đầu tiên.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/75", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Cho một số nguyên dương, tìm số La Mã tương ứng và trả về dưới dạng chuỗi viết thường.\n    Giới hạn: 1 <= num <= 1000\n\n        Ví dụ:\n    \n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "description": "Cho một số nguyên dương, tìm số La Mã tương ứng và trả về dưới dạng chuỗi viết thường.\n    Giới hạn: 1 <= num <= 1000\n\n        Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/76", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Cho độ dài của ba cạnh của một tam giác. Trả về True nếu ba cạnh tạo thành một tam giác vuông, False nếu không phải. Một tam giác vuông là một tam giác có một góc vuông hoặc 90 độ. Ví dụ:\n    \n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "language": "python", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "description": "Cho độ dài của ba cạnh của một tam giác. Trả về True nếu ba cạnh tạo thành một tam giác vuông, False nếu không phải. Một tam giác vuông là một tam giác có một góc vuông hoặc 90 độ. Ví dụ:\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/77", "prompt": "\ndef solve(s):\n    \"\"\"Bạn được cho một chuỗi s.\n    Nếu s[i] là một chữ cái, đảo ngược trường hợp của nó từ chữ thường thành chữ hoa hoặc ngược lại,\n    nếu không giữ nguyên như vậy.\n    Nếu chuỗi không chứa chữ cái, đảo ngược chuỗi.\n    Hàm nên trả về chuỗi kết quả.\n    Ví dụ\n    \n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "language": "python", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "description": "Bạn được cho một chuỗi s.\n    Nếu s[i] là một chữ cái, đảo ngược trường hợp của nó từ chữ thường thành chữ hoa hoặc ngược lại,\n    nếu không giữ nguyên như vậy.\n    Nếu chuỗi không chứa chữ cái, đảo ngược chuỗi.\n    Hàm nên trả về chuỗi kết quả.\n    Ví dụ\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/78", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Cho một chuỗi 'text', trả về chuỗi tương đương với băm md5 của nó.\n    Nếu 'text' là một chuỗi rỗng, trả về null.\n    \n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "language": "python", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "description": "Cho một chuỗi 'text', trả về chuỗi tương đương với băm md5 của nó.\n    Nếu 'text' là một chuỗi rỗng, trả về null.\n    ", "natural_language": "Vietnamese"}
{"task_id": "python/79", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Cho hai số nguyên dương a và b, trả về các chữ số chẵn giữa a và b, theo thứ tự tăng dần.\n\n    Ví dụ:\n    \n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "language": "python", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "description": "Cho hai số nguyên dương a và b, trả về các chữ số chẵn giữa a và b, theo thứ tự tăng dần.\n\n    Ví dụ:\n    ", "natural_language": "Vietnamese"}
