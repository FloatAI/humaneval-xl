{"task_id": "go/0", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Σας δίνεται μια λίστα με λειτουργίες κατάθεσης και ανάληψης σε έναν τραπεζικό λογαριασμό που ξεκινά με μηδενικό υπόλοιπο. Η εργασία σας είναι να ανιχνεύσετε αν σε οποιοδήποτε σημείο το υπόλοιπο του λογαριασμού πέσει κάτω από το μηδέν, και σε αυτό το σημείο η συνάρτηση θα πρέπει να επιστρέψει True. Διαφορετικά θα πρέπει να επιστρέψει False.\n// >>> below_zero([1, 2, 3])\n// False\n// >>> below_zero([1, 2, -4, 5])\n// True\n// \nfunc below_zero (operations []int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := below_zero([]int{})\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := below_zero([]int{1, 2, -3, 1, 2, -3})\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := below_zero([]int{1, 2, -4, 5, 6})\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := below_zero([]int{1, -1, 2, -2, 5, -5, 4, -4})\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := below_zero([]int{1, -1, 2, -2, 5, -5, 4, -5})\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := below_zero([]int{1, -2, 2, -2, 5, -5, 4, -4})\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνεται μια λίστα με λειτουργίες κατάθεσης και ανάληψης σε έναν τραπεζικό λογαριασμό που ξεκινά με μηδενικό υπόλοιπο. Η εργασία σας είναι να ανιχνεύσετε αν σε οποιοδήποτε σημείο το υπόλοιπο του λογαριασμού πέσει κάτω από το μηδέν, και σε αυτό το σημείο η συνάρτηση θα πρέπει να επιστρέψει True. Διαφορετικά θα πρέπει να επιστρέψει False.", "entry_point": "below_zero", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/1", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Για μια δεδομένη λίστα ακεραίων, επιστρέψτε ένα tuple που αποτελείται από το άθροισμα και το γινόμενο όλων των ακεραίων στη λίστα.\n// Το άθροισμα της κενής λίστας πρέπει να είναι ίσο με 0 και το γινόμενο της κενής λίστας πρέπει να είναι ίσο με 1.\n// >>> sum_product([])\n// (0, 1)\n// >>> sum_product([1, 2, 3, 4])\n// (10, 24)\n// \nfunc sum_product (numbers []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := sum_product([]int{})\n\texpected_1 := []int{0, 1}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := sum_product([]int{1, 1, 1})\n\texpected_2 := []int{3, 1}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := sum_product([]int{100, 0})\n\texpected_3 := []int{100, 0}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := sum_product([]int{3, 5, 7})\n\texpected_4 := []int{15, 105}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := sum_product([]int{10})\n\texpected_5 := []int{10, 10}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Για μια δεδομένη λίστα ακεραίων, επιστρέψτε ένα tuple που αποτελείται από το άθροισμα και το γινόμενο όλων των ακεραίων στη λίστα.\nΤο άθροισμα της κενής λίστας πρέπει να είναι ίσο με 0 και το γινόμενο της κενής λίστας πρέπει να είναι ίσο με 1.", "entry_point": "sum_product", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/2", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Τα εισαγόμενα είναι δύο συμβολοσειρές a και b που αποτελούνται μόνο από 1s και 0s.\n//     Εκτελέστε δυαδικό XOR σε αυτές τις εισόδους και επιστρέψτε το αποτέλεσμα επίσης ως συμβολοσειρά.\n// >>> string_xor('010', '110')\n// '100'\n// \nfunc string_xor (a string, b string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := string_xor(\"111000\",\"101010\")\n\texpected_1 := \"010010\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := string_xor(\"1\",\"1\")\n\texpected_2 := \"0\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := string_xor(\"0101\",\"0000\")\n\texpected_3 := \"0101\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n}", "language": "go", "description": "Τα εισαγόμενα είναι δύο συμβολοσειρές a και b που αποτελούνται μόνο από 1s και 0s.\n    Εκτελέστε δυαδικό XOR σε αυτές τις εισόδους και επιστρέψτε το αποτέλεσμα επίσης ως συμβολοσειρά.", "entry_point": "string_xor", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/3", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Από μια λίστα από αλφαριθμητικά, επιστρέψτε το μακρύτερο. Επιστρέψτε το πρώτο στην περίπτωση πολλαπλών αλφαριθμητικών με το ίδιο μήκος. Επιστρέψτε null στην περίπτωση που η εισαγωγική λίστα είναι άδεια.\n// >>> longest([])\n// \n// >>> longest(['a', 'b', 'c'])\n// 'a'\n// >>> longest(['a', 'bb', 'ccc'])\n// 'ccc'\n// \nfunc longest (strings []string) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := longest([]string{})\n\texpected_1 := nil\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := longest([]string{\"x\", \"y\", \"z\"})\n\texpected_2 := \"x\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := longest([]string{\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"})\n\texpected_3 := \"zzzz\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n}", "language": "go", "description": "Από μια λίστα από αλφαριθμητικά, επιστρέψτε το μακρύτερο. Επιστρέψτε το πρώτο στην περίπτωση πολλαπλών αλφαριθμητικών με το ίδιο μήκος. Επιστρέψτε null στην περίπτωση που η εισαγωγική λίστα είναι άδεια.", "entry_point": "longest", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/4", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Επιστροφή του μεγαλύτερου κοινού διαιρέτη δύο ακεραίων αριθμών a και b.\n// >>> greatest_common_divisor(3, 5)\n// 1\n// >>> greatest_common_divisor(25, 15)\n// 5\n// \nfunc greatest_common_divisor (a int, b int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := greatest_common_divisor(3,7)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := greatest_common_divisor(10,15)\n\texpected_2 := 5\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := greatest_common_divisor(49,14)\n\texpected_3 := 7\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := greatest_common_divisor(144,60)\n\texpected_4 := 12\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "Επιστροφή του μεγαλύτερου κοινού διαιρέτη δύο ακεραίων αριθμών a και b.", "entry_point": "greatest_common_divisor", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/5", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Η είσοδος είναι μια συμβολοσειρά διαχωρισμένη με κενό από αριθμητικά χαρακτήρες από το 'μηδέν' έως το 'εννέα'.\n//     Οι έγκυρες επιλογές είναι 'μηδέν', 'ένα', 'δύο', 'τρία', 'τέσσερα', 'πέντε', 'έξι', 'επτά', 'οκτώ' και 'εννέα'.\n//     Επιστρέψτε τη συμβολοσειρά με τους αριθμούς ταξινομημένους από τον μικρότερο στον μεγαλύτερο.\n// >>> sort_numbers('three one five')\n// 'one three five'\n// \nfunc sort_numbers (numbers string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := sort_numbers(\"\")\n\texpected_1 := \"\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := sort_numbers(\"three\")\n\texpected_2 := \"three\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := sort_numbers(\"three five nine\")\n\texpected_3 := \"three five nine\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := sort_numbers(\"five zero four seven nine eight\")\n\texpected_4 := \"zero four five seven eight nine\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := sort_numbers(\"six five four three two one zero\")\n\texpected_5 := \"zero one two three four five six\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Η είσοδος είναι μια συμβολοσειρά διαχωρισμένη με κενό από αριθμητικά χαρακτήρες από το 'μηδέν' έως το 'εννέα'.\n    Οι έγκυρες επιλογές είναι 'μηδέν', 'ένα', 'δύο', 'τρία', 'τέσσερα', 'πέντε', 'έξι', 'επτά', 'οκτώ' και 'εννέα'.\n    Επιστρέψτε τη συμβολοσειρά με τους αριθμούς ταξινομημένους από τον μικρότερο στον μεγαλύτερο.", "entry_point": "sort_numbers", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/6", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Δεδομένης μιας λίστας αριθμών (τουλάχιστον δύο στοιχείων), εφαρμόστε μια γραμμική μετασχηματιστική λειτουργία σε αυτήν τη λίστα, έτσι ώστε ο μικρότερος αριθμός να γίνει 0 και ο μεγαλύτερος να γίνει 1.\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// \nfunc rescale_to_unit (numbers []float64) []float64 {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := rescale_to_unit([]float64{2.0, 49.9})\n\texpected_1 := []float64{0.0, 1.0}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := rescale_to_unit([]float64{100.0, 49.9})\n\texpected_2 := []float64{1.0, 0.0}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n\texpected_3 := []float64{0.0, 0.25, 0.5, 0.75, 1.0}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := rescale_to_unit([]float64{2.0, 1.0, 5.0, 3.0, 4.0})\n\texpected_4 := []float64{0.25, 0.0, 1.0, 0.5, 0.75}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := rescale_to_unit([]float64{12.0, 11.0, 15.0, 13.0, 14.0})\n\texpected_5 := []float64{0.25, 0.0, 1.0, 0.5, 0.75}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένης μιας λίστας αριθμών (τουλάχιστον δύο στοιχείων), εφαρμόστε μια γραμμική μετασχηματιστική λειτουργία σε αυτήν τη λίστα, έτσι ώστε ο μικρότερος αριθμός να γίνει 0 και ο μεγαλύτερος να γίνει 1.", "entry_point": "rescale_to_unit", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/7", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Για μια δεδομένη συμβολοσειρά, αντιστρέψτε τους πεζούς χαρακτήρες σε κεφαλαίους και τους κεφαλαίους σε πεζούς.\n// >>> flip_case('Hello')\n// 'hELLO'\n// \nfunc flip_case (string0 string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := flip_case(\"\")\n\texpected_1 := \"\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := flip_case(\"Hello!\")\n\texpected_2 := \"hELLO!\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := flip_case(\"These violent delights have violent ends\")\n\texpected_3 := \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n}", "language": "go", "description": "Για μια δεδομένη συμβολοσειρά, αντιστρέψτε τους πεζούς χαρακτήρες σε κεφαλαίους και τους κεφαλαίους σε πεζούς.", "entry_point": "flip_case", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/8", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Επιστρέψτε μόνο θετικούς αριθμούς στη λίστα.\n// >>> get_positive([-1, 2, -4, 5, 6])\n// [2, 5, 6]\n// >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// [5, 3, 2, 3, 9, 123, 1]\n// \nfunc get_positive (l []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := get_positive([]int{-1, -2, 4, 5, 6})\n\texpected_1 := []int{4, 5, 6}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := get_positive([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10})\n\texpected_2 := []int{5, 3, 2, 3, 3, 9, 123, 1}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := get_positive([]int{-1, -2})\n\texpected_3 := []int{}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := get_positive([]int{})\n\texpected_4 := []int{}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "Επιστρέψτε μόνο θετικούς αριθμούς στη λίστα.", "entry_point": "get_positive", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/9", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Επιστρέφει αληθές αν ένας δεδομένος αριθμός είναι πρώτος και ψευδές σε διαφορετική περίπτωση.\n// >>> is_prime(6)\n// False\n// >>> is_prime(101)\n// True\n// >>> is_prime(11)\n// True\n// >>> is_prime(13441)\n// True\n// >>> is_prime(61)\n// True\n// >>> is_prime(4)\n// False\n// >>> is_prime(1)\n// False\n// \nfunc is_prime (n int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_prime(6)\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_prime(101)\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_prime(11)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_prime(13441)\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_prime(61)\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_prime(4)\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_prime(1)\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := is_prime(5)\n\texpected_8 := true\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := is_prime(11)\n\texpected_9 := true\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := is_prime(17)\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := is_prime(85)\n\texpected_11 := false\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := is_prime(77)\n\texpected_12 := false\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := is_prime(255379)\n\texpected_13 := false\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n}", "language": "go", "description": "Επιστρέφει αληθές αν ένας δεδομένος αριθμός είναι πρώτος και ψευδές σε διαφορετική περίπτωση.", "entry_point": "is_prime", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/10", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Επιστροφή ταξινομημένων μοναδικών στοιχείων σε μια λίστα.\n// >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [0, 2, 3, 5, 9, 123]\n// \nfunc unique (l []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\texpected_1 := []int{0, 2, 3, 5, 9, 123}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n}", "language": "go", "description": "Επιστροφή ταξινομημένων μοναδικών στοιχείων σε μια λίστα.", "entry_point": "unique", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/11", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Η prime_fib επιστρέφει τον n-οστό αριθμό που είναι Fibonacci και είναι επίσης πρώτος.\n// >>> prime_fib(1)\n// 2\n// >>> prime_fib(2)\n// 3\n// >>> prime_fib(3)\n// 5\n// >>> prime_fib(4)\n// 13\n// >>> prime_fib(5)\n// 89\n// \nfunc prime_fib (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := prime_fib(1)\n\texpected_1 := 2\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := prime_fib(2)\n\texpected_2 := 3\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := prime_fib(3)\n\texpected_3 := 5\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := prime_fib(4)\n\texpected_4 := 13\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := prime_fib(5)\n\texpected_5 := 89\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := prime_fib(6)\n\texpected_6 := 233\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := prime_fib(7)\n\texpected_7 := 1597\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := prime_fib(8)\n\texpected_8 := 28657\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := prime_fib(9)\n\texpected_9 := 514229\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := prime_fib(10)\n\texpected_10 := 433494437\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "Η prime_fib επιστρέφει τον n-οστό αριθμό που είναι Fibonacci και είναι επίσης πρώτος.", "entry_point": "prime_fib", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/12", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Η triples_sum_to_zero λαμβάνει μια λίστα ακεραίων ως είσοδο.\n//     επιστρέφει True αν υπάρχουν τρία διακριτά στοιχεία στη λίστα που\n//     άθροισμα τους είναι μηδέν, και False διαφορετικά.\n// >>> triples_sum_to_zero([1, 3, 5, 0])\n// False\n// >>> triples_sum_to_zero([1, 3, -2, 1])\n// True\n// >>> triples_sum_to_zero([1, 2, 3, 7])\n// False\n// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n// True\n// >>> triples_sum_to_zero([1])\n// False\n// \nfunc triples_sum_to_zero (l []int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := triples_sum_to_zero([]int{1, 3, 5, 0})\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := triples_sum_to_zero([]int{1, 3, 5, -1})\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := triples_sum_to_zero([]int{1, 3, -2, 1})\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := triples_sum_to_zero([]int{1, 2, 3, 7})\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := triples_sum_to_zero([]int{1, 2, 5, 7})\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := triples_sum_to_zero([]int{1})\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := triples_sum_to_zero([]int{1, 3, 5, -100})\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := triples_sum_to_zero([]int{100, 3, 5, -100})\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "Η triples_sum_to_zero λαμβάνει μια λίστα ακεραίων ως είσοδο.\n    επιστρέφει True αν υπάρχουν τρία διακριτά στοιχεία στη λίστα που\n    άθροισμα τους είναι μηδέν, και False διαφορετικά.", "entry_point": "triples_sum_to_zero", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/13", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Η συνάρτηση pairs_sum_to_zero παίρνει μια λίστα ακεραίων ως είσοδο.\n//     Επιστρέφει True αν υπάρχουν δύο διακριτά στοιχεία στη λίστα που\n//     έχουν άθροισμα μηδέν, και False αλλιώς.\n// >>> pairs_sum_to_zero([1, 3, 5, 0])\n// False\n// >>> pairs_sum_to_zero([1, 3, -2, 1])\n// False\n// >>> pairs_sum_to_zero([1, 2, 3, 7])\n// False\n// >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n// True\n// >>> pairs_sum_to_zero([1])\n// False\n// \nfunc pairs_sum_to_zero (l []int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := pairs_sum_to_zero([]int{1, 3, 5, 0})\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := pairs_sum_to_zero([]int{1, 3, -2, 1})\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := pairs_sum_to_zero([]int{1, 2, 3, 7})\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := pairs_sum_to_zero([]int{1})\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := pairs_sum_to_zero([]int{-3, 9, -1, 3, 2, 30})\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := pairs_sum_to_zero([]int{-3, 9, -1, 3, 2, 31})\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := pairs_sum_to_zero([]int{-3, 9, -1, 4, 2, 30})\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := pairs_sum_to_zero([]int{-3, 9, -1, 4, 2, 31})\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "Η συνάρτηση pairs_sum_to_zero παίρνει μια λίστα ακεραίων ως είσοδο.\n    Επιστρέφει True αν υπάρχουν δύο διακριτά στοιχεία στη λίστα που\n    έχουν άθροισμα μηδέν, και False αλλιώς.", "entry_point": "pairs_sum_to_zero", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/14", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Η ακολουθία αριθμών Fib4 είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n//     fib4(0) -> 0\n//     fib4(1) -> 0\n//     fib4(2) -> 2\n//     fib4(3) -> 0\n//     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n//     Παρακαλούμε γράψτε μια συνάρτηση για τον αποτελεσματικό υπολογισμό του n-οστού στοιχείου της ακολουθίας Fib4. Μην χρησιμοποιήσετε αναδρομή.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n// >>> fib4(7)\n// 14\n// \nfunc fib4 (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := fib4(5)\n\texpected_1 := 4\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := fib4(8)\n\texpected_2 := 28\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := fib4(10)\n\texpected_3 := 104\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := fib4(12)\n\texpected_4 := 386\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "Η ακολουθία αριθμών Fib4 είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Παρακαλούμε γράψτε μια συνάρτηση για τον αποτελεσματικό υπολογισμό του n-οστού στοιχείου της ακολουθίας Fib4. Μην χρησιμοποιήσετε αναδρομή.", "entry_point": "fib4", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/15", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Επιστροφή της μεσαίας τιμής των στοιχείων στη λίστα l.\n// >>> median([3, 1, 2, 4, 5])\n// 3\n// >>> median([-10, 4, 6, 1000, 10, 20])\n// 15.0\n// \nfunc median (l []int) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := median([]int{3, 1, 2, 4, 5})\n\texpected_1 := 3\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := median([]int{-10, 4, 6, 1000, 10, 20})\n\texpected_2 := 8.0\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := median([]int{5})\n\texpected_3 := 5\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := median([]int{6, 5})\n\texpected_4 := 5.5\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := median([]int{8, 1, 3, 9, 9, 2, 7})\n\texpected_5 := 7\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Επιστροφή της μεσαίας τιμής των στοιχείων στη λίστα l.", "entry_point": "median", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/16", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Ελέγχει αν η δοθείσα συμβολοσειρά είναι παλίνδρομη.\n// >>> is_palindrome('')\n// True\n// >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n// >>> is_palindrome('zbcd')\n// False\n// \nfunc is_palindrome (text string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_palindrome(\"\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_palindrome(\"aba\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_palindrome(\"aaaaa\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_palindrome(\"zbcd\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_palindrome(\"xywyx\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_palindrome(\"xywyz\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_palindrome(\"xywzx\")\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Ελέγχει αν η δοθείσα συμβολοσειρά είναι παλίνδρομη.", "entry_point": "is_palindrome", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/17", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Η remove_vowels είναι μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει το αλφαριθμητικό χωρίς φωνήεντα.\n// >>> remove_vowels('')\n// ''\n// >>> remove_vowels(\"abcdef\\nghijklm\")\n// 'bcdf\\nghjklm'\n// >>> remove_vowels('abcdef')\n// 'bcdf'\n// >>> remove_vowels('aaaaa')\n// ''\n// >>> remove_vowels('aaBAA')\n// 'B'\n// >>> remove_vowels('zbcd')\n// 'zbcd'\n// \nfunc remove_vowels (text string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := remove_vowels(\"\")\n\texpected_1 := \"\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := remove_vowels(\"abcdef\\nghijklm\")\n\texpected_2 := \"bcdf\\nghjklm\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := remove_vowels(\"fedcba\")\n\texpected_3 := \"fdcb\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := remove_vowels(\"eeeee\")\n\texpected_4 := \"\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := remove_vowels(\"acBAA\")\n\texpected_5 := \"cB\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := remove_vowels(\"EcBOO\")\n\texpected_6 := \"cB\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := remove_vowels(\"ybcd\")\n\texpected_7 := \"ybcd\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Η remove_vowels είναι μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει το αλφαριθμητικό χωρίς φωνήεντα.", "entry_point": "remove_vowels", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/18", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Επιστρέφει True αν όλοι οι αριθμοί στη λίστα l είναι κάτω από το κατώφλι t.\n// >>> below_threshold([1, 2, 4, 10], 100)\n// True\n// >>> below_threshold([1, 20, 4, 10], 5)\n// False\n// \nfunc below_threshold (l []int, t int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := below_threshold([]int{1, 2, 4, 10},100)\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := below_threshold([]int{1, 20, 4, 10},5)\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := below_threshold([]int{1, 20, 4, 10},21)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := below_threshold([]int{1, 20, 4, 10},22)\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := below_threshold([]int{1, 8, 4, 10},11)\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := below_threshold([]int{1, 8, 4, 10},10)\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "Επιστρέφει True αν όλοι οι αριθμοί στη λίστα l είναι κάτω από το κατώφλι t.", "entry_point": "below_threshold", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/19", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Προσθέστε δύο αριθμούς x και y.\n// >>> add(2, 3)\n// 5\n// >>> add(5, 7)\n// 12\n// \nfunc add (x int, y int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := add(0,1)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := add(1,0)\n\texpected_2 := 1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := add(2,3)\n\texpected_3 := 5\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := add(5,7)\n\texpected_4 := 12\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := add(7,5)\n\texpected_5 := 12\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := add(572,725)\n\texpected_6 := 1297\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := add(51,804)\n\texpected_7 := 855\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := add(645,96)\n\texpected_8 := 741\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := add(712,853)\n\texpected_9 := 1565\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := add(223,101)\n\texpected_10 := 324\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := add(76,29)\n\texpected_11 := 105\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := add(416,149)\n\texpected_12 := 565\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := add(145,409)\n\texpected_13 := 554\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := add(535,430)\n\texpected_14 := 965\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n\tactual_15 := add(118,303)\n\texpected_15 := 421\n\tdeepCompare(actual_15, expected_15, \"Exception --- test case 14 failed to pass\")\n\n\tactual_16 := add(287,94)\n\texpected_16 := 381\n\tdeepCompare(actual_16, expected_16, \"Exception --- test case 15 failed to pass\")\n\n\tactual_17 := add(768,257)\n\texpected_17 := 1025\n\tdeepCompare(actual_17, expected_17, \"Exception --- test case 16 failed to pass\")\n\n\tactual_18 := add(421,677)\n\texpected_18 := 1098\n\tdeepCompare(actual_18, expected_18, \"Exception --- test case 17 failed to pass\")\n\n\tactual_19 := add(802,814)\n\texpected_19 := 1616\n\tdeepCompare(actual_19, expected_19, \"Exception --- test case 18 failed to pass\")\n\n\tactual_20 := add(510,922)\n\texpected_20 := 1432\n\tdeepCompare(actual_20, expected_20, \"Exception --- test case 19 failed to pass\")\n\n\tactual_21 := add(345,819)\n\texpected_21 := 1164\n\tdeepCompare(actual_21, expected_21, \"Exception --- test case 20 failed to pass\")\n\n\tactual_22 := add(895,436)\n\texpected_22 := 1331\n\tdeepCompare(actual_22, expected_22, \"Exception --- test case 21 failed to pass\")\n\n\tactual_23 := add(123,424)\n\texpected_23 := 547\n\tdeepCompare(actual_23, expected_23, \"Exception --- test case 22 failed to pass\")\n\n\tactual_24 := add(923,245)\n\texpected_24 := 1168\n\tdeepCompare(actual_24, expected_24, \"Exception --- test case 23 failed to pass\")\n\n\tactual_25 := add(23,438)\n\texpected_25 := 461\n\tdeepCompare(actual_25, expected_25, \"Exception --- test case 24 failed to pass\")\n\n\tactual_26 := add(565,133)\n\texpected_26 := 698\n\tdeepCompare(actual_26, expected_26, \"Exception --- test case 25 failed to pass\")\n\n\tactual_27 := add(945,925)\n\texpected_27 := 1870\n\tdeepCompare(actual_27, expected_27, \"Exception --- test case 26 failed to pass\")\n\n\tactual_28 := add(261,983)\n\texpected_28 := 1244\n\tdeepCompare(actual_28, expected_28, \"Exception --- test case 27 failed to pass\")\n\n\tactual_29 := add(139,577)\n\texpected_29 := 716\n\tdeepCompare(actual_29, expected_29, \"Exception --- test case 28 failed to pass\")\n\n\tactual_30 := add(763,178)\n\texpected_30 := 941\n\tdeepCompare(actual_30, expected_30, \"Exception --- test case 29 failed to pass\")\n\n\tactual_31 := add(147,892)\n\texpected_31 := 1039\n\tdeepCompare(actual_31, expected_31, \"Exception --- test case 30 failed to pass\")\n\n\tactual_32 := add(436,402)\n\texpected_32 := 838\n\tdeepCompare(actual_32, expected_32, \"Exception --- test case 31 failed to pass\")\n\n\tactual_33 := add(610,581)\n\texpected_33 := 1191\n\tdeepCompare(actual_33, expected_33, \"Exception --- test case 32 failed to pass\")\n\n\tactual_34 := add(103,416)\n\texpected_34 := 519\n\tdeepCompare(actual_34, expected_34, \"Exception --- test case 33 failed to pass\")\n\n\tactual_35 := add(339,990)\n\texpected_35 := 1329\n\tdeepCompare(actual_35, expected_35, \"Exception --- test case 34 failed to pass\")\n\n\tactual_36 := add(130,504)\n\texpected_36 := 634\n\tdeepCompare(actual_36, expected_36, \"Exception --- test case 35 failed to pass\")\n\n\tactual_37 := add(242,717)\n\texpected_37 := 959\n\tdeepCompare(actual_37, expected_37, \"Exception --- test case 36 failed to pass\")\n\n\tactual_38 := add(562,110)\n\texpected_38 := 672\n\tdeepCompare(actual_38, expected_38, \"Exception --- test case 37 failed to pass\")\n\n\tactual_39 := add(396,909)\n\texpected_39 := 1305\n\tdeepCompare(actual_39, expected_39, \"Exception --- test case 38 failed to pass\")\n\n\tactual_40 := add(887,703)\n\texpected_40 := 1590\n\tdeepCompare(actual_40, expected_40, \"Exception --- test case 39 failed to pass\")\n\n\tactual_41 := add(870,551)\n\texpected_41 := 1421\n\tdeepCompare(actual_41, expected_41, \"Exception --- test case 40 failed to pass\")\n\n\tactual_42 := add(422,391)\n\texpected_42 := 813\n\tdeepCompare(actual_42, expected_42, \"Exception --- test case 41 failed to pass\")\n\n\tactual_43 := add(299,505)\n\texpected_43 := 804\n\tdeepCompare(actual_43, expected_43, \"Exception --- test case 42 failed to pass\")\n\n\tactual_44 := add(346,56)\n\texpected_44 := 402\n\tdeepCompare(actual_44, expected_44, \"Exception --- test case 43 failed to pass\")\n\n\tactual_45 := add(36,706)\n\texpected_45 := 742\n\tdeepCompare(actual_45, expected_45, \"Exception --- test case 44 failed to pass\")\n\n\tactual_46 := add(738,411)\n\texpected_46 := 1149\n\tdeepCompare(actual_46, expected_46, \"Exception --- test case 45 failed to pass\")\n\n\tactual_47 := add(679,87)\n\texpected_47 := 766\n\tdeepCompare(actual_47, expected_47, \"Exception --- test case 46 failed to pass\")\n\n\tactual_48 := add(25,303)\n\texpected_48 := 328\n\tdeepCompare(actual_48, expected_48, \"Exception --- test case 47 failed to pass\")\n\n\tactual_49 := add(161,612)\n\texpected_49 := 773\n\tdeepCompare(actual_49, expected_49, \"Exception --- test case 48 failed to pass\")\n\n\tactual_50 := add(306,841)\n\texpected_50 := 1147\n\tdeepCompare(actual_50, expected_50, \"Exception --- test case 49 failed to pass\")\n\n\tactual_51 := add(973,411)\n\texpected_51 := 1384\n\tdeepCompare(actual_51, expected_51, \"Exception --- test case 50 failed to pass\")\n\n\tactual_52 := add(711,157)\n\texpected_52 := 868\n\tdeepCompare(actual_52, expected_52, \"Exception --- test case 51 failed to pass\")\n\n\tactual_53 := add(471,27)\n\texpected_53 := 498\n\tdeepCompare(actual_53, expected_53, \"Exception --- test case 52 failed to pass\")\n\n\tactual_54 := add(714,792)\n\texpected_54 := 1506\n\tdeepCompare(actual_54, expected_54, \"Exception --- test case 53 failed to pass\")\n\n\tactual_55 := add(38,206)\n\texpected_55 := 244\n\tdeepCompare(actual_55, expected_55, \"Exception --- test case 54 failed to pass\")\n\n\tactual_56 := add(907,343)\n\texpected_56 := 1250\n\tdeepCompare(actual_56, expected_56, \"Exception --- test case 55 failed to pass\")\n\n\tactual_57 := add(23,760)\n\texpected_57 := 783\n\tdeepCompare(actual_57, expected_57, \"Exception --- test case 56 failed to pass\")\n\n\tactual_58 := add(524,859)\n\texpected_58 := 1383\n\tdeepCompare(actual_58, expected_58, \"Exception --- test case 57 failed to pass\")\n\n\tactual_59 := add(30,529)\n\texpected_59 := 559\n\tdeepCompare(actual_59, expected_59, \"Exception --- test case 58 failed to pass\")\n\n\tactual_60 := add(341,691)\n\texpected_60 := 1032\n\tdeepCompare(actual_60, expected_60, \"Exception --- test case 59 failed to pass\")\n\n\tactual_61 := add(167,729)\n\texpected_61 := 896\n\tdeepCompare(actual_61, expected_61, \"Exception --- test case 60 failed to pass\")\n\n\tactual_62 := add(636,289)\n\texpected_62 := 925\n\tdeepCompare(actual_62, expected_62, \"Exception --- test case 61 failed to pass\")\n\n\tactual_63 := add(503,144)\n\texpected_63 := 647\n\tdeepCompare(actual_63, expected_63, \"Exception --- test case 62 failed to pass\")\n\n\tactual_64 := add(51,985)\n\texpected_64 := 1036\n\tdeepCompare(actual_64, expected_64, \"Exception --- test case 63 failed to pass\")\n\n\tactual_65 := add(287,149)\n\texpected_65 := 436\n\tdeepCompare(actual_65, expected_65, \"Exception --- test case 64 failed to pass\")\n\n\tactual_66 := add(659,75)\n\texpected_66 := 734\n\tdeepCompare(actual_66, expected_66, \"Exception --- test case 65 failed to pass\")\n\n\tactual_67 := add(462,797)\n\texpected_67 := 1259\n\tdeepCompare(actual_67, expected_67, \"Exception --- test case 66 failed to pass\")\n\n\tactual_68 := add(406,141)\n\texpected_68 := 547\n\tdeepCompare(actual_68, expected_68, \"Exception --- test case 67 failed to pass\")\n\n\tactual_69 := add(106,44)\n\texpected_69 := 150\n\tdeepCompare(actual_69, expected_69, \"Exception --- test case 68 failed to pass\")\n\n\tactual_70 := add(300,934)\n\texpected_70 := 1234\n\tdeepCompare(actual_70, expected_70, \"Exception --- test case 69 failed to pass\")\n\n\tactual_71 := add(471,524)\n\texpected_71 := 995\n\tdeepCompare(actual_71, expected_71, \"Exception --- test case 70 failed to pass\")\n\n\tactual_72 := add(122,429)\n\texpected_72 := 551\n\tdeepCompare(actual_72, expected_72, \"Exception --- test case 71 failed to pass\")\n\n\tactual_73 := add(735,195)\n\texpected_73 := 930\n\tdeepCompare(actual_73, expected_73, \"Exception --- test case 72 failed to pass\")\n\n\tactual_74 := add(335,484)\n\texpected_74 := 819\n\tdeepCompare(actual_74, expected_74, \"Exception --- test case 73 failed to pass\")\n\n\tactual_75 := add(28,809)\n\texpected_75 := 837\n\tdeepCompare(actual_75, expected_75, \"Exception --- test case 74 failed to pass\")\n\n\tactual_76 := add(430,20)\n\texpected_76 := 450\n\tdeepCompare(actual_76, expected_76, \"Exception --- test case 75 failed to pass\")\n\n\tactual_77 := add(916,635)\n\texpected_77 := 1551\n\tdeepCompare(actual_77, expected_77, \"Exception --- test case 76 failed to pass\")\n\n\tactual_78 := add(301,999)\n\texpected_78 := 1300\n\tdeepCompare(actual_78, expected_78, \"Exception --- test case 77 failed to pass\")\n\n\tactual_79 := add(454,466)\n\texpected_79 := 920\n\tdeepCompare(actual_79, expected_79, \"Exception --- test case 78 failed to pass\")\n\n\tactual_80 := add(905,259)\n\texpected_80 := 1164\n\tdeepCompare(actual_80, expected_80, \"Exception --- test case 79 failed to pass\")\n\n\tactual_81 := add(168,205)\n\texpected_81 := 373\n\tdeepCompare(actual_81, expected_81, \"Exception --- test case 80 failed to pass\")\n\n\tactual_82 := add(570,434)\n\texpected_82 := 1004\n\tdeepCompare(actual_82, expected_82, \"Exception --- test case 81 failed to pass\")\n\n\tactual_83 := add(64,959)\n\texpected_83 := 1023\n\tdeepCompare(actual_83, expected_83, \"Exception --- test case 82 failed to pass\")\n\n\tactual_84 := add(957,510)\n\texpected_84 := 1467\n\tdeepCompare(actual_84, expected_84, \"Exception --- test case 83 failed to pass\")\n\n\tactual_85 := add(722,598)\n\texpected_85 := 1320\n\tdeepCompare(actual_85, expected_85, \"Exception --- test case 84 failed to pass\")\n\n\tactual_86 := add(770,226)\n\texpected_86 := 996\n\tdeepCompare(actual_86, expected_86, \"Exception --- test case 85 failed to pass\")\n\n\tactual_87 := add(579,66)\n\texpected_87 := 645\n\tdeepCompare(actual_87, expected_87, \"Exception --- test case 86 failed to pass\")\n\n\tactual_88 := add(117,674)\n\texpected_88 := 791\n\tdeepCompare(actual_88, expected_88, \"Exception --- test case 87 failed to pass\")\n\n\tactual_89 := add(530,30)\n\texpected_89 := 560\n\tdeepCompare(actual_89, expected_89, \"Exception --- test case 88 failed to pass\")\n\n\tactual_90 := add(776,345)\n\texpected_90 := 1121\n\tdeepCompare(actual_90, expected_90, \"Exception --- test case 89 failed to pass\")\n\n\tactual_91 := add(327,389)\n\texpected_91 := 716\n\tdeepCompare(actual_91, expected_91, \"Exception --- test case 90 failed to pass\")\n\n\tactual_92 := add(596,12)\n\texpected_92 := 608\n\tdeepCompare(actual_92, expected_92, \"Exception --- test case 91 failed to pass\")\n\n\tactual_93 := add(599,511)\n\texpected_93 := 1110\n\tdeepCompare(actual_93, expected_93, \"Exception --- test case 92 failed to pass\")\n\n\tactual_94 := add(936,476)\n\texpected_94 := 1412\n\tdeepCompare(actual_94, expected_94, \"Exception --- test case 93 failed to pass\")\n\n\tactual_95 := add(461,14)\n\texpected_95 := 475\n\tdeepCompare(actual_95, expected_95, \"Exception --- test case 94 failed to pass\")\n\n\tactual_96 := add(966,157)\n\texpected_96 := 1123\n\tdeepCompare(actual_96, expected_96, \"Exception --- test case 95 failed to pass\")\n\n\tactual_97 := add(326,91)\n\texpected_97 := 417\n\tdeepCompare(actual_97, expected_97, \"Exception --- test case 96 failed to pass\")\n\n\tactual_98 := add(392,455)\n\texpected_98 := 847\n\tdeepCompare(actual_98, expected_98, \"Exception --- test case 97 failed to pass\")\n\n\tactual_99 := add(446,477)\n\texpected_99 := 923\n\tdeepCompare(actual_99, expected_99, \"Exception --- test case 98 failed to pass\")\n\n\tactual_100 := add(324,860)\n\texpected_100 := 1184\n\tdeepCompare(actual_100, expected_100, \"Exception --- test case 99 failed to pass\")\n\n\tactual_101 := add(945,85)\n\texpected_101 := 1030\n\tdeepCompare(actual_101, expected_101, \"Exception --- test case 100 failed to pass\")\n\n\tactual_102 := add(886,582)\n\texpected_102 := 1468\n\tdeepCompare(actual_102, expected_102, \"Exception --- test case 101 failed to pass\")\n\n\tactual_103 := add(886,712)\n\texpected_103 := 1598\n\tdeepCompare(actual_103, expected_103, \"Exception --- test case 102 failed to pass\")\n\n\tactual_104 := add(842,953)\n\texpected_104 := 1795\n\tdeepCompare(actual_104, expected_104, \"Exception --- test case 103 failed to pass\")\n\n}", "language": "go", "description": "Προσθέστε δύο αριθμούς x και y.", "entry_point": "add", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/20", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Ελέγξτε αν δύο λέξεις έχουν τους ίδιους χαρακτήρες.\n// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n// True\n// >>> same_chars('abcd', 'dddddddabc')\n// True\n// >>> same_chars('dddddddabc', 'abcd')\n// True\n// >>> same_chars('eabcd', 'dddddddabc')\n// False\n// >>> same_chars('abcd', 'dddddddabce')\n// False\n// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n// False\n// \nfunc same_chars (s0 string, s1 string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := same_chars(\"eabcdzzzz\",\"dddzzzzzzzddeddabc\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := same_chars(\"abcd\",\"dddddddabc\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := same_chars(\"dddddddabc\",\"abcd\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := same_chars(\"eabcd\",\"dddddddabc\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := same_chars(\"abcd\",\"dddddddabcf\")\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := same_chars(\"eabcdzzzz\",\"dddzzzzzzzddddabc\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := same_chars(\"aabb\",\"aaccc\")\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Ελέγξτε αν δύο λέξεις έχουν τους ίδιους χαρακτήρες.", "entry_point": "same_chars", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/21", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Επιστροφή του n-οστού αριθμού Fibonacci.\n// >>> fib(10)\n// 55\n// >>> fib(1)\n// 1\n// >>> fib(8)\n// 21\n// \nfunc fib (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := fib(10)\n\texpected_1 := 55\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := fib(1)\n\texpected_2 := 1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := fib(8)\n\texpected_3 := 21\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := fib(11)\n\texpected_4 := 89\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := fib(12)\n\texpected_5 := 144\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Επιστροφή του n-οστού αριθμού Fibonacci.", "entry_point": "fib", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/22", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Επιστροφή ταξινομημένων μοναδικών κοινών στοιχείων για δύο λίστες.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\n// \n// \nfunc common (l1 []int, l2 []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := common([]int{1, 4, 3, 34, 653, 2, 5},[]int{5, 7, 1, 5, 9, 653, 121})\n\texpected_1 := []int{1, 5, 653}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := common([]int{5, 3, 2, 8},[]int{3, 2})\n\texpected_2 := []int{2, 3}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := common([]int{4, 3, 2, 8},[]int{3, 2, 4})\n\texpected_3 := []int{2, 3, 4}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := common([]int{4, 3, 2, 8},[]int{})\n\texpected_4 := []int{}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "Επιστροφή ταξινομημένων μοναδικών κοινών στοιχείων για δύο λίστες.", "entry_point": "common", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/23", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Επιστρέφει το μεγαλύτερο πρώτο παράγοντα του n. Υποθέτουμε ότι το n > 1 και δεν είναι πρώτος.\n// >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n// 2\n// \nfunc largest_prime_factor (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := largest_prime_factor(15)\n\texpected_1 := 5\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := largest_prime_factor(27)\n\texpected_2 := 3\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := largest_prime_factor(63)\n\texpected_3 := 7\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := largest_prime_factor(330)\n\texpected_4 := 11\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := largest_prime_factor(13195)\n\texpected_5 := 29\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Επιστρέφει το μεγαλύτερο πρώτο παράγοντα του n. Υποθέτουμε ότι το n > 1 και δεν είναι πρώτος.", "entry_point": "largest_prime_factor", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/24", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Η sum_to_n είναι μια συνάρτηση που αθροίζει αριθμούς από το 1 έως το n.\n// >>> sum_to_n(30)\n// 465\n// >>> sum_to_n(100)\n// 5050\n// >>> sum_to_n(5)\n// 15\n// >>> sum_to_n(10)\n// 55\n// >>> sum_to_n(1)\n// 1\n// \nfunc sum_to_n (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := sum_to_n(1)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := sum_to_n(6)\n\texpected_2 := 21\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := sum_to_n(11)\n\texpected_3 := 66\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := sum_to_n(30)\n\texpected_4 := 465\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := sum_to_n(100)\n\texpected_5 := 5050\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Η sum_to_n είναι μια συνάρτηση που αθροίζει αριθμούς από το 1 έως το n.", "entry_point": "sum_to_n", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/25", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Οι xs αντιπροσωπεύουν τους συντελεστές ενός πολυωνύμου.\n//     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n//     Επιστρέφει την παράγωγο αυτού του πολυωνύμου στην ίδια μορφή.\n// >>> derivative([3, 1, 2, 4, 5])\n// [1, 4, 12, 20]\n// >>> derivative([1, 2, 3])\n// [2, 6]\n// \nfunc derivative (xs []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := derivative([]int{3, 1, 2, 4, 5})\n\texpected_1 := []int{1, 4, 12, 20}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := derivative([]int{1, 2, 3})\n\texpected_2 := []int{2, 6}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := derivative([]int{3, 2, 1})\n\texpected_3 := []int{2, 2}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := derivative([]int{3, 2, 1, 0, 4})\n\texpected_4 := []int{2, 2, 0, 16}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := derivative([]int{1})\n\texpected_5 := []int{}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Οι xs αντιπροσωπεύουν τους συντελεστές ενός πολυωνύμου.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Επιστρέφει την παράγωγο αυτού του πολυωνύμου στην ίδια μορφή.", "entry_point": "derivative", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/26", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Η ακολουθία αριθμών FibFib είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n//     fibfib(0) == 0\n//     fibfib(1) == 0\n//     fibfib(2) == 1\n//     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n//     Παρακαλούμε γράψτε μια συνάρτηση για τον αποδοτικό υπολογισμό του n-οστού στοιχείου της ακολουθίας αριθμών FibFib.\n// >>> fibfib(1)\n// 0\n// >>> fibfib(5)\n// 4\n// >>> fibfib(8)\n// 24\n// \nfunc fibfib (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := fibfib(2)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := fibfib(1)\n\texpected_2 := 0\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := fibfib(5)\n\texpected_3 := 4\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := fibfib(8)\n\texpected_4 := 24\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := fibfib(10)\n\texpected_5 := 81\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := fibfib(12)\n\texpected_6 := 274\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := fibfib(14)\n\texpected_7 := 927\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Η ακολουθία αριθμών FibFib είναι μια ακολουθία παρόμοια με την ακολουθία Fibonacci που ορίζεται ως εξής:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Παρακαλούμε γράψτε μια συνάρτηση για τον αποδοτικό υπολογισμό του n-οστού στοιχείου της ακολουθίας αριθμών FibFib.", "entry_point": "fibfib", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/27", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Γράψτε μια συνάρτηση vowels_count η οποία παίρνει ως είσοδο μια συμβολοσειρά που αναπαριστά ένα λέξη και επιστρέφει τον αριθμό των φωνηέντων στη συμβολοσειρά. Τα φωνήεντα σε αυτήν την περίπτωση είναι 'a', 'e', 'i', 'o', 'u'. Εδώ, το 'y' είναι επίσης ένα φωνήεν, αλλά μόνο όταν βρίσκεται στο τέλος της δοθείσας λέξης.\n// \n// Παράδειγμα:\n// >>> vowels_count(\"abcde\")\n// 2\n// >>> vowels_count(\"ACEDY\")\n// 3\n// \nfunc vowels_count (s string) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := vowels_count(\"abcde\")\n\texpected_1 := 2\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := vowels_count(\"Alone\")\n\texpected_2 := 3\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := vowels_count(\"key\")\n\texpected_3 := 2\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := vowels_count(\"bye\")\n\texpected_4 := 1\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := vowels_count(\"keY\")\n\texpected_5 := 2\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := vowels_count(\"bYe\")\n\texpected_6 := 1\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := vowels_count(\"ACEDY\")\n\texpected_7 := 3\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Γράψτε μια συνάρτηση vowels_count η οποία παίρνει ως είσοδο μια συμβολοσειρά που αναπαριστά ένα λέξη και επιστρέφει τον αριθμό των φωνηέντων στη συμβολοσειρά. Τα φωνήεντα σε αυτήν την περίπτωση είναι 'a', 'e', 'i', 'o', 'u'. Εδώ, το 'y' είναι επίσης ένα φωνήεν, αλλά μόνο όταν βρίσκεται στο τέλος της δοθείσας λέξης.\n\nΠαράδειγμα:", "entry_point": "vowels_count", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/28", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Σας δίνεται μια μη κενή λίστα θετικών ακεραίων. Επιστρέψτε το μεγαλύτερο ακέραιο που είναι μεγαλύτερο από το μηδέν και έχει συχνότητα μεγαλύτερη ή ίση με την τιμή του ακεραίου. Η συχνότητα ενός ακεραίου είναι ο αριθμός των φορών που εμφανίζεται στη λίστα. Εάν δεν υπάρχει τέτοια τιμή, επιστρέψτε -1. Παραδείγματα:\n// \n// search([4, 1, 2, 2, 3, 1]) == 2\n// search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n// search([5, 5, 4, 4, 4]) == -1\n// \nfunc search (lst []int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := search([]int{5, 5, 5, 5, 1})\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := search([]int{4, 1, 4, 1, 4, 4})\n\texpected_2 := 4\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := search([]int{3, 3})\n\texpected_3 := -1\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := search([]int{8, 8, 8, 8, 8, 8, 8, 8})\n\texpected_4 := 8\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := search([]int{2, 3, 3, 2, 2})\n\texpected_5 := 2\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := search([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1})\n\texpected_6 := 1\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := search([]int{3, 2, 8, 2})\n\texpected_7 := 2\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := search([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10})\n\texpected_8 := 1\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := search([]int{8, 8, 3, 6, 5, 6, 4})\n\texpected_9 := -1\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := search([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9})\n\texpected_10 := 1\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := search([]int{1, 9, 10, 1, 3})\n\texpected_11 := 1\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := search([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10})\n\texpected_12 := 5\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := search([]int{1})\n\texpected_13 := 1\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := search([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5})\n\texpected_14 := 4\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n\tactual_15 := search([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10})\n\texpected_15 := 2\n\tdeepCompare(actual_15, expected_15, \"Exception --- test case 14 failed to pass\")\n\n\tactual_16 := search([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3})\n\texpected_16 := 1\n\tdeepCompare(actual_16, expected_16, \"Exception --- test case 15 failed to pass\")\n\n\tactual_17 := search([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4})\n\texpected_17 := 4\n\tdeepCompare(actual_17, expected_17, \"Exception --- test case 16 failed to pass\")\n\n\tactual_18 := search([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7})\n\texpected_18 := 4\n\tdeepCompare(actual_18, expected_18, \"Exception --- test case 17 failed to pass\")\n\n\tactual_19 := search([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1})\n\texpected_19 := 2\n\tdeepCompare(actual_19, expected_19, \"Exception --- test case 18 failed to pass\")\n\n\tactual_20 := search([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8})\n\texpected_20 := -1\n\tdeepCompare(actual_20, expected_20, \"Exception --- test case 19 failed to pass\")\n\n\tactual_21 := search([]int{10})\n\texpected_21 := -1\n\tdeepCompare(actual_21, expected_21, \"Exception --- test case 20 failed to pass\")\n\n\tactual_22 := search([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2})\n\texpected_22 := 2\n\tdeepCompare(actual_22, expected_22, \"Exception --- test case 21 failed to pass\")\n\n\tactual_23 := search([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8})\n\texpected_23 := 1\n\tdeepCompare(actual_23, expected_23, \"Exception --- test case 22 failed to pass\")\n\n\tactual_24 := search([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6})\n\texpected_24 := 1\n\tdeepCompare(actual_24, expected_24, \"Exception --- test case 23 failed to pass\")\n\n\tactual_25 := search([]int{3, 10, 10, 9, 2})\n\texpected_25 := -1\n\tdeepCompare(actual_25, expected_25, \"Exception --- test case 24 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνεται μια μη κενή λίστα θετικών ακεραίων. Επιστρέψτε το μεγαλύτερο ακέραιο που είναι μεγαλύτερο από το μηδέν και έχει συχνότητα μεγαλύτερη ή ίση με την τιμή του ακεραίου. Η συχνότητα ενός ακεραίου είναι ο αριθμός των φορών που εμφανίζεται στη λίστα. Εάν δεν υπάρχει τέτοια τιμή, επιστρέψτε -1. Παραδείγματα:", "entry_point": "search", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/29", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέψτε την περιοχή του τριγώνου στρογγυλοποιημένη στα 2 δεκαδικά ψηφία αν οι τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο. Διαφορετικά, επιστρέψτε -1. Τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο όταν το άθροισμα οποιωνδήποτε δύο πλευρών είναι μεγαλύτερο από την τρίτη πλευρά. Παράδειγμα:\n// \n// triangle_area(3, 4, 5) == 6.00\n// triangle_area(1, 2, 10) == -1\n// \nfunc triangle_area (a int, b int, c int) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := triangle_area(3,4,5)\n\texpected_1 := 6.0\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := triangle_area(1,2,10)\n\texpected_2 := -1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := triangle_area(4,8,5)\n\texpected_3 := 8.18\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := triangle_area(2,2,2)\n\texpected_4 := 1.73\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := triangle_area(1,2,3)\n\texpected_5 := -1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := triangle_area(10,5,7)\n\texpected_6 := 16.25\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := triangle_area(2,6,3)\n\texpected_7 := -1\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := triangle_area(1,1,1)\n\texpected_8 := 0.43\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := triangle_area(2,2,10)\n\texpected_9 := -1\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέψτε την περιοχή του τριγώνου στρογγυλοποιημένη στα 2 δεκαδικά ψηφία αν οι τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο. Διαφορετικά, επιστρέψτε -1. Τρεις πλευρές αποτελούν ένα έγκυρο τρίγωνο όταν το άθροισμα οποιωνδήποτε δύο πλευρών είναι μεγαλύτερο από την τρίτη πλευρά. Παράδειγμα:", "entry_point": "triangle_area", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/30", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Γράψτε μια συνάρτηση που επιστρέφει True αν το αντικείμενο q θα πετάξει, και False αλλιώς.\n// Το αντικείμενο q θα πετάξει αν είναι ισορροπημένο (είναι παλινδρομική λίστα) και άθροισμα των στοιχείων του είναι μικρότερο ή ίσο του μέγιστου δυνατού βάρους w.\n// \n// Παράδειγμα:\n// will_it_fly([1, 2], 5) ➞ False\n// # 1+2 είναι μικρότερο από το μέγιστο δυνατό βάρος, αλλά δεν είναι ισορροπημένο.\n// \n// will_it_fly([3, 2, 3], 1) ➞ False\n// # είναι ισορροπημένο, αλλά 3+2+3 είναι περισσότερο από το μέγιστο δυνατό βάρος.\n// \n// will_it_fly([3, 2, 3], 9) ➞ True\n// # 3+2+3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n// \n// will_it_fly([3], 5) ➞ True\n// # 3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n// \n// \nfunc will_it_fly (q []int, w int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := will_it_fly([]int{3, 2, 3},9)\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := will_it_fly([]int{1, 2},5)\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := will_it_fly([]int{3},5)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := will_it_fly([]int{3, 2, 3},1)\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := will_it_fly([]int{1, 2, 3},6)\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := will_it_fly([]int{5},5)\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "Γράψτε μια συνάρτηση που επιστρέφει True αν το αντικείμενο q θα πετάξει, και False αλλιώς.\nΤο αντικείμενο q θα πετάξει αν είναι ισορροπημένο (είναι παλινδρομική λίστα) και άθροισμα των στοιχείων του είναι μικρότερο ή ίσο του μέγιστου δυνατού βάρους w.\n\nΠαράδειγμα:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 είναι μικρότερο από το μέγιστο δυνατό βάρος, αλλά δεν είναι ισορροπημένο.\n\nwill_it_fly([3, 2, 3], 1) ➞ False\n# είναι ισορροπημένο, αλλά 3+2+3 είναι περισσότερο από το μέγιστο δυνατό βάρος.\n\nwill_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.\n\nwill_it_fly([3], 5) ➞ True\n# 3 είναι μικρότερο από το μέγιστο δυνατό βάρος, και είναι ισορροπημένο.", "entry_point": "will_it_fly", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/31", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Γράψτε μια συνάρτηση που επιστρέφει true αν το δοθέν αριθμός είναι το γινόμενο τριών πρώτων αριθμών και false σε διαφορετική περίπτωση.\n//     Γνωρίζοντας ότι (α) είναι μικρότερο από το 100.\n//     Παράδειγμα:\n// \n// is_multiply_prime(30) == True\n// 30 = 2 * 3 * 5\n// \nfunc is_multiply_prime (a int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_multiply_prime(5)\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_multiply_prime(30)\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_multiply_prime(8)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_multiply_prime(10)\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_multiply_prime(125)\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_multiply_prime(105)\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_multiply_prime(126)\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := is_multiply_prime(729)\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := is_multiply_prime(891)\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := is_multiply_prime(1001)\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "Γράψτε μια συνάρτηση που επιστρέφει true αν το δοθέν αριθμός είναι το γινόμενο τριών πρώτων αριθμών και false σε διαφορετική περίπτωση.\n    Γνωρίζοντας ότι (α) είναι μικρότερο από το 100.\n    Παράδειγμα:", "entry_point": "is_multiply_prime", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/32", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Θα σας δοθεί ένας αριθμός σε δεκαδική μορφή και η εργασία σας είναι να τον μετατρέψετε σε δυαδική μορφή. Η συνάρτηση θα πρέπει να επιστρέφει μια συμβολοσειρά, με κάθε χαρακτήρα που αντιπροσωπεύει ένα δυαδικό αριθμό. Κάθε χαρακτήρας στη συμβολοσειρά θα είναι '0' ή '1'.\n// \n// Θα υπάρχουν μερικοί επιπλέον χαρακτήρες 'db' στην αρχή και στο τέλος της συμβολοσειράς. Οι επιπλέον χαρακτήρες είναι εκεί για να βοηθήσουν με τη μορφοποίηση.\n// \n// Παραδείγματα:\n// \n// decimal_to_binary(15)   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\n// \nfunc decimal_to_binary (decimal int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := decimal_to_binary(0)\n\texpected_1 := \"db0db\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := decimal_to_binary(32)\n\texpected_2 := \"db100000db\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := decimal_to_binary(103)\n\texpected_3 := \"db1100111db\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := decimal_to_binary(15)\n\texpected_4 := \"db1111db\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "Θα σας δοθεί ένας αριθμός σε δεκαδική μορφή και η εργασία σας είναι να τον μετατρέψετε σε δυαδική μορφή. Η συνάρτηση θα πρέπει να επιστρέφει μια συμβολοσειρά, με κάθε χαρακτήρα που αντιπροσωπεύει ένα δυαδικό αριθμό. Κάθε χαρακτήρας στη συμβολοσειρά θα είναι '0' ή '1'.\n\nΘα υπάρχουν μερικοί επιπλέον χαρακτήρες 'db' στην αρχή και στο τέλος της συμβολοσειράς. Οι επιπλέον χαρακτήρες είναι εκεί για να βοηθήσουν με τη μορφοποίηση.\n\nΠαραδείγματα:", "entry_point": "decimal_to_binary", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/33", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Σας δίνεται μια συμβολοσειρά s.\n//     Η εργασία σας είναι να ελέγξετε αν η συμβολοσειρά είναι ευτυχισμένη ή όχι.\n//     Μια συμβολοσειρά είναι ευτυχισμένη αν η μήκος της είναι τουλάχιστον 3 και κάθε 3 συνεχόμενα γράμματα είναι διαφορετικά.\n//     Για παράδειγμα:\n// \n// is_happy(a) => False\n// is_happy(aa) => False\n// is_happy(abcd) => True\n// is_happy(aabb) => False\n// is_happy(adb) => True\n// is_happy(xyy) => False\n// \nfunc is_happy (s string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_happy(\"a\")\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_happy(\"aa\")\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_happy(\"abcd\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_happy(\"aabb\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_happy(\"adb\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_happy(\"xyy\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_happy(\"iopaxpoi\")\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := is_happy(\"iopaxioi\")\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνεται μια συμβολοσειρά s.\n    Η εργασία σας είναι να ελέγξετε αν η συμβολοσειρά είναι ευτυχισμένη ή όχι.\n    Μια συμβολοσειρά είναι ευτυχισμένη αν η μήκος της είναι τουλάχιστον 3 και κάθε 3 συνεχόμενα γράμματα είναι διαφορετικά.\n    Για παράδειγμα:", "entry_point": "is_happy", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/34", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Είναι η τελευταία εβδομάδα του εξαμήνου και ο καθηγητής πρέπει να δώσει τους βαθμούς στους μαθητές. Ο καθηγητής έχει δημιουργήσει το δικό του αλγόριθμο για τη βαθμολογία. Το μόνο πρόβλημα είναι ότι έχασε τον κώδικα που χρησιμοποιούσε για τη βαθμολογία. Σας έχει δώσει μια λίστα με τα GPA για μερικούς μαθητές και πρέπει να γράψετε μια συνάρτηση που μπορεί να εξάγει μια λίστα με τις βαθμολογίες γραμμάτων χρησιμοποιώντας τον παρακάτω πίνακα:\n//              GPA       |    Βαθμός γράμματος\n//               4.0                Α+\n//             > 3.7                Α \n//             > 3.3                Α- \n//             > 3.0                Β+\n//             > 2.7                Β \n//             > 2.3                Β-\n//             > 2.0                C+\n//             > 1.7                C\n//             > 1.3                C-\n//             > 1.0                D+ \n//             > 0.7                D \n//             > 0.0                D-\n//               0.0                Ε\n//     \n// \n//     Παράδειγμα:\n// \n// grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n// \nfunc numerical_letter_grade (grades []interface{}) []string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := numerical_letter_grade([]interface{}{4.0, 3, 1.7, 2, 3.5})\n\texpected_1 := []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := numerical_letter_grade([]interface{}{1.2})\n\texpected_2 := []string{\"D+\"}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := numerical_letter_grade([]interface{}{0.5})\n\texpected_3 := []string{\"D-\"}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := numerical_letter_grade([]interface{}{0.0})\n\texpected_4 := []string{\"E\"}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := numerical_letter_grade([]interface{}{1, 0.3, 1.5, 2.8, 3.3})\n\texpected_5 := []string{\"D\", \"D-\", \"C-\", \"B\", \"B+\"}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := numerical_letter_grade([]interface{}{0, 0.7})\n\texpected_6 := []string{\"E\", \"D-\"}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "Είναι η τελευταία εβδομάδα του εξαμήνου και ο καθηγητής πρέπει να δώσει τους βαθμούς στους μαθητές. Ο καθηγητής έχει δημιουργήσει το δικό του αλγόριθμο για τη βαθμολογία. Το μόνο πρόβλημα είναι ότι έχασε τον κώδικα που χρησιμοποιούσε για τη βαθμολογία. Σας έχει δώσει μια λίστα με τα GPA για μερικούς μαθητές και πρέπει να γράψετε μια συνάρτηση που μπορεί να εξάγει μια λίστα με τις βαθμολογίες γραμμάτων χρησιμοποιώντας τον παρακάτω πίνακα:\n             GPA       |    Βαθμός γράμματος\n              4.0                Α+\n            > 3.7                Α \n            > 3.3                Α- \n            > 3.0                Β+\n            > 2.7                Β \n            > 2.3                Β-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                Ε\n    \n\n    Παράδειγμα:", "entry_point": "numerical_letter_grade", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/35", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Γράψτε μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει True αν το μήκος του αλφαριθμητικού είναι πρώτος αριθμός ή False αλλιώς. Παραδείγματα.\n// \n// prime_length('Hello') == True\n// prime_length('abcdcba') == True\n// prime_length('kittens') == True\n// prime_length('orange') == False\n// \nfunc prime_length (string0 string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := prime_length(\"Hello\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := prime_length(\"abcdcba\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := prime_length(\"kittens\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := prime_length(\"orange\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := prime_length(\"wow\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := prime_length(\"world\")\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := prime_length(\"MadaM\")\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := prime_length(\"Wow\")\n\texpected_8 := true\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := prime_length(\"\")\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := prime_length(\"HI\")\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := prime_length(\"go\")\n\texpected_11 := true\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := prime_length(\"gogo\")\n\texpected_12 := false\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := prime_length(\"aaaaaaaaaaaaaaa\")\n\texpected_13 := false\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := prime_length(\"Madam\")\n\texpected_14 := true\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n\tactual_15 := prime_length(\"M\")\n\texpected_15 := false\n\tdeepCompare(actual_15, expected_15, \"Exception --- test case 14 failed to pass\")\n\n\tactual_16 := prime_length(\"0\")\n\texpected_16 := false\n\tdeepCompare(actual_16, expected_16, \"Exception --- test case 15 failed to pass\")\n\n}", "language": "go", "description": "Γράψτε μια συνάρτηση που παίρνει ένα αλφαριθμητικό και επιστρέφει True αν το μήκος του αλφαριθμητικού είναι πρώτος αριθμός ή False αλλιώς. Παραδείγματα.", "entry_point": "prime_length", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/36", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Δεδομένου ενός θετικού ακεραίου N, επιστρέφεται το συνολικό άθροισμα των ψηφίων του σε δυαδική μορφή.\n// \n//     Παράδειγμα\n//         Για N = 1000, το άθροισμα των ψηφίων θα είναι 1 και η έξοδος θα πρέπει να είναι \"1\".\n//         Για N = 150, το άθροισμα των ψηφίων θα είναι 6 και η έξοδος θα πρέπει να είναι \"110\".\n//         Για N = 147, το άθροισμα των ψηφίων θα είναι 12 και η έξοδος θα πρέπει να είναι \"1100\".\n//     \n//     Μεταβλητές:\n//         @N ακέραιος\n//              Περιορισμοί: 0 ≤ N ≤ 10000.\n//     Έξοδος:\n//          μια συμβολοσειρά δυαδικού αριθμού\n// \n// \nfunc solve (N int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := solve(1000)\n\texpected_1 := \"1\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := solve(150)\n\texpected_2 := \"110\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := solve(147)\n\texpected_3 := \"1100\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := solve(333)\n\texpected_4 := \"1001\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := solve(963)\n\texpected_5 := \"10010\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένου ενός θετικού ακεραίου N, επιστρέφεται το συνολικό άθροισμα των ψηφίων του σε δυαδική μορφή.\n\n    Παράδειγμα\n        Για N = 1000, το άθροισμα των ψηφίων θα είναι 1 και η έξοδος θα πρέπει να είναι \"1\".\n        Για N = 150, το άθροισμα των ψηφίων θα είναι 6 και η έξοδος θα πρέπει να είναι \"110\".\n        Για N = 147, το άθροισμα των ψηφίων θα είναι 12 και η έξοδος θα πρέπει να είναι \"1100\".\n    \n    Μεταβλητές:\n        @N ακέραιος\n             Περιορισμοί: 0 ≤ N ≤ 10000.\n    Έξοδος:\n         μια συμβολοσειρά δυαδικού αριθμού", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/37", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Σας δίνεται μια δισδιάστατη δομή δεδομένων, ως εμφωλευμένες λίστες, που είναι παρόμοια με μια πίνακα, αλλά, αντίθετα από τους πίνακες, κάθε γραμμή μπορεί να περιέχει διαφορετικό αριθμό στηλών. Δεδομένης της λίστας lst και του ακεραίου x, βρείτε τους ακεραίους x στη λίστα και επιστρέψτε μια λίστα από tuples, [(x1, y1), (x2, y2) ...] ώστε κάθε tuple να είναι μια συντεταγμένη - (γραμμή, στήλες), ξεκινώντας από το 0. Ταξινομήστε αρχικά τις συντεταγμένες ανά γραμμή με αύξουσα σειρά. Επίσης, ταξινομήστε τις συντεταγμένες της γραμμής με φθίνουσα σειρά.\n// \n// Παραδείγματα:\n// \n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n// \nfunc get_row (lst [][]int, x int) [][]int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}},1)\n\texpected_1 := [][]int{[]int{0, 0}, []int{1, 4}, []int{1, 0}, []int{2, 5}, []int{2, 0}}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}},2)\n\texpected_2 := [][]int{[]int{0, 1}, []int{1, 1}, []int{2, 1}, []int{3, 1}, []int{4, 1}, []int{5, 1}}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}},1)\n\texpected_3 := [][]int{[]int{0, 0}, []int{1, 0}, []int{2, 1}, []int{2, 0}, []int{3, 2}, []int{3, 0}, []int{4, 3}, []int{4, 0}, []int{5, 4}, []int{5, 0}, []int{6, 5}, []int{6, 0}}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := get_row([][]int{},1)\n\texpected_4 := [][]int{}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := get_row([][]int{[]int{1}},2)\n\texpected_5 := [][]int{}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := get_row([][]int{[]int{}, []int{1}, []int{1, 2, 3}},3)\n\texpected_6 := [][]int{[]int{2, 2}}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνεται μια δισδιάστατη δομή δεδομένων, ως εμφωλευμένες λίστες, που είναι παρόμοια με μια πίνακα, αλλά, αντίθετα από τους πίνακες, κάθε γραμμή μπορεί να περιέχει διαφορετικό αριθμό στηλών. Δεδομένης της λίστας lst και του ακεραίου x, βρείτε τους ακεραίους x στη λίστα και επιστρέψτε μια λίστα από tuples, [(x1, y1), (x2, y2) ...] ώστε κάθε tuple να είναι μια συντεταγμένη - (γραμμή, στήλες), ξεκινώντας από το 0. Ταξινομήστε αρχικά τις συντεταγμένες ανά γραμμή με αύξουσα σειρά. Επίσης, ταξινομήστε τις συντεταγμένες της γραμμής με φθίνουσα σειρά.\n\nΠαραδείγματα:", "entry_point": "get_row", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/38", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Σας δίνεται μια λίστα ακεραίων.\n// Γράψτε μια συνάρτηση next_smallest() που επιστρέφει τον δεύτερο μικρότερο στοιχείο της λίστας.\n// Επιστρέψτε null αν δεν υπάρχει τέτοιο στοιχείο.\n// next_smallest([1, 2, 3, 4, 5]) == 2\n// next_smallest([5, 1, 4, 3, 2]) == 2\n// next_smallest([]) == None\n// next_smallest([1, 1]) == None\n// \nfunc next_smallest (lst []int) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := next_smallest([]int{1, 2, 3, 4, 5})\n\texpected_1 := 2\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := next_smallest([]int{5, 1, 4, 3, 2})\n\texpected_2 := 2\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := next_smallest([]int{})\n\texpected_3 := nil\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := next_smallest([]int{1, 1})\n\texpected_4 := nil\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := next_smallest([]int{1, 1, 1, 1, 0})\n\texpected_5 := 1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := next_smallest([]int{1, 1})\n\texpected_6 := nil\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := next_smallest([]int{-35, 34, 12, -45})\n\texpected_7 := -35\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνεται μια λίστα ακεραίων.\nΓράψτε μια συνάρτηση next_smallest() που επιστρέφει τον δεύτερο μικρότερο στοιχείο της λίστας.\nΕπιστρέψτε null αν δεν υπάρχει τέτοιο στοιχείο.", "entry_point": "next_smallest", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/39", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Θα σας δοθεί μια συμβολοσειρά λέξεων και η εργασία σας είναι να μετρήσετε τον αριθμό των βαρεμάρων. Μια βαρεμάρα είναι μια πρόταση που ξεκινά με τη λέξη \"Εγώ\". Οι προτάσεις διαχωρίζονται μεταξύ τους με '.' , '?' ή '!'.\n// \n// Για παράδειγμα:\n// >>> is_bored(\"Hello world\")\n// 0\n// >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n// 1\n// \nfunc is_bored (S string) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_bored(\"Hello world\")\n\texpected_1 := 0\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_bored(\"Is the sky blue?\")\n\texpected_2 := 0\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_bored(\"I love It !\")\n\texpected_3 := 1\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_bored(\"bIt\")\n\texpected_4 := 0\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_bored(\"I feel good today. I will be productive. will kill It\")\n\texpected_5 := 2\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_bored(\"You and I are going for a walk\")\n\texpected_6 := 0\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "Θα σας δοθεί μια συμβολοσειρά λέξεων και η εργασία σας είναι να μετρήσετε τον αριθμό των βαρεμάρων. Μια βαρεμάρα είναι μια πρόταση που ξεκινά με τη λέξη \"Εγώ\". Οι προτάσεις διαχωρίζονται μεταξύ τους με '.' , '?' ή '!'.\n\nΓια παράδειγμα:", "entry_point": "is_bored", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/40", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Σας δίνεται μια λίστα ακεραίων.\n//     Πρέπει να βρείτε τη μεγαλύτερη πρώτη τιμή και να επιστρέψετε το άθροισμα των ψηφίων της.\n// \n//     Παραδείγματα:\n// \n// For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n// For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n// For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n// For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n// For lst = [0,81,12,3,1,21] the output should be 3\n// For lst = [0,8,1,2,1,7] the output should be 7\n// \nfunc skjkasdkd (lst []int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n\texpected_1 := 10\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n\texpected_2 := 25\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n\texpected_3 := 13\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n\texpected_4 := 11\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := skjkasdkd([]int{0, 81, 12, 3, 1, 21})\n\texpected_5 := 3\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := skjkasdkd([]int{0, 8, 1, 2, 1, 7})\n\texpected_6 := 7\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := skjkasdkd([]int{8191})\n\texpected_7 := 19\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := skjkasdkd([]int{8191, 123456, 127, 7})\n\texpected_8 := 19\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := skjkasdkd([]int{127, 97, 8192})\n\texpected_9 := 10\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνεται μια λίστα ακεραίων.\n    Πρέπει να βρείτε τη μεγαλύτερη πρώτη τιμή και να επιστρέψετε το άθροισμα των ψηφίων της.\n\n    Παραδείγματα:", "entry_point": "skjkasdkd", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/41", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δεδομένου ενός λεξικού, επιστρέψτε True αν όλα τα κλειδιά είναι συμβολοσειρές σε πεζά γράμματα ή όλα τα κλειδιά είναι συμβολοσειρές σε κεφαλαία γράμματα, αλλιώς επιστρέψτε False. Η συνάρτηση πρέπει να επιστρέφει False αν το δοσμένο λεξικό είναι κενό. Παραδείγματα:\n// \n// check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n// \nfunc check_dict_case (dict map[interface{}]string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := check_dict_case(map[interface{}]string{ \"p\": \"pineapple\", \"b\": \"banana\",  })\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := check_dict_case(map[interface{}]string{ \"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\",  })\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := check_dict_case(map[interface{}]string{ \"p\": \"pineapple\", 5: \"banana\", \"a\": \"apple\",  })\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := check_dict_case(map[interface{}]string{ \"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\",  })\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := check_dict_case(map[interface{}]string{ \"STATE\": \"NC\", \"ZIP\": \"12345\",  })\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := check_dict_case(map[interface{}]string{ \"fruit\": \"Orange\", \"taste\": \"Sweet\",  })\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := check_dict_case(map[interface{}]string{  })\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένου ενός λεξικού, επιστρέψτε True αν όλα τα κλειδιά είναι συμβολοσειρές σε πεζά γράμματα ή όλα τα κλειδιά είναι συμβολοσειρές σε κεφαλαία γράμματα, αλλιώς επιστρέψτε False. Η συνάρτηση πρέπει να επιστρέφει False αν το δοσμένο λεξικό είναι κενό. Παραδείγματα:", "entry_point": "check_dict_case", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/42", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δημιουργήστε μια συνάρτηση που παίρνει μια τιμή (συμβολοσειρά) που αναπαριστά έναν αριθμό και επιστρέφει τον πλησιέστερο ακέραιο αριθμό σε αυτόν. Εάν ο αριθμός είναι ισοαπόστακτος από δύο ακεραίους, στρογγυλοποιήστε τον μακριά από το μηδέν.\n// \n// Παραδείγματα\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// \n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\n// \nfunc closest_integer (value string) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := closest_integer(\"10\")\n\texpected_1 := 10\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := closest_integer(\"14.5\")\n\texpected_2 := 15\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := closest_integer(\"-15.5\")\n\texpected_3 := -16\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := closest_integer(\"15.3\")\n\texpected_4 := 15\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := closest_integer(\"0\")\n\texpected_5 := 0\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Δημιουργήστε μια συνάρτηση που παίρνει μια τιμή (συμβολοσειρά) που αναπαριστά έναν αριθμό και επιστρέφει τον πλησιέστερο ακέραιο αριθμό σε αυτόν. Εάν ο αριθμός είναι ισοαπόστακτος από δύο ακεραίους, στρογγυλοποιήστε τον μακριά από το μηδέν.\n\nΠαραδείγματα", "entry_point": "closest_integer", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/43", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δεδομένου ενός θετικού ακεραίου n, πρέπει να φτιάξετε ένα σωρό από n επίπεδα πέτρες.\n//     Το πρώτο επίπεδο έχει n πέτρες.\n//     Ο αριθμός των πετρών στο επόμενο επίπεδο είναι:\n//         - ο επόμενος μονός αριθμός αν το n είναι περιττός.\n//         - ο επόμενος άρτιος αριθμός αν το n είναι άρτιος.\n//     Επιστρέψτε τον αριθμό των πετρών σε κάθε επίπεδο σε μια λίστα, όπου το στοιχείο στη θέση\n//     i αντιπροσωπεύει τον αριθμό των πετρών στο επίπεδο (i + 1).\n// \n//     Παραδείγματα:\n// >>> make_a_pile(3)\n// [3, 5, 7]\n// \nfunc make_a_pile (n int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := make_a_pile(3)\n\texpected_1 := []int{3, 5, 7}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := make_a_pile(4)\n\texpected_2 := []int{4, 6, 8, 10}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := make_a_pile(5)\n\texpected_3 := []int{5, 7, 9, 11, 13}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := make_a_pile(6)\n\texpected_4 := []int{6, 8, 10, 12, 14, 16}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := make_a_pile(8)\n\texpected_5 := []int{8, 10, 12, 14, 16, 18, 20, 22}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένου ενός θετικού ακεραίου n, πρέπει να φτιάξετε ένα σωρό από n επίπεδα πέτρες.\n    Το πρώτο επίπεδο έχει n πέτρες.\n    Ο αριθμός των πετρών στο επόμενο επίπεδο είναι:\n        - ο επόμενος μονός αριθμός αν το n είναι περιττός.\n        - ο επόμενος άρτιος αριθμός αν το n είναι άρτιος.\n    Επιστρέψτε τον αριθμό των πετρών σε κάθε επίπεδο σε μια λίστα, όπου το στοιχείο στη θέση\n    i αντιπροσωπεύει τον αριθμό των πετρών στο επίπεδο (i + 1).\n\n    Παραδείγματα:", "entry_point": "make_a_pile", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/44", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Θα σας δοθεί μια συμβολοσειρά λέξεων που χωρίζονται με κόμματα ή κενά. Η εργασία σας είναι να χωρίσετε τη συμβολοσειρά σε λέξεις και να επιστρέψετε έναν πίνακα με τις λέξεις.\n// \n// Για παράδειγμα:\n// \n// words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n// words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n// \nfunc words_string (s string) []string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := words_string(\"Hi, my name is John\")\n\texpected_1 := []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := words_string(\"One, two, three, four, five, six\")\n\texpected_2 := []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := words_string(\"Hi, my name\")\n\texpected_3 := []string{\"Hi\", \"my\", \"name\"}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := words_string(\"One,, two, three, four, five, six,\")\n\texpected_4 := []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := words_string(\"\")\n\texpected_5 := []string{}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := words_string(\"ahmed     , gamal\")\n\texpected_6 := []string{\"ahmed\", \"gamal\"}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "Θα σας δοθεί μια συμβολοσειρά λέξεων που χωρίζονται με κόμματα ή κενά. Η εργασία σας είναι να χωρίσετε τη συμβολοσειρά σε λέξεις και να επιστρέψετε έναν πίνακα με τις λέξεις.\n\nΓια παράδειγμα:", "entry_point": "words_string", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/45", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Αυτή η συνάρτηση παίρνει δύο θετικούς αριθμούς x και y και επιστρέφει το μεγαλύτερο άρτιο ακέραιο αριθμό που βρίσκεται στο διάστημα [x, y] συμπεριλαμβανομένου. Εάν δεν υπάρχει τέτοιος αριθμός, η συνάρτηση θα πρέπει να επιστρέψει -1.\n// \n// Για παράδειγμα:\n// \n// choose_num(12, 15) = 14\n// choose_num(13, 12) = -1\n// \nfunc choose_num (x int, y int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := choose_num(12,15)\n\texpected_1 := 14\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := choose_num(13,12)\n\texpected_2 := -1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := choose_num(33,12354)\n\texpected_3 := 12354\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := choose_num(5234,5233)\n\texpected_4 := -1\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := choose_num(6,29)\n\texpected_5 := 28\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := choose_num(27,10)\n\texpected_6 := -1\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := choose_num(7,7)\n\texpected_7 := -1\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := choose_num(546,546)\n\texpected_8 := 546\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "Αυτή η συνάρτηση παίρνει δύο θετικούς αριθμούς x και y και επιστρέφει το μεγαλύτερο άρτιο ακέραιο αριθμό που βρίσκεται στο διάστημα [x, y] συμπεριλαμβανομένου. Εάν δεν υπάρχει τέτοιος αριθμός, η συνάρτηση θα πρέπει να επιστρέψει -1.\n\nΓια παράδειγμα:", "entry_point": "choose_num", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/46", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Σας δίνονται δύο θετικοί ακέραιοι αριθμοί n και m, και η εργασία σας είναι να υπολογίσετε τον μέσο όρο των ακεραίων από το n έως το m (συμπεριλαμβανομένων του n και του m). Στρογγυλοποιήστε την απάντηση στον πλησιέστερο ακέραιο και μετατρέψτε τον σε δυαδικό. Εάν το n είναι μεγαλύτερο από το m, επιστρέψτε -1. Παράδειγμα:\n// \n// rounded_avg(1, 5) => \"0b11\"\n// rounded_avg(7, 5) => -1\n// rounded_avg(10, 20) => \"0b1111\"\n// rounded_avg(20, 33) => \"0b11010\"\n// \nfunc rounded_avg (n int, m int) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := rounded_avg(1,5)\n\texpected_1 := \"0b11\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := rounded_avg(7,13)\n\texpected_2 := \"0b1010\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := rounded_avg(964,977)\n\texpected_3 := \"0b1111001010\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := rounded_avg(996,997)\n\texpected_4 := \"0b1111100100\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := rounded_avg(560,851)\n\texpected_5 := \"0b1011000010\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := rounded_avg(185,546)\n\texpected_6 := \"0b101101110\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := rounded_avg(362,496)\n\texpected_7 := \"0b110101101\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := rounded_avg(350,902)\n\texpected_8 := \"0b1001110010\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := rounded_avg(197,233)\n\texpected_9 := \"0b11010111\"\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := rounded_avg(7,5)\n\texpected_10 := -1\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := rounded_avg(5,1)\n\texpected_11 := -1\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := rounded_avg(5,5)\n\texpected_12 := \"0b101\"\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνονται δύο θετικοί ακέραιοι αριθμοί n και m, και η εργασία σας είναι να υπολογίσετε τον μέσο όρο των ακεραίων από το n έως το m (συμπεριλαμβανομένων του n και του m). Στρογγυλοποιήστε την απάντηση στον πλησιέστερο ακέραιο και μετατρέψτε τον σε δυαδικό. Εάν το n είναι μεγαλύτερο από το m, επιστρέψτε -1. Παράδειγμα:", "entry_point": "rounded_avg", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/47", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Υλοποιήστε τη συνάρτηση f που παίρνει το n ως παράμετρο και επιστρέφει μια λίστα μεγέθους n, όπου η τιμή του στοιχείου στη θέση i είναι το παραγοντικό του i αν είναι άρτιος ή άθροισμα αριθμών από 1 έως i αλλιώς. Το i ξεκινά από 1. Το παραγοντικό του i είναι ο πολλαπλασιασμός των αριθμών από 1 έως i (1 * 2 * ... * i). Παράδειγμα:\n// \n// f(5) == [1, 2, 6, 24, 15]\n// \nfunc f (n int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := f(5)\n\texpected_1 := []int{1, 2, 6, 24, 15}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := f(7)\n\texpected_2 := []int{1, 2, 6, 24, 15, 720, 28}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := f(1)\n\texpected_3 := []int{1}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := f(3)\n\texpected_4 := []int{1, 2, 6}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "Υλοποιήστε τη συνάρτηση f που παίρνει το n ως παράμετρο και επιστρέφει μια λίστα μεγέθους n, όπου η τιμή του στοιχείου στη θέση i είναι το παραγοντικό του i αν είναι άρτιος ή άθροισμα αριθμών από 1 έως i αλλιώς. Το i ξεκινά από 1. Το παραγοντικό του i είναι ο πολλαπλασιασμός των αριθμών από 1 έως i (1 * 2 * ... * i). Παράδειγμα:", "entry_point": "f", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/48", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δεδομένου ενός θετικού ακεραίου n, επιστρέφεται ένα tuple που περιέχει τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών που βρίσκονται στο εύρος (1, n), συμπεριλαμβανομένου του n.\n// \n//     Παράδειγμα 1:\n// \n//         Είσοδος: 3\n//         Έξοδος: (1, 2)\n//         Εξήγηση:\n//         Οι παλινδρομικοί αριθμοί είναι 1, 2, 3. Ένας από αυτούς είναι άρτιος και δύο είναι περιττοί.\n// \n//     Παράδειγμα 2:\n// \n//         Είσοδος: 12\n//         Έξοδος: (4, 6)\n//         Εξήγηση:\n//         Οι παλινδρομικοί αριθμοί είναι 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Τέσσερις από αυτούς είναι άρτιοι και έξι είναι περιττοί.\n// \n//     Σημείωση:\n//         1. 1 <= n <= 10^3\n//         2. Το επιστρεφόμενο tuple περιέχει αντίστοιχα τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών.\n// \n// \nfunc even_odd_palindrome (n int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := even_odd_palindrome(123)\n\texpected_1 := []int{8, 13}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := even_odd_palindrome(12)\n\texpected_2 := []int{4, 6}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := even_odd_palindrome(3)\n\texpected_3 := []int{1, 2}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := even_odd_palindrome(63)\n\texpected_4 := []int{6, 8}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := even_odd_palindrome(25)\n\texpected_5 := []int{5, 6}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := even_odd_palindrome(19)\n\texpected_6 := []int{4, 6}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := even_odd_palindrome(9)\n\texpected_7 := []int{4, 5}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := even_odd_palindrome(1)\n\texpected_8 := []int{0, 1}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένου ενός θετικού ακεραίου n, επιστρέφεται ένα tuple που περιέχει τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών που βρίσκονται στο εύρος (1, n), συμπεριλαμβανομένου του n.\n\n    Παράδειγμα 1:\n\n        Είσοδος: 3\n        Έξοδος: (1, 2)\n        Εξήγηση:\n        Οι παλινδρομικοί αριθμοί είναι 1, 2, 3. Ένας από αυτούς είναι άρτιος και δύο είναι περιττοί.\n\n    Παράδειγμα 2:\n\n        Είσοδος: 12\n        Έξοδος: (4, 6)\n        Εξήγηση:\n        Οι παλινδρομικοί αριθμοί είναι 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Τέσσερις από αυτούς είναι άρτιοι και έξι είναι περιττοί.\n\n    Σημείωση:\n        1. 1 <= n <= 10^3\n        2. Το επιστρεφόμενο tuple περιέχει αντίστοιχα τον αριθμό των άρτιων και περιττών ακεραίων παλινδρομικών αριθμών.", "entry_point": "even_odd_palindrome", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/49", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Έχουμε έναν πίνακα 'arr' από N ακεραίους arr[1], arr[2], ..., arr[N]. Οι αριθμοί στον πίνακα θα είναι τυχαία ταξινομημένοι. Η εργασία σας είναι να καθορίσετε εάν είναι δυνατόν να λάβετε έναν ταξινομημένο πίνακα σε μη φθίνουσα σειρά εκτελώντας την ακόλουθη λειτουργία στον δοσμένο πίνακα:\n//         Σας επιτρέπεται να εκτελέσετε τη λειτουργία μετατόπισης δεξιά οποιοδήποτε αριθμό φορών.\n//     \n//     Μια λειτουργία μετατόπισης δεξιά σημαίνει τη μετατόπιση όλων των στοιχείων του πίνακα κατά ένα θέση προς τη δεξιά κατεύθυνση. Το τελευταίο στοιχείο του πίνακα θα μετακινηθεί στην αρχική θέση στον πίνακα, δηλαδή στη θέση 0. \n// \n//     Εάν είναι δυνατόν να λάβετε τον ταξινομημένο πίνακα εκτελώντας την παραπάνω λειτουργία, τότε επιστρέψτε True, αλλιώς επιστρέψτε False.\n//     Εάν ο δοσμένος πίνακας είναι κενός, τότε επιστρέψτε True.\n// \n//     Σημείωση: Εγγυόμαστε ότι ο δοσμένος πίνακας θα έχει μοναδικά στοιχεία.\n// \n//     Για παράδειγμα:\n//     \n//     move_one_ball([3, 4, 5, 1, 2])==>True\n//     Εξήγηση: Εκτελώντας 2 λειτουργίες μετατόπισης δεξιά, μπορεί να επιτευχθεί μη φθίνουσα σειρά για τον δοσμένο πίνακα.\n//     move_one_ball([3, 5, 4, 1, 2])==>False\n//     Εξήγηση: Δεν είναι δυνατόν να λάβετε μη φθίνουσα σειρά για τον δοσμένο πίνακα εκτελώντας οποιονδήποτε αριθμό λειτουργιών μετατόπισης δεξιά.\n// \n// \n// \nfunc move_one_ball (arr []int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := move_one_ball([]int{3, 4, 5, 1, 2})\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := move_one_ball([]int{3, 5, 10, 1, 2})\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := move_one_ball([]int{4, 3, 1, 2})\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := move_one_ball([]int{3, 5, 4, 1, 2})\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := move_one_ball([]int{})\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Έχουμε έναν πίνακα 'arr' από N ακεραίους arr[1], arr[2], ..., arr[N]. Οι αριθμοί στον πίνακα θα είναι τυχαία ταξινομημένοι. Η εργασία σας είναι να καθορίσετε εάν είναι δυνατόν να λάβετε έναν ταξινομημένο πίνακα σε μη φθίνουσα σειρά εκτελώντας την ακόλουθη λειτουργία στον δοσμένο πίνακα:\n        Σας επιτρέπεται να εκτελέσετε τη λειτουργία μετατόπισης δεξιά οποιοδήποτε αριθμό φορών.\n    \n    Μια λειτουργία μετατόπισης δεξιά σημαίνει τη μετατόπιση όλων των στοιχείων του πίνακα κατά ένα θέση προς τη δεξιά κατεύθυνση. Το τελευταίο στοιχείο του πίνακα θα μετακινηθεί στην αρχική θέση στον πίνακα, δηλαδή στη θέση 0. \n\n    Εάν είναι δυνατόν να λάβετε τον ταξινομημένο πίνακα εκτελώντας την παραπάνω λειτουργία, τότε επιστρέψτε True, αλλιώς επιστρέψτε False.\n    Εάν ο δοσμένος πίνακας είναι κενός, τότε επιστρέψτε True.\n\n    Σημείωση: Εγγυόμαστε ότι ο δοσμένος πίνακας θα έχει μοναδικά στοιχεία.\n\n    Για παράδειγμα:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Εξήγηση: Εκτελώντας 2 λειτουργίες μετατόπισης δεξιά, μπορεί να επιτευχθεί μη φθίνουσα σειρά για τον δοσμένο πίνακα.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Εξήγηση: Δεν είναι δυνατόν να λάβετε μη φθίνουσα σειρά για τον δοσμένο πίνακα εκτελώντας οποιονδήποτε αριθμό λειτουργιών μετατόπισης δεξιά.", "entry_point": "move_one_ball", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/50", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Σε αυτό το πρόβλημα, θα υλοποιήσετε μια συνάρτηση που παίρνει δύο λίστες αριθμών και καθορίζει εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ τους για να κάνει την lst1 μια λίστα μόνο με άρτιους αριθμούς. Δεν υπάρχει όριο στον αριθμό των ανταλλαγών στοιχείων μεταξύ lst1 και lst2. Εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ των lst1 και lst2 για να κάνει όλα τα στοιχεία της lst1 να είναι άρτια, επιστρέψτε \"YES\". Διαφορετικά, επιστρέψτε \"NO\". Για παράδειγμα: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\", exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Υποθέτειται ότι οι λίστες εισόδου θα είναι μη κενές.\n// \n// \nfunc exchange (lst1 []int, lst2 []int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := exchange([]int{1, 2, 3, 4},[]int{1, 2, 3, 4})\n\texpected_1 := \"YES\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := exchange([]int{1, 2, 3, 4},[]int{1, 5, 3, 4})\n\texpected_2 := \"NO\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := exchange([]int{1, 2, 3, 4},[]int{2, 1, 4, 3})\n\texpected_3 := \"YES\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := exchange([]int{5, 7, 3},[]int{2, 6, 4})\n\texpected_4 := \"YES\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := exchange([]int{5, 7, 3},[]int{2, 6, 3})\n\texpected_5 := \"NO\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := exchange([]int{3, 2, 6, 1, 8, 9},[]int{3, 5, 5, 1, 1, 1})\n\texpected_6 := \"NO\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := exchange([]int{100, 200},[]int{200, 200})\n\texpected_7 := \"YES\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Σε αυτό το πρόβλημα, θα υλοποιήσετε μια συνάρτηση που παίρνει δύο λίστες αριθμών και καθορίζει εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ τους για να κάνει την lst1 μια λίστα μόνο με άρτιους αριθμούς. Δεν υπάρχει όριο στον αριθμό των ανταλλαγών στοιχείων μεταξύ lst1 και lst2. Εάν είναι δυνατή η ανταλλαγή στοιχείων μεταξύ των lst1 και lst2 για να κάνει όλα τα στοιχεία της lst1 να είναι άρτια, επιστρέψτε \"YES\". Διαφορετικά, επιστρέψτε \"NO\". Για παράδειγμα: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\", exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Υποθέτειται ότι οι λίστες εισόδου θα είναι μη κενές.", "entry_point": "exchange", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/51", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Εργασία\n//     Δίνονται δύο αλφαριθμητικά s και c, πρέπει να διαγράψετε όλους τους χαρακτήρες στο s που είναι ίσοι με οποιονδήποτε χαρακτήρα στο c\n//     και στη συνέχεια να ελέγξετε αν το αποτέλεσμα είναι παλίνδρομο.\n//     Ένα αλφαριθμητικό ονομάζεται παλίνδρομο αν διαβάζεται το ίδιο προς τα πίσω και προς τα εμπρός.\n//     Θα πρέπει να επιστρέψετε ένα tuple που περιέχει το αποτέλεσμα αλφαριθμητικό και True/False για τον έλεγχο.\n//     Παράδειγμα\n//     Για s = \"abcde\", c = \"ae\", το αποτέλεσμα θα πρέπει να είναι ('bcd',False)\n//     Για s = \"abcdef\", c = \"b\" το αποτέλεσμα θα πρέπει να είναι ('acdef',False)\n//     Για s = \"abcdedcba\", c = \"ab\", το αποτέλεσμα θα πρέπει να είναι ('cdedc',True)\n// \n// \nfunc reverse_delete (s string, c string) []interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := reverse_delete(\"abcde\",\"ae\")\n\texpected_1 := []interface{}{\"bcd\", false}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := reverse_delete(\"abcdef\",\"b\")\n\texpected_2 := []interface{}{\"acdef\", false}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := reverse_delete(\"abcdedcba\",\"ab\")\n\texpected_3 := []interface{}{\"cdedc\", true}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := reverse_delete(\"dwik\",\"w\")\n\texpected_4 := []interface{}{\"dik\", false}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := reverse_delete(\"a\",\"a\")\n\texpected_5 := []interface{}{\"\", true}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := reverse_delete(\"abcdedcba\",\"\")\n\texpected_6 := []interface{}{\"abcdedcba\", true}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := reverse_delete(\"abcdedcba\",\"v\")\n\texpected_7 := []interface{}{\"abcdedcba\", true}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := reverse_delete(\"vabba\",\"v\")\n\texpected_8 := []interface{}{\"abba\", true}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := reverse_delete(\"mamma\",\"mia\")\n\texpected_9 := []interface{}{\"\", true}\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "Εργασία\n    Δίνονται δύο αλφαριθμητικά s και c, πρέπει να διαγράψετε όλους τους χαρακτήρες στο s που είναι ίσοι με οποιονδήποτε χαρακτήρα στο c\n    και στη συνέχεια να ελέγξετε αν το αποτέλεσμα είναι παλίνδρομο.\n    Ένα αλφαριθμητικό ονομάζεται παλίνδρομο αν διαβάζεται το ίδιο προς τα πίσω και προς τα εμπρός.\n    Θα πρέπει να επιστρέψετε ένα tuple που περιέχει το αποτέλεσμα αλφαριθμητικό και True/False για τον έλεγχο.\n    Παράδειγμα\n    Για s = \"abcde\", c = \"ae\", το αποτέλεσμα θα πρέπει να είναι ('bcd',False)\n    Για s = \"abcdef\", c = \"b\" το αποτέλεσμα θα πρέπει να είναι ('acdef',False)\n    Για s = \"abcdedcba\", c = \"ab\", το αποτέλεσμα θα πρέπει να είναι ('cdedc',True)", "entry_point": "reverse_delete", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/52", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Σας δίνεται ένα ορθογώνιο πλέγμα από πηγάδια. Κάθε σειρά αντιπροσωπεύει ένα μόνο πηγάδι, και κάθε 1 σε μια σειρά αντιπροσωπεύει μια μονάδα νερού. Κάθε πηγάδι έχει ένα αντίστοιχο κουβά που μπορεί να χρησιμοποιηθεί για να αντλήσει νερό από αυτό, και όλοι οι κουβάδες έχουν την ίδια χωρητικότητα. Η εργασία σας είναι να χρησιμοποιήσετε τους κουβάδες για να αδειάσετε τα πηγάδια. Εξαγάγετε τον αριθμό των φορών που χρειάζεται να χαμηλώσετε τους κουβάδες.\n// \n//     Παράδειγμα 1:\n//         Είσοδος:\n//             grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n//             χωρητικότητα κουβά: 1\n//         Έξοδος: 6\n// \n//     Παράδειγμα 2:\n//         Είσοδος:\n//             grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n//             χωρητικότητα κουβά: 2\n//         Έξοδος: 5\n//     \n//     Παράδειγμα 3:\n//         Είσοδος:\n//             grid: [[0,0,0], [0,0,0]]\n//             χωρητικότητα κουβά: 5\n//         Έξοδος: 0\n// \n//     Περιορισμοί:\n//         * όλα τα πηγάδια έχουν το ίδιο μήκος\n//         * 1 <= μήκος πλέγματος <= 10^2\n//         * 1 <= μήκος grid[:,1] <= 10^2\n//         * grid[i][j] -> 0 | 1\n//         * 1 <= χωρητικότητα <= 10\n// \n// \nfunc max_fill (grid [][]int, capacity int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}},1)\n\texpected_1 := 6\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := max_fill([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}},2)\n\texpected_2 := 5\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}},5)\n\texpected_3 := 0\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := max_fill([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}},2)\n\texpected_4 := 4\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := max_fill([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}},9)\n\texpected_5 := 2\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνεται ένα ορθογώνιο πλέγμα από πηγάδια. Κάθε σειρά αντιπροσωπεύει ένα μόνο πηγάδι, και κάθε 1 σε μια σειρά αντιπροσωπεύει μια μονάδα νερού. Κάθε πηγάδι έχει ένα αντίστοιχο κουβά που μπορεί να χρησιμοποιηθεί για να αντλήσει νερό από αυτό, και όλοι οι κουβάδες έχουν την ίδια χωρητικότητα. Η εργασία σας είναι να χρησιμοποιήσετε τους κουβάδες για να αδειάσετε τα πηγάδια. Εξαγάγετε τον αριθμό των φορών που χρειάζεται να χαμηλώσετε τους κουβάδες.\n\n    Παράδειγμα 1:\n        Είσοδος:\n            grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            χωρητικότητα κουβά: 1\n        Έξοδος: 6\n\n    Παράδειγμα 2:\n        Είσοδος:\n            grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            χωρητικότητα κουβά: 2\n        Έξοδος: 5\n    \n    Παράδειγμα 3:\n        Είσοδος:\n            grid: [[0,0,0], [0,0,0]]\n            χωρητικότητα κουβά: 5\n        Έξοδος: 0\n\n    Περιορισμοί:\n        * όλα τα πηγάδια έχουν το ίδιο μήκος\n        * 1 <= μήκος πλέγματος <= 10^2\n        * 1 <= μήκος grid[:,1] <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= χωρητικότητα <= 10", "entry_point": "max_fill", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/53", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Δεδομένου ενός αλφαριθμητικού s και ενός φυσικού αριθμού n, σας έχει ανατεθεί να υλοποιήσετε μια συνάρτηση που επιστρέφει μια λίστα με όλες τις λέξεις από το αλφαριθμητικό s που περιέχουν ακριβώς n σύμφωνα, με τη σειρά που εμφανίζονται στο αλφαριθμητικό s. Εάν το αλφαριθμητικό s είναι κενό, τότε η συνάρτηση θα πρέπει να επιστρέψει μια κενή λίστα. Σημείωση: μπορείτε να υποθέσετε ότι το εισαγόμενο αλφαριθμητικό περιέχει μόνο γράμματα και κενά. Παραδείγματα:\n// \n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n// \nfunc select_words (s string, n int) []string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := select_words(\"Mary had a little lamb\",4)\n\texpected_1 := []string{\"little\"}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := select_words(\"Mary had a little lamb\",3)\n\texpected_2 := []string{\"Mary\", \"lamb\"}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := select_words(\"simple white space\",2)\n\texpected_3 := []string{}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := select_words(\"Hello world\",4)\n\texpected_4 := []string{\"world\"}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := select_words(\"Uncle sam\",3)\n\texpected_5 := []string{\"Uncle\"}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := select_words(\"\",4)\n\texpected_6 := []string{}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := select_words(\"a b c d e f\",1)\n\texpected_7 := []string{\"b\", \"c\", \"d\", \"f\"}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένου ενός αλφαριθμητικού s και ενός φυσικού αριθμού n, σας έχει ανατεθεί να υλοποιήσετε μια συνάρτηση που επιστρέφει μια λίστα με όλες τις λέξεις από το αλφαριθμητικό s που περιέχουν ακριβώς n σύμφωνα, με τη σειρά που εμφανίζονται στο αλφαριθμητικό s. Εάν το αλφαριθμητικό s είναι κενό, τότε η συνάρτηση θα πρέπει να επιστρέψει μια κενή λίστα. Σημείωση: μπορείτε να υποθέσετε ότι το εισαγόμενο αλφαριθμητικό περιέχει μόνο γράμματα και κενά. Παραδείγματα:", "entry_point": "select_words", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/54", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δεδομένου ενός πίνακα arr ακεραίων και ενός θετικού ακεραίου k, επιστρέφει μια ταξινομημένη λίστα μήκους k με τους μεγαλύτερους k αριθμούς στον πίνακα arr.\n// \n//     Παράδειγμα 1:\n// \n//         Είσοδος: arr = [-3, -4, 5], k = 3\n//         Έξοδος: [-4, -3, 5]\n// \n//     Παράδειγμα 2:\n// \n//         Είσοδος: arr = [4, -4, 4], k = 2\n//         Έξοδος: [4, 4]\n// \n//     Παράδειγμα 3:\n// \n//         Είσοδος: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n//         Έξοδος: [2]\n// \n//     Σημείωση:\n//         1. Το μήκος του πίνακα θα είναι στο εύρος [1, 1000].\n//         2. Τα στοιχεία του πίνακα θα είναι στο εύρος [-1000, 1000].\n//         3. 0 <= k <= len(arr)\n// \n// \nfunc maximum (arr []int, k int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := maximum([]int{-3, -4, 5},3)\n\texpected_1 := []int{-4, -3, 5}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := maximum([]int{4, -4, 4},2)\n\texpected_2 := []int{4, 4}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := maximum([]int{-3, 2, 1, 2, -1, -2, 1},1)\n\texpected_3 := []int{2}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := maximum([]int{123, -123, 20, 0, 1, 2, -3},3)\n\texpected_4 := []int{2, 20, 123}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := maximum([]int{-123, 20, 0, 1, 2, -3},4)\n\texpected_5 := []int{0, 1, 2, 20}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := maximum([]int{5, 15, 0, 3, -13, -8, 0},7)\n\texpected_6 := []int{-13, -8, 0, 0, 3, 5, 15}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := maximum([]int{-1, 0, 2, 5, 3, -10},2)\n\texpected_7 := []int{3, 5}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := maximum([]int{1, 0, 5, -7},1)\n\texpected_8 := []int{5}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := maximum([]int{4, -4},2)\n\texpected_9 := []int{-4, 4}\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := maximum([]int{-10, 10},2)\n\texpected_10 := []int{-10, 10}\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := maximum([]int{1, 2, 3, -23, 243, -400, 0},0)\n\texpected_11 := []int{}\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένου ενός πίνακα arr ακεραίων και ενός θετικού ακεραίου k, επιστρέφει μια ταξινομημένη λίστα μήκους k με τους μεγαλύτερους k αριθμούς στον πίνακα arr.\n\n    Παράδειγμα 1:\n\n        Είσοδος: arr = [-3, -4, 5], k = 3\n        Έξοδος: [-4, -3, 5]\n\n    Παράδειγμα 2:\n\n        Είσοδος: arr = [4, -4, 4], k = 2\n        Έξοδος: [4, 4]\n\n    Παράδειγμα 3:\n\n        Είσοδος: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Έξοδος: [2]\n\n    Σημείωση:\n        1. Το μήκος του πίνακα θα είναι στο εύρος [1, 1000].\n        2. Τα στοιχεία του πίνακα θα είναι στο εύρος [-1000, 1000].\n        3. 0 <= k <= len(arr)", "entry_point": "maximum", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/55", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δεδομένου ενός μη κενού πίνακα ακεραίων arr και ενός ακεραίου k, επιστρέφεται\n//     το άθροισμα των στοιχείων με τουλάχιστον δύο ψηφία από τα πρώτα k στοιχεία του arr.\n// \n//     Παράδειγμα:\n// \n//         Είσοδος: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n//         Έξοδος: 24 # άθροισμα των 21 + 3\n// \n//     Περιορισμοί:\n//         1. 1 <= len(arr) <= 100\n//         2. 1 <= k <= len(arr)\n// \n// \nfunc add_elements (arr []int, k int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := add_elements([]int{1, -2, -3, 41, 57, 76, 87, 88, 99},3)\n\texpected_1 := -4\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := add_elements([]int{111, 121, 3, 4000, 5, 6},2)\n\texpected_2 := 0\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := add_elements([]int{11, 21, 3, 90, 5, 6, 7, 8, 9},4)\n\texpected_3 := 125\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9},4)\n\texpected_4 := 24\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := add_elements([]int{1},1)\n\texpected_5 := 1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένου ενός μη κενού πίνακα ακεραίων arr και ενός ακεραίου k, επιστρέφεται\n    το άθροισμα των στοιχείων με τουλάχιστον δύο ψηφία από τα πρώτα k στοιχεία του arr.\n\n    Παράδειγμα:\n\n        Είσοδος: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Έξοδος: 24 # άθροισμα των 21 + 3\n\n    Περιορισμοί:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)", "entry_point": "add_elements", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/56", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Σας δίνονται δύο διαστήματα,\n//     όπου κάθε διάστημα είναι ένα ζευγάρι ακεραίων. Για παράδειγμα, διάστημα = (αρχή, τέλος) = (1, 2).\n//     Τα δεδομένα διαστήματα είναι κλειστά, που σημαίνει ότι το διάστημα (αρχή, τέλος)\n//     περιλαμβάνει τόσο την αρχή όσο και το τέλος.\n//     Για κάθε δοσμένο διάστημα, υποθέτεται ότι η αρχή του είναι μικρότερη ή ίση με το τέλος του.\n//     Η εργασία σας είναι να καθορίσετε εάν το μήκος της τομής αυτών των δύο\n//     διαστημάτων είναι ένας πρώτος αριθμός.\n//     Για παράδειγμα, η τομή των διαστημάτων (1, 3), (2, 4) είναι (2, 3)\n//     το οποίο το μήκος του είναι 1, που δεν είναι πρώτος αριθμός.\n//     Εάν το μήκος της τομής είναι ένας πρώτος αριθμός, επιστρέψτε \"YES\",\n//     διαφορετικά, επιστρέψτε \"NO\".\n//     Εάν τα δύο διαστήματα δεν τέμνονται, επιστρέψτε \"NO\".\n// \n// \n//     [είσοδος/έξοδος] δείγματα:\n// \n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\n// \nfunc intersection (interval1 []int, interval2 []int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := intersection([]int{1, 2},[]int{2, 3})\n\texpected_1 := \"NO\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := intersection([]int{-1, 1},[]int{0, 4})\n\texpected_2 := \"NO\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := intersection([]int{-3, -1},[]int{-5, 5})\n\texpected_3 := \"YES\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := intersection([]int{-2, 2},[]int{-4, 0})\n\texpected_4 := \"YES\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := intersection([]int{-11, 2},[]int{-1, -1})\n\texpected_5 := \"NO\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := intersection([]int{1, 2},[]int{3, 5})\n\texpected_6 := \"NO\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := intersection([]int{1, 2},[]int{1, 2})\n\texpected_7 := \"NO\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := intersection([]int{-2, -2},[]int{-3, -2})\n\texpected_8 := \"NO\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνονται δύο διαστήματα,\n    όπου κάθε διάστημα είναι ένα ζευγάρι ακεραίων. Για παράδειγμα, διάστημα = (αρχή, τέλος) = (1, 2).\n    Τα δεδομένα διαστήματα είναι κλειστά, που σημαίνει ότι το διάστημα (αρχή, τέλος)\n    περιλαμβάνει τόσο την αρχή όσο και το τέλος.\n    Για κάθε δοσμένο διάστημα, υποθέτεται ότι η αρχή του είναι μικρότερη ή ίση με το τέλος του.\n    Η εργασία σας είναι να καθορίσετε εάν το μήκος της τομής αυτών των δύο\n    διαστημάτων είναι ένας πρώτος αριθμός.\n    Για παράδειγμα, η τομή των διαστημάτων (1, 3), (2, 4) είναι (2, 3)\n    το οποίο το μήκος του είναι 1, που δεν είναι πρώτος αριθμός.\n    Εάν το μήκος της τομής είναι ένας πρώτος αριθμός, επιστρέψτε \"YES\",\n    διαφορετικά, επιστρέψτε \"NO\".\n    Εάν τα δύο διαστήματα δεν τέμνονται, επιστρέψτε \"NO\".\n\n\n    [είσοδος/έξοδος] δείγματα:", "entry_point": "intersection", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/57", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Όλοι γνωρίζουν την ακολουθία του Fibonacci, η οποία μελετήθηκε βαθιά από μαθηματικούς τα τελευταία δύο αιώνες. Ωστόσο, αυτό που οι άνθρωποι δεν γνωρίζουν είναι η ακολουθία του Tribonacci. Η ακολουθία του Tribonacci ορίζεται από την επανάληψη:\n//     tri(1) = 3\n//     tri(n) = 1 + n / 2, αν το n είναι ζυγός.\n//     tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), αν το n είναι περιττό.\n//     Για παράδειγμα:\n//     tri(2) = 1 + (2 / 2) = 2\n//     tri(4) = 3\n//     tri(3) = tri(2) + tri(1) + tri(4)\n//            = 2 + 3 + 3 = 8 \n//     Σας δίνεται ένας μη αρνητικός ακέραιος αριθμός n, πρέπει να επιστρέψετε μια λίστα με τους πρώτους n + 1 αριθμούς της ακολουθίας του Tribonacci.\n//     Παραδείγματα:\n//     tri(3) = [1, 3, 2, 8]\n// \n// \nfunc tri (n int) []interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := tri(3)\n\texpected_1 := []interface{}{1, 3, 2.0, 8.0}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := tri(4)\n\texpected_2 := []interface{}{1, 3, 2.0, 8.0, 3.0}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := tri(5)\n\texpected_3 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := tri(6)\n\texpected_4 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := tri(7)\n\texpected_5 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := tri(8)\n\texpected_6 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := tri(9)\n\texpected_7 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := tri(20)\n\texpected_8 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := tri(0)\n\texpected_9 := []interface{}{1}\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := tri(1)\n\texpected_10 := []interface{}{1, 3}\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "Όλοι γνωρίζουν την ακολουθία του Fibonacci, η οποία μελετήθηκε βαθιά από μαθηματικούς τα τελευταία δύο αιώνες. Ωστόσο, αυτό που οι άνθρωποι δεν γνωρίζουν είναι η ακολουθία του Tribonacci. Η ακολουθία του Tribonacci ορίζεται από την επανάληψη:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, αν το n είναι ζυγός.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), αν το n είναι περιττό.\n    Για παράδειγμα:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    Σας δίνεται ένας μη αρνητικός ακέραιος αριθμός n, πρέπει να επιστρέψετε μια λίστα με τους πρώτους n + 1 αριθμούς της ακολουθίας του Tribonacci.\n    Παραδείγματα:\n    tri(3) = [1, 3, 2, 8]", "entry_point": "tri", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/58", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Δεδομένου ενός θετικού ακεραίου n, επιστρέφει το γινόμενο των μονών ψηφίων.\n//     Επιστρέφει 0 αν όλα τα ψηφία είναι άρτια.\n//     Για παράδειγμα:\n// \n// digits(1)  == 1\n// digits(4)  == 0\n// digits(235) == 15\n// \nfunc digits (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := digits(5)\n\texpected_1 := 5\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := digits(54)\n\texpected_2 := 5\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := digits(120)\n\texpected_3 := 1\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := digits(5014)\n\texpected_4 := 5\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := digits(98765)\n\texpected_5 := 315\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := digits(5576543)\n\texpected_6 := 2625\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := digits(2468)\n\texpected_7 := 0\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένου ενός θετικού ακεραίου n, επιστρέφει το γινόμενο των μονών ψηφίων.\n    Επιστρέφει 0 αν όλα τα ψηφία είναι άρτια.\n    Για παράδειγμα:", "entry_point": "digits", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/59", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δημιουργήστε μια συνάρτηση που παίρνει μια συμβολοσειρά ως είσοδο η οποία περιέχει μόνο αγκύλες.\n//     Η συνάρτηση θα πρέπει να επιστρέφει True μόνο αν υπάρχει μια έγκυρη υποακολουθία αγκυλών \n//     όπου τουλάχιστον μια αγκύλη στην υποακολουθία είναι ενσωματωμένη.\n// is_nested('[[]]') ➞ True\n// is_nested('[]]]]]]][[[[[]') ➞ False\n// is_nested('[][]') ➞ False\n// is_nested('[]') ➞ False\n// is_nested('[[][]]') ➞ True\n// is_nested('[[]][[') ➞ True\n// \nfunc is_nested (string0 string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_nested(\"[[]]\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_nested(\"[]]]]]]][[[[[]\")\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_nested(\"[][]\")\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_nested(\"[]\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_nested(\"[[[[]]]]\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_nested(\"[]]]]]]]]]]\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_nested(\"[][][[]]\")\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := is_nested(\"[[]\")\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := is_nested(\"[]]\")\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := is_nested(\"[[]][[\")\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := is_nested(\"[[][]]\")\n\texpected_11 := true\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := is_nested(\"\")\n\texpected_12 := false\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := is_nested(\"[[[[[[[[\")\n\texpected_13 := false\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := is_nested(\"]]]]]]]]\")\n\texpected_14 := false\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n}", "language": "go", "description": "Δημιουργήστε μια συνάρτηση που παίρνει μια συμβολοσειρά ως είσοδο η οποία περιέχει μόνο αγκύλες.\n    Η συνάρτηση θα πρέπει να επιστρέφει True μόνο αν υπάρχει μια έγκυρη υποακολουθία αγκυλών \n    όπου τουλάχιστον μια αγκύλη στην υποακολουθία είναι ενσωματωμένη.", "entry_point": "is_nested", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/60", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Σας δίνεται μια λίστα αριθμών.\n//     Χρειάζεστε να επιστρέψετε το άθροισμα των τετραγωνισμένων αριθμών στην δεδομένη λίστα,\n//     στρογγυλοποιήστε κάθε στοιχείο στη λίστα στο ανώτατο ακέραιο (Ceiling) πρώτα.\n//     Παραδείγματα:\n//     Για lst = [1,2,3] η έξοδος πρέπει να είναι 14\n//     Για lst = [1,4,9] η έξοδος πρέπει να είναι 98\n//     Για lst = [1,3,5,7] η έξοδος πρέπει να είναι 84\n//     Για lst = [1.4,4.2,0] η έξοδος πρέπει να είναι 29\n//     Για lst = [-2.4,1,1] η έξοδος πρέπει να είναι 6\n// \n// \n// \n// \nfunc sum_squares (lst []interface{}) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := sum_squares([]interface{}{1, 2, 3})\n\texpected_1 := 14\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := sum_squares([]interface{}{1.0, 2, 3})\n\texpected_2 := 14\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := sum_squares([]interface{}{1, 3, 5, 7})\n\texpected_3 := 84\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := sum_squares([]interface{}{1.4, 4.2, 0})\n\texpected_4 := 29\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := sum_squares([]interface{}{-2.4, 1, 1})\n\texpected_5 := 6\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := sum_squares([]interface{}{100, 1, 15, 2})\n\texpected_6 := 10230\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := sum_squares([]interface{}{10000, 10000})\n\texpected_7 := 200000000\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := sum_squares([]interface{}{-1.4, 4.6, 6.3})\n\texpected_8 := 75\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := sum_squares([]interface{}{-1.4, 17.9, 18.9, 19.9})\n\texpected_9 := 1086\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := sum_squares([]interface{}{0})\n\texpected_10 := 0\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := sum_squares([]interface{}{-1})\n\texpected_11 := 1\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := sum_squares([]interface{}{-1, 1, 0})\n\texpected_12 := 2\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνεται μια λίστα αριθμών.\n    Χρειάζεστε να επιστρέψετε το άθροισμα των τετραγωνισμένων αριθμών στην δεδομένη λίστα,\n    στρογγυλοποιήστε κάθε στοιχείο στη λίστα στο ανώτατο ακέραιο (Ceiling) πρώτα.\n    Παραδείγματα:\n    Για lst = [1,2,3] η έξοδος πρέπει να είναι 14\n    Για lst = [1,4,9] η έξοδος πρέπει να είναι 98\n    Για lst = [1,3,5,7] η έξοδος πρέπει να είναι 84\n    Για lst = [1.4,4.2,0] η έξοδος πρέπει να είναι 29\n    Για lst = [-2.4,1,1] η έξοδος πρέπει να είναι 6", "entry_point": "sum_squares", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/61", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δημιουργήστε μια συνάρτηση που επιστρέφει True αν ο τελευταίος χαρακτήρας\n//     ενός δεδομένου string είναι αλφαβητικός χαρακτήρας και δεν είναι\n//     μέρος ενός λέξης, και False αλλιώς.\n//     Σημείωση: \"λέξη\" είναι μια ομάδα χαρακτήρων που χωρίζονται από κενό.\n// \n//     Παραδείγματα:\n// \n// check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n// check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n// check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n// check_if_last_char_is_a_letter(\"\") ➞ False \n// \nfunc check_if_last_char_is_a_letter (txt string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := check_if_last_char_is_a_letter(\"apple\")\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := check_if_last_char_is_a_letter(\"apple pi e\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := check_if_last_char_is_a_letter(\"eeeee\")\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := check_if_last_char_is_a_letter(\"A\")\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := check_if_last_char_is_a_letter(\"Pumpkin pie \")\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := check_if_last_char_is_a_letter(\"Pumpkin pie 1\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := check_if_last_char_is_a_letter(\"\")\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := check_if_last_char_is_a_letter(\"eeeee e \")\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := check_if_last_char_is_a_letter(\"apple pie\")\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := check_if_last_char_is_a_letter(\"apple pi e \")\n\texpected_10 := false\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "Δημιουργήστε μια συνάρτηση που επιστρέφει True αν ο τελευταίος χαρακτήρας\n    ενός δεδομένου string είναι αλφαβητικός χαρακτήρας και δεν είναι\n    μέρος ενός λέξης, και False αλλιώς.\n    Σημείωση: \"λέξη\" είναι μια ομάδα χαρακτήρων που χωρίζονται από κενό.\n\n    Παραδείγματα:", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/62", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Δημιουργήστε μια συνάρτηση η οποία επιστρέφει το μεγαλύτερο δείκτη ενός στοιχείου που δεν είναι μεγαλύτερο ή ίσο από το στοιχείο που ακολουθεί αμέσως πριν από αυτό. Εάν δεν υπάρχει τέτοιο στοιχείο, τότε επιστρέψτε -1. Ο δοσμένος πίνακας δεν θα περιέχει διπλότυπες τιμές.\n// \n// Παραδείγματα:\n// \n// can_arrange([1,2,4,3,5]) = 3\n// can_arrange([1,2,3]) = -1\n// \nfunc can_arrange (arr []int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := can_arrange([]int{1, 2, 4, 3, 5})\n\texpected_1 := 3\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := can_arrange([]int{1, 2, 4, 5})\n\texpected_2 := -1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := can_arrange([]int{1, 4, 2, 5, 6, 7, 8, 9, 10})\n\texpected_3 := 2\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := can_arrange([]int{4, 8, 5, 7, 3})\n\texpected_4 := 4\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := can_arrange([]int{})\n\texpected_5 := -1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "Δημιουργήστε μια συνάρτηση η οποία επιστρέφει το μεγαλύτερο δείκτη ενός στοιχείου που δεν είναι μεγαλύτερο ή ίσο από το στοιχείο που ακολουθεί αμέσως πριν από αυτό. Εάν δεν υπάρχει τέτοιο στοιχείο, τότε επιστρέψτε -1. Ο δοσμένος πίνακας δεν θα περιέχει διπλότυπες τιμές.\n\nΠαραδείγματα:", "entry_point": "can_arrange", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/63", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δημιουργήστε μια συνάρτηση που επιστρέφει ένα tuple (a, b), όπου 'a' είναι ο μεγαλύτερος από τους αρνητικούς ακέραιους και 'b' είναι ο μικρότερος από τους θετικούς ακέραιους σε μια λίστα. Εάν δεν υπάρχουν αρνητικοί ή θετικοί ακέραιοι, επιστρέψτε τους ως None.\n// \n// Παραδείγματα:\n// \n// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0]) == (None, None)\n// \nfunc largest_smallest_integers (lst []int) []interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})\n\texpected_1 := []interface{}{nil, 1}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := largest_smallest_integers([]int{2, 4, 1, 3, 5, 7, 0})\n\texpected_2 := []interface{}{nil, 1}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := largest_smallest_integers([]int{1, 3, 2, 4, 5, 6, -2})\n\texpected_3 := []interface{}{-2, 1}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := largest_smallest_integers([]int{4, 5, 3, 6, 2, 7, -7})\n\texpected_4 := []interface{}{-7, 2}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := largest_smallest_integers([]int{7, 3, 8, 4, 9, 2, 5, -9})\n\texpected_5 := []interface{}{-9, 2}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := largest_smallest_integers([]int{})\n\texpected_6 := []interface{}{nil, nil}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := largest_smallest_integers([]int{0})\n\texpected_7 := []interface{}{nil, nil}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := largest_smallest_integers([]int{-1, -3, -5, -6})\n\texpected_8 := []interface{}{-1, nil}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := largest_smallest_integers([]int{-1, -3, -5, -6, 0})\n\texpected_9 := []interface{}{-1, nil}\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := largest_smallest_integers([]int{-6, -4, -4, -3, 1})\n\texpected_10 := []interface{}{-3, 1}\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := largest_smallest_integers([]int{-6, -4, -4, -3, -100, 1})\n\texpected_11 := []interface{}{-3, 1}\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n}", "language": "go", "description": "Δημιουργήστε μια συνάρτηση που επιστρέφει ένα tuple (a, b), όπου 'a' είναι ο μεγαλύτερος από τους αρνητικούς ακέραιους και 'b' είναι ο μικρότερος από τους θετικούς ακέραιους σε μια λίστα. Εάν δεν υπάρχουν αρνητικοί ή θετικοί ακέραιοι, επιστρέψτε τους ως None.\n\nΠαραδείγματα:", "entry_point": "largest_smallest_integers", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/64", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Το βραζιλιάνικο παραγοντικό ορίζεται ως:\n//     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n//     όπου n > 0\n// \n//     Για παράδειγμα:\n// >>> special_factorial(4)\n// 288\n// \n// The function will receive an integer as input and should return the special\n// factorial of this integer.\n// \nfunc special_factorial (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := special_factorial(4)\n\texpected_1 := 288\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := special_factorial(5)\n\texpected_2 := 34560\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := special_factorial(7)\n\texpected_3 := 125411328000\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := special_factorial(1)\n\texpected_4 := 1\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "Το βραζιλιάνικο παραγοντικό ορίζεται ως:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    όπου n > 0\n\n    Για παράδειγμα:", "entry_point": "special_factorial", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/65", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Σας δίνεται μια συμβολοσειρά που αντιπροσωπεύει μια πρόταση,\n//     η πρόταση περιέχει μερικές λέξεις που χωρίζονται από ένα κενό,\n//     και πρέπει να επιστρέψετε μια συμβολοσειρά που περιέχει τις λέξεις από την αρχική πρόταση,\n//     οι οποίες έχουν πρωταρχικά μήκη,\n//     η σειρά των λέξεων στη νέα συμβολοσειρά πρέπει να είναι η ίδια με την αρχική.\n// \n//     Παράδειγμα 1:\n//         Είσοδος: πρόταση = \"Αυτό είναι ένα τεστ\"\n//         Έξοδος: \"είναι\"\n// \n//     Παράδειγμα 2:\n//         Είσοδος: πρόταση = \"πάμε για κολύμπι\"\n//         Έξοδος: \"για\"\n// \n//     Περιορισμοί:\n//         * 1 <= len(sentence) <= 100\n//         * Η πρόταση περιέχει μόνο γράμματα.\n// \n// \nfunc words_in_sentence (sentence string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := words_in_sentence(\"This is a test\")\n\texpected_1 := \"is\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := words_in_sentence(\"lets go for swimming\")\n\texpected_2 := \"go for\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := words_in_sentence(\"there is no place available here\")\n\texpected_3 := \"there is no place\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := words_in_sentence(\"Hi I am Hussein\")\n\texpected_4 := \"Hi am Hussein\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := words_in_sentence(\"go for it\")\n\texpected_5 := \"go for it\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := words_in_sentence(\"here\")\n\texpected_6 := \"\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := words_in_sentence(\"here is\")\n\texpected_7 := \"is\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνεται μια συμβολοσειρά που αντιπροσωπεύει μια πρόταση,\n    η πρόταση περιέχει μερικές λέξεις που χωρίζονται από ένα κενό,\n    και πρέπει να επιστρέψετε μια συμβολοσειρά που περιέχει τις λέξεις από την αρχική πρόταση,\n    οι οποίες έχουν πρωταρχικά μήκη,\n    η σειρά των λέξεων στη νέα συμβολοσειρά πρέπει να είναι η ίδια με την αρχική.\n\n    Παράδειγμα 1:\n        Είσοδος: πρόταση = \"Αυτό είναι ένα τεστ\"\n        Έξοδος: \"είναι\"\n\n    Παράδειγμα 2:\n        Είσοδος: πρόταση = \"πάμε για κολύμπι\"\n        Έξοδος: \"για\"\n\n    Περιορισμοί:\n        * 1 <= len(sentence) <= 100\n        * Η πρόταση περιέχει μόνο γράμματα.", "entry_point": "words_in_sentence", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/66", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Η εργασία σας είναι να υλοποιήσετε μια συνάρτηση που θα απλοποιεί την έκφραση x * n. Η συνάρτηση επιστρέφει True αν το x * n αξιολογείται σε έναν ακέραιο αριθμό και False διαφορετικά. Και τα δύο x και n είναι αναπαράσταση συντελεστή, και έχουν την ακόλουθη μορφή, <αριθμητέας>/<παρονομαστής> όπου και ο αριθμητέας και ο παρονομαστής είναι θετικοί ακέραιοι αριθμοί.\n// \n// Μπορείτε να υποθέσετε ότι το x και το n είναι έγκυροι συντελεστές και δεν έχουν μηδέν ως παρονομαστή.\n// simplify(\"1/5\", \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\", \"10/2\") = False\n// \nfunc simplify (x string, n string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := simplify(\"1/5\",\"5/1\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := simplify(\"1/6\",\"2/1\")\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := simplify(\"5/1\",\"3/1\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := simplify(\"7/10\",\"10/2\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := simplify(\"2/10\",\"50/10\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := simplify(\"7/2\",\"4/2\")\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := simplify(\"11/6\",\"6/1\")\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := simplify(\"2/3\",\"5/2\")\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := simplify(\"5/2\",\"3/5\")\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := simplify(\"2/4\",\"8/4\")\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := simplify(\"2/4\",\"4/2\")\n\texpected_11 := true\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := simplify(\"1/5\",\"5/1\")\n\texpected_12 := true\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := simplify(\"1/5\",\"1/5\")\n\texpected_13 := false\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n}", "language": "go", "description": "Η εργασία σας είναι να υλοποιήσετε μια συνάρτηση που θα απλοποιεί την έκφραση x * n. Η συνάρτηση επιστρέφει True αν το x * n αξιολογείται σε έναν ακέραιο αριθμό και False διαφορετικά. Και τα δύο x και n είναι αναπαράσταση συντελεστή, και έχουν την ακόλουθη μορφή, <αριθμητέας>/<παρονομαστής> όπου και ο αριθμητέας και ο παρονομαστής είναι θετικοί ακέραιοι αριθμοί.\n\nΜπορείτε να υποθέσετε ότι το x και το n είναι έγκυροι συντελεστές και δεν έχουν μηδέν ως παρονομαστή.", "entry_point": "simplify", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/67", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Γράψτε μια συνάρτηση η οποία ταξινομεί τη δοσμένη λίστα ακεραίων σε αύξουσα σειρά βάσει του αθροίσματος των ψηφίων τους. Σημείωση: αν υπάρχουν πολλά στοιχεία με παρόμοιο άθροισμα των ψηφίων τους, ταξινομήστε τα βάσει της θέσης τους στην αρχική λίστα.\n// \n// Παράδειγμα:\n// >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n// >>> order_by_points([]) == []\n// \nfunc order_by_points (nums []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := order_by_points([]int{1, 11, -1, -11, -12})\n\texpected_1 := []int{-1, -11, 1, -12, 11}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := order_by_points([]int{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46})\n\texpected_2 := []int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := order_by_points([]int{})\n\texpected_3 := []int{}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := order_by_points([]int{1, -11, -32, 43, 54, -98, 2, -3})\n\texpected_4 := []int{-3, -32, -98, -11, 1, 2, 43, 54}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := order_by_points([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11})\n\texpected_5 := []int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := order_by_points([]int{0, 6, 6, -76, -21, 23, 4})\n\texpected_6 := []int{-76, -21, 0, 4, 23, 6, 6}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "Γράψτε μια συνάρτηση η οποία ταξινομεί τη δοσμένη λίστα ακεραίων σε αύξουσα σειρά βάσει του αθροίσματος των ψηφίων τους. Σημείωση: αν υπάρχουν πολλά στοιχεία με παρόμοιο άθροισμα των ψηφίων τους, ταξινομήστε τα βάσει της θέσης τους στην αρχική λίστα.\n\nΠαράδειγμα:", "entry_point": "order_by_points", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/68", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Γράψτε μια συνάρτηση που παίρνει έναν πίνακα αριθμών ως είσοδο και επιστρέφει τον αριθμό των στοιχείων στον πίνακα που είναι μεγαλύτερα από 10 και και οι πρώτοι και οι τελευταίοι αριθμοί ενός αριθμού είναι περιττοί (1, 3, 5, 7, 9). Για παράδειγμα:\n// \n// specialFilter([15, -73, 14, -15]) => 1 \n// specialFilter([33, -2, -3, 45, 21, 109]) => 2\n// \nfunc specialFilter (nums []int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := specialFilter([]int{5, -2, 1, -5})\n\texpected_1 := 0\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := specialFilter([]int{15, -73, 14, -15})\n\texpected_2 := 1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := specialFilter([]int{33, -2, -3, 45, 21, 109})\n\texpected_3 := 2\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := specialFilter([]int{43, -12, 93, 125, 121, 109})\n\texpected_4 := 4\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := specialFilter([]int{71, -2, -33, 75, 21, 19})\n\texpected_5 := 3\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := specialFilter([]int{1})\n\texpected_6 := 0\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := specialFilter([]int{})\n\texpected_7 := 0\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Γράψτε μια συνάρτηση που παίρνει έναν πίνακα αριθμών ως είσοδο και επιστρέφει τον αριθμό των στοιχείων στον πίνακα που είναι μεγαλύτερα από 10 και και οι πρώτοι και οι τελευταίοι αριθμοί ενός αριθμού είναι περιττοί (1, 3, 5, 7, 9). Για παράδειγμα:", "entry_point": "specialFilter", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/69", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Σας δίνεται ένα θετικό ακέραιο n. Πρέπει να δημιουργήσετε έναν πίνακα ακεραίων a μήκους n. Για κάθε i (1 ≤ i ≤ n), η τιμή του a[i] = i * i - i + 1. Επιστρέψτε τον αριθμό των τριάδων (a[i], a[j], a[k]) του a όπου i < j < k, και a[i] + a[j] + a[k] είναι πολλαπλάσιο του 3.\n// \n// Παράδειγμα:\n//     Είσοδος: n = 5\n//     Έξοδος: 1\n//     Εξήγηση:\n//     a = [1, 3, 7, 13, 21]\n//     Η μόνη έγκυρη τριάδα είναι (1, 7, 13).\n// \n// \nfunc get_max_triples (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := get_max_triples(5)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := get_max_triples(6)\n\texpected_2 := 4\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := get_max_triples(10)\n\texpected_3 := 36\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := get_max_triples(100)\n\texpected_4 := 53361\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνεται ένα θετικό ακέραιο n. Πρέπει να δημιουργήσετε έναν πίνακα ακεραίων a μήκους n. Για κάθε i (1 ≤ i ≤ n), η τιμή του a[i] = i * i - i + 1. Επιστρέψτε τον αριθμό των τριάδων (a[i], a[j], a[k]) του a όπου i < j < k, και a[i] + a[j] + a[k] είναι πολλαπλάσιο του 3.\n\nΠαράδειγμα:\n    Είσοδος: n = 5\n    Έξοδος: 1\n    Εξήγηση:\n    a = [1, 3, 7, 13, 21]\n    Η μόνη έγκυρη τριάδα είναι (1, 7, 13).", "entry_point": "get_max_triples", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/70", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Υπάρχουν οκτώ πλανήτες στο ηλιακό μας σύστημα: ο πλανήτης που βρίσκεται πιο κοντά στον Ήλιο είναι ο Ερμής, ο επόμενος είναι η Αφροδίτη, έπειτα η Γη, ο Άρης, ο Δίας, ο Κρόνος, ο Ουρανός και ο Ποσειδώνας. \n// Γράψτε μια συνάρτηση που παίρνει δύο ονόματα πλανητών ως αλφαριθμητικά planet1 και planet2. Η συνάρτηση θα πρέπει να επιστρέφει ένα tuple που περιέχει όλους τους πλανήτες των οποίων οι τροχιές βρίσκονται μεταξύ της τροχιάς του πλανήτη1 και της τροχιάς του πλανήτη2, ταξινομημένους κατά την εγγύτητά τους στον Ήλιο. Η συνάρτηση θα πρέπει να επιστρέφει ένα κενό tuple εάν το planet1 ή το planet2 δεν είναι σωστά ονόματα πλανητών. \n// Παραδείγματα:\n// \n// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n// \nfunc bf (planet1 string, planet2 string) []string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := bf(\"Jupiter\",\"Neptune\")\n\texpected_1 := []string{\"Saturn\", \"Uranus\"}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := bf(\"Earth\",\"Mercury\")\n\texpected_2 := []string{\"Venus\"}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := bf(\"Mercury\",\"Uranus\")\n\texpected_3 := []string{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := bf(\"Neptune\",\"Venus\")\n\texpected_4 := []string{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := bf(\"Earth\",\"Earth\")\n\texpected_5 := []string{}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := bf(\"Mars\",\"Earth\")\n\texpected_6 := []string{}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := bf(\"Jupiter\",\"Makemake\")\n\texpected_7 := []string{}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Υπάρχουν οκτώ πλανήτες στο ηλιακό μας σύστημα: ο πλανήτης που βρίσκεται πιο κοντά στον Ήλιο είναι ο Ερμής, ο επόμενος είναι η Αφροδίτη, έπειτα η Γη, ο Άρης, ο Δίας, ο Κρόνος, ο Ουρανός και ο Ποσειδώνας. \nΓράψτε μια συνάρτηση που παίρνει δύο ονόματα πλανητών ως αλφαριθμητικά planet1 και planet2. Η συνάρτηση θα πρέπει να επιστρέφει ένα tuple που περιέχει όλους τους πλανήτες των οποίων οι τροχιές βρίσκονται μεταξύ της τροχιάς του πλανήτη1 και της τροχιάς του πλανήτη2, ταξινομημένους κατά την εγγύτητά τους στον Ήλιο. Η συνάρτηση θα πρέπει να επιστρέφει ένα κενό tuple εάν το planet1 ή το planet2 δεν είναι σωστά ονόματα πλανητών. \nΠαραδείγματα:", "entry_point": "bf", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/71", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Ένα απλό πρόγραμμα που θα πρέπει να επιστρέφει την τιμή του x αν το n είναι πρώτος αριθμός και θα πρέπει να επιστρέφει την τιμή του y σε διαφορετική περίπτωση.\n// \n// Παραδείγματα:\n// \n// for x_or_y(7, 34, 12) == 34\n// for x_or_y(15, 8, 5) == 5\n// \n// \nfunc x_or_y (n int, x int, y int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := x_or_y(7,34,12)\n\texpected_1 := 34\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := x_or_y(15,8,5)\n\texpected_2 := 5\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := x_or_y(3,33,5212)\n\texpected_3 := 33\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := x_or_y(1259,3,52)\n\texpected_4 := 3\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := x_or_y(7919,-1,12)\n\texpected_5 := -1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := x_or_y(3609,1245,583)\n\texpected_6 := 583\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := x_or_y(91,56,129)\n\texpected_7 := 129\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := x_or_y(6,34,1234)\n\texpected_8 := 1234\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := x_or_y(1,2,0)\n\texpected_9 := 0\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := x_or_y(2,2,0)\n\texpected_10 := 2\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "Ένα απλό πρόγραμμα που θα πρέπει να επιστρέφει την τιμή του x αν το n είναι πρώτος αριθμός και θα πρέπει να επιστρέφει την τιμή του y σε διαφορετική περίπτωση.\n\nΠαραδείγματα:", "entry_point": "x_or_y", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/72", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δεδομένης μιας λίστας αριθμών, επιστρέψτε το άθροισμα των τετραγώνων των αριθμών στη λίστα που είναι περιττοί. Αγνοήστε τους αριθμούς που είναι αρνητικοί ή δεν είναι ακέραιοι.\n// \n//     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n//     double_the_difference([-1, -2, 0]) == 0\n//     double_the_difference([9, -2]) == 81\n//     double_the_difference([0]) == 0\n// \n//     Εάν η είσοδος είναι κενή λίστα, επιστρέψτε 0.\n// \n// \nfunc double_the_difference (lst []interface{}) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := double_the_difference([]interface{}{})\n\texpected_1 := 0\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := double_the_difference([]interface{}{5, 4})\n\texpected_2 := 25\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := double_the_difference([]interface{}{0.1, 0.2, 0.3})\n\texpected_3 := 0\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := double_the_difference([]interface{}{-10, -20, -30})\n\texpected_4 := 0\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := double_the_difference([]interface{}{-1, -2, 8})\n\texpected_5 := 0\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := double_the_difference([]interface{}{0.2, 3, 5})\n\texpected_6 := 34\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := double_the_difference([]interface{}{-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99})\n\texpected_7 := 166650\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένης μιας λίστας αριθμών, επιστρέψτε το άθροισμα των τετραγώνων των αριθμών στη λίστα που είναι περιττοί. Αγνοήστε τους αριθμούς που είναι αρνητικοί ή δεν είναι ακέραιοι.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    Εάν η είσοδος είναι κενή λίστα, επιστρέψτε 0.", "entry_point": "double_the_difference", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/73", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Θα σας δοθεί το όνομα μιας κλάσης (ένα string) και μια λίστα επεκτάσεων. Οι επεκτάσεις πρέπει να χρησιμοποιηθούν για να φορτώσουν επιπλέον κλάσεις στην κλάση. Η δύναμη της επέκτασης είναι ως εξής: Ας είναι CAP ο αριθμός των κεφαλαίων γραμμάτων στο όνομα της επέκτασης και ας είναι SM ο αριθμός των πεζών γραμμάτων στο όνομα της επέκτασης, η δύναμη δίνεται από το κλάσμα CAP - SM. Θα πρέπει να βρείτε την ισχυρότερη επέκταση και να επιστρέψετε ένα string σε αυτή τη μορφή: ClassName.StrongestExtensionName. Εάν υπάρχουν δύο ή περισσότερες επεκτάσεις με την ίδια δύναμη, θα πρέπει να επιλέξετε αυτή που έρχεται πρώτη στη λίστα. Για παράδειγμα, εάν σας δοθεί \"Slices\" ως κλάση και μια λίστα επεκτάσεων: ['SErviNGSliCes', 'Cheese', 'StuFfed'], τότε θα πρέπει να επιστρέψετε 'Slices.SErviNGSliCes' καθώς η 'SErviNGSliCes' είναι η ισχυρότερη επέκταση (η δύναμή της είναι -1). Παράδειγμα:\n// \n// for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n// \nfunc Strongest_Extension (class_name string, extensions []string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := Strongest_Extension(\"Watashi\",[]string{\"tEN\", \"niNE\", \"eIGHt8OKe\"})\n\texpected_1 := \"Watashi.eIGHt8OKe\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := Strongest_Extension(\"Boku123\",[]string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"})\n\texpected_2 := \"Boku123.YEs.WeCaNe\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := Strongest_Extension(\"__YESIMHERE\",[]string{\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"})\n\texpected_3 := \"__YESIMHERE.NuLl__\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := Strongest_Extension(\"K\",[]string{\"Ta\", \"TAR\", \"t234An\", \"cosSo\"})\n\texpected_4 := \"K.TAR\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := Strongest_Extension(\"__HAHA\",[]string{\"Tab\", \"123\", \"781345\", \"-_-\"})\n\texpected_5 := \"__HAHA.123\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := Strongest_Extension(\"YameRore\",[]string{\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"})\n\texpected_6 := \"YameRore.okIWILL123\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := Strongest_Extension(\"finNNalLLly\",[]string{\"Die\", \"NowW\", \"Wow\", \"WoW\"})\n\texpected_7 := \"finNNalLLly.WoW\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := Strongest_Extension(\"_\",[]string{\"Bb\", \"91245\"})\n\texpected_8 := \"_.Bb\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := Strongest_Extension(\"Sp\",[]string{\"671235\", \"Bb\"})\n\texpected_9 := \"Sp.671235\"\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "Θα σας δοθεί το όνομα μιας κλάσης (ένα string) και μια λίστα επεκτάσεων. Οι επεκτάσεις πρέπει να χρησιμοποιηθούν για να φορτώσουν επιπλέον κλάσεις στην κλάση. Η δύναμη της επέκτασης είναι ως εξής: Ας είναι CAP ο αριθμός των κεφαλαίων γραμμάτων στο όνομα της επέκτασης και ας είναι SM ο αριθμός των πεζών γραμμάτων στο όνομα της επέκτασης, η δύναμη δίνεται από το κλάσμα CAP - SM. Θα πρέπει να βρείτε την ισχυρότερη επέκταση και να επιστρέψετε ένα string σε αυτή τη μορφή: ClassName.StrongestExtensionName. Εάν υπάρχουν δύο ή περισσότερες επεκτάσεις με την ίδια δύναμη, θα πρέπει να επιλέξετε αυτή που έρχεται πρώτη στη λίστα. Για παράδειγμα, εάν σας δοθεί \"Slices\" ως κλάση και μια λίστα επεκτάσεων: ['SErviNGSliCes', 'Cheese', 'StuFfed'], τότε θα πρέπει να επιστρέψετε 'Slices.SErviNGSliCes' καθώς η 'SErviNGSliCes' είναι η ισχυρότερη επέκταση (η δύναμή της είναι -1). Παράδειγμα:", "entry_point": "Strongest_Extension", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/74", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Σας δίνονται 2 λέξεις. Χρειάζεται να επιστρέψετε True αν η δεύτερη λέξη ή οποιαδήποτε από τις περιστροφές της είναι υποσυμβολοσειρά στην πρώτη λέξη.\n// cycpattern_check(\"abcd\",\"abd\") => False\n// cycpattern_check(\"hello\",\"ell\") => True\n// cycpattern_check(\"whassup\",\"psus\") => False\n// cycpattern_check(\"abab\",\"baa\") => True\n// cycpattern_check(\"efef\",\"eeff\") => False\n// cycpattern_check(\"himenss\",\"simen\") => True\n// \n// \nfunc cycpattern_check (a string, b string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := cycpattern_check(\"xyzw\",\"xyw\")\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := cycpattern_check(\"yello\",\"ell\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := cycpattern_check(\"whattup\",\"ptut\")\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := cycpattern_check(\"efef\",\"fee\")\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := cycpattern_check(\"abab\",\"aabb\")\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := cycpattern_check(\"winemtt\",\"tinem\")\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνονται 2 λέξεις. Χρειάζεται να επιστρέψετε True αν η δεύτερη λέξη ή οποιαδήποτε από τις περιστροφές της είναι υποσυμβολοσειρά στην πρώτη λέξη.", "entry_point": "cycpattern_check", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/75", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δεδομένου ενός θετικού ακεραίου, να ανακτηθεί η αντίστοιχη ρωμαϊκή αριθμητική του σε μορφή συμβολοσειράς και να επιστραφεί σε πεζά γράμματα.\n//     Περιορισμοί: 1 <= num <= 1000\n// \n//     Παραδείγματα:\n// >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n// >>> int_to_mini_roman(426) == 'cdxxvi'\n// \nfunc int_to_mini_roman (number int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := int_to_mini_roman(19)\n\texpected_1 := \"xix\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := int_to_mini_roman(152)\n\texpected_2 := \"clii\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := int_to_mini_roman(251)\n\texpected_3 := \"ccli\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := int_to_mini_roman(426)\n\texpected_4 := \"cdxxvi\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := int_to_mini_roman(500)\n\texpected_5 := \"d\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := int_to_mini_roman(1)\n\texpected_6 := \"i\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := int_to_mini_roman(4)\n\texpected_7 := \"iv\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := int_to_mini_roman(43)\n\texpected_8 := \"xliii\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := int_to_mini_roman(90)\n\texpected_9 := \"xc\"\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := int_to_mini_roman(94)\n\texpected_10 := \"xciv\"\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := int_to_mini_roman(532)\n\texpected_11 := \"dxxxii\"\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := int_to_mini_roman(900)\n\texpected_12 := \"cm\"\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := int_to_mini_roman(994)\n\texpected_13 := \"cmxciv\"\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := int_to_mini_roman(1000)\n\texpected_14 := \"m\"\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένου ενός θετικού ακεραίου, να ανακτηθεί η αντίστοιχη ρωμαϊκή αριθμητική του σε μορφή συμβολοσειράς και να επιστραφεί σε πεζά γράμματα.\n    Περιορισμοί: 1 <= num <= 1000\n\n    Παραδείγματα:", "entry_point": "int_to_mini_roman", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/76", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέφει True αν οι τρεις πλευρές σχηματίζουν ένα ορθογώνιο τρίγωνο, False διαφορετικά. Ένα ορθογώνιο τρίγωνο είναι ένα τρίγωνο στο οποίο ένα γωνία είναι ορθή ή 90 μοίρες. Παράδειγμα:\n// \n// right_angle_triangle(3, 4, 5) == True\n// right_angle_triangle(1, 2, 3) == False\n// \nfunc right_angle_triangle (a int, b int, c int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := right_angle_triangle(3,4,5)\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := right_angle_triangle(1,2,3)\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := right_angle_triangle(10,6,8)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := right_angle_triangle(2,2,2)\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := right_angle_triangle(7,24,25)\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := right_angle_triangle(10,5,7)\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := right_angle_triangle(5,12,13)\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := right_angle_triangle(15,8,17)\n\texpected_8 := true\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := right_angle_triangle(48,55,73)\n\texpected_9 := true\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := right_angle_triangle(1,1,1)\n\texpected_10 := false\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := right_angle_triangle(2,2,10)\n\texpected_11 := false\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένων των μήκων των τριών πλευρών ενός τριγώνου, επιστρέφει True αν οι τρεις πλευρές σχηματίζουν ένα ορθογώνιο τρίγωνο, False διαφορετικά. Ένα ορθογώνιο τρίγωνο είναι ένα τρίγωνο στο οποίο ένα γωνία είναι ορθή ή 90 μοίρες. Παράδειγμα:", "entry_point": "right_angle_triangle", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/77", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// Σας δίνεται μια συμβολοσειρά s.\n//     Αν s[i] είναι γράμμα, αντιστρέψτε την πεζή πεζή σε κεφαλαία ή αντίστροφα, \n//     διαφορετικά κρατήστε το όπως είναι.\n//     Εάν η συμβολοσειρά δεν περιέχει γράμματα, αντιστρέψτε τη συμβολοσειρά.\n//     Η συνάρτηση πρέπει να επιστρέψει τη συμβολοσειρά που προέκυψε.\n//     Παραδείγματα\n// \n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\n// \nfunc solve (s string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := solve(\"AsDf\")\n\texpected_1 := \"aSdF\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := solve(\"1234\")\n\texpected_2 := \"4321\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := solve(\"ab\")\n\texpected_3 := \"AB\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := solve(\"#a@C\")\n\texpected_4 := \"#A@c\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := solve(\"#AsdfW^45\")\n\texpected_5 := \"#aSDFw^45\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := solve(\"#6@2\")\n\texpected_6 := \"2@6#\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := solve(\"#$a^D\")\n\texpected_7 := \"#$A^d\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := solve(\"#ccc\")\n\texpected_8 := \"#CCC\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "Σας δίνεται μια συμβολοσειρά s.\n    Αν s[i] είναι γράμμα, αντιστρέψτε την πεζή πεζή σε κεφαλαία ή αντίστροφα, \n    διαφορετικά κρατήστε το όπως είναι.\n    Εάν η συμβολοσειρά δεν περιέχει γράμματα, αντιστρέψτε τη συμβολοσειρά.\n    Η συνάρτηση πρέπει να επιστρέψει τη συμβολοσειρά που προέκυψε.\n    Παραδείγματα", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/78", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δεδομένου ενός αλφαριθμητικού 'text', επιστρέψτε ένα αντίστοιχο αλφαριθμητικό md5 hash του. Εάν το 'text' είναι ένα κενό αλφαριθμητικό, επιστρέψτε null.\n// >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n// \nfunc string_to_md5 (text string) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := string_to_md5(\"Hello world\")\n\texpected_1 := \"3e25960a79dbc69b674cd4ec67a72c62\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := string_to_md5(\"\")\n\texpected_2 := nil\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := string_to_md5(\"A B C\")\n\texpected_3 := \"0ef78513b0cb8cef12743f5aeb35f888\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := string_to_md5(\"password\")\n\texpected_4 := \"5f4dcc3b5aa765d61d8327deb882cf99\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένου ενός αλφαριθμητικού 'text', επιστρέψτε ένα αντίστοιχο αλφαριθμητικό md5 hash του. Εάν το 'text' είναι ένα κενό αλφαριθμητικό, επιστρέψτε null.", "entry_point": "string_to_md5", "canonical_solution": NaN, "natural_language": "Greek"}
{"task_id": "go/79", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// Είστε ένας ειδικός προγραμματιστής στη Golang.\n// \n// Δεδομένων δύο θετικών ακεραίων a και b, επιστρέφονται οι άρτιοι αριθμοί μεταξύ a και b, με αύξουσα σειρά.\n// \n// Για παράδειγμα:\n// \n// generate_integers(2, 8) => [2, 4, 6, 8]\n// generate_integers(8, 2) => [2, 4, 6, 8]\n// generate_integers(10, 14) => []\n// \nfunc generate_integers (a int, b int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := generate_integers(2,10)\n\texpected_1 := []int{2, 4, 6, 8}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := generate_integers(10,2)\n\texpected_2 := []int{2, 4, 6, 8}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := generate_integers(132,2)\n\texpected_3 := []int{2, 4, 6, 8}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := generate_integers(17,89)\n\texpected_4 := []int{}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "Δεδομένων δύο θετικών ακεραίων a και b, επιστρέφονται οι άρτιοι αριθμοί μεταξύ a και b, με αύξουσα σειρά.\n\nΓια παράδειγμα:", "entry_point": "generate_integers", "canonical_solution": NaN, "natural_language": "Greek"}
