{"task_id": "go/0", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// شما یک لیست از عملیات واریز و برداشت در یک حساب بانکی با موجودی صفر داده شده است. وظیفه شما این است که در صورتی که در هر نقطه موجودی حساب کمتر از صفر شود، تشخیص دهید و در آن نقطه تابع باید True را برگرداند. در غیر این صورت باید False را برگرداند.\n// >>> below_zero([1, 2, 3])\n// False\n// >>> below_zero([1, 2, -4, 5])\n// True\n// \nfunc below_zero (operations []int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := below_zero([]int{})\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := below_zero([]int{1, 2, -3, 1, 2, -3})\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := below_zero([]int{1, 2, -4, 5, 6})\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := below_zero([]int{1, -1, 2, -2, 5, -5, 4, -4})\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := below_zero([]int{1, -1, 2, -2, 5, -5, 4, -5})\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := below_zero([]int{1, -2, 2, -2, 5, -5, 4, -4})\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "شما یک لیست از عملیات واریز و برداشت در یک حساب بانکی با موجودی صفر داده شده است. وظیفه شما این است که در صورتی که در هر نقطه موجودی حساب کمتر از صفر شود، تشخیص دهید و در آن نقطه تابع باید True را برگرداند. در غیر این صورت باید False را برگرداند.", "entry_point": "below_zero", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/1", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// برای یک لیست داده شده از اعداد صحیح، یک تاپل شامل جمع و ضرب تمام اعداد در لیست برگردانید.\n// جمع خالی باید برابر با 0 و ضرب خالی باید برابر با 1 باشد.\n// >>> sum_product([])\n// (0, 1)\n// >>> sum_product([1, 2, 3, 4])\n// (10, 24)\n// \nfunc sum_product (numbers []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := sum_product([]int{})\n\texpected_1 := []int{0, 1}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := sum_product([]int{1, 1, 1})\n\texpected_2 := []int{3, 1}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := sum_product([]int{100, 0})\n\texpected_3 := []int{100, 0}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := sum_product([]int{3, 5, 7})\n\texpected_4 := []int{15, 105}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := sum_product([]int{10})\n\texpected_5 := []int{10, 10}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "برای یک لیست داده شده از اعداد صحیح، یک تاپل شامل جمع و ضرب تمام اعداد در لیست برگردانید.\nجمع خالی باید برابر با 0 و ضرب خالی باید برابر با 1 باشد.", "entry_point": "sum_product", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/2", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// ورودی دو رشته a و b هستند که فقط شامل اعداد ۱ و ۰ هستند.\n//     عملگر XOR دودویی را روی این ورودی ها انجام داده و نتیجه را نیز به صورت یک رشته برگردانید.\n// >>> string_xor('010', '110')\n// '100'\n// \nfunc string_xor (a string, b string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := string_xor(\"111000\",\"101010\")\n\texpected_1 := \"010010\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := string_xor(\"1\",\"1\")\n\texpected_2 := \"0\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := string_xor(\"0101\",\"0000\")\n\texpected_3 := \"0101\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n}", "language": "go", "description": "ورودی دو رشته a و b هستند که فقط شامل اعداد ۱ و ۰ هستند.\n    عملگر XOR دودویی را روی این ورودی ها انجام داده و نتیجه را نیز به صورت یک رشته برگردانید.", "entry_point": "string_xor", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/3", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// از لیستی از رشته‌ها، بزرگترین رشته را بازگردانید. در صورت وجود چند رشته با طول یکسان، اولین رشته را بازگردانید. در صورت خالی بودن لیست ورودی، null بازگردانید.\n// >>> longest([])\n// \n// >>> longest(['a', 'b', 'c'])\n// 'a'\n// >>> longest(['a', 'bb', 'ccc'])\n// 'ccc'\n// \nfunc longest (strings []string) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := longest([]string{})\n\texpected_1 := nil\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := longest([]string{\"x\", \"y\", \"z\"})\n\texpected_2 := \"x\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := longest([]string{\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"})\n\texpected_3 := \"zzzz\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n}", "language": "go", "description": "از لیستی از رشته‌ها، بزرگترین رشته را بازگردانید. در صورت وجود چند رشته با طول یکسان، اولین رشته را بازگردانید. در صورت خالی بودن لیست ورودی، null بازگردانید.", "entry_point": "longest", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/4", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// بازگشت بزرگترین مقسوم علیه مشترک دو عدد a و b\n// >>> greatest_common_divisor(3, 5)\n// 1\n// >>> greatest_common_divisor(25, 15)\n// 5\n// \nfunc greatest_common_divisor (a int, b int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := greatest_common_divisor(3,7)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := greatest_common_divisor(10,15)\n\texpected_2 := 5\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := greatest_common_divisor(49,14)\n\texpected_3 := 7\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := greatest_common_divisor(144,60)\n\texpected_4 := 12\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "بازگشت بزرگترین مقسوم علیه مشترک دو عدد a و b", "entry_point": "greatest_common_divisor", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/5", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// ورودی یک رشته با فاصله جدا شده از اعداد از 'صفر' تا 'نه' است.\n//     انتخاب های معتبر عبارتند از 'صفر'، 'یک'، 'دو'، 'سه'، 'چهار'، 'پنج'، 'شش'، 'هفت'، 'هشت' و 'نه'.\n//     رشته را با اعداد مرتب شده از کوچکترین تا بزرگترین برگردانید.\n// >>> sort_numbers('three one five')\n// 'one three five'\n// \nfunc sort_numbers (numbers string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := sort_numbers(\"\")\n\texpected_1 := \"\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := sort_numbers(\"three\")\n\texpected_2 := \"three\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := sort_numbers(\"three five nine\")\n\texpected_3 := \"three five nine\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := sort_numbers(\"five zero four seven nine eight\")\n\texpected_4 := \"zero four five seven eight nine\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := sort_numbers(\"six five four three two one zero\")\n\texpected_5 := \"zero one two three four five six\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "ورودی یک رشته با فاصله جدا شده از اعداد از 'صفر' تا 'نه' است.\n    انتخاب های معتبر عبارتند از 'صفر'، 'یک'، 'دو'، 'سه'، 'چهار'، 'پنج'، 'شش'، 'هفت'، 'هشت' و 'نه'.\n    رشته را با اعداد مرتب شده از کوچکترین تا بزرگترین برگردانید.", "entry_point": "sort_numbers", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/6", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// در لیستی از اعداد (حداقل دو عنصر)، یک تبدیل خطی به این لیست اعمال شود، به گونه‌ای که کوچکترین عدد برابر با ۰ و بزرگترین عدد برابر با ۱ شود.\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// \nfunc rescale_to_unit (numbers []float64) []float64 {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := rescale_to_unit([]float64{2.0, 49.9})\n\texpected_1 := []float64{0.0, 1.0}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := rescale_to_unit([]float64{100.0, 49.9})\n\texpected_2 := []float64{1.0, 0.0}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n\texpected_3 := []float64{0.0, 0.25, 0.5, 0.75, 1.0}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := rescale_to_unit([]float64{2.0, 1.0, 5.0, 3.0, 4.0})\n\texpected_4 := []float64{0.25, 0.0, 1.0, 0.5, 0.75}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := rescale_to_unit([]float64{12.0, 11.0, 15.0, 13.0, 14.0})\n\texpected_5 := []float64{0.25, 0.0, 1.0, 0.5, 0.75}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "در لیستی از اعداد (حداقل دو عنصر)، یک تبدیل خطی به این لیست اعمال شود، به گونه‌ای که کوچکترین عدد برابر با ۰ و بزرگترین عدد برابر با ۱ شود.", "entry_point": "rescale_to_unit", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/7", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// برای یک رشته داده شده، حروف کوچک را به حروف بزرگ و حروف بزرگ را به حروف کوچک تبدیل کنید.\n// >>> flip_case('Hello')\n// 'hELLO'\n// \nfunc flip_case (string0 string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := flip_case(\"\")\n\texpected_1 := \"\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := flip_case(\"Hello!\")\n\texpected_2 := \"hELLO!\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := flip_case(\"These violent delights have violent ends\")\n\texpected_3 := \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n}", "language": "go", "description": "برای یک رشته داده شده، حروف کوچک را به حروف بزرگ و حروف بزرگ را به حروف کوچک تبدیل کنید.", "entry_point": "flip_case", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/8", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// تنها اعداد مثبت در لیست را بازگردانید.\n// >>> get_positive([-1, 2, -4, 5, 6])\n// [2, 5, 6]\n// >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// [5, 3, 2, 3, 9, 123, 1]\n// \nfunc get_positive (l []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := get_positive([]int{-1, -2, 4, 5, 6})\n\texpected_1 := []int{4, 5, 6}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := get_positive([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10})\n\texpected_2 := []int{5, 3, 2, 3, 3, 9, 123, 1}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := get_positive([]int{-1, -2})\n\texpected_3 := []int{}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := get_positive([]int{})\n\texpected_4 := []int{}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "تنها اعداد مثبت در لیست را بازگردانید.", "entry_point": "get_positive", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/9", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// اگر یک عدد داده شده اول باشد، true برگردانید و در غیر این صورت false.\n// >>> is_prime(6)\n// False\n// >>> is_prime(101)\n// True\n// >>> is_prime(11)\n// True\n// >>> is_prime(13441)\n// True\n// >>> is_prime(61)\n// True\n// >>> is_prime(4)\n// False\n// >>> is_prime(1)\n// False\n// \nfunc is_prime (n int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_prime(6)\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_prime(101)\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_prime(11)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_prime(13441)\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_prime(61)\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_prime(4)\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_prime(1)\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := is_prime(5)\n\texpected_8 := true\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := is_prime(11)\n\texpected_9 := true\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := is_prime(17)\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := is_prime(85)\n\texpected_11 := false\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := is_prime(77)\n\texpected_12 := false\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := is_prime(255379)\n\texpected_13 := false\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n}", "language": "go", "description": "اگر یک عدد داده شده اول باشد، true برگردانید و در غیر این صورت false.", "entry_point": "is_prime", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/10", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// بازگشت عناصر منحصر به فرد مرتب شده در یک لیست\n// >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [0, 2, 3, 5, 9, 123]\n// \nfunc unique (l []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\texpected_1 := []int{0, 2, 3, 5, 9, 123}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n}", "language": "go", "description": "بازگشت عناصر منحصر به فرد مرتب شده در یک لیست", "entry_point": "unique", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/11", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// prime_fib عدد n ام را برمیگرداند که یک عدد فیبوناچی است و همچنین اول است.\n// >>> prime_fib(1)\n// 2\n// >>> prime_fib(2)\n// 3\n// >>> prime_fib(3)\n// 5\n// >>> prime_fib(4)\n// 13\n// >>> prime_fib(5)\n// 89\n// \nfunc prime_fib (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := prime_fib(1)\n\texpected_1 := 2\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := prime_fib(2)\n\texpected_2 := 3\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := prime_fib(3)\n\texpected_3 := 5\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := prime_fib(4)\n\texpected_4 := 13\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := prime_fib(5)\n\texpected_5 := 89\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := prime_fib(6)\n\texpected_6 := 233\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := prime_fib(7)\n\texpected_7 := 1597\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := prime_fib(8)\n\texpected_8 := 28657\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := prime_fib(9)\n\texpected_9 := 514229\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := prime_fib(10)\n\texpected_10 := 433494437\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "prime_fib عدد n ام را برمیگرداند که یک عدد فیبوناچی است و همچنین اول است.", "entry_point": "prime_fib", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/12", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// تابع triples_sum_to_zero یک لیست اعداد صحیح را به عنوان ورودی دریافت می‌کند.\n//     اگر در لیست سه عنصر متمایز وجود داشته باشد که مجموع آن‌ها صفر باشد، True برمی‌گرداند و در غیر این صورت False.\n// >>> triples_sum_to_zero([1, 3, 5, 0])\n// False\n// >>> triples_sum_to_zero([1, 3, -2, 1])\n// True\n// >>> triples_sum_to_zero([1, 2, 3, 7])\n// False\n// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n// True\n// >>> triples_sum_to_zero([1])\n// False\n// \nfunc triples_sum_to_zero (l []int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := triples_sum_to_zero([]int{1, 3, 5, 0})\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := triples_sum_to_zero([]int{1, 3, 5, -1})\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := triples_sum_to_zero([]int{1, 3, -2, 1})\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := triples_sum_to_zero([]int{1, 2, 3, 7})\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := triples_sum_to_zero([]int{1, 2, 5, 7})\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := triples_sum_to_zero([]int{1})\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := triples_sum_to_zero([]int{1, 3, 5, -100})\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := triples_sum_to_zero([]int{100, 3, 5, -100})\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "تابع triples_sum_to_zero یک لیست اعداد صحیح را به عنوان ورودی دریافت می‌کند.\n    اگر در لیست سه عنصر متمایز وجود داشته باشد که مجموع آن‌ها صفر باشد، True برمی‌گرداند و در غیر این صورت False.", "entry_point": "triples_sum_to_zero", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/13", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// pairs_sum_to_zero یک لیست اعداد صحیح را به عنوان ورودی می‌گیرد.\n//     اگر دو عنصر متمایز در لیست وجود داشته باشند که مجموع آن‌ها صفر باشد، True برمی‌گرداند و در غیر این صورت False.\n// >>> pairs_sum_to_zero([1, 3, 5, 0])\n// False\n// >>> pairs_sum_to_zero([1, 3, -2, 1])\n// False\n// >>> pairs_sum_to_zero([1, 2, 3, 7])\n// False\n// >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n// True\n// >>> pairs_sum_to_zero([1])\n// False\n// \nfunc pairs_sum_to_zero (l []int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := pairs_sum_to_zero([]int{1, 3, 5, 0})\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := pairs_sum_to_zero([]int{1, 3, -2, 1})\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := pairs_sum_to_zero([]int{1, 2, 3, 7})\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := pairs_sum_to_zero([]int{1})\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := pairs_sum_to_zero([]int{-3, 9, -1, 3, 2, 30})\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := pairs_sum_to_zero([]int{-3, 9, -1, 3, 2, 31})\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := pairs_sum_to_zero([]int{-3, 9, -1, 4, 2, 30})\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := pairs_sum_to_zero([]int{-3, 9, -1, 4, 2, 31})\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "pairs_sum_to_zero یک لیست اعداد صحیح را به عنوان ورودی می‌گیرد.\n    اگر دو عنصر متمایز در لیست وجود داشته باشند که مجموع آن‌ها صفر باشد، True برمی‌گرداند و در غیر این صورت False.", "entry_point": "pairs_sum_to_zero", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/14", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// دنباله اعداد فیبوناچی 4 یک دنباله مشابه دنباله فیبوناچی است که به شرح زیر تعریف می‌شود:\n//     fib4(0) -> 0\n//     fib4(1) -> 0\n//     fib4(2) -> 2\n//     fib4(3) -> 0\n//     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n//     لطفا یک تابع برای محاسبه بهینه عنصر n ام از دنباله اعداد فیبوناچی 4 بنویسید. از بازگشتی استفاده نکنید.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n// >>> fib4(7)\n// 14\n// \nfunc fib4 (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := fib4(5)\n\texpected_1 := 4\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := fib4(8)\n\texpected_2 := 28\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := fib4(10)\n\texpected_3 := 104\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := fib4(12)\n\texpected_4 := 386\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "دنباله اعداد فیبوناچی 4 یک دنباله مشابه دنباله فیبوناچی است که به شرح زیر تعریف می‌شود:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    لطفا یک تابع برای محاسبه بهینه عنصر n ام از دنباله اعداد فیبوناچی 4 بنویسید. از بازگشتی استفاده نکنید.", "entry_point": "fib4", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/15", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// بازگشت میانگین عناصر لیست l.\n// >>> median([3, 1, 2, 4, 5])\n// 3\n// >>> median([-10, 4, 6, 1000, 10, 20])\n// 15.0\n// \nfunc median (l []int) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := median([]int{3, 1, 2, 4, 5})\n\texpected_1 := 3\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := median([]int{-10, 4, 6, 1000, 10, 20})\n\texpected_2 := 8.0\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := median([]int{5})\n\texpected_3 := 5\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := median([]int{6, 5})\n\texpected_4 := 5.5\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := median([]int{8, 1, 3, 9, 9, 2, 7})\n\texpected_5 := 7\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "بازگشت میانگین عناصر لیست l.", "entry_point": "median", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/16", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// بررسی می‌کند که رشته داده شده یک پالیندروم است یا خیر.\n// >>> is_palindrome('')\n// True\n// >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n// >>> is_palindrome('zbcd')\n// False\n// \nfunc is_palindrome (text string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_palindrome(\"\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_palindrome(\"aba\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_palindrome(\"aaaaa\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_palindrome(\"zbcd\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_palindrome(\"xywyx\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_palindrome(\"xywyz\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_palindrome(\"xywzx\")\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "بررسی می‌کند که رشته داده شده یک پالیندروم است یا خیر.", "entry_point": "is_palindrome", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/17", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// remove_vowels یک تابع است که یک رشته را دریافت کرده و رشته‌ای بدون حروف صدادار برمی‌گرداند.\n// >>> remove_vowels('')\n// ''\n// >>> remove_vowels(\"abcdef\\nghijklm\")\n// 'bcdf\\nghjklm'\n// >>> remove_vowels('abcdef')\n// 'bcdf'\n// >>> remove_vowels('aaaaa')\n// ''\n// >>> remove_vowels('aaBAA')\n// 'B'\n// >>> remove_vowels('zbcd')\n// 'zbcd'\n// \nfunc remove_vowels (text string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := remove_vowels(\"\")\n\texpected_1 := \"\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := remove_vowels(\"abcdef\\nghijklm\")\n\texpected_2 := \"bcdf\\nghjklm\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := remove_vowels(\"fedcba\")\n\texpected_3 := \"fdcb\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := remove_vowels(\"eeeee\")\n\texpected_4 := \"\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := remove_vowels(\"acBAA\")\n\texpected_5 := \"cB\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := remove_vowels(\"EcBOO\")\n\texpected_6 := \"cB\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := remove_vowels(\"ybcd\")\n\texpected_7 := \"ybcd\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "remove_vowels یک تابع است که یک رشته را دریافت کرده و رشته‌ای بدون حروف صدادار برمی‌گرداند.", "entry_point": "remove_vowels", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/18", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// اگر همه اعداد در لیست l کمتر از آستانه t باشند، True برگردانید.\n// >>> below_threshold([1, 2, 4, 10], 100)\n// True\n// >>> below_threshold([1, 20, 4, 10], 5)\n// False\n// \nfunc below_threshold (l []int, t int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := below_threshold([]int{1, 2, 4, 10},100)\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := below_threshold([]int{1, 20, 4, 10},5)\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := below_threshold([]int{1, 20, 4, 10},21)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := below_threshold([]int{1, 20, 4, 10},22)\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := below_threshold([]int{1, 8, 4, 10},11)\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := below_threshold([]int{1, 8, 4, 10},10)\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "اگر همه اعداد در لیست l کمتر از آستانه t باشند، True برگردانید.", "entry_point": "below_threshold", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/19", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// افزودن دو عدد x و y\n// >>> add(2, 3)\n// 5\n// >>> add(5, 7)\n// 12\n// \nfunc add (x int, y int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := add(0,1)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := add(1,0)\n\texpected_2 := 1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := add(2,3)\n\texpected_3 := 5\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := add(5,7)\n\texpected_4 := 12\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := add(7,5)\n\texpected_5 := 12\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := add(572,725)\n\texpected_6 := 1297\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := add(51,804)\n\texpected_7 := 855\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := add(645,96)\n\texpected_8 := 741\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := add(712,853)\n\texpected_9 := 1565\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := add(223,101)\n\texpected_10 := 324\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := add(76,29)\n\texpected_11 := 105\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := add(416,149)\n\texpected_12 := 565\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := add(145,409)\n\texpected_13 := 554\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := add(535,430)\n\texpected_14 := 965\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n\tactual_15 := add(118,303)\n\texpected_15 := 421\n\tdeepCompare(actual_15, expected_15, \"Exception --- test case 14 failed to pass\")\n\n\tactual_16 := add(287,94)\n\texpected_16 := 381\n\tdeepCompare(actual_16, expected_16, \"Exception --- test case 15 failed to pass\")\n\n\tactual_17 := add(768,257)\n\texpected_17 := 1025\n\tdeepCompare(actual_17, expected_17, \"Exception --- test case 16 failed to pass\")\n\n\tactual_18 := add(421,677)\n\texpected_18 := 1098\n\tdeepCompare(actual_18, expected_18, \"Exception --- test case 17 failed to pass\")\n\n\tactual_19 := add(802,814)\n\texpected_19 := 1616\n\tdeepCompare(actual_19, expected_19, \"Exception --- test case 18 failed to pass\")\n\n\tactual_20 := add(510,922)\n\texpected_20 := 1432\n\tdeepCompare(actual_20, expected_20, \"Exception --- test case 19 failed to pass\")\n\n\tactual_21 := add(345,819)\n\texpected_21 := 1164\n\tdeepCompare(actual_21, expected_21, \"Exception --- test case 20 failed to pass\")\n\n\tactual_22 := add(895,436)\n\texpected_22 := 1331\n\tdeepCompare(actual_22, expected_22, \"Exception --- test case 21 failed to pass\")\n\n\tactual_23 := add(123,424)\n\texpected_23 := 547\n\tdeepCompare(actual_23, expected_23, \"Exception --- test case 22 failed to pass\")\n\n\tactual_24 := add(923,245)\n\texpected_24 := 1168\n\tdeepCompare(actual_24, expected_24, \"Exception --- test case 23 failed to pass\")\n\n\tactual_25 := add(23,438)\n\texpected_25 := 461\n\tdeepCompare(actual_25, expected_25, \"Exception --- test case 24 failed to pass\")\n\n\tactual_26 := add(565,133)\n\texpected_26 := 698\n\tdeepCompare(actual_26, expected_26, \"Exception --- test case 25 failed to pass\")\n\n\tactual_27 := add(945,925)\n\texpected_27 := 1870\n\tdeepCompare(actual_27, expected_27, \"Exception --- test case 26 failed to pass\")\n\n\tactual_28 := add(261,983)\n\texpected_28 := 1244\n\tdeepCompare(actual_28, expected_28, \"Exception --- test case 27 failed to pass\")\n\n\tactual_29 := add(139,577)\n\texpected_29 := 716\n\tdeepCompare(actual_29, expected_29, \"Exception --- test case 28 failed to pass\")\n\n\tactual_30 := add(763,178)\n\texpected_30 := 941\n\tdeepCompare(actual_30, expected_30, \"Exception --- test case 29 failed to pass\")\n\n\tactual_31 := add(147,892)\n\texpected_31 := 1039\n\tdeepCompare(actual_31, expected_31, \"Exception --- test case 30 failed to pass\")\n\n\tactual_32 := add(436,402)\n\texpected_32 := 838\n\tdeepCompare(actual_32, expected_32, \"Exception --- test case 31 failed to pass\")\n\n\tactual_33 := add(610,581)\n\texpected_33 := 1191\n\tdeepCompare(actual_33, expected_33, \"Exception --- test case 32 failed to pass\")\n\n\tactual_34 := add(103,416)\n\texpected_34 := 519\n\tdeepCompare(actual_34, expected_34, \"Exception --- test case 33 failed to pass\")\n\n\tactual_35 := add(339,990)\n\texpected_35 := 1329\n\tdeepCompare(actual_35, expected_35, \"Exception --- test case 34 failed to pass\")\n\n\tactual_36 := add(130,504)\n\texpected_36 := 634\n\tdeepCompare(actual_36, expected_36, \"Exception --- test case 35 failed to pass\")\n\n\tactual_37 := add(242,717)\n\texpected_37 := 959\n\tdeepCompare(actual_37, expected_37, \"Exception --- test case 36 failed to pass\")\n\n\tactual_38 := add(562,110)\n\texpected_38 := 672\n\tdeepCompare(actual_38, expected_38, \"Exception --- test case 37 failed to pass\")\n\n\tactual_39 := add(396,909)\n\texpected_39 := 1305\n\tdeepCompare(actual_39, expected_39, \"Exception --- test case 38 failed to pass\")\n\n\tactual_40 := add(887,703)\n\texpected_40 := 1590\n\tdeepCompare(actual_40, expected_40, \"Exception --- test case 39 failed to pass\")\n\n\tactual_41 := add(870,551)\n\texpected_41 := 1421\n\tdeepCompare(actual_41, expected_41, \"Exception --- test case 40 failed to pass\")\n\n\tactual_42 := add(422,391)\n\texpected_42 := 813\n\tdeepCompare(actual_42, expected_42, \"Exception --- test case 41 failed to pass\")\n\n\tactual_43 := add(299,505)\n\texpected_43 := 804\n\tdeepCompare(actual_43, expected_43, \"Exception --- test case 42 failed to pass\")\n\n\tactual_44 := add(346,56)\n\texpected_44 := 402\n\tdeepCompare(actual_44, expected_44, \"Exception --- test case 43 failed to pass\")\n\n\tactual_45 := add(36,706)\n\texpected_45 := 742\n\tdeepCompare(actual_45, expected_45, \"Exception --- test case 44 failed to pass\")\n\n\tactual_46 := add(738,411)\n\texpected_46 := 1149\n\tdeepCompare(actual_46, expected_46, \"Exception --- test case 45 failed to pass\")\n\n\tactual_47 := add(679,87)\n\texpected_47 := 766\n\tdeepCompare(actual_47, expected_47, \"Exception --- test case 46 failed to pass\")\n\n\tactual_48 := add(25,303)\n\texpected_48 := 328\n\tdeepCompare(actual_48, expected_48, \"Exception --- test case 47 failed to pass\")\n\n\tactual_49 := add(161,612)\n\texpected_49 := 773\n\tdeepCompare(actual_49, expected_49, \"Exception --- test case 48 failed to pass\")\n\n\tactual_50 := add(306,841)\n\texpected_50 := 1147\n\tdeepCompare(actual_50, expected_50, \"Exception --- test case 49 failed to pass\")\n\n\tactual_51 := add(973,411)\n\texpected_51 := 1384\n\tdeepCompare(actual_51, expected_51, \"Exception --- test case 50 failed to pass\")\n\n\tactual_52 := add(711,157)\n\texpected_52 := 868\n\tdeepCompare(actual_52, expected_52, \"Exception --- test case 51 failed to pass\")\n\n\tactual_53 := add(471,27)\n\texpected_53 := 498\n\tdeepCompare(actual_53, expected_53, \"Exception --- test case 52 failed to pass\")\n\n\tactual_54 := add(714,792)\n\texpected_54 := 1506\n\tdeepCompare(actual_54, expected_54, \"Exception --- test case 53 failed to pass\")\n\n\tactual_55 := add(38,206)\n\texpected_55 := 244\n\tdeepCompare(actual_55, expected_55, \"Exception --- test case 54 failed to pass\")\n\n\tactual_56 := add(907,343)\n\texpected_56 := 1250\n\tdeepCompare(actual_56, expected_56, \"Exception --- test case 55 failed to pass\")\n\n\tactual_57 := add(23,760)\n\texpected_57 := 783\n\tdeepCompare(actual_57, expected_57, \"Exception --- test case 56 failed to pass\")\n\n\tactual_58 := add(524,859)\n\texpected_58 := 1383\n\tdeepCompare(actual_58, expected_58, \"Exception --- test case 57 failed to pass\")\n\n\tactual_59 := add(30,529)\n\texpected_59 := 559\n\tdeepCompare(actual_59, expected_59, \"Exception --- test case 58 failed to pass\")\n\n\tactual_60 := add(341,691)\n\texpected_60 := 1032\n\tdeepCompare(actual_60, expected_60, \"Exception --- test case 59 failed to pass\")\n\n\tactual_61 := add(167,729)\n\texpected_61 := 896\n\tdeepCompare(actual_61, expected_61, \"Exception --- test case 60 failed to pass\")\n\n\tactual_62 := add(636,289)\n\texpected_62 := 925\n\tdeepCompare(actual_62, expected_62, \"Exception --- test case 61 failed to pass\")\n\n\tactual_63 := add(503,144)\n\texpected_63 := 647\n\tdeepCompare(actual_63, expected_63, \"Exception --- test case 62 failed to pass\")\n\n\tactual_64 := add(51,985)\n\texpected_64 := 1036\n\tdeepCompare(actual_64, expected_64, \"Exception --- test case 63 failed to pass\")\n\n\tactual_65 := add(287,149)\n\texpected_65 := 436\n\tdeepCompare(actual_65, expected_65, \"Exception --- test case 64 failed to pass\")\n\n\tactual_66 := add(659,75)\n\texpected_66 := 734\n\tdeepCompare(actual_66, expected_66, \"Exception --- test case 65 failed to pass\")\n\n\tactual_67 := add(462,797)\n\texpected_67 := 1259\n\tdeepCompare(actual_67, expected_67, \"Exception --- test case 66 failed to pass\")\n\n\tactual_68 := add(406,141)\n\texpected_68 := 547\n\tdeepCompare(actual_68, expected_68, \"Exception --- test case 67 failed to pass\")\n\n\tactual_69 := add(106,44)\n\texpected_69 := 150\n\tdeepCompare(actual_69, expected_69, \"Exception --- test case 68 failed to pass\")\n\n\tactual_70 := add(300,934)\n\texpected_70 := 1234\n\tdeepCompare(actual_70, expected_70, \"Exception --- test case 69 failed to pass\")\n\n\tactual_71 := add(471,524)\n\texpected_71 := 995\n\tdeepCompare(actual_71, expected_71, \"Exception --- test case 70 failed to pass\")\n\n\tactual_72 := add(122,429)\n\texpected_72 := 551\n\tdeepCompare(actual_72, expected_72, \"Exception --- test case 71 failed to pass\")\n\n\tactual_73 := add(735,195)\n\texpected_73 := 930\n\tdeepCompare(actual_73, expected_73, \"Exception --- test case 72 failed to pass\")\n\n\tactual_74 := add(335,484)\n\texpected_74 := 819\n\tdeepCompare(actual_74, expected_74, \"Exception --- test case 73 failed to pass\")\n\n\tactual_75 := add(28,809)\n\texpected_75 := 837\n\tdeepCompare(actual_75, expected_75, \"Exception --- test case 74 failed to pass\")\n\n\tactual_76 := add(430,20)\n\texpected_76 := 450\n\tdeepCompare(actual_76, expected_76, \"Exception --- test case 75 failed to pass\")\n\n\tactual_77 := add(916,635)\n\texpected_77 := 1551\n\tdeepCompare(actual_77, expected_77, \"Exception --- test case 76 failed to pass\")\n\n\tactual_78 := add(301,999)\n\texpected_78 := 1300\n\tdeepCompare(actual_78, expected_78, \"Exception --- test case 77 failed to pass\")\n\n\tactual_79 := add(454,466)\n\texpected_79 := 920\n\tdeepCompare(actual_79, expected_79, \"Exception --- test case 78 failed to pass\")\n\n\tactual_80 := add(905,259)\n\texpected_80 := 1164\n\tdeepCompare(actual_80, expected_80, \"Exception --- test case 79 failed to pass\")\n\n\tactual_81 := add(168,205)\n\texpected_81 := 373\n\tdeepCompare(actual_81, expected_81, \"Exception --- test case 80 failed to pass\")\n\n\tactual_82 := add(570,434)\n\texpected_82 := 1004\n\tdeepCompare(actual_82, expected_82, \"Exception --- test case 81 failed to pass\")\n\n\tactual_83 := add(64,959)\n\texpected_83 := 1023\n\tdeepCompare(actual_83, expected_83, \"Exception --- test case 82 failed to pass\")\n\n\tactual_84 := add(957,510)\n\texpected_84 := 1467\n\tdeepCompare(actual_84, expected_84, \"Exception --- test case 83 failed to pass\")\n\n\tactual_85 := add(722,598)\n\texpected_85 := 1320\n\tdeepCompare(actual_85, expected_85, \"Exception --- test case 84 failed to pass\")\n\n\tactual_86 := add(770,226)\n\texpected_86 := 996\n\tdeepCompare(actual_86, expected_86, \"Exception --- test case 85 failed to pass\")\n\n\tactual_87 := add(579,66)\n\texpected_87 := 645\n\tdeepCompare(actual_87, expected_87, \"Exception --- test case 86 failed to pass\")\n\n\tactual_88 := add(117,674)\n\texpected_88 := 791\n\tdeepCompare(actual_88, expected_88, \"Exception --- test case 87 failed to pass\")\n\n\tactual_89 := add(530,30)\n\texpected_89 := 560\n\tdeepCompare(actual_89, expected_89, \"Exception --- test case 88 failed to pass\")\n\n\tactual_90 := add(776,345)\n\texpected_90 := 1121\n\tdeepCompare(actual_90, expected_90, \"Exception --- test case 89 failed to pass\")\n\n\tactual_91 := add(327,389)\n\texpected_91 := 716\n\tdeepCompare(actual_91, expected_91, \"Exception --- test case 90 failed to pass\")\n\n\tactual_92 := add(596,12)\n\texpected_92 := 608\n\tdeepCompare(actual_92, expected_92, \"Exception --- test case 91 failed to pass\")\n\n\tactual_93 := add(599,511)\n\texpected_93 := 1110\n\tdeepCompare(actual_93, expected_93, \"Exception --- test case 92 failed to pass\")\n\n\tactual_94 := add(936,476)\n\texpected_94 := 1412\n\tdeepCompare(actual_94, expected_94, \"Exception --- test case 93 failed to pass\")\n\n\tactual_95 := add(461,14)\n\texpected_95 := 475\n\tdeepCompare(actual_95, expected_95, \"Exception --- test case 94 failed to pass\")\n\n\tactual_96 := add(966,157)\n\texpected_96 := 1123\n\tdeepCompare(actual_96, expected_96, \"Exception --- test case 95 failed to pass\")\n\n\tactual_97 := add(326,91)\n\texpected_97 := 417\n\tdeepCompare(actual_97, expected_97, \"Exception --- test case 96 failed to pass\")\n\n\tactual_98 := add(392,455)\n\texpected_98 := 847\n\tdeepCompare(actual_98, expected_98, \"Exception --- test case 97 failed to pass\")\n\n\tactual_99 := add(446,477)\n\texpected_99 := 923\n\tdeepCompare(actual_99, expected_99, \"Exception --- test case 98 failed to pass\")\n\n\tactual_100 := add(324,860)\n\texpected_100 := 1184\n\tdeepCompare(actual_100, expected_100, \"Exception --- test case 99 failed to pass\")\n\n\tactual_101 := add(945,85)\n\texpected_101 := 1030\n\tdeepCompare(actual_101, expected_101, \"Exception --- test case 100 failed to pass\")\n\n\tactual_102 := add(886,582)\n\texpected_102 := 1468\n\tdeepCompare(actual_102, expected_102, \"Exception --- test case 101 failed to pass\")\n\n\tactual_103 := add(886,712)\n\texpected_103 := 1598\n\tdeepCompare(actual_103, expected_103, \"Exception --- test case 102 failed to pass\")\n\n\tactual_104 := add(842,953)\n\texpected_104 := 1795\n\tdeepCompare(actual_104, expected_104, \"Exception --- test case 103 failed to pass\")\n\n}", "language": "go", "description": "افزودن دو عدد x و y", "entry_point": "add", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/20", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// بررسی کنید که دو کلمه دارای کاراکترهای یکسان هستند یا خیر.\n// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n// True\n// >>> same_chars('abcd', 'dddddddabc')\n// True\n// >>> same_chars('dddddddabc', 'abcd')\n// True\n// >>> same_chars('eabcd', 'dddddddabc')\n// False\n// >>> same_chars('abcd', 'dddddddabce')\n// False\n// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n// False\n// \nfunc same_chars (s0 string, s1 string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := same_chars(\"eabcdzzzz\",\"dddzzzzzzzddeddabc\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := same_chars(\"abcd\",\"dddddddabc\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := same_chars(\"dddddddabc\",\"abcd\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := same_chars(\"eabcd\",\"dddddddabc\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := same_chars(\"abcd\",\"dddddddabcf\")\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := same_chars(\"eabcdzzzz\",\"dddzzzzzzzddddabc\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := same_chars(\"aabb\",\"aaccc\")\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "بررسی کنید که دو کلمه دارای کاراکترهای یکسان هستند یا خیر.", "entry_point": "same_chars", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/21", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// بازگشت عدد فیبوناچی n ام.\n// >>> fib(10)\n// 55\n// >>> fib(1)\n// 1\n// >>> fib(8)\n// 21\n// \nfunc fib (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := fib(10)\n\texpected_1 := 55\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := fib(1)\n\texpected_2 := 1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := fib(8)\n\texpected_3 := 21\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := fib(11)\n\texpected_4 := 89\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := fib(12)\n\texpected_5 := 144\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "بازگشت عدد فیبوناچی n ام.", "entry_point": "fib", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/22", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// بازگشت عناصر مشترک منحصر به فرد مرتب شده برای دو لیست.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\n// \n// \nfunc common (l1 []int, l2 []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := common([]int{1, 4, 3, 34, 653, 2, 5},[]int{5, 7, 1, 5, 9, 653, 121})\n\texpected_1 := []int{1, 5, 653}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := common([]int{5, 3, 2, 8},[]int{3, 2})\n\texpected_2 := []int{2, 3}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := common([]int{4, 3, 2, 8},[]int{3, 2, 4})\n\texpected_3 := []int{2, 3, 4}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := common([]int{4, 3, 2, 8},[]int{})\n\texpected_4 := []int{}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "بازگشت عناصر مشترک منحصر به فرد مرتب شده برای دو لیست.", "entry_point": "common", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/23", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// بزرگترین عامل اول n را بازگردانید. فرض کنید n> 1 و اول نیست.\n// >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n// 2\n// \nfunc largest_prime_factor (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := largest_prime_factor(15)\n\texpected_1 := 5\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := largest_prime_factor(27)\n\texpected_2 := 3\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := largest_prime_factor(63)\n\texpected_3 := 7\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := largest_prime_factor(330)\n\texpected_4 := 11\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := largest_prime_factor(13195)\n\texpected_5 := 29\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "بزرگترین عامل اول n را بازگردانید. فرض کنید n> 1 و اول نیست.", "entry_point": "largest_prime_factor", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/24", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// تابع sum_to_n مجموع اعداد از ۱ تا n را محاسبه می‌کند.\n// >>> sum_to_n(30)\n// 465\n// >>> sum_to_n(100)\n// 5050\n// >>> sum_to_n(5)\n// 15\n// >>> sum_to_n(10)\n// 55\n// >>> sum_to_n(1)\n// 1\n// \nfunc sum_to_n (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := sum_to_n(1)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := sum_to_n(6)\n\texpected_2 := 21\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := sum_to_n(11)\n\texpected_3 := 66\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := sum_to_n(30)\n\texpected_4 := 465\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := sum_to_n(100)\n\texpected_5 := 5050\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "تابع sum_to_n مجموع اعداد از ۱ تا n را محاسبه می‌کند.", "entry_point": "sum_to_n", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/25", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// xs ضرایب یک چندجمله‌ای را نشان می‌دهد.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// مشتق این چندجمله‌ای را با همان فرم برگردانید.\n// >>> derivative([3, 1, 2, 4, 5])\n// [1, 4, 12, 20]\n// >>> derivative([1, 2, 3])\n// [2, 6]\n// \nfunc derivative (xs []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := derivative([]int{3, 1, 2, 4, 5})\n\texpected_1 := []int{1, 4, 12, 20}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := derivative([]int{1, 2, 3})\n\texpected_2 := []int{2, 6}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := derivative([]int{3, 2, 1})\n\texpected_3 := []int{2, 2}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := derivative([]int{3, 2, 1, 0, 4})\n\texpected_4 := []int{2, 2, 0, 16}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := derivative([]int{1})\n\texpected_5 := []int{}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "xs ضرایب یک چندجمله‌ای را نشان می‌دهد.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\nمشتق این چندجمله‌ای را با همان فرم برگردانید.", "entry_point": "derivative", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/26", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// دنباله اعداد فیبفیب یک دنباله مشابه دنباله فیبوناچی است که به شرح زیر تعریف می‌شود:\n//     fibfib(0) == 0\n//     fibfib(1) == 0\n//     fibfib(2) == 1\n//     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n//     لطفا یک تابع برای محاسبه بهینه عنصر nام دنباله اعداد فیبفیب بنویسید.\n// >>> fibfib(1)\n// 0\n// >>> fibfib(5)\n// 4\n// >>> fibfib(8)\n// 24\n// \nfunc fibfib (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := fibfib(2)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := fibfib(1)\n\texpected_2 := 0\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := fibfib(5)\n\texpected_3 := 4\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := fibfib(8)\n\texpected_4 := 24\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := fibfib(10)\n\texpected_5 := 81\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := fibfib(12)\n\texpected_6 := 274\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := fibfib(14)\n\texpected_7 := 927\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "دنباله اعداد فیبفیب یک دنباله مشابه دنباله فیبوناچی است که به شرح زیر تعریف می‌شود:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    لطفا یک تابع برای محاسبه بهینه عنصر nام دنباله اعداد فیبفیب بنویسید.", "entry_point": "fibfib", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/27", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// تابع vowels_count را بنویسید که یک رشته که یک کلمه را نشان می دهد را به عنوان ورودی می گیرد و تعداد حروف صدادار در رشته را برمی گرداند. حروف صدادار در اینجا 'a'، 'e'، 'i'، 'o'، 'u' هستند. در اینجا، 'y' نیز یک حرف صدادار است، اما فقط زمانی که در انتهای کلمه داده شده باشد.\n// \n//     مثال:\n// >>> vowels_count(\"abcde\")\n// 2\n// >>> vowels_count(\"ACEDY\")\n// 3\n// \nfunc vowels_count (s string) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := vowels_count(\"abcde\")\n\texpected_1 := 2\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := vowels_count(\"Alone\")\n\texpected_2 := 3\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := vowels_count(\"key\")\n\texpected_3 := 2\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := vowels_count(\"bye\")\n\texpected_4 := 1\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := vowels_count(\"keY\")\n\texpected_5 := 2\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := vowels_count(\"bYe\")\n\texpected_6 := 1\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := vowels_count(\"ACEDY\")\n\texpected_7 := 3\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "تابع vowels_count را بنویسید که یک رشته که یک کلمه را نشان می دهد را به عنوان ورودی می گیرد و تعداد حروف صدادار در رشته را برمی گرداند. حروف صدادار در اینجا 'a'، 'e'، 'i'، 'o'، 'u' هستند. در اینجا، 'y' نیز یک حرف صدادار است، اما فقط زمانی که در انتهای کلمه داده شده باشد.\n\n    مثال:", "entry_point": "vowels_count", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/28", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// شما یک لیست غیر خالی از اعداد صحیح مثبت دارید. بزرگترین عدد صحیحی را که بزرگتر از صفر است و فرکانس آن بیشتر یا مساوی با مقدار خود عدد است، برگردانید. فرکانس یک عدد، تعداد بارهایی است که در لیست ظاهر می‌شود. اگر چنین مقداری وجود نداشته باشد، -1 را برگردانید. نمونه‌ها:\n// \n// search([4, 1, 2, 2, 3, 1]) == 2\n// search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n// search([5, 5, 4, 4, 4]) == -1\n// \nfunc search (lst []int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := search([]int{5, 5, 5, 5, 1})\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := search([]int{4, 1, 4, 1, 4, 4})\n\texpected_2 := 4\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := search([]int{3, 3})\n\texpected_3 := -1\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := search([]int{8, 8, 8, 8, 8, 8, 8, 8})\n\texpected_4 := 8\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := search([]int{2, 3, 3, 2, 2})\n\texpected_5 := 2\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := search([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1})\n\texpected_6 := 1\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := search([]int{3, 2, 8, 2})\n\texpected_7 := 2\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := search([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10})\n\texpected_8 := 1\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := search([]int{8, 8, 3, 6, 5, 6, 4})\n\texpected_9 := -1\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := search([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9})\n\texpected_10 := 1\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := search([]int{1, 9, 10, 1, 3})\n\texpected_11 := 1\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := search([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10})\n\texpected_12 := 5\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := search([]int{1})\n\texpected_13 := 1\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := search([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5})\n\texpected_14 := 4\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n\tactual_15 := search([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10})\n\texpected_15 := 2\n\tdeepCompare(actual_15, expected_15, \"Exception --- test case 14 failed to pass\")\n\n\tactual_16 := search([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3})\n\texpected_16 := 1\n\tdeepCompare(actual_16, expected_16, \"Exception --- test case 15 failed to pass\")\n\n\tactual_17 := search([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4})\n\texpected_17 := 4\n\tdeepCompare(actual_17, expected_17, \"Exception --- test case 16 failed to pass\")\n\n\tactual_18 := search([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7})\n\texpected_18 := 4\n\tdeepCompare(actual_18, expected_18, \"Exception --- test case 17 failed to pass\")\n\n\tactual_19 := search([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1})\n\texpected_19 := 2\n\tdeepCompare(actual_19, expected_19, \"Exception --- test case 18 failed to pass\")\n\n\tactual_20 := search([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8})\n\texpected_20 := -1\n\tdeepCompare(actual_20, expected_20, \"Exception --- test case 19 failed to pass\")\n\n\tactual_21 := search([]int{10})\n\texpected_21 := -1\n\tdeepCompare(actual_21, expected_21, \"Exception --- test case 20 failed to pass\")\n\n\tactual_22 := search([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2})\n\texpected_22 := 2\n\tdeepCompare(actual_22, expected_22, \"Exception --- test case 21 failed to pass\")\n\n\tactual_23 := search([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8})\n\texpected_23 := 1\n\tdeepCompare(actual_23, expected_23, \"Exception --- test case 22 failed to pass\")\n\n\tactual_24 := search([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6})\n\texpected_24 := 1\n\tdeepCompare(actual_24, expected_24, \"Exception --- test case 23 failed to pass\")\n\n\tactual_25 := search([]int{3, 10, 10, 9, 2})\n\texpected_25 := -1\n\tdeepCompare(actual_25, expected_25, \"Exception --- test case 24 failed to pass\")\n\n}", "language": "go", "description": "شما یک لیست غیر خالی از اعداد صحیح مثبت دارید. بزرگترین عدد صحیحی را که بزرگتر از صفر است و فرکانس آن بیشتر یا مساوی با مقدار خود عدد است، برگردانید. فرکانس یک عدد، تعداد بارهایی است که در لیست ظاهر می‌شود. اگر چنین مقداری وجود نداشته باشد، -1 را برگردانید. نمونه‌ها:", "entry_point": "search", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/29", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// با دریافت طول سه ضلع مثلث، مساحت مثلث را با دو رقم اعشار گرد کرده و در صورتی که سه ضلع یک مثلث معتبر را تشکیل دهند، آن را برگردانید. در غیر این صورت، -1 را برگردانید. سه ضلع یک مثلث معتبر را زمانی تشکیل می دهند که مجموع هر دو ضلع بزرگتر از ضلع سوم باشد. مثال:\n// \n// triangle_area(3, 4, 5) == 6.00\n// triangle_area(1, 2, 10) == -1\n// \nfunc triangle_area (a int, b int, c int) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := triangle_area(3,4,5)\n\texpected_1 := 6.0\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := triangle_area(1,2,10)\n\texpected_2 := -1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := triangle_area(4,8,5)\n\texpected_3 := 8.18\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := triangle_area(2,2,2)\n\texpected_4 := 1.73\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := triangle_area(1,2,3)\n\texpected_5 := -1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := triangle_area(10,5,7)\n\texpected_6 := 16.25\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := triangle_area(2,6,3)\n\texpected_7 := -1\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := triangle_area(1,1,1)\n\texpected_8 := 0.43\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := triangle_area(2,2,10)\n\texpected_9 := -1\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "با دریافت طول سه ضلع مثلث، مساحت مثلث را با دو رقم اعشار گرد کرده و در صورتی که سه ضلع یک مثلث معتبر را تشکیل دهند، آن را برگردانید. در غیر این صورت، -1 را برگردانید. سه ضلع یک مثلث معتبر را زمانی تشکیل می دهند که مجموع هر دو ضلع بزرگتر از ضلع سوم باشد. مثال:", "entry_point": "triangle_area", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/30", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// تابعی بنویسید که در صورتی که شیء q پرواز کند، True برمی گرداند و در غیر این صورت False.\n// شیء q در صورتی پرواز می کند که متعادل باشد (یک لیست پالیندرومیک است) و مجموع عناصر آن کمتر یا مساوی حداکثر وزن ممکن w باشد.\n// \n// مثال:\n// will_it_fly([1، 2]، 5) ➞ False\n// # 1 + 2 کمتر از حداکثر وزن ممکن است، اما متعادل نیست.\n// \n// will_it_fly([3، 2، 3]، 1) ➞ False\n// # متعادل است، اما 3 + 2 + 3 بیشتر از حداکثر وزن ممکن است.\n// \n// will_it_fly([3، 2، 3]، 9) ➞ True\n// # 3 + 2 + 3 کمتر از حداکثر وزن ممکن است و متعادل است.\n// \n// will_it_fly([3]، 5) ➞ True\n// # 3 کمتر از حداکثر وزن ممکن است و متعادل است.\n// \n// \nfunc will_it_fly (q []int, w int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := will_it_fly([]int{3, 2, 3},9)\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := will_it_fly([]int{1, 2},5)\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := will_it_fly([]int{3},5)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := will_it_fly([]int{3, 2, 3},1)\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := will_it_fly([]int{1, 2, 3},6)\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := will_it_fly([]int{5},5)\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "تابعی بنویسید که در صورتی که شیء q پرواز کند، True برمی گرداند و در غیر این صورت False.\nشیء q در صورتی پرواز می کند که متعادل باشد (یک لیست پالیندرومیک است) و مجموع عناصر آن کمتر یا مساوی حداکثر وزن ممکن w باشد.\n\nمثال:\nwill_it_fly([1، 2]، 5) ➞ False\n# 1 + 2 کمتر از حداکثر وزن ممکن است، اما متعادل نیست.\n\nwill_it_fly([3، 2، 3]، 1) ➞ False\n# متعادل است، اما 3 + 2 + 3 بیشتر از حداکثر وزن ممکن است.\n\nwill_it_fly([3، 2، 3]، 9) ➞ True\n# 3 + 2 + 3 کمتر از حداکثر وزن ممکن است و متعادل است.\n\nwill_it_fly([3]، 5) ➞ True\n# 3 کمتر از حداکثر وزن ممکن است و متعادل است.", "entry_point": "will_it_fly", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/31", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// یک تابع بنویسید که در صورتی که عدد داده شده حاصلضرب 3 عدد اول باشد، مقدار درست را برگرداند و در غیر این صورت، مقدار نادرست را برگرداند.\n//     با دانستن اینکه (a) کمتر از 100 است.\n//     مثال:\n// \n// is_multiply_prime(30) == True\n// 30 = 2 * 3 * 5\n// \nfunc is_multiply_prime (a int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_multiply_prime(5)\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_multiply_prime(30)\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_multiply_prime(8)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_multiply_prime(10)\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_multiply_prime(125)\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_multiply_prime(105)\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_multiply_prime(126)\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := is_multiply_prime(729)\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := is_multiply_prime(891)\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := is_multiply_prime(1001)\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "یک تابع بنویسید که در صورتی که عدد داده شده حاصلضرب 3 عدد اول باشد، مقدار درست را برگرداند و در غیر این صورت، مقدار نادرست را برگرداند.\n    با دانستن اینکه (a) کمتر از 100 است.\n    مثال:", "entry_point": "is_multiply_prime", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/32", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// شما یک عدد به صورت دهدهی دریافت خواهید کرد و وظیفه شما تبدیل آن به فرمت دودویی است. تابع باید یک رشته بازگرداند که هر کاراکتر آن یک عدد دودویی را نشان می‌دهد. هر کاراکتر در رشته '0' یا '1' خواهد بود.\n// \n// در ابتدا و انتهای رشته، چند کاراکتر اضافی 'db' وجود دارد. این کاراکترهای اضافی برای کمک به فرمت‌بندی است.\n// \n// مثال‌ها:\n// \n// decimal_to_binary(15)   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\n// \nfunc decimal_to_binary (decimal int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := decimal_to_binary(0)\n\texpected_1 := \"db0db\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := decimal_to_binary(32)\n\texpected_2 := \"db100000db\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := decimal_to_binary(103)\n\texpected_3 := \"db1100111db\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := decimal_to_binary(15)\n\texpected_4 := \"db1111db\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "شما یک عدد به صورت دهدهی دریافت خواهید کرد و وظیفه شما تبدیل آن به فرمت دودویی است. تابع باید یک رشته بازگرداند که هر کاراکتر آن یک عدد دودویی را نشان می‌دهد. هر کاراکتر در رشته '0' یا '1' خواهد بود.\n\nدر ابتدا و انتهای رشته، چند کاراکتر اضافی 'db' وجود دارد. این کاراکترهای اضافی برای کمک به فرمت‌بندی است.\n\nمثال‌ها:", "entry_point": "decimal_to_binary", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/33", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// شما یک رشته s دریافت می کنید.\n//     وظیفه شما بررسی این است که رشته خوشحال است یا خیر.\n//     یک رشته خوشحال است اگر طول آن حداقل 3 باشد و هر 3 حرف متوالی آن متفاوت باشد.\n//     به عنوان مثال:\n// \n// is_happy(a) => False\n// is_happy(aa) => False\n// is_happy(abcd) => True\n// is_happy(aabb) => False\n// is_happy(adb) => True\n// is_happy(xyy) => False\n// \nfunc is_happy (s string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_happy(\"a\")\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_happy(\"aa\")\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_happy(\"abcd\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_happy(\"aabb\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_happy(\"adb\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_happy(\"xyy\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_happy(\"iopaxpoi\")\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := is_happy(\"iopaxioi\")\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "شما یک رشته s دریافت می کنید.\n    وظیفه شما بررسی این است که رشته خوشحال است یا خیر.\n    یک رشته خوشحال است اگر طول آن حداقل 3 باشد و هر 3 حرف متوالی آن متفاوت باشد.\n    به عنوان مثال:", "entry_point": "is_happy", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/34", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// در هفته آخر ترم، معلم باید نمرات را به دانش آموزان بدهد. معلم الگوریتم خود را برای نمره دادن ارائه داده است. تنها مشکل این است که او کدی که برای نمره دادن استفاده کرده است را از دست داده است. او لیستی از معدل های برخی از دانش آموزان به شما داده است و شما باید یک تابع بنویسید که با استفاده از جدول زیر، لیستی از نمرات حروفی را خروجی دهد:\n// \n//              GPA       |    Letter grade\n//               4.0                A+\n//             > 3.7                A \n//             > 3.3                A- \n//             > 3.0                B+\n//             > 2.7                B \n//             > 2.3                B-\n//             > 2.0                C+\n//             > 1.7                C\n//             > 1.3                C-\n//             > 1.0                D+ \n//             > 0.7                D \n//             > 0.0                D-\n//               0.0                E\n//     \n// \n//     مثال:\n// \n// grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n// \nfunc numerical_letter_grade (grades []interface{}) []string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := numerical_letter_grade([]interface{}{4.0, 3, 1.7, 2, 3.5})\n\texpected_1 := []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := numerical_letter_grade([]interface{}{1.2})\n\texpected_2 := []string{\"D+\"}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := numerical_letter_grade([]interface{}{0.5})\n\texpected_3 := []string{\"D-\"}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := numerical_letter_grade([]interface{}{0.0})\n\texpected_4 := []string{\"E\"}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := numerical_letter_grade([]interface{}{1, 0.3, 1.5, 2.8, 3.3})\n\texpected_5 := []string{\"D\", \"D-\", \"C-\", \"B\", \"B+\"}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := numerical_letter_grade([]interface{}{0, 0.7})\n\texpected_6 := []string{\"E\", \"D-\"}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "در هفته آخر ترم، معلم باید نمرات را به دانش آموزان بدهد. معلم الگوریتم خود را برای نمره دادن ارائه داده است. تنها مشکل این است که او کدی که برای نمره دادن استفاده کرده است را از دست داده است. او لیستی از معدل های برخی از دانش آموزان به شما داده است و شما باید یک تابع بنویسید که با استفاده از جدول زیر، لیستی از نمرات حروفی را خروجی دهد:\n\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    مثال:", "entry_point": "numerical_letter_grade", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/35", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// یک تابع بنویسید که یک رشته را دریافت کرده و در صورتی که طول رشته یک عدد اول باشد، True و در غیر این صورت False برگرداند.\n// مثال ها:\n// \n// prime_length('Hello') == True\n// prime_length('abcdcba') == True\n// prime_length('kittens') == True\n// prime_length('orange') == False\n// \nfunc prime_length (string0 string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := prime_length(\"Hello\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := prime_length(\"abcdcba\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := prime_length(\"kittens\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := prime_length(\"orange\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := prime_length(\"wow\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := prime_length(\"world\")\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := prime_length(\"MadaM\")\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := prime_length(\"Wow\")\n\texpected_8 := true\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := prime_length(\"\")\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := prime_length(\"HI\")\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := prime_length(\"go\")\n\texpected_11 := true\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := prime_length(\"gogo\")\n\texpected_12 := false\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := prime_length(\"aaaaaaaaaaaaaaa\")\n\texpected_13 := false\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := prime_length(\"Madam\")\n\texpected_14 := true\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n\tactual_15 := prime_length(\"M\")\n\texpected_15 := false\n\tdeepCompare(actual_15, expected_15, \"Exception --- test case 14 failed to pass\")\n\n\tactual_16 := prime_length(\"0\")\n\texpected_16 := false\n\tdeepCompare(actual_16, expected_16, \"Exception --- test case 15 failed to pass\")\n\n}", "language": "go", "description": "یک تابع بنویسید که یک رشته را دریافت کرده و در صورتی که طول رشته یک عدد اول باشد، True و در غیر این صورت False برگرداند.\nمثال ها:", "entry_point": "prime_length", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/36", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// با دادن یک عدد صحیح مثبت N، مجموع کل رقم های آن در سیستم دو برگردانده می شود.\n// \n//     مثال:\n//         برای N = 1000، مجموع ارقام برابر با 1 خواهد بود و خروجی \"1\" خواهد بود.\n//         برای N = 150، مجموع ارقام برابر با 6 خواهد بود و خروجی \"110\" خواهد بود.\n//         برای N = 147، مجموع ارقام برابر با 12 خواهد بود و خروجی \"1100\" خواهد بود.\n//     \n//     متغیرها:\n//         @N عدد صحیح\n//              محدودیت ها: 0 ≤ N ≤ 10000.\n//     خروجی:\n//          یک رشته از عدد دودویی.\n// \n// \nfunc solve (N int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := solve(1000)\n\texpected_1 := \"1\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := solve(150)\n\texpected_2 := \"110\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := solve(147)\n\texpected_3 := \"1100\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := solve(333)\n\texpected_4 := \"1001\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := solve(963)\n\texpected_5 := \"10010\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "با دادن یک عدد صحیح مثبت N، مجموع کل رقم های آن در سیستم دو برگردانده می شود.\n\n    مثال:\n        برای N = 1000، مجموع ارقام برابر با 1 خواهد بود و خروجی \"1\" خواهد بود.\n        برای N = 150، مجموع ارقام برابر با 6 خواهد بود و خروجی \"110\" خواهد بود.\n        برای N = 147، مجموع ارقام برابر با 12 خواهد بود و خروجی \"1100\" خواهد بود.\n    \n    متغیرها:\n        @N عدد صحیح\n             محدودیت ها: 0 ≤ N ≤ 10000.\n    خروجی:\n         یک رشته از عدد دودویی.", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/37", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// شما یک داده دو بعدی به عنوان لیست های تو در تو دریافت می کنید که شبیه به ماتریس است، با این حال، برخلاف ماتریس ها، هر ردیف ممکن است شامل تعداد مختلفی ستون باشد. با دادن lst و عدد صحیح x، اعداد صحیح x را در لیست پیدا کرده و لیستی از تاپل ها، [(x1، y1)، (x2، y2) ...] را برگردانید که هر تاپل یک مختصات - (ردیف، ستون)، با شروع از 0 است. مختصات را در ابتدا بر اساس ردیف ها به ترتیب صعودی مرتب کنید. همچنین، مختصات ردیف را بر اساس ستون ها به ترتیب نزولی مرتب کنید.\n// \n// مثال ها:\n// \n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n// \nfunc get_row (lst [][]int, x int) [][]int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}},1)\n\texpected_1 := [][]int{[]int{0, 0}, []int{1, 4}, []int{1, 0}, []int{2, 5}, []int{2, 0}}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}},2)\n\texpected_2 := [][]int{[]int{0, 1}, []int{1, 1}, []int{2, 1}, []int{3, 1}, []int{4, 1}, []int{5, 1}}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}},1)\n\texpected_3 := [][]int{[]int{0, 0}, []int{1, 0}, []int{2, 1}, []int{2, 0}, []int{3, 2}, []int{3, 0}, []int{4, 3}, []int{4, 0}, []int{5, 4}, []int{5, 0}, []int{6, 5}, []int{6, 0}}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := get_row([][]int{},1)\n\texpected_4 := [][]int{}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := get_row([][]int{[]int{1}},2)\n\texpected_5 := [][]int{}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := get_row([][]int{[]int{}, []int{1}, []int{1, 2, 3}},3)\n\texpected_6 := [][]int{[]int{2, 2}}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "شما یک داده دو بعدی به عنوان لیست های تو در تو دریافت می کنید که شبیه به ماتریس است، با این حال، برخلاف ماتریس ها، هر ردیف ممکن است شامل تعداد مختلفی ستون باشد. با دادن lst و عدد صحیح x، اعداد صحیح x را در لیست پیدا کرده و لیستی از تاپل ها، [(x1، y1)، (x2، y2) ...] را برگردانید که هر تاپل یک مختصات - (ردیف، ستون)، با شروع از 0 است. مختصات را در ابتدا بر اساس ردیف ها به ترتیب صعودی مرتب کنید. همچنین، مختصات ردیف را بر اساس ستون ها به ترتیب نزولی مرتب کنید.\n\nمثال ها:", "entry_point": "get_row", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/38", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// شما یک لیست اعداد صحیح دارید.\n// تابع next_smallest() را بنویسید که دومین کوچکترین عنصر لیست را برمی‌گرداند.\n// اگر چنین عنصری وجود نداشته باشد، null برگردانید.\n// next_smallest([1, 2, 3, 4, 5]) == 2\n// next_smallest([5, 1, 4, 3, 2]) == 2\n// next_smallest([]) == None\n// next_smallest([1, 1]) == None\n// \nfunc next_smallest (lst []int) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := next_smallest([]int{1, 2, 3, 4, 5})\n\texpected_1 := 2\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := next_smallest([]int{5, 1, 4, 3, 2})\n\texpected_2 := 2\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := next_smallest([]int{})\n\texpected_3 := nil\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := next_smallest([]int{1, 1})\n\texpected_4 := nil\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := next_smallest([]int{1, 1, 1, 1, 0})\n\texpected_5 := 1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := next_smallest([]int{1, 1})\n\texpected_6 := nil\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := next_smallest([]int{-35, 34, 12, -45})\n\texpected_7 := -35\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "شما یک لیست اعداد صحیح دارید.\nتابع next_smallest() را بنویسید که دومین کوچکترین عنصر لیست را برمی‌گرداند.\nاگر چنین عنصری وجود نداشته باشد، null برگردانید.", "entry_point": "next_smallest", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/39", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// شما یک رشته از کلمات دریافت خواهید کرد و وظیفه شما شمارش تعداد خستگی ها است. خستگی یک جمله است که با کلمه \"من\" شروع می شود. جملات با '.'، '?' یا '!' محدود می شوند.\n// \n//     به عنوان مثال:\n// >>> is_bored(\"Hello world\")\n// 0\n// >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n// 1\n// \nfunc is_bored (S string) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_bored(\"Hello world\")\n\texpected_1 := 0\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_bored(\"Is the sky blue?\")\n\texpected_2 := 0\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_bored(\"I love It !\")\n\texpected_3 := 1\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_bored(\"bIt\")\n\texpected_4 := 0\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_bored(\"I feel good today. I will be productive. will kill It\")\n\texpected_5 := 2\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_bored(\"You and I are going for a walk\")\n\texpected_6 := 0\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "شما یک رشته از کلمات دریافت خواهید کرد و وظیفه شما شمارش تعداد خستگی ها است. خستگی یک جمله است که با کلمه \"من\" شروع می شود. جملات با '.'، '?' یا '!' محدود می شوند.\n\n    به عنوان مثال:", "entry_point": "is_bored", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/40", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// شما یک لیست اعداد صحیح دارید.\n// شما باید بزرگترین مقدار اولیه را پیدا کرده و مجموع ارقام آن را برگردانید.\n// \n// مثال ها:\n// \n// For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n// For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n// For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n// For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n// For lst = [0,81,12,3,1,21] the output should be 3\n// For lst = [0,8,1,2,1,7] the output should be 7\n// \nfunc skjkasdkd (lst []int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n\texpected_1 := 10\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n\texpected_2 := 25\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n\texpected_3 := 13\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n\texpected_4 := 11\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := skjkasdkd([]int{0, 81, 12, 3, 1, 21})\n\texpected_5 := 3\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := skjkasdkd([]int{0, 8, 1, 2, 1, 7})\n\texpected_6 := 7\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := skjkasdkd([]int{8191})\n\texpected_7 := 19\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := skjkasdkd([]int{8191, 123456, 127, 7})\n\texpected_8 := 19\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := skjkasdkd([]int{127, 97, 8192})\n\texpected_9 := 10\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "شما یک لیست اعداد صحیح دارید.\nشما باید بزرگترین مقدار اولیه را پیدا کرده و مجموع ارقام آن را برگردانید.\n\nمثال ها:", "entry_point": "skjkasdkd", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/41", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// با توجه به یک فرهنگ لغت، در صورتی که همه کلیدها رشته‌هایی با حروف کوچک باشند یا همه کلیدها رشته‌هایی با حروف بزرگ باشند، True را برگردانید. در غیر این صورت، False را برگردانید. اگر فرهنگ لغت داده شده خالی باشد، تابع باید False را برگرداند. مثال‌ها:\n// \n// check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n// \nfunc check_dict_case (dict map[interface{}]string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := check_dict_case(map[interface{}]string{ \"p\": \"pineapple\", \"b\": \"banana\",  })\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := check_dict_case(map[interface{}]string{ \"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\",  })\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := check_dict_case(map[interface{}]string{ \"p\": \"pineapple\", 5: \"banana\", \"a\": \"apple\",  })\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := check_dict_case(map[interface{}]string{ \"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\",  })\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := check_dict_case(map[interface{}]string{ \"STATE\": \"NC\", \"ZIP\": \"12345\",  })\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := check_dict_case(map[interface{}]string{ \"fruit\": \"Orange\", \"taste\": \"Sweet\",  })\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := check_dict_case(map[interface{}]string{  })\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "با توجه به یک فرهنگ لغت، در صورتی که همه کلیدها رشته‌هایی با حروف کوچک باشند یا همه کلیدها رشته‌هایی با حروف بزرگ باشند، True را برگردانید. در غیر این صورت، False را برگردانید. اگر فرهنگ لغت داده شده خالی باشد، تابع باید False را برگرداند. مثال‌ها:", "entry_point": "check_dict_case", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/42", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// تابعی بسازید که یک مقدار (رشته) که یک عدد را نشان می‌دهد را بگیرد و نزدیک‌ترین عدد صحیح به آن را برگرداند. اگر عدد از دو عدد صحیح به یک فاصله باشد، آن را به سمت دور از صفر گرد کنید.\n// \n//     مثال‌ها\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// \n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\n// \nfunc closest_integer (value string) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := closest_integer(\"10\")\n\texpected_1 := 10\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := closest_integer(\"14.5\")\n\texpected_2 := 15\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := closest_integer(\"-15.5\")\n\texpected_3 := -16\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := closest_integer(\"15.3\")\n\texpected_4 := 15\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := closest_integer(\"0\")\n\texpected_5 := 0\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "تابعی بسازید که یک مقدار (رشته) که یک عدد را نشان می‌دهد را بگیرد و نزدیک‌ترین عدد صحیح به آن را برگرداند. اگر عدد از دو عدد صحیح به یک فاصله باشد، آن را به سمت دور از صفر گرد کنید.\n\n    مثال‌ها", "entry_point": "closest_integer", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/43", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// با دریافت یک عدد صحیح مثبت n، باید یک توده از n سطح سنگ بسازید.\n//     سطح اول دارای n سنگ است.\n//     تعداد سنگ در سطح بعدی به شرح زیر است:\n//         - اگر n فرد باشد، تعداد سنگ بعدی برابر با بعد بعدی فرد خواهد بود.\n//         - اگر n زوج باشد، تعداد سنگ بعدی برابر با بعد بعدی زوج خواهد بود.\n//     تعداد سنگ در هر سطح را در یک لیست بازگردانید، به طوری که المان در اندیس\n//     i تعداد سنگ در سطح (i+1) را نشان می دهد.\n// \n//     مثال ها:\n// >>> make_a_pile(3)\n// [3, 5, 7]\n// \nfunc make_a_pile (n int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := make_a_pile(3)\n\texpected_1 := []int{3, 5, 7}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := make_a_pile(4)\n\texpected_2 := []int{4, 6, 8, 10}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := make_a_pile(5)\n\texpected_3 := []int{5, 7, 9, 11, 13}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := make_a_pile(6)\n\texpected_4 := []int{6, 8, 10, 12, 14, 16}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := make_a_pile(8)\n\texpected_5 := []int{8, 10, 12, 14, 16, 18, 20, 22}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "با دریافت یک عدد صحیح مثبت n، باید یک توده از n سطح سنگ بسازید.\n    سطح اول دارای n سنگ است.\n    تعداد سنگ در سطح بعدی به شرح زیر است:\n        - اگر n فرد باشد، تعداد سنگ بعدی برابر با بعد بعدی فرد خواهد بود.\n        - اگر n زوج باشد، تعداد سنگ بعدی برابر با بعد بعدی زوج خواهد بود.\n    تعداد سنگ در هر سطح را در یک لیست بازگردانید، به طوری که المان در اندیس\n    i تعداد سنگ در سطح (i+1) را نشان می دهد.\n\n    مثال ها:", "entry_point": "make_a_pile", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/44", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// شما یک رشته از کلمات جدا شده توسط کاما یا فاصله دریافت خواهید کرد. وظیفه شما این است که رشته را به کلمات تقسیم کرده و یک آرایه از کلمات برگردانید.\n// \n//     به عنوان مثال:\n// \n// words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n// words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n// \nfunc words_string (s string) []string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := words_string(\"Hi, my name is John\")\n\texpected_1 := []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := words_string(\"One, two, three, four, five, six\")\n\texpected_2 := []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := words_string(\"Hi, my name\")\n\texpected_3 := []string{\"Hi\", \"my\", \"name\"}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := words_string(\"One,, two, three, four, five, six,\")\n\texpected_4 := []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := words_string(\"\")\n\texpected_5 := []string{}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := words_string(\"ahmed     , gamal\")\n\texpected_6 := []string{\"ahmed\", \"gamal\"}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "شما یک رشته از کلمات جدا شده توسط کاما یا فاصله دریافت خواهید کرد. وظیفه شما این است که رشته را به کلمات تقسیم کرده و یک آرایه از کلمات برگردانید.\n\n    به عنوان مثال:", "entry_point": "words_string", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/45", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// این تابع دو عدد مثبت x و y را می‌گیرد و بزرگترین عدد صحیح زوجی را که در بازه [x، y] قرار دارد، برمی‌گرداند. اگر چنین عددی وجود نداشته باشد، تابع باید -1 را برگرداند.\n// \n//     به عنوان مثال:\n// \n// choose_num(12, 15) = 14\n// choose_num(13, 12) = -1\n// \nfunc choose_num (x int, y int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := choose_num(12,15)\n\texpected_1 := 14\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := choose_num(13,12)\n\texpected_2 := -1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := choose_num(33,12354)\n\texpected_3 := 12354\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := choose_num(5234,5233)\n\texpected_4 := -1\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := choose_num(6,29)\n\texpected_5 := 28\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := choose_num(27,10)\n\texpected_6 := -1\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := choose_num(7,7)\n\texpected_7 := -1\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := choose_num(546,546)\n\texpected_8 := 546\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "این تابع دو عدد مثبت x و y را می‌گیرد و بزرگترین عدد صحیح زوجی را که در بازه [x، y] قرار دارد، برمی‌گرداند. اگر چنین عددی وجود نداشته باشد، تابع باید -1 را برگرداند.\n\n    به عنوان مثال:", "entry_point": "choose_num", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/46", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// شما دو عدد صحیح مثبت n و m را دریافت می‌کنید و وظیفه شما محاسبه میانگین اعداد صحیح از n تا m (شامل n و m) است. پاسخ را به نزدیک‌ترین عدد صحیح گرد کرده و آن را به دودویی تبدیل کنید. اگر n بزرگتر از m باشد، -1 را برگردانید.\n// مثال:\n// \n// rounded_avg(1, 5) => \"0b11\"\n// rounded_avg(7, 5) => -1\n// rounded_avg(10, 20) => \"0b1111\"\n// rounded_avg(20, 33) => \"0b11010\"\n// \nfunc rounded_avg (n int, m int) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := rounded_avg(1,5)\n\texpected_1 := \"0b11\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := rounded_avg(7,13)\n\texpected_2 := \"0b1010\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := rounded_avg(964,977)\n\texpected_3 := \"0b1111001010\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := rounded_avg(996,997)\n\texpected_4 := \"0b1111100100\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := rounded_avg(560,851)\n\texpected_5 := \"0b1011000010\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := rounded_avg(185,546)\n\texpected_6 := \"0b101101110\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := rounded_avg(362,496)\n\texpected_7 := \"0b110101101\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := rounded_avg(350,902)\n\texpected_8 := \"0b1001110010\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := rounded_avg(197,233)\n\texpected_9 := \"0b11010111\"\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := rounded_avg(7,5)\n\texpected_10 := -1\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := rounded_avg(5,1)\n\texpected_11 := -1\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := rounded_avg(5,5)\n\texpected_12 := \"0b101\"\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n}", "language": "go", "description": "شما دو عدد صحیح مثبت n و m را دریافت می‌کنید و وظیفه شما محاسبه میانگین اعداد صحیح از n تا m (شامل n و m) است. پاسخ را به نزدیک‌ترین عدد صحیح گرد کرده و آن را به دودویی تبدیل کنید. اگر n بزرگتر از m باشد، -1 را برگردانید.\nمثال:", "entry_point": "rounded_avg", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/47", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// تابع f را پیاده سازی کنید که n را به عنوان پارامتر دریافت می کند،\n// و یک لیست به اندازه n برمی گرداند، به گونه ای که مقدار المان در اندیس i برابر با فاکتوریل i است اگر i زوج باشد\n// و در غیر این صورت مجموع اعداد از 1 تا i است.\n// i از 1 شروع می شود.\n// فاکتوریل i ضرب اعداد از 1 تا i است (1 * 2 * ... * i).\n// مثال:\n// \n// f(5) == [1, 2, 6, 24, 15]\n// \nfunc f (n int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := f(5)\n\texpected_1 := []int{1, 2, 6, 24, 15}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := f(7)\n\texpected_2 := []int{1, 2, 6, 24, 15, 720, 28}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := f(1)\n\texpected_3 := []int{1}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := f(3)\n\texpected_4 := []int{1, 2, 6}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "تابع f را پیاده سازی کنید که n را به عنوان پارامتر دریافت می کند،\nو یک لیست به اندازه n برمی گرداند، به گونه ای که مقدار المان در اندیس i برابر با فاکتوریل i است اگر i زوج باشد\nو در غیر این صورت مجموع اعداد از 1 تا i است.\ni از 1 شروع می شود.\nفاکتوریل i ضرب اعداد از 1 تا i است (1 * 2 * ... * i).\nمثال:", "entry_point": "f", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/48", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// با توجه به یک عدد صحیح مثبت n، یک tuple را برگردانید که شامل تعداد اعداد پالیندروم زوج و فردی است که در بازه (1، n)، شامل هستند.\n// \n//     مثال 1:\n// \n//         ورودی: 3\n//         خروجی: (1، 2)\n//         توضیحات:\n//         اعداد پالیندروم شامل 1، 2، 3 هستند. یکی از آن‌ها زوج و دوتای دیگر فرد هستند.\n// \n//     مثال 2:\n// \n//         ورودی: 12\n//         خروجی: (4، 6)\n//         توضیحات:\n//         اعداد پالیندروم شامل 1، 2، 3، 4، 5، 6، 7، 8، 9، 11 هستند. چهارتای آن‌ها زوج و 6 تای دیگر فرد هستند.\n// \n//     توجه:\n//         1. 1 <= n <= 10^3\n//         2. توپل برگشتی تعداد اعداد پالیندروم زوج و فردی را به ترتیب دارد.\n// \n// \nfunc even_odd_palindrome (n int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := even_odd_palindrome(123)\n\texpected_1 := []int{8, 13}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := even_odd_palindrome(12)\n\texpected_2 := []int{4, 6}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := even_odd_palindrome(3)\n\texpected_3 := []int{1, 2}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := even_odd_palindrome(63)\n\texpected_4 := []int{6, 8}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := even_odd_palindrome(25)\n\texpected_5 := []int{5, 6}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := even_odd_palindrome(19)\n\texpected_6 := []int{4, 6}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := even_odd_palindrome(9)\n\texpected_7 := []int{4, 5}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := even_odd_palindrome(1)\n\texpected_8 := []int{0, 1}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "با توجه به یک عدد صحیح مثبت n، یک tuple را برگردانید که شامل تعداد اعداد پالیندروم زوج و فردی است که در بازه (1، n)، شامل هستند.\n\n    مثال 1:\n\n        ورودی: 3\n        خروجی: (1، 2)\n        توضیحات:\n        اعداد پالیندروم شامل 1، 2، 3 هستند. یکی از آن‌ها زوج و دوتای دیگر فرد هستند.\n\n    مثال 2:\n\n        ورودی: 12\n        خروجی: (4، 6)\n        توضیحات:\n        اعداد پالیندروم شامل 1، 2، 3، 4، 5، 6، 7، 8، 9، 11 هستند. چهارتای آن‌ها زوج و 6 تای دیگر فرد هستند.\n\n    توجه:\n        1. 1 <= n <= 10^3\n        2. توپل برگشتی تعداد اعداد پالیندروم زوج و فردی را به ترتیب دارد.", "entry_point": "even_odd_palindrome", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/49", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// ما یک آرایه به نام 'arr' از N عدد صحیح arr [1]، arr [2]، ...، arr [N] داریم. اعداد در آرایه به صورت تصادفی مرتب شده اند. وظیفه شما تعیین این است که آیا می توان با انجام عملیات shift به راست بر روی آرایه داده شده آرایه ای را در ترتیب صعودی غیر صعودی بدست آورد یا خیر:\n// \n//     شما مجاز به انجام عملیات shift به راست به تعداد دلخواه هستید.\n//     \n//     یک عملیات shift به راست به معنی جابجایی تمام عناصر آرایه به یک موقعیت به سمت راست است. آخرین عنصر آرایه به موقعیت شروع آرایه یعنی فهرست 0 اندیس منتقل می شود.\n// \n//     اگر با انجام عملیات فوق می توان آرایه مرتب شده را بدست آورد ، آنگاه True را برگردانید در غیر این صورت False را برگردانید.\n//     اگر آرایه داده شده خالی باشد ، True را برگردانید.\n// \n//     توجه: لیست داده شده تضمین می کند که عناصر منحصر به فردی دارد.\n// \n//     به عنوان مثال:\n// \n//     move_one_ball([3، 4، 5، 1، 2]) ==> True\n//     توضیح: با انجام 2 عملیات shift به راست ، می توان برای آرایه داده شده ترتیب صعودی غیر صعودی را بدست آورد.\n//     move_one_ball([3، 5، 4، 1، 2]) ==> False\n//     توضیح: با انجام هر تعداد عملیات shift به راست ، نمی توان برای آرایه داده شده ترتیب صعودی غیر صعودی را بدست آورد.\n// \n// \n// \nfunc move_one_ball (arr []int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := move_one_ball([]int{3, 4, 5, 1, 2})\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := move_one_ball([]int{3, 5, 10, 1, 2})\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := move_one_ball([]int{4, 3, 1, 2})\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := move_one_ball([]int{3, 5, 4, 1, 2})\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := move_one_ball([]int{})\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "ما یک آرایه به نام 'arr' از N عدد صحیح arr [1]، arr [2]، ...، arr [N] داریم. اعداد در آرایه به صورت تصادفی مرتب شده اند. وظیفه شما تعیین این است که آیا می توان با انجام عملیات shift به راست بر روی آرایه داده شده آرایه ای را در ترتیب صعودی غیر صعودی بدست آورد یا خیر:\n\n    شما مجاز به انجام عملیات shift به راست به تعداد دلخواه هستید.\n    \n    یک عملیات shift به راست به معنی جابجایی تمام عناصر آرایه به یک موقعیت به سمت راست است. آخرین عنصر آرایه به موقعیت شروع آرایه یعنی فهرست 0 اندیس منتقل می شود.\n\n    اگر با انجام عملیات فوق می توان آرایه مرتب شده را بدست آورد ، آنگاه True را برگردانید در غیر این صورت False را برگردانید.\n    اگر آرایه داده شده خالی باشد ، True را برگردانید.\n\n    توجه: لیست داده شده تضمین می کند که عناصر منحصر به فردی دارد.\n\n    به عنوان مثال:\n\n    move_one_ball([3، 4، 5، 1، 2]) ==> True\n    توضیح: با انجام 2 عملیات shift به راست ، می توان برای آرایه داده شده ترتیب صعودی غیر صعودی را بدست آورد.\n    move_one_ball([3، 5، 4، 1، 2]) ==> False\n    توضیح: با انجام هر تعداد عملیات shift به راست ، نمی توان برای آرایه داده شده ترتیب صعودی غیر صعودی را بدست آورد.", "entry_point": "move_one_ball", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/50", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// در این مسئله، شما باید یک تابع پیاده سازی کنید که دو لیست از اعداد را دریافت کرده، تعیین می کند که آیا امکان تعویض عناصر بین آنها وجود دارد تا lst1 یک لیست از اعداد زوج باشد یا خیر. هیچ محدودیتی برای تعویض عناصر بین lst1 و lst2 وجود ندارد. اگر امکان تعویض عناصر بین lst1 و lst2 برای تبدیل تمام عناصر lst1 به اعداد زوج وجود داشت، \"YES\" را برگردانید. در غیر این صورت، \"NO\" را برگردانید. به عنوان مثال: exchange([1، 2، 3، 4]، [1، 2، 3، 4]) => \"YES\" exchange([1، 2، 3، 4]، [1، 5، 3، 4]) => \"NO\" فرض می شود که لیست های ورودی خالی نخواهند بود.\n// \n// \nfunc exchange (lst1 []int, lst2 []int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := exchange([]int{1, 2, 3, 4},[]int{1, 2, 3, 4})\n\texpected_1 := \"YES\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := exchange([]int{1, 2, 3, 4},[]int{1, 5, 3, 4})\n\texpected_2 := \"NO\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := exchange([]int{1, 2, 3, 4},[]int{2, 1, 4, 3})\n\texpected_3 := \"YES\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := exchange([]int{5, 7, 3},[]int{2, 6, 4})\n\texpected_4 := \"YES\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := exchange([]int{5, 7, 3},[]int{2, 6, 3})\n\texpected_5 := \"NO\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := exchange([]int{3, 2, 6, 1, 8, 9},[]int{3, 5, 5, 1, 1, 1})\n\texpected_6 := \"NO\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := exchange([]int{100, 200},[]int{200, 200})\n\texpected_7 := \"YES\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "در این مسئله، شما باید یک تابع پیاده سازی کنید که دو لیست از اعداد را دریافت کرده، تعیین می کند که آیا امکان تعویض عناصر بین آنها وجود دارد تا lst1 یک لیست از اعداد زوج باشد یا خیر. هیچ محدودیتی برای تعویض عناصر بین lst1 و lst2 وجود ندارد. اگر امکان تعویض عناصر بین lst1 و lst2 برای تبدیل تمام عناصر lst1 به اعداد زوج وجود داشت، \"YES\" را برگردانید. در غیر این صورت، \"NO\" را برگردانید. به عنوان مثال: exchange([1، 2، 3، 4]، [1، 2، 3، 4]) => \"YES\" exchange([1، 2، 3، 4]، [1، 5، 3، 4]) => \"NO\" فرض می شود که لیست های ورودی خالی نخواهند بود.", "entry_point": "exchange", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/51", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// وظیفه\n//     دو رشته s و c داده شده است، شما باید تمامی حروفی را که در s با هر حرفی در c برابر است، حذف کنید\n//     سپس بررسی کنید که رشته نتیجه شده یک پالیندروم است یا خیر.\n//     یک رشته پالیندروم نامیده می شود اگر به صورت معکوس با خودش برابر باشد.\n//     شما باید یک تاپل شامل رشته نتیجه و True/False برای بررسی برگردانید.\n//     مثال\n//     برای s = \"abcde\"، c = \"ae\"، نتیجه باید ('bcd'،False) باشد\n//     برای s = \"abcdef\"، c = \"b\"، نتیجه باید ('acdef'،False) باشد\n//     برای s = \"abcdedcba\"، c = \"ab\"، نتیجه باید ('cdedc'،True) باشد\n// \n// \nfunc reverse_delete (s string, c string) []interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := reverse_delete(\"abcde\",\"ae\")\n\texpected_1 := []interface{}{\"bcd\", false}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := reverse_delete(\"abcdef\",\"b\")\n\texpected_2 := []interface{}{\"acdef\", false}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := reverse_delete(\"abcdedcba\",\"ab\")\n\texpected_3 := []interface{}{\"cdedc\", true}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := reverse_delete(\"dwik\",\"w\")\n\texpected_4 := []interface{}{\"dik\", false}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := reverse_delete(\"a\",\"a\")\n\texpected_5 := []interface{}{\"\", true}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := reverse_delete(\"abcdedcba\",\"\")\n\texpected_6 := []interface{}{\"abcdedcba\", true}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := reverse_delete(\"abcdedcba\",\"v\")\n\texpected_7 := []interface{}{\"abcdedcba\", true}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := reverse_delete(\"vabba\",\"v\")\n\texpected_8 := []interface{}{\"abba\", true}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := reverse_delete(\"mamma\",\"mia\")\n\texpected_9 := []interface{}{\"\", true}\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "وظیفه\n    دو رشته s و c داده شده است، شما باید تمامی حروفی را که در s با هر حرفی در c برابر است، حذف کنید\n    سپس بررسی کنید که رشته نتیجه شده یک پالیندروم است یا خیر.\n    یک رشته پالیندروم نامیده می شود اگر به صورت معکوس با خودش برابر باشد.\n    شما باید یک تاپل شامل رشته نتیجه و True/False برای بررسی برگردانید.\n    مثال\n    برای s = \"abcde\"، c = \"ae\"، نتیجه باید ('bcd'،False) باشد\n    برای s = \"abcdef\"، c = \"b\"، نتیجه باید ('acdef'،False) باشد\n    برای s = \"abcdedcba\"، c = \"ab\"، نتیجه باید ('cdedc'،True) باشد", "entry_point": "reverse_delete", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/52", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// شما یک شبکه مستطیلی از چاه ها دارید. هر ردیف یک چاه را نشان می دهد و هر 1 در یک ردیف یک واحد آب را نشان می دهد. هر چاه دارای یک سطل متناظر است که می توان از آن برای استخراج آب استفاده کرد و تمام سطل ها دارای ظرفیت یکسان هستند. وظیفه شما استفاده از سطل ها برای خالی کردن چاه ها است. تعداد بارهایی که باید سطل ها را پایین بیاورید را خروجی دهید.\n// \n// مثال ۱:\n//     ورودی:\n//         شبکه: [[0،0،1،0]، [0،1،0،0]، [1،1،1،1]]\n//         ظرفیت سطل: ۱\n//     خروجی: ۶\n// \n// مثال ۲:\n//     ورودی:\n//         شبکه: [[0،0،1،1]، [0،0،0،0]، [1،1،1،1]، [0،1،1،1]]\n//         ظرفیت سطل: ۲\n//     خروجی: ۵\n// \n// مثال ۳:\n//     ورودی:\n//         شبکه: [[0،0،0]، [0،0،0]]\n//         ظرفیت سطل: ۵\n//     خروجی: ۰\n// \n// محدودیت ها:\n//     * تمام چاه ها طول یکسانی دارند\n//     * ۱ <= طول شبکه <= ۱۰^۲\n//     * ۱ <= طول grid [:، ۱] <= ۱۰^۲\n//     * grid [i] [j] -> ۰ | ۱\n//     * ۱ <= ظرفیت <= ۱۰\n// \n// \nfunc max_fill (grid [][]int, capacity int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}},1)\n\texpected_1 := 6\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := max_fill([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}},2)\n\texpected_2 := 5\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}},5)\n\texpected_3 := 0\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := max_fill([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}},2)\n\texpected_4 := 4\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := max_fill([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}},9)\n\texpected_5 := 2\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "شما یک شبکه مستطیلی از چاه ها دارید. هر ردیف یک چاه را نشان می دهد و هر 1 در یک ردیف یک واحد آب را نشان می دهد. هر چاه دارای یک سطل متناظر است که می توان از آن برای استخراج آب استفاده کرد و تمام سطل ها دارای ظرفیت یکسان هستند. وظیفه شما استفاده از سطل ها برای خالی کردن چاه ها است. تعداد بارهایی که باید سطل ها را پایین بیاورید را خروجی دهید.\n\nمثال ۱:\n    ورودی:\n        شبکه: [[0،0،1،0]، [0،1،0،0]، [1،1،1،1]]\n        ظرفیت سطل: ۱\n    خروجی: ۶\n\nمثال ۲:\n    ورودی:\n        شبکه: [[0،0،1،1]، [0،0،0،0]، [1،1،1،1]، [0،1،1،1]]\n        ظرفیت سطل: ۲\n    خروجی: ۵\n\nمثال ۳:\n    ورودی:\n        شبکه: [[0،0،0]، [0،0،0]]\n        ظرفیت سطل: ۵\n    خروجی: ۰\n\nمحدودیت ها:\n    * تمام چاه ها طول یکسانی دارند\n    * ۱ <= طول شبکه <= ۱۰^۲\n    * ۱ <= طول grid [:، ۱] <= ۱۰^۲\n    * grid [i] [j] -> ۰ | ۱\n    * ۱ <= ظرفیت <= ۱۰", "entry_point": "max_fill", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/53", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// با دادن یک رشته s و یک عدد طبیعی n، شما مسئولیت پیاده سازی یک تابع را دارید که لیستی از تمام کلمات رشته s را که دقیقاً n حرف بی صدا دارند، به ترتیبی که این کلمات در رشته s ظاهر می شوند، برمی گرداند. اگر رشته s خالی باشد، تابع باید یک لیست خالی برگرداند. توجه: شما می توانید فرض کنید رشته ورودی فقط شامل حروف و فضاها است.\n//     مثال ها:\n// \n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n// \nfunc select_words (s string, n int) []string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := select_words(\"Mary had a little lamb\",4)\n\texpected_1 := []string{\"little\"}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := select_words(\"Mary had a little lamb\",3)\n\texpected_2 := []string{\"Mary\", \"lamb\"}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := select_words(\"simple white space\",2)\n\texpected_3 := []string{}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := select_words(\"Hello world\",4)\n\texpected_4 := []string{\"world\"}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := select_words(\"Uncle sam\",3)\n\texpected_5 := []string{\"Uncle\"}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := select_words(\"\",4)\n\texpected_6 := []string{}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := select_words(\"a b c d e f\",1)\n\texpected_7 := []string{\"b\", \"c\", \"d\", \"f\"}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "با دادن یک رشته s و یک عدد طبیعی n، شما مسئولیت پیاده سازی یک تابع را دارید که لیستی از تمام کلمات رشته s را که دقیقاً n حرف بی صدا دارند، به ترتیبی که این کلمات در رشته s ظاهر می شوند، برمی گرداند. اگر رشته s خالی باشد، تابع باید یک لیست خالی برگرداند. توجه: شما می توانید فرض کنید رشته ورودی فقط شامل حروف و فضاها است.\n    مثال ها:", "entry_point": "select_words", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/54", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// با دادن یک آرایه از اعداد صحیح و یک عدد صحیح مثبت k، یک لیست مرتب شده با طول k حاوی بزرگترین k عدد در آرایه برگردانید.\n// \n// مثال ۱:\n// \n// ورودی: arr = [-3، -4، 5]، k = 3\n// خروجی: [-4، -3، 5]\n// \n// مثال ۲:\n// \n// ورودی: arr = [4، -4، 4]، k = 2\n// خروجی: [4، 4]\n// \n// مثال ۳:\n// \n// ورودی: arr = [-3، 2، 1، 2، -1، -2، 1]، k = 1\n// خروجی: [2]\n// \n// توجه:\n// ۱. طول آرایه در محدوده [1، 1000] خواهد بود.\n// ۲. عناصر آرایه در محدوده [-1000، 1000] خواهند بود.\n// ۳. 0 <= k <= len(arr)\n// \n// \nfunc maximum (arr []int, k int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := maximum([]int{-3, -4, 5},3)\n\texpected_1 := []int{-4, -3, 5}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := maximum([]int{4, -4, 4},2)\n\texpected_2 := []int{4, 4}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := maximum([]int{-3, 2, 1, 2, -1, -2, 1},1)\n\texpected_3 := []int{2}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := maximum([]int{123, -123, 20, 0, 1, 2, -3},3)\n\texpected_4 := []int{2, 20, 123}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := maximum([]int{-123, 20, 0, 1, 2, -3},4)\n\texpected_5 := []int{0, 1, 2, 20}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := maximum([]int{5, 15, 0, 3, -13, -8, 0},7)\n\texpected_6 := []int{-13, -8, 0, 0, 3, 5, 15}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := maximum([]int{-1, 0, 2, 5, 3, -10},2)\n\texpected_7 := []int{3, 5}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := maximum([]int{1, 0, 5, -7},1)\n\texpected_8 := []int{5}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := maximum([]int{4, -4},2)\n\texpected_9 := []int{-4, 4}\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := maximum([]int{-10, 10},2)\n\texpected_10 := []int{-10, 10}\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := maximum([]int{1, 2, 3, -23, 243, -400, 0},0)\n\texpected_11 := []int{}\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n}", "language": "go", "description": "با دادن یک آرایه از اعداد صحیح و یک عدد صحیح مثبت k، یک لیست مرتب شده با طول k حاوی بزرگترین k عدد در آرایه برگردانید.\n\nمثال ۱:\n\nورودی: arr = [-3، -4، 5]، k = 3\nخروجی: [-4، -3، 5]\n\nمثال ۲:\n\nورودی: arr = [4، -4، 4]، k = 2\nخروجی: [4، 4]\n\nمثال ۳:\n\nورودی: arr = [-3، 2، 1، 2، -1، -2، 1]، k = 1\nخروجی: [2]\n\nتوجه:\n۱. طول آرایه در محدوده [1، 1000] خواهد بود.\n۲. عناصر آرایه در محدوده [-1000، 1000] خواهند بود.\n۳. 0 <= k <= len(arr)", "entry_point": "maximum", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/55", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// با دریافت یک آرایه غیر خالی از اعداد صحیح arr و یک عدد صحیح k، مجموع عناصر با حداکثر دو رقم از اولین k عنصر از arr را برگردانید.\n// \n// مثال:\n// \n//     ورودی: arr = [111، 21، 3، 4000، 5، 6، 7، 8، 9]، k = 4\n//     خروجی: 24 # مجموع 21 + 3\n// \n// محدودیت ها:\n//     1. 1 <= len(arr) <= 100\n//     2. 1 <= k <= len(arr)\n// \n// \nfunc add_elements (arr []int, k int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := add_elements([]int{1, -2, -3, 41, 57, 76, 87, 88, 99},3)\n\texpected_1 := -4\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := add_elements([]int{111, 121, 3, 4000, 5, 6},2)\n\texpected_2 := 0\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := add_elements([]int{11, 21, 3, 90, 5, 6, 7, 8, 9},4)\n\texpected_3 := 125\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9},4)\n\texpected_4 := 24\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := add_elements([]int{1},1)\n\texpected_5 := 1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "با دریافت یک آرایه غیر خالی از اعداد صحیح arr و یک عدد صحیح k، مجموع عناصر با حداکثر دو رقم از اولین k عنصر از arr را برگردانید.\n\nمثال:\n\n    ورودی: arr = [111، 21، 3، 4000، 5، 6، 7، 8، 9]، k = 4\n    خروجی: 24 # مجموع 21 + 3\n\nمحدودیت ها:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)", "entry_point": "add_elements", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/56", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// شما دو بازه داده شده دارید،\n//     که هر بازه شامل یک جفت عدد صحیح است. به عنوان مثال، بازه = (شروع، پایان) = (1، 2).\n//     بازه های داده شده بسته هستند که به این معنی است که بازه (شروع، پایان)\n//     شامل هر دو شروع و پایان است.\n//     برای هر بازه داده شده، فرض می شود که شروع آن کمتر یا مساوی پایان آن است.\n//     وظیفه شما تعیین این است که طول تقاطع این دو بازه\n//     یک عدد اول است یا خیر.\n//     به عنوان مثال، تقاطع بازه ها (1، 3)، (2، 4) (2، 3) است\n//     که طول آن 1 است، که یک عدد اول نیست.\n//     اگر طول تقاطع یک عدد اول باشد، \"YES\" را برگردانید،\n//     در غیر این صورت، \"NO\" را برگردانید.\n//     اگر دو بازه با هم تداخل ندارند، \"NO\" را برگردانید.\n// \n// \n//     [ورودی / خروجی] نمونه:\n// \n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\n// \nfunc intersection (interval1 []int, interval2 []int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := intersection([]int{1, 2},[]int{2, 3})\n\texpected_1 := \"NO\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := intersection([]int{-1, 1},[]int{0, 4})\n\texpected_2 := \"NO\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := intersection([]int{-3, -1},[]int{-5, 5})\n\texpected_3 := \"YES\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := intersection([]int{-2, 2},[]int{-4, 0})\n\texpected_4 := \"YES\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := intersection([]int{-11, 2},[]int{-1, -1})\n\texpected_5 := \"NO\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := intersection([]int{1, 2},[]int{3, 5})\n\texpected_6 := \"NO\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := intersection([]int{1, 2},[]int{1, 2})\n\texpected_7 := \"NO\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := intersection([]int{-2, -2},[]int{-3, -2})\n\texpected_8 := \"NO\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "شما دو بازه داده شده دارید،\n    که هر بازه شامل یک جفت عدد صحیح است. به عنوان مثال، بازه = (شروع، پایان) = (1، 2).\n    بازه های داده شده بسته هستند که به این معنی است که بازه (شروع، پایان)\n    شامل هر دو شروع و پایان است.\n    برای هر بازه داده شده، فرض می شود که شروع آن کمتر یا مساوی پایان آن است.\n    وظیفه شما تعیین این است که طول تقاطع این دو بازه\n    یک عدد اول است یا خیر.\n    به عنوان مثال، تقاطع بازه ها (1، 3)، (2، 4) (2، 3) است\n    که طول آن 1 است، که یک عدد اول نیست.\n    اگر طول تقاطع یک عدد اول باشد، \"YES\" را برگردانید،\n    در غیر این صورت، \"NO\" را برگردانید.\n    اگر دو بازه با هم تداخل ندارند، \"NO\" را برگردانید.\n\n\n    [ورودی / خروجی] نمونه:", "entry_point": "intersection", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/57", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// همه می‌دانند دنباله فیبوناچی، که در چند قرن گذشته توسط ریاضی‌دانان عمیقاً مورد بررسی قرار گرفته است. با این حال، آنچه مردم نمی‌دانند دنباله تریبوناچی است. دنباله تریبوناچی توسط بازگشتی تعریف می‌شود:\n//     tri(1) = 3\n//     tri(n) = 1 + n / 2، اگر n زوج باشد.\n//     tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، اگر n فرد باشد.\n//     به عنوان مثال:\n//     tri(2) = 1 + (2 / 2) = 2\n//     tri(4) = 3\n//     tri(3) = tri(2) + tri(1) + tri(4)\n//            = 2 + 3 + 3 = 8 \n//     شما یک عدد صحیح غیر منفی n را دریافت می‌کنید، شما باید یک لیست از اولین n + 1 عدد دنباله تریبوناچی را برگردانید.\n//     مثال:\n//     tri(3) = [1، 3، 2، 8]\n// \n// \nfunc tri (n int) []interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := tri(3)\n\texpected_1 := []interface{}{1, 3, 2.0, 8.0}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := tri(4)\n\texpected_2 := []interface{}{1, 3, 2.0, 8.0, 3.0}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := tri(5)\n\texpected_3 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := tri(6)\n\texpected_4 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := tri(7)\n\texpected_5 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := tri(8)\n\texpected_6 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := tri(9)\n\texpected_7 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := tri(20)\n\texpected_8 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := tri(0)\n\texpected_9 := []interface{}{1}\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := tri(1)\n\texpected_10 := []interface{}{1, 3}\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "همه می‌دانند دنباله فیبوناچی، که در چند قرن گذشته توسط ریاضی‌دانان عمیقاً مورد بررسی قرار گرفته است. با این حال، آنچه مردم نمی‌دانند دنباله تریبوناچی است. دنباله تریبوناچی توسط بازگشتی تعریف می‌شود:\n    tri(1) = 3\n    tri(n) = 1 + n / 2، اگر n زوج باشد.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، اگر n فرد باشد.\n    به عنوان مثال:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    شما یک عدد صحیح غیر منفی n را دریافت می‌کنید، شما باید یک لیست از اولین n + 1 عدد دنباله تریبوناچی را برگردانید.\n    مثال:\n    tri(3) = [1، 3، 2، 8]", "entry_point": "tri", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/58", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// با دادن یک عدد صحیح مثبت n، حاصلضرب ارقام فرد را برگردانید.\n//     اگر همه ارقام زوج باشند، 0 را برگردانید.\n//     به عنوان مثال:\n// \n// digits(1)  == 1\n// digits(4)  == 0\n// digits(235) == 15\n// \nfunc digits (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := digits(5)\n\texpected_1 := 5\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := digits(54)\n\texpected_2 := 5\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := digits(120)\n\texpected_3 := 1\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := digits(5014)\n\texpected_4 := 5\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := digits(98765)\n\texpected_5 := 315\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := digits(5576543)\n\texpected_6 := 2625\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := digits(2468)\n\texpected_7 := 0\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "با دادن یک عدد صحیح مثبت n، حاصلضرب ارقام فرد را برگردانید.\n    اگر همه ارقام زوج باشند، 0 را برگردانید.\n    به عنوان مثال:", "entry_point": "digits", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/59", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// یک تابع ایجاد کنید که یک رشته را به عنوان ورودی دریافت می کند که فقط شامل براکت های مربعی است.\n// این تابع باید در صورت وجود زیردنباله معتبری از براکت ها که حداقل یک براکت درونی در آن وجود دارد، True را برگرداند.\n// is_nested('[[]]') ➞ True\n// is_nested('[]]]]]]][[[[[]') ➞ False\n// is_nested('[][]') ➞ False\n// is_nested('[]') ➞ False\n// is_nested('[[][]]') ➞ True\n// is_nested('[[]][[') ➞ True\n// \nfunc is_nested (string0 string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_nested(\"[[]]\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_nested(\"[]]]]]]][[[[[]\")\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_nested(\"[][]\")\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_nested(\"[]\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_nested(\"[[[[]]]]\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_nested(\"[]]]]]]]]]]\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_nested(\"[][][[]]\")\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := is_nested(\"[[]\")\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := is_nested(\"[]]\")\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := is_nested(\"[[]][[\")\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := is_nested(\"[[][]]\")\n\texpected_11 := true\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := is_nested(\"\")\n\texpected_12 := false\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := is_nested(\"[[[[[[[[\")\n\texpected_13 := false\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := is_nested(\"]]]]]]]]\")\n\texpected_14 := false\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n}", "language": "go", "description": "یک تابع ایجاد کنید که یک رشته را به عنوان ورودی دریافت می کند که فقط شامل براکت های مربعی است.\nاین تابع باید در صورت وجود زیردنباله معتبری از براکت ها که حداقل یک براکت درونی در آن وجود دارد، True را برگرداند.", "entry_point": "is_nested", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/60", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// شما یک لیست اعداد دارید.\n// شما باید مجموع اعداد مربع شده در لیست داده شده را برگردانید،\n// هر عنصر در لیست را ابتدا به بالاترین عدد صحیح (سقف) گرد کنید.\n// مثال:\n// برای lst = [1،2،3] خروجی باید 14 باشد\n// برای lst = [1،4،9] خروجی باید 98 باشد\n// برای lst = [1،3،5،7] خروجی باید 84 باشد\n// برای lst = [1.4،4.2،0] خروجی باید 29 باشد\n// برای lst = [-2.4،1،1] خروجی باید 6 باشد\n// \n// \n// \n// \nfunc sum_squares (lst []interface{}) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := sum_squares([]interface{}{1, 2, 3})\n\texpected_1 := 14\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := sum_squares([]interface{}{1.0, 2, 3})\n\texpected_2 := 14\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := sum_squares([]interface{}{1, 3, 5, 7})\n\texpected_3 := 84\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := sum_squares([]interface{}{1.4, 4.2, 0})\n\texpected_4 := 29\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := sum_squares([]interface{}{-2.4, 1, 1})\n\texpected_5 := 6\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := sum_squares([]interface{}{100, 1, 15, 2})\n\texpected_6 := 10230\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := sum_squares([]interface{}{10000, 10000})\n\texpected_7 := 200000000\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := sum_squares([]interface{}{-1.4, 4.6, 6.3})\n\texpected_8 := 75\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := sum_squares([]interface{}{-1.4, 17.9, 18.9, 19.9})\n\texpected_9 := 1086\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := sum_squares([]interface{}{0})\n\texpected_10 := 0\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := sum_squares([]interface{}{-1})\n\texpected_11 := 1\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := sum_squares([]interface{}{-1, 1, 0})\n\texpected_12 := 2\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n}", "language": "go", "description": "شما یک لیست اعداد دارید.\nشما باید مجموع اعداد مربع شده در لیست داده شده را برگردانید،\nهر عنصر در لیست را ابتدا به بالاترین عدد صحیح (سقف) گرد کنید.\nمثال:\nبرای lst = [1،2،3] خروجی باید 14 باشد\nبرای lst = [1،4،9] خروجی باید 98 باشد\nبرای lst = [1،3،5،7] خروجی باید 84 باشد\nبرای lst = [1.4،4.2،0] خروجی باید 29 باشد\nبرای lst = [-2.4،1،1] خروجی باید 6 باشد", "entry_point": "sum_squares", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/61", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// تابعی بسازید که در صورتی که آخرین حرف رشته داده شده یک حرف الفبایی باشد و بخشی از یک کلمه نباشد، True برگرداند و در غیر این صورت False.\n// توجه: \"کلمه\" یک گروه از حروف جدا شده توسط فاصله است.\n// \n// مثال ها:\n// \n// check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n// check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n// check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n// check_if_last_char_is_a_letter(\"\") ➞ False \n// \nfunc check_if_last_char_is_a_letter (txt string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := check_if_last_char_is_a_letter(\"apple\")\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := check_if_last_char_is_a_letter(\"apple pi e\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := check_if_last_char_is_a_letter(\"eeeee\")\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := check_if_last_char_is_a_letter(\"A\")\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := check_if_last_char_is_a_letter(\"Pumpkin pie \")\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := check_if_last_char_is_a_letter(\"Pumpkin pie 1\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := check_if_last_char_is_a_letter(\"\")\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := check_if_last_char_is_a_letter(\"eeeee e \")\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := check_if_last_char_is_a_letter(\"apple pie\")\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := check_if_last_char_is_a_letter(\"apple pi e \")\n\texpected_10 := false\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "تابعی بسازید که در صورتی که آخرین حرف رشته داده شده یک حرف الفبایی باشد و بخشی از یک کلمه نباشد، True برگرداند و در غیر این صورت False.\nتوجه: \"کلمه\" یک گروه از حروف جدا شده توسط فاصله است.\n\nمثال ها:", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/62", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// تابعی بسازید که بزرگترین شاخص یک عنصر را که بزرگتر یا مساوی عنصر قبلی آن نیست، برگرداند. اگر چنین عنصری وجود نداشته باشد، -1 را برگردانید. آرایه داده شده شامل مقادیر تکراری نخواهد بود.\n// \n// مثال ها:\n// \n// can_arrange([1,2,4,3,5]) = 3\n// can_arrange([1,2,3]) = -1\n// \nfunc can_arrange (arr []int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := can_arrange([]int{1, 2, 4, 3, 5})\n\texpected_1 := 3\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := can_arrange([]int{1, 2, 4, 5})\n\texpected_2 := -1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := can_arrange([]int{1, 4, 2, 5, 6, 7, 8, 9, 10})\n\texpected_3 := 2\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := can_arrange([]int{4, 8, 5, 7, 3})\n\texpected_4 := 4\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := can_arrange([]int{})\n\texpected_5 := -1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "تابعی بسازید که بزرگترین شاخص یک عنصر را که بزرگتر یا مساوی عنصر قبلی آن نیست، برگرداند. اگر چنین عنصری وجود نداشته باشد، -1 را برگردانید. آرایه داده شده شامل مقادیر تکراری نخواهد بود.\n\nمثال ها:", "entry_point": "can_arrange", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/63", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// تابعی بسازید که یک تاپل (a، b) را برمی گرداند، جایی که 'a' بزرگترین اعداد منفی و 'b' کوچکترین اعداد مثبت در یک لیست است. اگر هیچ عدد منفی یا مثبتی وجود نداشته باشد، آنها را به عنوان None برگردانید.\n// \n// مثال ها:\n// \n// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0]) == (None, None)\n// \nfunc largest_smallest_integers (lst []int) []interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})\n\texpected_1 := []interface{}{nil, 1}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := largest_smallest_integers([]int{2, 4, 1, 3, 5, 7, 0})\n\texpected_2 := []interface{}{nil, 1}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := largest_smallest_integers([]int{1, 3, 2, 4, 5, 6, -2})\n\texpected_3 := []interface{}{-2, 1}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := largest_smallest_integers([]int{4, 5, 3, 6, 2, 7, -7})\n\texpected_4 := []interface{}{-7, 2}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := largest_smallest_integers([]int{7, 3, 8, 4, 9, 2, 5, -9})\n\texpected_5 := []interface{}{-9, 2}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := largest_smallest_integers([]int{})\n\texpected_6 := []interface{}{nil, nil}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := largest_smallest_integers([]int{0})\n\texpected_7 := []interface{}{nil, nil}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := largest_smallest_integers([]int{-1, -3, -5, -6})\n\texpected_8 := []interface{}{-1, nil}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := largest_smallest_integers([]int{-1, -3, -5, -6, 0})\n\texpected_9 := []interface{}{-1, nil}\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := largest_smallest_integers([]int{-6, -4, -4, -3, 1})\n\texpected_10 := []interface{}{-3, 1}\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := largest_smallest_integers([]int{-6, -4, -4, -3, -100, 1})\n\texpected_11 := []interface{}{-3, 1}\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n}", "language": "go", "description": "تابعی بسازید که یک تاپل (a، b) را برمی گرداند، جایی که 'a' بزرگترین اعداد منفی و 'b' کوچکترین اعداد مثبت در یک لیست است. اگر هیچ عدد منفی یا مثبتی وجود نداشته باشد، آنها را به عنوان None برگردانید.\n\nمثال ها:", "entry_point": "largest_smallest_integers", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/64", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// فاکتوریل برزیلی به شکل زیر تعریف می‌شود:\n//     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n//     که در آن n > 0\n// \n//     به عنوان مثال:\n// >>> special_factorial(4)\n// 288\n// \n// The function will receive an integer as input and should return the special\n// factorial of this integer.\n// \nfunc special_factorial (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := special_factorial(4)\n\texpected_1 := 288\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := special_factorial(5)\n\texpected_2 := 34560\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := special_factorial(7)\n\texpected_3 := 125411328000\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := special_factorial(1)\n\texpected_4 := 1\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "فاکتوریل برزیلی به شکل زیر تعریف می‌شود:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    که در آن n > 0\n\n    به عنوان مثال:", "entry_point": "special_factorial", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/65", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// شما یک رشته به عنوان جمله دریافت می‌کنید،\n//     جمله شامل برخی کلمات جدا شده با یک فضا است،\n//     و شما باید یک رشته برگردانید که شامل کلمات از جمله اصلی باشد،\n//     که طول آن‌ها اعداد اول هستند،\n//     ترتیب کلمات در رشته جدید باید همانند اصلی باشد.\n// \n//     مثال ۱:\n//         ورودی: جمله = \"This is a test\"\n//         خروجی: \"is\"\n// \n//     مثال ۲:\n//         ورودی: جمله = \"lets go for swimming\"\n//         خروجی: \"go for\"\n// \n//     محدودیت‌ها:\n//         * ۱ <= len(sentence) <= ۱۰۰\n//         * جمله فقط شامل حروف است.\n// \n// \nfunc words_in_sentence (sentence string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := words_in_sentence(\"This is a test\")\n\texpected_1 := \"is\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := words_in_sentence(\"lets go for swimming\")\n\texpected_2 := \"go for\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := words_in_sentence(\"there is no place available here\")\n\texpected_3 := \"there is no place\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := words_in_sentence(\"Hi I am Hussein\")\n\texpected_4 := \"Hi am Hussein\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := words_in_sentence(\"go for it\")\n\texpected_5 := \"go for it\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := words_in_sentence(\"here\")\n\texpected_6 := \"\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := words_in_sentence(\"here is\")\n\texpected_7 := \"is\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "شما یک رشته به عنوان جمله دریافت می‌کنید،\n    جمله شامل برخی کلمات جدا شده با یک فضا است،\n    و شما باید یک رشته برگردانید که شامل کلمات از جمله اصلی باشد،\n    که طول آن‌ها اعداد اول هستند،\n    ترتیب کلمات در رشته جدید باید همانند اصلی باشد.\n\n    مثال ۱:\n        ورودی: جمله = \"This is a test\"\n        خروجی: \"is\"\n\n    مثال ۲:\n        ورودی: جمله = \"lets go for swimming\"\n        خروجی: \"go for\"\n\n    محدودیت‌ها:\n        * ۱ <= len(sentence) <= ۱۰۰\n        * جمله فقط شامل حروف است.", "entry_point": "words_in_sentence", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/66", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// وظیفه شما پیاده سازی یک تابع است که عبارت x * n را ساده سازی می کند. اگر x * n به یک عدد صحیح تبدیل شود، تابع True را برمی گرداند و در غیر این صورت False. هر دو x و n، نمایش رشته ای یک کسر هستند و فرمت آنها به شرح زیر است، <شمارنده>/<مخرج> که هر دو شمارنده و مخرج اعداد صحیح مثبت هستند.\n// \n// می توانید فرض کنید که x و n کسرهای معتبری هستند و صفر به عنوان مخرج ندارند.\n// simplify(\"1/5\", \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\", \"10/2\") = False\n// \nfunc simplify (x string, n string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := simplify(\"1/5\",\"5/1\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := simplify(\"1/6\",\"2/1\")\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := simplify(\"5/1\",\"3/1\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := simplify(\"7/10\",\"10/2\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := simplify(\"2/10\",\"50/10\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := simplify(\"7/2\",\"4/2\")\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := simplify(\"11/6\",\"6/1\")\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := simplify(\"2/3\",\"5/2\")\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := simplify(\"5/2\",\"3/5\")\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := simplify(\"2/4\",\"8/4\")\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := simplify(\"2/4\",\"4/2\")\n\texpected_11 := true\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := simplify(\"1/5\",\"5/1\")\n\texpected_12 := true\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := simplify(\"1/5\",\"1/5\")\n\texpected_13 := false\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n}", "language": "go", "description": "وظیفه شما پیاده سازی یک تابع است که عبارت x * n را ساده سازی می کند. اگر x * n به یک عدد صحیح تبدیل شود، تابع True را برمی گرداند و در غیر این صورت False. هر دو x و n، نمایش رشته ای یک کسر هستند و فرمت آنها به شرح زیر است، <شمارنده>/<مخرج> که هر دو شمارنده و مخرج اعداد صحیح مثبت هستند.\n\nمی توانید فرض کنید که x و n کسرهای معتبری هستند و صفر به عنوان مخرج ندارند.", "entry_point": "simplify", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/67", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// یک تابع بنویسید که لیست داده شده از اعداد صحیح را بر اساس مجموع ارقام آنها به ترتیب صعودی مرتب کند. توجه: اگر چند مورد با مجموع مشابه از ارقام آنها وجود داشته باشد، آنها را بر اساس شاخص آنها در لیست اصلی مرتب کنید.\n// \n//     به عنوان مثال:\n// >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n// >>> order_by_points([]) == []\n// \nfunc order_by_points (nums []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := order_by_points([]int{1, 11, -1, -11, -12})\n\texpected_1 := []int{-1, -11, 1, -12, 11}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := order_by_points([]int{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46})\n\texpected_2 := []int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := order_by_points([]int{})\n\texpected_3 := []int{}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := order_by_points([]int{1, -11, -32, 43, 54, -98, 2, -3})\n\texpected_4 := []int{-3, -32, -98, -11, 1, 2, 43, 54}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := order_by_points([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11})\n\texpected_5 := []int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := order_by_points([]int{0, 6, 6, -76, -21, 23, 4})\n\texpected_6 := []int{-76, -21, 0, 4, 23, 6, 6}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "یک تابع بنویسید که لیست داده شده از اعداد صحیح را بر اساس مجموع ارقام آنها به ترتیب صعودی مرتب کند. توجه: اگر چند مورد با مجموع مشابه از ارقام آنها وجود داشته باشد، آنها را بر اساس شاخص آنها در لیست اصلی مرتب کنید.\n\n    به عنوان مثال:", "entry_point": "order_by_points", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/68", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// یک تابع بنویسید که یک آرایه از اعداد را به عنوان ورودی دریافت کرده و تعداد عناصر آرایه را که بزرگتر از 10 هستند و هر دو رقم اول و آخر یک عدد فرد هستند (1، 3، 5، 7، 9) برمی گرداند. به عنوان مثال:\n// \n// specialFilter([15, -73, 14, -15]) => 1 \n// specialFilter([33, -2, -3, 45, 21, 109]) => 2\n// \nfunc specialFilter (nums []int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := specialFilter([]int{5, -2, 1, -5})\n\texpected_1 := 0\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := specialFilter([]int{15, -73, 14, -15})\n\texpected_2 := 1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := specialFilter([]int{33, -2, -3, 45, 21, 109})\n\texpected_3 := 2\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := specialFilter([]int{43, -12, 93, 125, 121, 109})\n\texpected_4 := 4\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := specialFilter([]int{71, -2, -33, 75, 21, 19})\n\texpected_5 := 3\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := specialFilter([]int{1})\n\texpected_6 := 0\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := specialFilter([]int{})\n\texpected_7 := 0\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "یک تابع بنویسید که یک آرایه از اعداد را به عنوان ورودی دریافت کرده و تعداد عناصر آرایه را که بزرگتر از 10 هستند و هر دو رقم اول و آخر یک عدد فرد هستند (1، 3، 5، 7، 9) برمی گرداند. به عنوان مثال:", "entry_point": "specialFilter", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/69", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// شما یک عدد صحیح مثبت n داده شده است. شما باید یک آرایه صحیح a با طول n ایجاد کنید.\n//         برای هر i (1 ≤ i ≤ n)، مقدار a[i] = i * i - i + 1 است.\n//         تعداد سه تایی (a[i]، a[j]، a[k]) از a را که i < j < k و a[i] + a[j] + a[k] بخشی از 3 است، برگردانید.\n// \n//     مثال:\n//         ورودی: n = 5\n//         خروجی: 1\n//         توضیحات:\n//         a = [1، 3، 7، 13، 21]\n//         تنها سه تایی معتبر (1، 7، 13) است.\n// \n// \nfunc get_max_triples (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := get_max_triples(5)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := get_max_triples(6)\n\texpected_2 := 4\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := get_max_triples(10)\n\texpected_3 := 36\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := get_max_triples(100)\n\texpected_4 := 53361\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "شما یک عدد صحیح مثبت n داده شده است. شما باید یک آرایه صحیح a با طول n ایجاد کنید.\n        برای هر i (1 ≤ i ≤ n)، مقدار a[i] = i * i - i + 1 است.\n        تعداد سه تایی (a[i]، a[j]، a[k]) از a را که i < j < k و a[i] + a[j] + a[k] بخشی از 3 است، برگردانید.\n\n    مثال:\n        ورودی: n = 5\n        خروجی: 1\n        توضیحات:\n        a = [1، 3، 7، 13، 21]\n        تنها سه تایی معتبر (1، 7، 13) است.", "entry_point": "get_max_triples", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/70", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// در سیستم شمسی ما هشت سیاره وجود دارد: نزدیک‌ترین سیاره به خورشید \n//     مریخ است، سپس ونوس، زمین، مریخ، مشتری، زحل، \n//     اورانوس و نپتون.\n//     یک تابع بنویسید که دو نام سیاره به عنوان رشته‌های planet1 و planet2 را دریافت کند. \n//     تابع باید یک تاپل حاوی تمام سیاره‌هایی که مدار آن‌ها بین مدار سیاره 1 و مدار سیاره 2 قرار دارد را برگرداند، مرتب شده بر اساس نزدیکی به خورشید. \n//     اگر planet1 یا planet2 نام سیاره صحیح نباشد، تابع باید یک تاپل خالی برگرداند. \n//     مثال‌ها:\n// \n// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n// \nfunc bf (planet1 string, planet2 string) []string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := bf(\"Jupiter\",\"Neptune\")\n\texpected_1 := []string{\"Saturn\", \"Uranus\"}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := bf(\"Earth\",\"Mercury\")\n\texpected_2 := []string{\"Venus\"}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := bf(\"Mercury\",\"Uranus\")\n\texpected_3 := []string{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := bf(\"Neptune\",\"Venus\")\n\texpected_4 := []string{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := bf(\"Earth\",\"Earth\")\n\texpected_5 := []string{}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := bf(\"Mars\",\"Earth\")\n\texpected_6 := []string{}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := bf(\"Jupiter\",\"Makemake\")\n\texpected_7 := []string{}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "در سیستم شمسی ما هشت سیاره وجود دارد: نزدیک‌ترین سیاره به خورشید \n    مریخ است، سپس ونوس، زمین، مریخ، مشتری، زحل، \n    اورانوس و نپتون.\n    یک تابع بنویسید که دو نام سیاره به عنوان رشته‌های planet1 و planet2 را دریافت کند. \n    تابع باید یک تاپل حاوی تمام سیاره‌هایی که مدار آن‌ها بین مدار سیاره 1 و مدار سیاره 2 قرار دارد را برگرداند، مرتب شده بر اساس نزدیکی به خورشید. \n    اگر planet1 یا planet2 نام سیاره صحیح نباشد، تابع باید یک تاپل خالی برگرداند. \n    مثال‌ها:", "entry_point": "bf", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/71", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// یک برنامه ساده که باید مقدار x را برگرداند اگر n یک عدد اول باشد و در غیر این صورت باید مقدار y را برگرداند.\n// \n//     مثال ها:\n// \n// for x_or_y(7, 34, 12) == 34\n// for x_or_y(15, 8, 5) == 5\n// \n// \nfunc x_or_y (n int, x int, y int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := x_or_y(7,34,12)\n\texpected_1 := 34\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := x_or_y(15,8,5)\n\texpected_2 := 5\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := x_or_y(3,33,5212)\n\texpected_3 := 33\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := x_or_y(1259,3,52)\n\texpected_4 := 3\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := x_or_y(7919,-1,12)\n\texpected_5 := -1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := x_or_y(3609,1245,583)\n\texpected_6 := 583\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := x_or_y(91,56,129)\n\texpected_7 := 129\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := x_or_y(6,34,1234)\n\texpected_8 := 1234\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := x_or_y(1,2,0)\n\texpected_9 := 0\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := x_or_y(2,2,0)\n\texpected_10 := 2\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "یک برنامه ساده که باید مقدار x را برگرداند اگر n یک عدد اول باشد و در غیر این صورت باید مقدار y را برگرداند.\n\n    مثال ها:", "entry_point": "x_or_y", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/72", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// با دادن یک لیست از اعداد، مجموع مربعات اعداد فرد در لیست را برگردانید. اعداد منفی یا غیرصحیح را نادیده بگیرید.\n// \n// double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n// double_the_difference([-1, -2, 0]) == 0\n// double_the_difference([9, -2]) == 81\n// double_the_difference([0]) == 0\n// \n// اگر لیست ورودی خالی باشد، 0 را برگردانید.\n// \n// \nfunc double_the_difference (lst []interface{}) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := double_the_difference([]interface{}{})\n\texpected_1 := 0\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := double_the_difference([]interface{}{5, 4})\n\texpected_2 := 25\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := double_the_difference([]interface{}{0.1, 0.2, 0.3})\n\texpected_3 := 0\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := double_the_difference([]interface{}{-10, -20, -30})\n\texpected_4 := 0\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := double_the_difference([]interface{}{-1, -2, 8})\n\texpected_5 := 0\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := double_the_difference([]interface{}{0.2, 3, 5})\n\texpected_6 := 34\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := double_the_difference([]interface{}{-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99})\n\texpected_7 := 166650\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "با دادن یک لیست از اعداد، مجموع مربعات اعداد فرد در لیست را برگردانید. اعداد منفی یا غیرصحیح را نادیده بگیرید.\n\ndouble_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0\n\nاگر لیست ورودی خالی باشد، 0 را برگردانید.", "entry_point": "double_the_difference", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/73", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// شما نام یک کلاس (رشته ای) و یک لیست از افزونه ها را دریافت خواهید کرد.\n//     افزونه ها برای بارگذاری کلاس های اضافی به کلاس استفاده می شوند. قدرت افزونه به شرح زیر است: CAP شماره حروف بزرگ در نام افزونه باشد و SM شماره حروف کوچک در نام افزونه باشد، قدرت با کسر CAP - SM داده می شود.\n//     شما باید قوی ترین افزونه را پیدا کرده و یک رشته در این بازه برگردانید: ClassName.StrongestExtensionName.\n//     اگر دو یا بیشتر از دو افزونه با قدرت یکسان وجود داشته باشد، باید آن را انتخاب کنید که اولین در لیست باشد.\n//     به عنوان مثال، اگر به عنوان کلاس \"Slices\" و لیستی از افزونه ها را به شما داده شود: ['SErviNGSliCes', 'Cheese', 'StuFfed'] ، باید 'Slices.SErviNGSliCes' را برگردانید زیرا 'SErviNGSliCes' قوی ترین افزونه است (قدرت آن -1 است).\n//     مثال:\n// \n// for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n// \nfunc Strongest_Extension (class_name string, extensions []string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := Strongest_Extension(\"Watashi\",[]string{\"tEN\", \"niNE\", \"eIGHt8OKe\"})\n\texpected_1 := \"Watashi.eIGHt8OKe\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := Strongest_Extension(\"Boku123\",[]string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"})\n\texpected_2 := \"Boku123.YEs.WeCaNe\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := Strongest_Extension(\"__YESIMHERE\",[]string{\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"})\n\texpected_3 := \"__YESIMHERE.NuLl__\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := Strongest_Extension(\"K\",[]string{\"Ta\", \"TAR\", \"t234An\", \"cosSo\"})\n\texpected_4 := \"K.TAR\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := Strongest_Extension(\"__HAHA\",[]string{\"Tab\", \"123\", \"781345\", \"-_-\"})\n\texpected_5 := \"__HAHA.123\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := Strongest_Extension(\"YameRore\",[]string{\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"})\n\texpected_6 := \"YameRore.okIWILL123\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := Strongest_Extension(\"finNNalLLly\",[]string{\"Die\", \"NowW\", \"Wow\", \"WoW\"})\n\texpected_7 := \"finNNalLLly.WoW\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := Strongest_Extension(\"_\",[]string{\"Bb\", \"91245\"})\n\texpected_8 := \"_.Bb\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := Strongest_Extension(\"Sp\",[]string{\"671235\", \"Bb\"})\n\texpected_9 := \"Sp.671235\"\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "شما نام یک کلاس (رشته ای) و یک لیست از افزونه ها را دریافت خواهید کرد.\n    افزونه ها برای بارگذاری کلاس های اضافی به کلاس استفاده می شوند. قدرت افزونه به شرح زیر است: CAP شماره حروف بزرگ در نام افزونه باشد و SM شماره حروف کوچک در نام افزونه باشد، قدرت با کسر CAP - SM داده می شود.\n    شما باید قوی ترین افزونه را پیدا کرده و یک رشته در این بازه برگردانید: ClassName.StrongestExtensionName.\n    اگر دو یا بیشتر از دو افزونه با قدرت یکسان وجود داشته باشد، باید آن را انتخاب کنید که اولین در لیست باشد.\n    به عنوان مثال، اگر به عنوان کلاس \"Slices\" و لیستی از افزونه ها را به شما داده شود: ['SErviNGSliCes', 'Cheese', 'StuFfed'] ، باید 'Slices.SErviNGSliCes' را برگردانید زیرا 'SErviNGSliCes' قوی ترین افزونه است (قدرت آن -1 است).\n    مثال:", "entry_point": "Strongest_Extension", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/74", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// شما دو کلمه داده شده است. شما باید در صورتی که کلمه دوم یا هر یک از چرخش های آن به عنوان زیررشته در کلمه اول وجود داشته باشد، True را برگردانید.\n// cycpattern_check(\"abcd\",\"abd\") => False\n// cycpattern_check(\"hello\",\"ell\") => True\n// cycpattern_check(\"whassup\",\"psus\") => False\n// cycpattern_check(\"abab\",\"baa\") => True\n// cycpattern_check(\"efef\",\"eeff\") => False\n// cycpattern_check(\"himenss\",\"simen\") => True\n// \n// \nfunc cycpattern_check (a string, b string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := cycpattern_check(\"xyzw\",\"xyw\")\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := cycpattern_check(\"yello\",\"ell\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := cycpattern_check(\"whattup\",\"ptut\")\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := cycpattern_check(\"efef\",\"fee\")\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := cycpattern_check(\"abab\",\"aabb\")\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := cycpattern_check(\"winemtt\",\"tinem\")\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "شما دو کلمه داده شده است. شما باید در صورتی که کلمه دوم یا هر یک از چرخش های آن به عنوان زیررشته در کلمه اول وجود داشته باشد، True را برگردانید.", "entry_point": "cycpattern_check", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/75", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// با دریافت یک عدد مثبت، معادل عدد رومی آن را به صورت رشته‌ای بدست آورده، و آن را به حروف کوچک برگردانید.\n// محدودیت‌ها: 1 <= num <= 1000\n// \n// مثال‌ها:\n// >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n// >>> int_to_mini_roman(426) == 'cdxxvi'\n// \nfunc int_to_mini_roman (number int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := int_to_mini_roman(19)\n\texpected_1 := \"xix\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := int_to_mini_roman(152)\n\texpected_2 := \"clii\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := int_to_mini_roman(251)\n\texpected_3 := \"ccli\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := int_to_mini_roman(426)\n\texpected_4 := \"cdxxvi\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := int_to_mini_roman(500)\n\texpected_5 := \"d\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := int_to_mini_roman(1)\n\texpected_6 := \"i\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := int_to_mini_roman(4)\n\texpected_7 := \"iv\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := int_to_mini_roman(43)\n\texpected_8 := \"xliii\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := int_to_mini_roman(90)\n\texpected_9 := \"xc\"\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := int_to_mini_roman(94)\n\texpected_10 := \"xciv\"\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := int_to_mini_roman(532)\n\texpected_11 := \"dxxxii\"\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := int_to_mini_roman(900)\n\texpected_12 := \"cm\"\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := int_to_mini_roman(994)\n\texpected_13 := \"cmxciv\"\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := int_to_mini_roman(1000)\n\texpected_14 := \"m\"\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n}", "language": "go", "description": "با دریافت یک عدد مثبت، معادل عدد رومی آن را به صورت رشته‌ای بدست آورده، و آن را به حروف کوچک برگردانید.\nمحدودیت‌ها: 1 <= num <= 1000\n\nمثال‌ها:", "entry_point": "int_to_mini_roman", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/76", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// با توجه به طول سه ضلع مثلث، اگر سه ضلع یک مثلث قائم‌الزاویه را تشکیل دهند، True برگردانده شود و در غیر این صورت False. یک مثلث قائم‌الزاویه، مثلثی است که یکی از زوایای آن زاویه قائمه یا ۹۰ درجه است. مثال:\n// \n// right_angle_triangle(3, 4, 5) == True\n// right_angle_triangle(1, 2, 3) == False\n// \nfunc right_angle_triangle (a int, b int, c int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := right_angle_triangle(3,4,5)\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := right_angle_triangle(1,2,3)\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := right_angle_triangle(10,6,8)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := right_angle_triangle(2,2,2)\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := right_angle_triangle(7,24,25)\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := right_angle_triangle(10,5,7)\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := right_angle_triangle(5,12,13)\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := right_angle_triangle(15,8,17)\n\texpected_8 := true\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := right_angle_triangle(48,55,73)\n\texpected_9 := true\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := right_angle_triangle(1,1,1)\n\texpected_10 := false\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := right_angle_triangle(2,2,10)\n\texpected_11 := false\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n}", "language": "go", "description": "با توجه به طول سه ضلع مثلث، اگر سه ضلع یک مثلث قائم‌الزاویه را تشکیل دهند، True برگردانده شود و در غیر این صورت False. یک مثلث قائم‌الزاویه، مثلثی است که یکی از زوایای آن زاویه قائمه یا ۹۰ درجه است. مثال:", "entry_point": "right_angle_triangle", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/77", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// شما یک رشته s دریافت می‌کنید.\n//     اگر s[i] یک حرف باشد، حالت آن را از کوچک به بزرگ یا برعکس تغییر دهید،\n//     در غیر این صورت آن را به عنوان آن باقی بگذارید.\n//     اگر رشته حاوی هیچ حرفی نباشد، رشته را برعکس کنید.\n//     تابع باید رشته حاصل را برگرداند.\n//     مثالها\n// \n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\n// \nfunc solve (s string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := solve(\"AsDf\")\n\texpected_1 := \"aSdF\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := solve(\"1234\")\n\texpected_2 := \"4321\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := solve(\"ab\")\n\texpected_3 := \"AB\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := solve(\"#a@C\")\n\texpected_4 := \"#A@c\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := solve(\"#AsdfW^45\")\n\texpected_5 := \"#aSDFw^45\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := solve(\"#6@2\")\n\texpected_6 := \"2@6#\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := solve(\"#$a^D\")\n\texpected_7 := \"#$A^d\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := solve(\"#ccc\")\n\texpected_8 := \"#CCC\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "شما یک رشته s دریافت می‌کنید.\n    اگر s[i] یک حرف باشد، حالت آن را از کوچک به بزرگ یا برعکس تغییر دهید،\n    در غیر این صورت آن را به عنوان آن باقی بگذارید.\n    اگر رشته حاوی هیچ حرفی نباشد، رشته را برعکس کنید.\n    تابع باید رشته حاصل را برگرداند.\n    مثالها", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/78", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// با دادن یک رشته 'text'، رشته معادل هش md5 آن را برگردانید. اگر 'text' یک رشته خالی است، null را برگردانید.\n// >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n// \nfunc string_to_md5 (text string) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := string_to_md5(\"Hello world\")\n\texpected_1 := \"3e25960a79dbc69b674cd4ec67a72c62\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := string_to_md5(\"\")\n\texpected_2 := nil\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := string_to_md5(\"A B C\")\n\texpected_3 := \"0ef78513b0cb8cef12743f5aeb35f888\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := string_to_md5(\"password\")\n\texpected_4 := \"5f4dcc3b5aa765d61d8327deb882cf99\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "با دادن یک رشته 'text'، رشته معادل هش md5 آن را برگردانید. اگر 'text' یک رشته خالی است، null را برگردانید.", "entry_point": "string_to_md5", "canonical_solution": NaN, "natural_language": "Persian"}
{"task_id": "go/79", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// شما یک برنامه نویس حرفه ای گولنگ هستید.\n// \n// با داشتن دو عدد مثبت a و b، ارقام زوج بین a و b را به ترتیب صعودی برگردانید.\n// \n//     به عنوان مثال:\n// \n// generate_integers(2, 8) => [2, 4, 6, 8]\n// generate_integers(8, 2) => [2, 4, 6, 8]\n// generate_integers(10, 14) => []\n// \nfunc generate_integers (a int, b int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := generate_integers(2,10)\n\texpected_1 := []int{2, 4, 6, 8}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := generate_integers(10,2)\n\texpected_2 := []int{2, 4, 6, 8}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := generate_integers(132,2)\n\texpected_3 := []int{2, 4, 6, 8}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := generate_integers(17,89)\n\texpected_4 := []int{}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "با داشتن دو عدد مثبت a و b، ارقام زوج بین a و b را به ترتیب صعودی برگردانید.\n\n    به عنوان مثال:", "entry_point": "generate_integers", "canonical_solution": NaN, "natural_language": "Persian"}
