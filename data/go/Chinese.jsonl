{"task_id": "go/0", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 你会得到一个银行账户的存款和取款操作列表，该账户从零余额开始。你的任务是检测账户余额是否在任何时候降至零以下，并在该点返回True。否则应返回False。\n// >>> below_zero([1, 2, 3])\n// False\n// >>> below_zero([1, 2, -4, 5])\n// True\n// \nfunc below_zero (operations []int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := below_zero([]int{})\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := below_zero([]int{1, 2, -3, 1, 2, -3})\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := below_zero([]int{1, 2, -4, 5, 6})\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := below_zero([]int{1, -1, 2, -2, 5, -5, 4, -4})\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := below_zero([]int{1, -1, 2, -2, 5, -5, 4, -5})\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := below_zero([]int{1, -2, 2, -2, 5, -5, 4, -4})\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "你会得到一个银行账户的存款和取款操作列表，该账户从零余额开始。你的任务是检测账户余额是否在任何时候降至零以下，并在该点返回True。否则应返回False。", "entry_point": "below_zero", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/1", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 对于给定的整数列表，返回一个元组，其中包含列表中所有整数的和与积。\n// 空列表的和应该等于0，空列表的积应该等于1。\n// >>> sum_product([])\n// (0, 1)\n// >>> sum_product([1, 2, 3, 4])\n// (10, 24)\n// \nfunc sum_product (numbers []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := sum_product([]int{})\n\texpected_1 := []int{0, 1}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := sum_product([]int{1, 1, 1})\n\texpected_2 := []int{3, 1}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := sum_product([]int{100, 0})\n\texpected_3 := []int{100, 0}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := sum_product([]int{3, 5, 7})\n\texpected_4 := []int{15, 105}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := sum_product([]int{10})\n\texpected_5 := []int{10, 10}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "对于给定的整数列表，返回一个元组，其中包含列表中所有整数的和与积。\n空列表的和应该等于0，空列表的积应该等于1。", "entry_point": "sum_product", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/2", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 输入两个仅由1和0组成的字符串a和b。\n// 对这些输入执行二进制异或，并将结果作为字符串返回。\n// >>> string_xor('010', '110')\n// '100'\n// \nfunc string_xor (a string, b string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := string_xor(\"111000\",\"101010\")\n\texpected_1 := \"010010\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := string_xor(\"1\",\"1\")\n\texpected_2 := \"0\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := string_xor(\"0101\",\"0000\")\n\texpected_3 := \"0101\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n}", "language": "go", "description": "输入两个仅由1和0组成的字符串a和b。\n对这些输入执行二进制异或，并将结果作为字符串返回。", "entry_point": "string_xor", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/3", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 从字符串列表中返回最长的字符串。如果有多个长度相同的字符串，则返回第一个字符串。如果输入列表为空，则返回null。\n// >>> longest([])\n// \n// >>> longest(['a', 'b', 'c'])\n// 'a'\n// >>> longest(['a', 'bb', 'ccc'])\n// 'ccc'\n// \nfunc longest (strings []string) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := longest([]string{})\n\texpected_1 := nil\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := longest([]string{\"x\", \"y\", \"z\"})\n\texpected_2 := \"x\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := longest([]string{\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"})\n\texpected_3 := \"zzzz\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n}", "language": "go", "description": "从字符串列表中返回最长的字符串。如果有多个长度相同的字符串，则返回第一个字符串。如果输入列表为空，则返回null。", "entry_point": "longest", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/4", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 返回两个整数a和b的最大公约数\n// >>> greatest_common_divisor(3, 5)\n// 1\n// >>> greatest_common_divisor(25, 15)\n// 5\n// \nfunc greatest_common_divisor (a int, b int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := greatest_common_divisor(3,7)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := greatest_common_divisor(10,15)\n\texpected_2 := 5\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := greatest_common_divisor(49,14)\n\texpected_3 := 7\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := greatest_common_divisor(144,60)\n\texpected_4 := 12\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "返回两个整数a和b的最大公约数", "entry_point": "greatest_common_divisor", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/5", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 输入一个由“零”到“九”数字组成的以空格分隔的字符串。\n// 有效选择为“零”、“一”、“二”、“三”、“四”、“五”、“六”、“七”、“八”和“九”。\n// 返回按从小到大排序的数字字符串。\n// >>> sort_numbers('three one five')\n// 'one three five'\n// \nfunc sort_numbers (numbers string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := sort_numbers(\"\")\n\texpected_1 := \"\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := sort_numbers(\"three\")\n\texpected_2 := \"three\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := sort_numbers(\"three five nine\")\n\texpected_3 := \"three five nine\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := sort_numbers(\"five zero four seven nine eight\")\n\texpected_4 := \"zero four five seven eight nine\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := sort_numbers(\"six five four three two one zero\")\n\texpected_5 := \"zero one two three four five six\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "输入一个由“零”到“九”数字组成的以空格分隔的字符串。\n有效选择为“零”、“一”、“二”、“三”、“四”、“五”、“六”、“七”、“八”和“九”。\n返回按从小到大排序的数字字符串。", "entry_point": "sort_numbers", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/6", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 给定一个数字列表（至少有两个元素），对该列表应用线性变换，使最小的数字变为0，最大的数字变为1。\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// \nfunc rescale_to_unit (numbers []float64) []float64 {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := rescale_to_unit([]float64{2.0, 49.9})\n\texpected_1 := []float64{0.0, 1.0}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := rescale_to_unit([]float64{100.0, 49.9})\n\texpected_2 := []float64{1.0, 0.0}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n\texpected_3 := []float64{0.0, 0.25, 0.5, 0.75, 1.0}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := rescale_to_unit([]float64{2.0, 1.0, 5.0, 3.0, 4.0})\n\texpected_4 := []float64{0.25, 0.0, 1.0, 0.5, 0.75}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := rescale_to_unit([]float64{12.0, 11.0, 15.0, 13.0, 14.0})\n\texpected_5 := []float64{0.25, 0.0, 1.0, 0.5, 0.75}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "给定一个数字列表（至少有两个元素），对该列表应用线性变换，使最小的数字变为0，最大的数字变为1。", "entry_point": "rescale_to_unit", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/7", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 对于给定的字符串，将小写字符翻转为大写，将大写字符翻转为小写。\n// >>> flip_case('Hello')\n// 'hELLO'\n// \nfunc flip_case (string0 string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := flip_case(\"\")\n\texpected_1 := \"\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := flip_case(\"Hello!\")\n\texpected_2 := \"hELLO!\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := flip_case(\"These violent delights have violent ends\")\n\texpected_3 := \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n}", "language": "go", "description": "对于给定的字符串，将小写字符翻转为大写，将大写字符翻转为小写。", "entry_point": "flip_case", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/8", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 返回列表中仅为正数的数字。\n// >>> get_positive([-1, 2, -4, 5, 6])\n// [2, 5, 6]\n// >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// [5, 3, 2, 3, 9, 123, 1]\n// \nfunc get_positive (l []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := get_positive([]int{-1, -2, 4, 5, 6})\n\texpected_1 := []int{4, 5, 6}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := get_positive([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10})\n\texpected_2 := []int{5, 3, 2, 3, 3, 9, 123, 1}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := get_positive([]int{-1, -2})\n\texpected_3 := []int{}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := get_positive([]int{})\n\texpected_4 := []int{}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "返回列表中仅为正数的数字。", "entry_point": "get_positive", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/9", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 如果给定的数字是质数，则返回true，否则返回false。\n// >>> is_prime(6)\n// False\n// >>> is_prime(101)\n// True\n// >>> is_prime(11)\n// True\n// >>> is_prime(13441)\n// True\n// >>> is_prime(61)\n// True\n// >>> is_prime(4)\n// False\n// >>> is_prime(1)\n// False\n// \nfunc is_prime (n int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_prime(6)\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_prime(101)\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_prime(11)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_prime(13441)\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_prime(61)\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_prime(4)\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_prime(1)\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := is_prime(5)\n\texpected_8 := true\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := is_prime(11)\n\texpected_9 := true\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := is_prime(17)\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := is_prime(85)\n\texpected_11 := false\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := is_prime(77)\n\texpected_12 := false\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := is_prime(255379)\n\texpected_13 := false\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n}", "language": "go", "description": "如果给定的数字是质数，则返回true，否则返回false。", "entry_point": "is_prime", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/10", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 返回列表中排序后的唯一元素\n// >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [0, 2, 3, 5, 9, 123]\n// \nfunc unique (l []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\texpected_1 := []int{0, 2, 3, 5, 9, 123}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n}", "language": "go", "description": "返回列表中排序后的唯一元素", "entry_point": "unique", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/11", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// prime_fib 返回第 n 个既是斐波那契数又是质数的数。\n// >>> prime_fib(1)\n// 2\n// >>> prime_fib(2)\n// 3\n// >>> prime_fib(3)\n// 5\n// >>> prime_fib(4)\n// 13\n// >>> prime_fib(5)\n// 89\n// \nfunc prime_fib (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := prime_fib(1)\n\texpected_1 := 2\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := prime_fib(2)\n\texpected_2 := 3\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := prime_fib(3)\n\texpected_3 := 5\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := prime_fib(4)\n\texpected_4 := 13\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := prime_fib(5)\n\texpected_5 := 89\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := prime_fib(6)\n\texpected_6 := 233\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := prime_fib(7)\n\texpected_7 := 1597\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := prime_fib(8)\n\texpected_8 := 28657\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := prime_fib(9)\n\texpected_9 := 514229\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := prime_fib(10)\n\texpected_10 := 433494437\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "prime_fib 返回第 n 个既是斐波那契数又是质数的数。", "entry_point": "prime_fib", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/12", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// triples_sum_to_zero 接受一个整数列表作为输入。\n// 如果列表中存在三个不同的元素相加等于零，则返回True，否则返回False。\n// >>> triples_sum_to_zero([1, 3, 5, 0])\n// False\n// >>> triples_sum_to_zero([1, 3, -2, 1])\n// True\n// >>> triples_sum_to_zero([1, 2, 3, 7])\n// False\n// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n// True\n// >>> triples_sum_to_zero([1])\n// False\n// \nfunc triples_sum_to_zero (l []int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := triples_sum_to_zero([]int{1, 3, 5, 0})\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := triples_sum_to_zero([]int{1, 3, 5, -1})\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := triples_sum_to_zero([]int{1, 3, -2, 1})\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := triples_sum_to_zero([]int{1, 2, 3, 7})\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := triples_sum_to_zero([]int{1, 2, 5, 7})\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := triples_sum_to_zero([]int{1})\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := triples_sum_to_zero([]int{1, 3, 5, -100})\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := triples_sum_to_zero([]int{100, 3, 5, -100})\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "triples_sum_to_zero 接受一个整数列表作为输入。\n如果列表中存在三个不同的元素相加等于零，则返回True，否则返回False。", "entry_point": "triples_sum_to_zero", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/13", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// pairs_sum_to_zero 接受一个整数列表作为输入。\n// 如果列表中存在两个不同的元素相加等于零，则返回True，否则返回False。\n// >>> pairs_sum_to_zero([1, 3, 5, 0])\n// False\n// >>> pairs_sum_to_zero([1, 3, -2, 1])\n// False\n// >>> pairs_sum_to_zero([1, 2, 3, 7])\n// False\n// >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n// True\n// >>> pairs_sum_to_zero([1])\n// False\n// \nfunc pairs_sum_to_zero (l []int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := pairs_sum_to_zero([]int{1, 3, 5, 0})\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := pairs_sum_to_zero([]int{1, 3, -2, 1})\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := pairs_sum_to_zero([]int{1, 2, 3, 7})\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := pairs_sum_to_zero([]int{1})\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := pairs_sum_to_zero([]int{-3, 9, -1, 3, 2, 30})\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := pairs_sum_to_zero([]int{-3, 9, -1, 3, 2, 31})\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := pairs_sum_to_zero([]int{-3, 9, -1, 4, 2, 30})\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := pairs_sum_to_zero([]int{-3, 9, -1, 4, 2, 31})\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "pairs_sum_to_zero 接受一个整数列表作为输入。\n如果列表中存在两个不同的元素相加等于零，则返回True，否则返回False。", "entry_point": "pairs_sum_to_zero", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/14", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// Fib4数列是一种类似于斐波那契数列的数列，定义如下：\n//     fib4(0) -> 0\n//     fib4(1) -> 0\n//     fib4(2) -> 2\n//     fib4(3) -> 0\n//     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)。\n//     请编写一个函数高效地计算Fib4数列的第n个元素。不要使用递归。\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n// >>> fib4(7)\n// 14\n// \nfunc fib4 (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := fib4(5)\n\texpected_1 := 4\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := fib4(8)\n\texpected_2 := 28\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := fib4(10)\n\texpected_3 := 104\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := fib4(12)\n\texpected_4 := 386\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "Fib4数列是一种类似于斐波那契数列的数列，定义如下：\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)。\n    请编写一个函数高效地计算Fib4数列的第n个元素。不要使用递归。", "entry_point": "fib4", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/15", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 返回列表l中元素的中位数。\n// >>> median([3, 1, 2, 4, 5])\n// 3\n// >>> median([-10, 4, 6, 1000, 10, 20])\n// 15.0\n// \nfunc median (l []int) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := median([]int{3, 1, 2, 4, 5})\n\texpected_1 := 3\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := median([]int{-10, 4, 6, 1000, 10, 20})\n\texpected_2 := 8.0\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := median([]int{5})\n\texpected_3 := 5\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := median([]int{6, 5})\n\texpected_4 := 5.5\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := median([]int{8, 1, 3, 9, 9, 2, 7})\n\texpected_5 := 7\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "返回列表l中元素的中位数。", "entry_point": "median", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/16", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 检查给定的字符串是否为回文。\n// >>> is_palindrome('')\n// True\n// >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n// >>> is_palindrome('zbcd')\n// False\n// \nfunc is_palindrome (text string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_palindrome(\"\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_palindrome(\"aba\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_palindrome(\"aaaaa\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_palindrome(\"zbcd\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_palindrome(\"xywyx\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_palindrome(\"xywyz\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_palindrome(\"xywzx\")\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "检查给定的字符串是否为回文。", "entry_point": "is_palindrome", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/17", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// remove_vowels是一个函数，它接受一个字符串并返回没有元音字母的字符串。\n// >>> remove_vowels('')\n// ''\n// >>> remove_vowels(\"abcdef\\nghijklm\")\n// 'bcdf\\nghjklm'\n// >>> remove_vowels('abcdef')\n// 'bcdf'\n// >>> remove_vowels('aaaaa')\n// ''\n// >>> remove_vowels('aaBAA')\n// 'B'\n// >>> remove_vowels('zbcd')\n// 'zbcd'\n// \nfunc remove_vowels (text string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := remove_vowels(\"\")\n\texpected_1 := \"\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := remove_vowels(\"abcdef\\nghijklm\")\n\texpected_2 := \"bcdf\\nghjklm\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := remove_vowels(\"fedcba\")\n\texpected_3 := \"fdcb\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := remove_vowels(\"eeeee\")\n\texpected_4 := \"\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := remove_vowels(\"acBAA\")\n\texpected_5 := \"cB\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := remove_vowels(\"EcBOO\")\n\texpected_6 := \"cB\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := remove_vowels(\"ybcd\")\n\texpected_7 := \"ybcd\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "remove_vowels是一个函数，它接受一个字符串并返回没有元音字母的字符串。", "entry_point": "remove_vowels", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/18", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 如果列表l中的所有数字都低于阈值t，则返回True。\n// >>> below_threshold([1, 2, 4, 10], 100)\n// True\n// >>> below_threshold([1, 20, 4, 10], 5)\n// False\n// \nfunc below_threshold (l []int, t int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := below_threshold([]int{1, 2, 4, 10},100)\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := below_threshold([]int{1, 20, 4, 10},5)\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := below_threshold([]int{1, 20, 4, 10},21)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := below_threshold([]int{1, 20, 4, 10},22)\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := below_threshold([]int{1, 8, 4, 10},11)\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := below_threshold([]int{1, 8, 4, 10},10)\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "如果列表l中的所有数字都低于阈值t，则返回True。", "entry_point": "below_threshold", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/19", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 添加两个数字 x 和 y\n// >>> add(2, 3)\n// 5\n// >>> add(5, 7)\n// 12\n// \nfunc add (x int, y int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := add(0,1)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := add(1,0)\n\texpected_2 := 1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := add(2,3)\n\texpected_3 := 5\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := add(5,7)\n\texpected_4 := 12\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := add(7,5)\n\texpected_5 := 12\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := add(572,725)\n\texpected_6 := 1297\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := add(51,804)\n\texpected_7 := 855\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := add(645,96)\n\texpected_8 := 741\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := add(712,853)\n\texpected_9 := 1565\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := add(223,101)\n\texpected_10 := 324\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := add(76,29)\n\texpected_11 := 105\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := add(416,149)\n\texpected_12 := 565\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := add(145,409)\n\texpected_13 := 554\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := add(535,430)\n\texpected_14 := 965\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n\tactual_15 := add(118,303)\n\texpected_15 := 421\n\tdeepCompare(actual_15, expected_15, \"Exception --- test case 14 failed to pass\")\n\n\tactual_16 := add(287,94)\n\texpected_16 := 381\n\tdeepCompare(actual_16, expected_16, \"Exception --- test case 15 failed to pass\")\n\n\tactual_17 := add(768,257)\n\texpected_17 := 1025\n\tdeepCompare(actual_17, expected_17, \"Exception --- test case 16 failed to pass\")\n\n\tactual_18 := add(421,677)\n\texpected_18 := 1098\n\tdeepCompare(actual_18, expected_18, \"Exception --- test case 17 failed to pass\")\n\n\tactual_19 := add(802,814)\n\texpected_19 := 1616\n\tdeepCompare(actual_19, expected_19, \"Exception --- test case 18 failed to pass\")\n\n\tactual_20 := add(510,922)\n\texpected_20 := 1432\n\tdeepCompare(actual_20, expected_20, \"Exception --- test case 19 failed to pass\")\n\n\tactual_21 := add(345,819)\n\texpected_21 := 1164\n\tdeepCompare(actual_21, expected_21, \"Exception --- test case 20 failed to pass\")\n\n\tactual_22 := add(895,436)\n\texpected_22 := 1331\n\tdeepCompare(actual_22, expected_22, \"Exception --- test case 21 failed to pass\")\n\n\tactual_23 := add(123,424)\n\texpected_23 := 547\n\tdeepCompare(actual_23, expected_23, \"Exception --- test case 22 failed to pass\")\n\n\tactual_24 := add(923,245)\n\texpected_24 := 1168\n\tdeepCompare(actual_24, expected_24, \"Exception --- test case 23 failed to pass\")\n\n\tactual_25 := add(23,438)\n\texpected_25 := 461\n\tdeepCompare(actual_25, expected_25, \"Exception --- test case 24 failed to pass\")\n\n\tactual_26 := add(565,133)\n\texpected_26 := 698\n\tdeepCompare(actual_26, expected_26, \"Exception --- test case 25 failed to pass\")\n\n\tactual_27 := add(945,925)\n\texpected_27 := 1870\n\tdeepCompare(actual_27, expected_27, \"Exception --- test case 26 failed to pass\")\n\n\tactual_28 := add(261,983)\n\texpected_28 := 1244\n\tdeepCompare(actual_28, expected_28, \"Exception --- test case 27 failed to pass\")\n\n\tactual_29 := add(139,577)\n\texpected_29 := 716\n\tdeepCompare(actual_29, expected_29, \"Exception --- test case 28 failed to pass\")\n\n\tactual_30 := add(763,178)\n\texpected_30 := 941\n\tdeepCompare(actual_30, expected_30, \"Exception --- test case 29 failed to pass\")\n\n\tactual_31 := add(147,892)\n\texpected_31 := 1039\n\tdeepCompare(actual_31, expected_31, \"Exception --- test case 30 failed to pass\")\n\n\tactual_32 := add(436,402)\n\texpected_32 := 838\n\tdeepCompare(actual_32, expected_32, \"Exception --- test case 31 failed to pass\")\n\n\tactual_33 := add(610,581)\n\texpected_33 := 1191\n\tdeepCompare(actual_33, expected_33, \"Exception --- test case 32 failed to pass\")\n\n\tactual_34 := add(103,416)\n\texpected_34 := 519\n\tdeepCompare(actual_34, expected_34, \"Exception --- test case 33 failed to pass\")\n\n\tactual_35 := add(339,990)\n\texpected_35 := 1329\n\tdeepCompare(actual_35, expected_35, \"Exception --- test case 34 failed to pass\")\n\n\tactual_36 := add(130,504)\n\texpected_36 := 634\n\tdeepCompare(actual_36, expected_36, \"Exception --- test case 35 failed to pass\")\n\n\tactual_37 := add(242,717)\n\texpected_37 := 959\n\tdeepCompare(actual_37, expected_37, \"Exception --- test case 36 failed to pass\")\n\n\tactual_38 := add(562,110)\n\texpected_38 := 672\n\tdeepCompare(actual_38, expected_38, \"Exception --- test case 37 failed to pass\")\n\n\tactual_39 := add(396,909)\n\texpected_39 := 1305\n\tdeepCompare(actual_39, expected_39, \"Exception --- test case 38 failed to pass\")\n\n\tactual_40 := add(887,703)\n\texpected_40 := 1590\n\tdeepCompare(actual_40, expected_40, \"Exception --- test case 39 failed to pass\")\n\n\tactual_41 := add(870,551)\n\texpected_41 := 1421\n\tdeepCompare(actual_41, expected_41, \"Exception --- test case 40 failed to pass\")\n\n\tactual_42 := add(422,391)\n\texpected_42 := 813\n\tdeepCompare(actual_42, expected_42, \"Exception --- test case 41 failed to pass\")\n\n\tactual_43 := add(299,505)\n\texpected_43 := 804\n\tdeepCompare(actual_43, expected_43, \"Exception --- test case 42 failed to pass\")\n\n\tactual_44 := add(346,56)\n\texpected_44 := 402\n\tdeepCompare(actual_44, expected_44, \"Exception --- test case 43 failed to pass\")\n\n\tactual_45 := add(36,706)\n\texpected_45 := 742\n\tdeepCompare(actual_45, expected_45, \"Exception --- test case 44 failed to pass\")\n\n\tactual_46 := add(738,411)\n\texpected_46 := 1149\n\tdeepCompare(actual_46, expected_46, \"Exception --- test case 45 failed to pass\")\n\n\tactual_47 := add(679,87)\n\texpected_47 := 766\n\tdeepCompare(actual_47, expected_47, \"Exception --- test case 46 failed to pass\")\n\n\tactual_48 := add(25,303)\n\texpected_48 := 328\n\tdeepCompare(actual_48, expected_48, \"Exception --- test case 47 failed to pass\")\n\n\tactual_49 := add(161,612)\n\texpected_49 := 773\n\tdeepCompare(actual_49, expected_49, \"Exception --- test case 48 failed to pass\")\n\n\tactual_50 := add(306,841)\n\texpected_50 := 1147\n\tdeepCompare(actual_50, expected_50, \"Exception --- test case 49 failed to pass\")\n\n\tactual_51 := add(973,411)\n\texpected_51 := 1384\n\tdeepCompare(actual_51, expected_51, \"Exception --- test case 50 failed to pass\")\n\n\tactual_52 := add(711,157)\n\texpected_52 := 868\n\tdeepCompare(actual_52, expected_52, \"Exception --- test case 51 failed to pass\")\n\n\tactual_53 := add(471,27)\n\texpected_53 := 498\n\tdeepCompare(actual_53, expected_53, \"Exception --- test case 52 failed to pass\")\n\n\tactual_54 := add(714,792)\n\texpected_54 := 1506\n\tdeepCompare(actual_54, expected_54, \"Exception --- test case 53 failed to pass\")\n\n\tactual_55 := add(38,206)\n\texpected_55 := 244\n\tdeepCompare(actual_55, expected_55, \"Exception --- test case 54 failed to pass\")\n\n\tactual_56 := add(907,343)\n\texpected_56 := 1250\n\tdeepCompare(actual_56, expected_56, \"Exception --- test case 55 failed to pass\")\n\n\tactual_57 := add(23,760)\n\texpected_57 := 783\n\tdeepCompare(actual_57, expected_57, \"Exception --- test case 56 failed to pass\")\n\n\tactual_58 := add(524,859)\n\texpected_58 := 1383\n\tdeepCompare(actual_58, expected_58, \"Exception --- test case 57 failed to pass\")\n\n\tactual_59 := add(30,529)\n\texpected_59 := 559\n\tdeepCompare(actual_59, expected_59, \"Exception --- test case 58 failed to pass\")\n\n\tactual_60 := add(341,691)\n\texpected_60 := 1032\n\tdeepCompare(actual_60, expected_60, \"Exception --- test case 59 failed to pass\")\n\n\tactual_61 := add(167,729)\n\texpected_61 := 896\n\tdeepCompare(actual_61, expected_61, \"Exception --- test case 60 failed to pass\")\n\n\tactual_62 := add(636,289)\n\texpected_62 := 925\n\tdeepCompare(actual_62, expected_62, \"Exception --- test case 61 failed to pass\")\n\n\tactual_63 := add(503,144)\n\texpected_63 := 647\n\tdeepCompare(actual_63, expected_63, \"Exception --- test case 62 failed to pass\")\n\n\tactual_64 := add(51,985)\n\texpected_64 := 1036\n\tdeepCompare(actual_64, expected_64, \"Exception --- test case 63 failed to pass\")\n\n\tactual_65 := add(287,149)\n\texpected_65 := 436\n\tdeepCompare(actual_65, expected_65, \"Exception --- test case 64 failed to pass\")\n\n\tactual_66 := add(659,75)\n\texpected_66 := 734\n\tdeepCompare(actual_66, expected_66, \"Exception --- test case 65 failed to pass\")\n\n\tactual_67 := add(462,797)\n\texpected_67 := 1259\n\tdeepCompare(actual_67, expected_67, \"Exception --- test case 66 failed to pass\")\n\n\tactual_68 := add(406,141)\n\texpected_68 := 547\n\tdeepCompare(actual_68, expected_68, \"Exception --- test case 67 failed to pass\")\n\n\tactual_69 := add(106,44)\n\texpected_69 := 150\n\tdeepCompare(actual_69, expected_69, \"Exception --- test case 68 failed to pass\")\n\n\tactual_70 := add(300,934)\n\texpected_70 := 1234\n\tdeepCompare(actual_70, expected_70, \"Exception --- test case 69 failed to pass\")\n\n\tactual_71 := add(471,524)\n\texpected_71 := 995\n\tdeepCompare(actual_71, expected_71, \"Exception --- test case 70 failed to pass\")\n\n\tactual_72 := add(122,429)\n\texpected_72 := 551\n\tdeepCompare(actual_72, expected_72, \"Exception --- test case 71 failed to pass\")\n\n\tactual_73 := add(735,195)\n\texpected_73 := 930\n\tdeepCompare(actual_73, expected_73, \"Exception --- test case 72 failed to pass\")\n\n\tactual_74 := add(335,484)\n\texpected_74 := 819\n\tdeepCompare(actual_74, expected_74, \"Exception --- test case 73 failed to pass\")\n\n\tactual_75 := add(28,809)\n\texpected_75 := 837\n\tdeepCompare(actual_75, expected_75, \"Exception --- test case 74 failed to pass\")\n\n\tactual_76 := add(430,20)\n\texpected_76 := 450\n\tdeepCompare(actual_76, expected_76, \"Exception --- test case 75 failed to pass\")\n\n\tactual_77 := add(916,635)\n\texpected_77 := 1551\n\tdeepCompare(actual_77, expected_77, \"Exception --- test case 76 failed to pass\")\n\n\tactual_78 := add(301,999)\n\texpected_78 := 1300\n\tdeepCompare(actual_78, expected_78, \"Exception --- test case 77 failed to pass\")\n\n\tactual_79 := add(454,466)\n\texpected_79 := 920\n\tdeepCompare(actual_79, expected_79, \"Exception --- test case 78 failed to pass\")\n\n\tactual_80 := add(905,259)\n\texpected_80 := 1164\n\tdeepCompare(actual_80, expected_80, \"Exception --- test case 79 failed to pass\")\n\n\tactual_81 := add(168,205)\n\texpected_81 := 373\n\tdeepCompare(actual_81, expected_81, \"Exception --- test case 80 failed to pass\")\n\n\tactual_82 := add(570,434)\n\texpected_82 := 1004\n\tdeepCompare(actual_82, expected_82, \"Exception --- test case 81 failed to pass\")\n\n\tactual_83 := add(64,959)\n\texpected_83 := 1023\n\tdeepCompare(actual_83, expected_83, \"Exception --- test case 82 failed to pass\")\n\n\tactual_84 := add(957,510)\n\texpected_84 := 1467\n\tdeepCompare(actual_84, expected_84, \"Exception --- test case 83 failed to pass\")\n\n\tactual_85 := add(722,598)\n\texpected_85 := 1320\n\tdeepCompare(actual_85, expected_85, \"Exception --- test case 84 failed to pass\")\n\n\tactual_86 := add(770,226)\n\texpected_86 := 996\n\tdeepCompare(actual_86, expected_86, \"Exception --- test case 85 failed to pass\")\n\n\tactual_87 := add(579,66)\n\texpected_87 := 645\n\tdeepCompare(actual_87, expected_87, \"Exception --- test case 86 failed to pass\")\n\n\tactual_88 := add(117,674)\n\texpected_88 := 791\n\tdeepCompare(actual_88, expected_88, \"Exception --- test case 87 failed to pass\")\n\n\tactual_89 := add(530,30)\n\texpected_89 := 560\n\tdeepCompare(actual_89, expected_89, \"Exception --- test case 88 failed to pass\")\n\n\tactual_90 := add(776,345)\n\texpected_90 := 1121\n\tdeepCompare(actual_90, expected_90, \"Exception --- test case 89 failed to pass\")\n\n\tactual_91 := add(327,389)\n\texpected_91 := 716\n\tdeepCompare(actual_91, expected_91, \"Exception --- test case 90 failed to pass\")\n\n\tactual_92 := add(596,12)\n\texpected_92 := 608\n\tdeepCompare(actual_92, expected_92, \"Exception --- test case 91 failed to pass\")\n\n\tactual_93 := add(599,511)\n\texpected_93 := 1110\n\tdeepCompare(actual_93, expected_93, \"Exception --- test case 92 failed to pass\")\n\n\tactual_94 := add(936,476)\n\texpected_94 := 1412\n\tdeepCompare(actual_94, expected_94, \"Exception --- test case 93 failed to pass\")\n\n\tactual_95 := add(461,14)\n\texpected_95 := 475\n\tdeepCompare(actual_95, expected_95, \"Exception --- test case 94 failed to pass\")\n\n\tactual_96 := add(966,157)\n\texpected_96 := 1123\n\tdeepCompare(actual_96, expected_96, \"Exception --- test case 95 failed to pass\")\n\n\tactual_97 := add(326,91)\n\texpected_97 := 417\n\tdeepCompare(actual_97, expected_97, \"Exception --- test case 96 failed to pass\")\n\n\tactual_98 := add(392,455)\n\texpected_98 := 847\n\tdeepCompare(actual_98, expected_98, \"Exception --- test case 97 failed to pass\")\n\n\tactual_99 := add(446,477)\n\texpected_99 := 923\n\tdeepCompare(actual_99, expected_99, \"Exception --- test case 98 failed to pass\")\n\n\tactual_100 := add(324,860)\n\texpected_100 := 1184\n\tdeepCompare(actual_100, expected_100, \"Exception --- test case 99 failed to pass\")\n\n\tactual_101 := add(945,85)\n\texpected_101 := 1030\n\tdeepCompare(actual_101, expected_101, \"Exception --- test case 100 failed to pass\")\n\n\tactual_102 := add(886,582)\n\texpected_102 := 1468\n\tdeepCompare(actual_102, expected_102, \"Exception --- test case 101 failed to pass\")\n\n\tactual_103 := add(886,712)\n\texpected_103 := 1598\n\tdeepCompare(actual_103, expected_103, \"Exception --- test case 102 failed to pass\")\n\n\tactual_104 := add(842,953)\n\texpected_104 := 1795\n\tdeepCompare(actual_104, expected_104, \"Exception --- test case 103 failed to pass\")\n\n}", "language": "go", "description": "添加两个数字 x 和 y", "entry_point": "add", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/20", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 检查两个单词是否具有相同的字符。\n// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n// True\n// >>> same_chars('abcd', 'dddddddabc')\n// True\n// >>> same_chars('dddddddabc', 'abcd')\n// True\n// >>> same_chars('eabcd', 'dddddddabc')\n// False\n// >>> same_chars('abcd', 'dddddddabce')\n// False\n// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n// False\n// \nfunc same_chars (s0 string, s1 string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := same_chars(\"eabcdzzzz\",\"dddzzzzzzzddeddabc\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := same_chars(\"abcd\",\"dddddddabc\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := same_chars(\"dddddddabc\",\"abcd\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := same_chars(\"eabcd\",\"dddddddabc\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := same_chars(\"abcd\",\"dddddddabcf\")\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := same_chars(\"eabcdzzzz\",\"dddzzzzzzzddddabc\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := same_chars(\"aabb\",\"aaccc\")\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "检查两个单词是否具有相同的字符。", "entry_point": "same_chars", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/21", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 返回第n个斐波那契数。\n// >>> fib(10)\n// 55\n// >>> fib(1)\n// 1\n// >>> fib(8)\n// 21\n// \nfunc fib (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := fib(10)\n\texpected_1 := 55\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := fib(1)\n\texpected_2 := 1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := fib(8)\n\texpected_3 := 21\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := fib(11)\n\texpected_4 := 89\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := fib(12)\n\texpected_5 := 144\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "返回第n个斐波那契数。", "entry_point": "fib", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/22", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 返回两个列表中排序后的唯一公共元素。\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\n// \n// \nfunc common (l1 []int, l2 []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := common([]int{1, 4, 3, 34, 653, 2, 5},[]int{5, 7, 1, 5, 9, 653, 121})\n\texpected_1 := []int{1, 5, 653}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := common([]int{5, 3, 2, 8},[]int{3, 2})\n\texpected_2 := []int{2, 3}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := common([]int{4, 3, 2, 8},[]int{3, 2, 4})\n\texpected_3 := []int{2, 3, 4}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := common([]int{4, 3, 2, 8},[]int{})\n\texpected_4 := []int{}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "返回两个列表中排序后的唯一公共元素。", "entry_point": "common", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/23", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 返回n的最大质因数。假设n>1且不是质数。\n// >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n// 2\n// \nfunc largest_prime_factor (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := largest_prime_factor(15)\n\texpected_1 := 5\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := largest_prime_factor(27)\n\texpected_2 := 3\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := largest_prime_factor(63)\n\texpected_3 := 7\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := largest_prime_factor(330)\n\texpected_4 := 11\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := largest_prime_factor(13195)\n\texpected_5 := 29\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "返回n的最大质因数。假设n>1且不是质数。", "entry_point": "largest_prime_factor", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/24", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// sum_to_n是一个函数，它将从1加到n的数字相加。\n// >>> sum_to_n(30)\n// 465\n// >>> sum_to_n(100)\n// 5050\n// >>> sum_to_n(5)\n// 15\n// >>> sum_to_n(10)\n// 55\n// >>> sum_to_n(1)\n// 1\n// \nfunc sum_to_n (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := sum_to_n(1)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := sum_to_n(6)\n\texpected_2 := 21\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := sum_to_n(11)\n\texpected_3 := 66\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := sum_to_n(30)\n\texpected_4 := 465\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := sum_to_n(100)\n\texpected_5 := 5050\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "sum_to_n是一个函数，它将从1加到n的数字相加。", "entry_point": "sum_to_n", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/25", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// xs表示一个多项式的系数。\n//     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n//     返回该多项式的导数，形式不变。\n// >>> derivative([3, 1, 2, 4, 5])\n// [1, 4, 12, 20]\n// >>> derivative([1, 2, 3])\n// [2, 6]\n// \nfunc derivative (xs []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := derivative([]int{3, 1, 2, 4, 5})\n\texpected_1 := []int{1, 4, 12, 20}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := derivative([]int{1, 2, 3})\n\texpected_2 := []int{2, 6}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := derivative([]int{3, 2, 1})\n\texpected_3 := []int{2, 2}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := derivative([]int{3, 2, 1, 0, 4})\n\texpected_4 := []int{2, 2, 0, 16}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := derivative([]int{1})\n\texpected_5 := []int{}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "xs表示一个多项式的系数。\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    返回该多项式的导数，形式不变。", "entry_point": "derivative", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/26", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// FibFib数列是一种类似于斐波那契数列的数列，定义如下：\n//     fibfib(0) == 0\n//     fibfib(1) == 0\n//     fibfib(2) == 1\n//     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)。\n//     请编写一个函数，高效地计算FibFib数列的第n个元素。\n// >>> fibfib(1)\n// 0\n// >>> fibfib(5)\n// 4\n// >>> fibfib(8)\n// 24\n// \nfunc fibfib (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := fibfib(2)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := fibfib(1)\n\texpected_2 := 0\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := fibfib(5)\n\texpected_3 := 4\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := fibfib(8)\n\texpected_4 := 24\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := fibfib(10)\n\texpected_5 := 81\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := fibfib(12)\n\texpected_6 := 274\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := fibfib(14)\n\texpected_7 := 927\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "FibFib数列是一种类似于斐波那契数列的数列，定义如下：\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)。\n    请编写一个函数，高效地计算FibFib数列的第n个元素。", "entry_point": "fibfib", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/27", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 编写一个函数vowels_count，它接受表示单词的字符串作为输入，并返回字符串中元音字母的数量。在这种情况下，元音字母是'a'，'e'，'i'，'o'，'u'。在这里，'y'也是元音字母，但仅当它在给定单词的末尾时。\n// \n// 例：\n// >>> vowels_count(\"abcde\")\n// 2\n// >>> vowels_count(\"ACEDY\")\n// 3\n// \nfunc vowels_count (s string) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := vowels_count(\"abcde\")\n\texpected_1 := 2\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := vowels_count(\"Alone\")\n\texpected_2 := 3\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := vowels_count(\"key\")\n\texpected_3 := 2\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := vowels_count(\"bye\")\n\texpected_4 := 1\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := vowels_count(\"keY\")\n\texpected_5 := 2\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := vowels_count(\"bYe\")\n\texpected_6 := 1\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := vowels_count(\"ACEDY\")\n\texpected_7 := 3\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "编写一个函数vowels_count，它接受表示单词的字符串作为输入，并返回字符串中元音字母的数量。在这种情况下，元音字母是'a'，'e'，'i'，'o'，'u'。在这里，'y'也是元音字母，但仅当它在给定单词的末尾时。\n\n例：", "entry_point": "vowels_count", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/28", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定一个非空的正整数列表。返回大于零且频率大于或等于该整数本身值的最大整数。整数的频率是它在列表中出现的次数。如果不存在这样的值，则返回-1。示例：\n// \n// search([4, 1, 2, 2, 3, 1]) == 2\n// search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n// search([5, 5, 4, 4, 4]) == -1\n// \nfunc search (lst []int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := search([]int{5, 5, 5, 5, 1})\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := search([]int{4, 1, 4, 1, 4, 4})\n\texpected_2 := 4\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := search([]int{3, 3})\n\texpected_3 := -1\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := search([]int{8, 8, 8, 8, 8, 8, 8, 8})\n\texpected_4 := 8\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := search([]int{2, 3, 3, 2, 2})\n\texpected_5 := 2\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := search([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1})\n\texpected_6 := 1\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := search([]int{3, 2, 8, 2})\n\texpected_7 := 2\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := search([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10})\n\texpected_8 := 1\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := search([]int{8, 8, 3, 6, 5, 6, 4})\n\texpected_9 := -1\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := search([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9})\n\texpected_10 := 1\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := search([]int{1, 9, 10, 1, 3})\n\texpected_11 := 1\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := search([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10})\n\texpected_12 := 5\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := search([]int{1})\n\texpected_13 := 1\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := search([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5})\n\texpected_14 := 4\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n\tactual_15 := search([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10})\n\texpected_15 := 2\n\tdeepCompare(actual_15, expected_15, \"Exception --- test case 14 failed to pass\")\n\n\tactual_16 := search([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3})\n\texpected_16 := 1\n\tdeepCompare(actual_16, expected_16, \"Exception --- test case 15 failed to pass\")\n\n\tactual_17 := search([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4})\n\texpected_17 := 4\n\tdeepCompare(actual_17, expected_17, \"Exception --- test case 16 failed to pass\")\n\n\tactual_18 := search([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7})\n\texpected_18 := 4\n\tdeepCompare(actual_18, expected_18, \"Exception --- test case 17 failed to pass\")\n\n\tactual_19 := search([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1})\n\texpected_19 := 2\n\tdeepCompare(actual_19, expected_19, \"Exception --- test case 18 failed to pass\")\n\n\tactual_20 := search([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8})\n\texpected_20 := -1\n\tdeepCompare(actual_20, expected_20, \"Exception --- test case 19 failed to pass\")\n\n\tactual_21 := search([]int{10})\n\texpected_21 := -1\n\tdeepCompare(actual_21, expected_21, \"Exception --- test case 20 failed to pass\")\n\n\tactual_22 := search([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2})\n\texpected_22 := 2\n\tdeepCompare(actual_22, expected_22, \"Exception --- test case 21 failed to pass\")\n\n\tactual_23 := search([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8})\n\texpected_23 := 1\n\tdeepCompare(actual_23, expected_23, \"Exception --- test case 22 failed to pass\")\n\n\tactual_24 := search([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6})\n\texpected_24 := 1\n\tdeepCompare(actual_24, expected_24, \"Exception --- test case 23 failed to pass\")\n\n\tactual_25 := search([]int{3, 10, 10, 9, 2})\n\texpected_25 := -1\n\tdeepCompare(actual_25, expected_25, \"Exception --- test case 24 failed to pass\")\n\n}", "language": "go", "description": "给定一个非空的正整数列表。返回大于零且频率大于或等于该整数本身值的最大整数。整数的频率是它在列表中出现的次数。如果不存在这样的值，则返回-1。示例：", "entry_point": "search", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/29", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定三角形的三条边长。如果这三条边可以组成一个有效的三角形，则返回保留两位小数的三角形面积。否则返回-1。当任意两条边的和大于第三条边时，三条边才能组成一个有效的三角形。例如：\n// \n// triangle_area(3, 4, 5) == 6.00\n// triangle_area(1, 2, 10) == -1\n// \nfunc triangle_area (a int, b int, c int) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := triangle_area(3,4,5)\n\texpected_1 := 6.0\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := triangle_area(1,2,10)\n\texpected_2 := -1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := triangle_area(4,8,5)\n\texpected_3 := 8.18\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := triangle_area(2,2,2)\n\texpected_4 := 1.73\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := triangle_area(1,2,3)\n\texpected_5 := -1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := triangle_area(10,5,7)\n\texpected_6 := 16.25\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := triangle_area(2,6,3)\n\texpected_7 := -1\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := triangle_area(1,1,1)\n\texpected_8 := 0.43\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := triangle_area(2,2,10)\n\texpected_9 := -1\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "给定三角形的三条边长。如果这三条边可以组成一个有效的三角形，则返回保留两位小数的三角形面积。否则返回-1。当任意两条边的和大于第三条边时，三条边才能组成一个有效的三角形。例如：", "entry_point": "triangle_area", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/30", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 编写一个函数，如果对象q能够飞行则返回True，否则返回False。\n//     如果对象q平衡（它是一个回文列表）且其元素的总和小于或等于最大可能重量w，则对象q将飞行。\n// \n//     示例：\n//     will_it_fly([1, 2], 5) ➞ False \n//     # 1+2小于最大可能重量，但不平衡。\n// \n//     will_it_fly([3, 2, 3], 1) ➞ False\n//     # 它是平衡的，但3+2+3大于最大可能重量。\n// \n//     will_it_fly([3, 2, 3], 9) ➞ True\n//     # 3+2+3小于最大可能重量，且平衡。\n// \n//     will_it_fly([3], 5) ➞ True\n//     # 3小于最大可能重量，且平衡。\n// \n// \nfunc will_it_fly (q []int, w int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := will_it_fly([]int{3, 2, 3},9)\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := will_it_fly([]int{1, 2},5)\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := will_it_fly([]int{3},5)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := will_it_fly([]int{3, 2, 3},1)\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := will_it_fly([]int{1, 2, 3},6)\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := will_it_fly([]int{5},5)\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "编写一个函数，如果对象q能够飞行则返回True，否则返回False。\n    如果对象q平衡（它是一个回文列表）且其元素的总和小于或等于最大可能重量w，则对象q将飞行。\n\n    示例：\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2小于最大可能重量，但不平衡。\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # 它是平衡的，但3+2+3大于最大可能重量。\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3小于最大可能重量，且平衡。\n\n    will_it_fly([3], 5) ➞ True\n    # 3小于最大可能重量，且平衡。", "entry_point": "will_it_fly", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/31", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 编写一个函数，如果给定的数字是3个质数的乘积，则返回true，否则返回false。已知（a）小于100。示例：\n// \n// is_multiply_prime(30) == True\n// 30 = 2 * 3 * 5\n// \nfunc is_multiply_prime (a int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_multiply_prime(5)\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_multiply_prime(30)\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_multiply_prime(8)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_multiply_prime(10)\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_multiply_prime(125)\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_multiply_prime(105)\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_multiply_prime(126)\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := is_multiply_prime(729)\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := is_multiply_prime(891)\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := is_multiply_prime(1001)\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "编写一个函数，如果给定的数字是3个质数的乘积，则返回true，否则返回false。已知（a）小于100。示例：", "entry_point": "is_multiply_prime", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/32", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 你将会得到一个十进制数，你的任务是将它转换成二进制格式。该函数应该返回一个字符串，每个字符代表一个二进制数。字符串中的每个字符都将是'0'或'1'。\n// \n// 字符串开头和结尾会有额外的字符'db'。这些额外的字符是为了帮助格式化。\n// \n// 例子：\n// \n// decimal_to_binary(15)   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\n// \nfunc decimal_to_binary (decimal int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := decimal_to_binary(0)\n\texpected_1 := \"db0db\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := decimal_to_binary(32)\n\texpected_2 := \"db100000db\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := decimal_to_binary(103)\n\texpected_3 := \"db1100111db\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := decimal_to_binary(15)\n\texpected_4 := \"db1111db\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "你将会得到一个十进制数，你的任务是将它转换成二进制格式。该函数应该返回一个字符串，每个字符代表一个二进制数。字符串中的每个字符都将是'0'或'1'。\n\n字符串开头和结尾会有额外的字符'db'。这些额外的字符是为了帮助格式化。\n\n例子：", "entry_point": "decimal_to_binary", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/33", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 给定一个字符串s。\n// 你的任务是检查该字符串是否快乐。\n// 如果字符串的长度至少为3且每3个连续的字母都不同，则该字符串是快乐的。\n// 例如：\n// \n// is_happy(a) => False\n// is_happy(aa) => False\n// is_happy(abcd) => True\n// is_happy(aabb) => False\n// is_happy(adb) => True\n// is_happy(xyy) => False\n// \nfunc is_happy (s string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_happy(\"a\")\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_happy(\"aa\")\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_happy(\"abcd\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_happy(\"aabb\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_happy(\"adb\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_happy(\"xyy\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_happy(\"iopaxpoi\")\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := is_happy(\"iopaxioi\")\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "给定一个字符串s。\n你的任务是检查该字符串是否快乐。\n如果字符串的长度至少为3且每3个连续的字母都不同，则该字符串是快乐的。\n例如：", "entry_point": "is_happy", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/34", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 这是学期的最后一周，老师需要给学生们打分。老师一直在制定自己的评分算法。唯一的问题是，她丢失了用于评分的代码。她给了你一份学生的GPA清单，你需要编写一个函数，根据以下表格输出字母等级的清单：\n// \n//              GPA       |    Letter grade\n//               4.0                A+\n//             > 3.7                A \n//             > 3.3                A- \n//             > 3.0                B+\n//             > 2.7                B \n//             > 2.3                B-\n//             > 2.0                C+\n//             > 1.7                C\n//             > 1.3                C-\n//             > 1.0                D+ \n//             > 0.7                D \n//             > 0.0                D-\n//               0.0                E\n//     \n// \n//     例如：\n// \n// grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n// \nfunc numerical_letter_grade (grades []interface{}) []string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := numerical_letter_grade([]interface{}{4.0, 3, 1.7, 2, 3.5})\n\texpected_1 := []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := numerical_letter_grade([]interface{}{1.2})\n\texpected_2 := []string{\"D+\"}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := numerical_letter_grade([]interface{}{0.5})\n\texpected_3 := []string{\"D-\"}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := numerical_letter_grade([]interface{}{0.0})\n\texpected_4 := []string{\"E\"}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := numerical_letter_grade([]interface{}{1, 0.3, 1.5, 2.8, 3.3})\n\texpected_5 := []string{\"D\", \"D-\", \"C-\", \"B\", \"B+\"}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := numerical_letter_grade([]interface{}{0, 0.7})\n\texpected_6 := []string{\"E\", \"D-\"}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "这是学期的最后一周，老师需要给学生们打分。老师一直在制定自己的评分算法。唯一的问题是，她丢失了用于评分的代码。她给了你一份学生的GPA清单，你需要编写一个函数，根据以下表格输出字母等级的清单：\n\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    例如：", "entry_point": "numerical_letter_grade", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/35", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 编写一个函数，它接受一个字符串并返回True，如果字符串长度是一个质数，否则返回False。\n// 示例：\n// \n// prime_length('Hello') == True\n// prime_length('abcdcba') == True\n// prime_length('kittens') == True\n// prime_length('orange') == False\n// \nfunc prime_length (string0 string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := prime_length(\"Hello\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := prime_length(\"abcdcba\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := prime_length(\"kittens\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := prime_length(\"orange\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := prime_length(\"wow\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := prime_length(\"world\")\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := prime_length(\"MadaM\")\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := prime_length(\"Wow\")\n\texpected_8 := true\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := prime_length(\"\")\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := prime_length(\"HI\")\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := prime_length(\"go\")\n\texpected_11 := true\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := prime_length(\"gogo\")\n\texpected_12 := false\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := prime_length(\"aaaaaaaaaaaaaaa\")\n\texpected_13 := false\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := prime_length(\"Madam\")\n\texpected_14 := true\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n\tactual_15 := prime_length(\"M\")\n\texpected_15 := false\n\tdeepCompare(actual_15, expected_15, \"Exception --- test case 14 failed to pass\")\n\n\tactual_16 := prime_length(\"0\")\n\texpected_16 := false\n\tdeepCompare(actual_16, expected_16, \"Exception --- test case 15 failed to pass\")\n\n}", "language": "go", "description": "编写一个函数，它接受一个字符串并返回True，如果字符串长度是一个质数，否则返回False。\n示例：", "entry_point": "prime_length", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/36", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 给定一个正整数N，返回其二进制表示下所有数字的总和。\n// \n//     示例\n//         对于N = 1000，数字总和为1，输出应为“1”。\n//         对于N = 150，数字总和为6，输出应为“110”。\n//         对于N = 147，数字总和为12，输出应为“1100”。\n// \n//     变量：\n//         @N 整数\n//              约束条件：0 ≤ N ≤ 10000。\n//     输出：\n//          一个二进制数字的字符串。\n// \n// \nfunc solve (N int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := solve(1000)\n\texpected_1 := \"1\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := solve(150)\n\texpected_2 := \"110\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := solve(147)\n\texpected_3 := \"1100\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := solve(333)\n\texpected_4 := \"1001\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := solve(963)\n\texpected_5 := \"10010\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "给定一个正整数N，返回其二进制表示下所有数字的总和。\n\n    示例\n        对于N = 1000，数字总和为1，输出应为“1”。\n        对于N = 150，数字总和为6，输出应为“110”。\n        对于N = 147，数字总和为12，输出应为“1100”。\n\n    变量：\n        @N 整数\n             约束条件：0 ≤ N ≤ 10000。\n    输出：\n         一个二进制数字的字符串。", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/37", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定一个二维数据，作为嵌套列表，类似于矩阵，但与矩阵不同的是，每行可能包含不同数量的列。给定lst和整数x，在列表中查找整数x，并返回元组列表[(x1，y1)，（x2，y2）...]，使得每个元组都是一个坐标-（行，列），从0开始。最初按行按升序排序坐标。此外，按列按降序排序行的坐标。\n// \n// 例子：\n// \n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n// \nfunc get_row (lst [][]int, x int) [][]int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}},1)\n\texpected_1 := [][]int{[]int{0, 0}, []int{1, 4}, []int{1, 0}, []int{2, 5}, []int{2, 0}}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}},2)\n\texpected_2 := [][]int{[]int{0, 1}, []int{1, 1}, []int{2, 1}, []int{3, 1}, []int{4, 1}, []int{5, 1}}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}},1)\n\texpected_3 := [][]int{[]int{0, 0}, []int{1, 0}, []int{2, 1}, []int{2, 0}, []int{3, 2}, []int{3, 0}, []int{4, 3}, []int{4, 0}, []int{5, 4}, []int{5, 0}, []int{6, 5}, []int{6, 0}}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := get_row([][]int{},1)\n\texpected_4 := [][]int{}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := get_row([][]int{[]int{1}},2)\n\texpected_5 := [][]int{}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := get_row([][]int{[]int{}, []int{1}, []int{1, 2, 3}},3)\n\texpected_6 := [][]int{[]int{2, 2}}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "给定一个二维数据，作为嵌套列表，类似于矩阵，但与矩阵不同的是，每行可能包含不同数量的列。给定lst和整数x，在列表中查找整数x，并返回元组列表[(x1，y1)，（x2，y2）...]，使得每个元组都是一个坐标-（行，列），从0开始。最初按行按升序排序坐标。此外，按列按降序排序行的坐标。\n\n例子：", "entry_point": "get_row", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/38", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 你有一个整数列表。\n// 编写一个函数next_smallest()，返回列表中第二小的元素。\n// 如果没有这样的元素，则返回null。\n// next_smallest([1, 2, 3, 4, 5]) == 2\n// next_smallest([5, 1, 4, 3, 2]) == 2\n// next_smallest([]) == None\n// next_smallest([1, 1]) == None\n// \nfunc next_smallest (lst []int) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := next_smallest([]int{1, 2, 3, 4, 5})\n\texpected_1 := 2\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := next_smallest([]int{5, 1, 4, 3, 2})\n\texpected_2 := 2\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := next_smallest([]int{})\n\texpected_3 := nil\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := next_smallest([]int{1, 1})\n\texpected_4 := nil\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := next_smallest([]int{1, 1, 1, 1, 0})\n\texpected_5 := 1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := next_smallest([]int{1, 1})\n\texpected_6 := nil\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := next_smallest([]int{-35, 34, 12, -45})\n\texpected_7 := -35\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "你有一个整数列表。\n编写一个函数next_smallest()，返回列表中第二小的元素。\n如果没有这样的元素，则返回null。", "entry_point": "next_smallest", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/39", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 你将会得到一个由单词组成的字符串，你的任务是计算无聊的数量。无聊的句子是以单词\"I\"开头的句子。句子以'.'、'?'或'!'为分隔符。\n// \n// 例如：\n// >>> is_bored(\"Hello world\")\n// 0\n// >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n// 1\n// \nfunc is_bored (S string) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_bored(\"Hello world\")\n\texpected_1 := 0\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_bored(\"Is the sky blue?\")\n\texpected_2 := 0\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_bored(\"I love It !\")\n\texpected_3 := 1\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_bored(\"bIt\")\n\texpected_4 := 0\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_bored(\"I feel good today. I will be productive. will kill It\")\n\texpected_5 := 2\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_bored(\"You and I are going for a walk\")\n\texpected_6 := 0\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "你将会得到一个由单词组成的字符串，你的任务是计算无聊的数量。无聊的句子是以单词\"I\"开头的句子。句子以'.'、'?'或'!'为分隔符。\n\n例如：", "entry_point": "is_bored", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/40", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 给定一个整数列表。\n// 你需要找到最大的质数值并返回其数字之和。\n// \n// 例子：\n// \n// For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n// For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n// For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n// For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n// For lst = [0,81,12,3,1,21] the output should be 3\n// For lst = [0,8,1,2,1,7] the output should be 7\n// \nfunc skjkasdkd (lst []int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n\texpected_1 := 10\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n\texpected_2 := 25\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n\texpected_3 := 13\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n\texpected_4 := 11\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := skjkasdkd([]int{0, 81, 12, 3, 1, 21})\n\texpected_5 := 3\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := skjkasdkd([]int{0, 8, 1, 2, 1, 7})\n\texpected_6 := 7\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := skjkasdkd([]int{8191})\n\texpected_7 := 19\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := skjkasdkd([]int{8191, 123456, 127, 7})\n\texpected_8 := 19\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := skjkasdkd([]int{127, 97, 8192})\n\texpected_9 := 10\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "给定一个整数列表。\n你需要找到最大的质数值并返回其数字之和。\n\n例子：", "entry_point": "skjkasdkd", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/41", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定一个字典，如果所有键都是小写字符串或所有键都是大写字符串，则返回True，否则返回False。如果给定的字典为空，则函数应返回False。示例：\n// \n// check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n// \nfunc check_dict_case (dict map[interface{}]string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := check_dict_case(map[interface{}]string{ \"p\": \"pineapple\", \"b\": \"banana\",  })\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := check_dict_case(map[interface{}]string{ \"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\",  })\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := check_dict_case(map[interface{}]string{ \"p\": \"pineapple\", 5: \"banana\", \"a\": \"apple\",  })\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := check_dict_case(map[interface{}]string{ \"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\",  })\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := check_dict_case(map[interface{}]string{ \"STATE\": \"NC\", \"ZIP\": \"12345\",  })\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := check_dict_case(map[interface{}]string{ \"fruit\": \"Orange\", \"taste\": \"Sweet\",  })\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := check_dict_case(map[interface{}]string{  })\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "给定一个字典，如果所有键都是小写字符串或所有键都是大写字符串，则返回True，否则返回False。如果给定的字典为空，则函数应返回False。示例：", "entry_point": "check_dict_case", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/42", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 创建一个函数，它接受一个表示数字的值（字符串），并返回最接近它的整数。如果该数字距离两个整数相等，则将其四舍五入到远离零的方向。\n// \n// 例子：\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// \n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\n// \nfunc closest_integer (value string) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := closest_integer(\"10\")\n\texpected_1 := 10\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := closest_integer(\"14.5\")\n\texpected_2 := 15\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := closest_integer(\"-15.5\")\n\texpected_3 := -16\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := closest_integer(\"15.3\")\n\texpected_4 := 15\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := closest_integer(\"0\")\n\texpected_5 := 0\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "创建一个函数，它接受一个表示数字的值（字符串），并返回最接近它的整数。如果该数字距离两个整数相等，则将其四舍五入到远离零的方向。\n\n例子：", "entry_point": "closest_integer", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/43", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定一个正整数n，你需要建立一个n级的石头堆。\n// 第一层有n个石头。\n// 下一层的石头数量为：\n// - 如果n是奇数，则为下一个奇数。\n// - 如果n是偶数，则为下一个偶数。\n// 返回一个列表，其中索引为i的元素表示第(i+1)层的石头数量。\n// \n// 例子：\n// >>> make_a_pile(3)\n// [3, 5, 7]\n// \nfunc make_a_pile (n int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := make_a_pile(3)\n\texpected_1 := []int{3, 5, 7}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := make_a_pile(4)\n\texpected_2 := []int{4, 6, 8, 10}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := make_a_pile(5)\n\texpected_3 := []int{5, 7, 9, 11, 13}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := make_a_pile(6)\n\texpected_4 := []int{6, 8, 10, 12, 14, 16}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := make_a_pile(8)\n\texpected_5 := []int{8, 10, 12, 14, 16, 18, 20, 22}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "给定一个正整数n，你需要建立一个n级的石头堆。\n第一层有n个石头。\n下一层的石头数量为：\n- 如果n是奇数，则为下一个奇数。\n- 如果n是偶数，则为下一个偶数。\n返回一个列表，其中索引为i的元素表示第(i+1)层的石头数量。\n\n例子：", "entry_point": "make_a_pile", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/44", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 你将会得到一个由逗号或空格分隔的单词字符串。你的任务是将字符串分割成单词并返回一个单词数组。\n// \n// 例如：\n// \n// words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n// words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n// \nfunc words_string (s string) []string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := words_string(\"Hi, my name is John\")\n\texpected_1 := []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := words_string(\"One, two, three, four, five, six\")\n\texpected_2 := []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := words_string(\"Hi, my name\")\n\texpected_3 := []string{\"Hi\", \"my\", \"name\"}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := words_string(\"One,, two, three, four, five, six,\")\n\texpected_4 := []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := words_string(\"\")\n\texpected_5 := []string{}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := words_string(\"ahmed     , gamal\")\n\texpected_6 := []string{\"ahmed\", \"gamal\"}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "你将会得到一个由逗号或空格分隔的单词字符串。你的任务是将字符串分割成单词并返回一个单词数组。\n\n例如：", "entry_point": "words_string", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/45", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 这个函数接受两个正整数x和y，并返回在[x，y]范围内的最大偶数整数。如果没有这样的数字，则函数应返回-1。\n// \n// 例如：\n// \n// choose_num(12, 15) = 14\n// choose_num(13, 12) = -1\n// \nfunc choose_num (x int, y int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := choose_num(12,15)\n\texpected_1 := 14\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := choose_num(13,12)\n\texpected_2 := -1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := choose_num(33,12354)\n\texpected_3 := 12354\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := choose_num(5234,5233)\n\texpected_4 := -1\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := choose_num(6,29)\n\texpected_5 := 28\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := choose_num(27,10)\n\texpected_6 := -1\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := choose_num(7,7)\n\texpected_7 := -1\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := choose_num(546,546)\n\texpected_8 := 546\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "这个函数接受两个正整数x和y，并返回在[x，y]范围内的最大偶数整数。如果没有这样的数字，则函数应返回-1。\n\n例如：", "entry_point": "choose_num", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/46", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 给定两个正整数n和m，你的任务是计算从n到m（包括n和m）的整数的平均值。\n// 将答案四舍五入为最接近的整数，并将其转换为二进制。\n// 如果n大于m，则返回-1。\n// 例子：\n// \n// rounded_avg(1, 5) => \"0b11\"\n// rounded_avg(7, 5) => -1\n// rounded_avg(10, 20) => \"0b1111\"\n// rounded_avg(20, 33) => \"0b11010\"\n// \nfunc rounded_avg (n int, m int) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := rounded_avg(1,5)\n\texpected_1 := \"0b11\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := rounded_avg(7,13)\n\texpected_2 := \"0b1010\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := rounded_avg(964,977)\n\texpected_3 := \"0b1111001010\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := rounded_avg(996,997)\n\texpected_4 := \"0b1111100100\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := rounded_avg(560,851)\n\texpected_5 := \"0b1011000010\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := rounded_avg(185,546)\n\texpected_6 := \"0b101101110\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := rounded_avg(362,496)\n\texpected_7 := \"0b110101101\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := rounded_avg(350,902)\n\texpected_8 := \"0b1001110010\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := rounded_avg(197,233)\n\texpected_9 := \"0b11010111\"\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := rounded_avg(7,5)\n\texpected_10 := -1\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := rounded_avg(5,1)\n\texpected_11 := -1\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := rounded_avg(5,5)\n\texpected_12 := \"0b101\"\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n}", "language": "go", "description": "给定两个正整数n和m，你的任务是计算从n到m（包括n和m）的整数的平均值。\n将答案四舍五入为最接近的整数，并将其转换为二进制。\n如果n大于m，则返回-1。\n例子：", "entry_point": "rounded_avg", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/47", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 实现函数f，它以n为参数，返回一个大小为n的列表，其中索引i处的元素值为i的阶乘（如果i为偶数）或1到i的数字之和（如果i为奇数）。i从1开始。i的阶乘是从1到i的数字的乘积（1 * 2 * ... * i）。例如：\n// \n// f(5) == [1, 2, 6, 24, 15]\n// \nfunc f (n int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := f(5)\n\texpected_1 := []int{1, 2, 6, 24, 15}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := f(7)\n\texpected_2 := []int{1, 2, 6, 24, 15, 720, 28}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := f(1)\n\texpected_3 := []int{1}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := f(3)\n\texpected_4 := []int{1, 2, 6}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "实现函数f，它以n为参数，返回一个大小为n的列表，其中索引i处的元素值为i的阶乘（如果i为偶数）或1到i的数字之和（如果i为奇数）。i从1开始。i的阶乘是从1到i的数字的乘积（1 * 2 * ... * i）。例如：", "entry_point": "f", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/48", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定一个正整数n，返回一个元组，其中包含在范围（1，n）内的偶数和奇数整数回文数的数量。\n// \n//     示例1：\n// \n//         输入：3\n//         输出：（1，2）\n//         说明：\n//         整数回文是1、2、3。其中一个是偶数，两个是奇数。\n// \n//     示例2：\n// \n//         输入：12\n//         输出：（4，6）\n//         说明：\n//         整数回文是1、2、3、4、5、6、7、8、9、11。其中4个是偶数，6个是奇数。\n// \n//     注意：\n//         1. 1 <= n <= 10^3\n//         2. 返回的元组分别是偶数和奇数整数回文数的数量。\n// \n// \nfunc even_odd_palindrome (n int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := even_odd_palindrome(123)\n\texpected_1 := []int{8, 13}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := even_odd_palindrome(12)\n\texpected_2 := []int{4, 6}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := even_odd_palindrome(3)\n\texpected_3 := []int{1, 2}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := even_odd_palindrome(63)\n\texpected_4 := []int{6, 8}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := even_odd_palindrome(25)\n\texpected_5 := []int{5, 6}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := even_odd_palindrome(19)\n\texpected_6 := []int{4, 6}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := even_odd_palindrome(9)\n\texpected_7 := []int{4, 5}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := even_odd_palindrome(1)\n\texpected_8 := []int{0, 1}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "给定一个正整数n，返回一个元组，其中包含在范围（1，n）内的偶数和奇数整数回文数的数量。\n\n    示例1：\n\n        输入：3\n        输出：（1，2）\n        说明：\n        整数回文是1、2、3。其中一个是偶数，两个是奇数。\n\n    示例2：\n\n        输入：12\n        输出：（4，6）\n        说明：\n        整数回文是1、2、3、4、5、6、7、8、9、11。其中4个是偶数，6个是奇数。\n\n    注意：\n        1. 1 <= n <= 10^3\n        2. 返回的元组分别是偶数和奇数整数回文数的数量。", "entry_point": "even_odd_palindrome", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/49", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 我们有一个由N个整数组成的数组'arr'，数组中的数字将是随机排序的。你的任务是确定是否可以通过对给定数组执行以下操作来获得按非递减顺序排序的数组：\n// \n//     您可以执行任意次数的右移操作。\n//     \n//     一个右移操作意味着将数组的所有元素向右移动一个位置。数组的最后一个元素将移动到数组的起始位置，即0号索引。\n// \n//     如果可以通过执行上述操作获得排序后的数组，则返回True，否则返回False。\n//     如果给定的数组为空，则返回True。\n// \n//     注意：给定的列表保证具有唯一元素。\n// \n//     例如：\n//     \n//     move_one_ball([3, 4, 5, 1, 2])==>True\n//     解释：通过执行2次右移操作，可以为给定数组实现非递减顺序。\n//     move_one_ball([3, 5, 4, 1, 2])==>False\n//     解释：通过执行任意数量的右移操作，无法为给定数组获得非递减顺序。\n// \n// \n// \nfunc move_one_ball (arr []int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := move_one_ball([]int{3, 4, 5, 1, 2})\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := move_one_ball([]int{3, 5, 10, 1, 2})\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := move_one_ball([]int{4, 3, 1, 2})\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := move_one_ball([]int{3, 5, 4, 1, 2})\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := move_one_ball([]int{})\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "我们有一个由N个整数组成的数组'arr'，数组中的数字将是随机排序的。你的任务是确定是否可以通过对给定数组执行以下操作来获得按非递减顺序排序的数组：\n\n    您可以执行任意次数的右移操作。\n    \n    一个右移操作意味着将数组的所有元素向右移动一个位置。数组的最后一个元素将移动到数组的起始位置，即0号索引。\n\n    如果可以通过执行上述操作获得排序后的数组，则返回True，否则返回False。\n    如果给定的数组为空，则返回True。\n\n    注意：给定的列表保证具有唯一元素。\n\n    例如：\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    解释：通过执行2次右移操作，可以为给定数组实现非递减顺序。\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    解释：通过执行任意数量的右移操作，无法为给定数组获得非递减顺序。", "entry_point": "move_one_ball", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/50", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 在这个问题中，您将实现一个函数，该函数接受两个数字列表，并确定是否可以执行元素交换，使lst1成为仅包含偶数的列表。在lst1和lst2之间交换元素的数量没有限制。如果可以在lst1和lst2之间交换元素以使lst1的所有元素都是偶数，则返回“YES”。否则，返回“NO”。例如：exchange（[1,2,3,4]，[1,2,3,4]）=>“YES”exchange（[1,2,3,4]，[1,5,3,4]）=>“NO”假定输入列表将不为空。\n// \n// \nfunc exchange (lst1 []int, lst2 []int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := exchange([]int{1, 2, 3, 4},[]int{1, 2, 3, 4})\n\texpected_1 := \"YES\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := exchange([]int{1, 2, 3, 4},[]int{1, 5, 3, 4})\n\texpected_2 := \"NO\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := exchange([]int{1, 2, 3, 4},[]int{2, 1, 4, 3})\n\texpected_3 := \"YES\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := exchange([]int{5, 7, 3},[]int{2, 6, 4})\n\texpected_4 := \"YES\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := exchange([]int{5, 7, 3},[]int{2, 6, 3})\n\texpected_5 := \"NO\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := exchange([]int{3, 2, 6, 1, 8, 9},[]int{3, 5, 5, 1, 1, 1})\n\texpected_6 := \"NO\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := exchange([]int{100, 200},[]int{200, 200})\n\texpected_7 := \"YES\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "在这个问题中，您将实现一个函数，该函数接受两个数字列表，并确定是否可以执行元素交换，使lst1成为仅包含偶数的列表。在lst1和lst2之间交换元素的数量没有限制。如果可以在lst1和lst2之间交换元素以使lst1的所有元素都是偶数，则返回“YES”。否则，返回“NO”。例如：exchange（[1,2,3,4]，[1,2,3,4]）=>“YES”exchange（[1,2,3,4]，[1,5,3,4]）=>“NO”假定输入列表将不为空。", "entry_point": "exchange", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/51", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 任务\n// 给定两个字符串s和c，您必须删除s中所有与c中任何字符相等的字符，然后检查结果字符串是否为回文。\n// 如果一个字符串从前往后读和从后往前读是一样的，那么这个字符串就是回文的。\n// 您应该返回一个包含结果字符串和True/False检查的元组。\n// 例子\n// 对于s =“abcde”，c =“ae”，结果应该是（'bcd'，False）\n// 对于s =“abcdef”，c =“b”，结果应该是（'acdef'，False）\n// 对于s =“abcdedcba”，c =“ab”，结果应该是（'cdedc'，True）\n// \n// \nfunc reverse_delete (s string, c string) []interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := reverse_delete(\"abcde\",\"ae\")\n\texpected_1 := []interface{}{\"bcd\", false}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := reverse_delete(\"abcdef\",\"b\")\n\texpected_2 := []interface{}{\"acdef\", false}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := reverse_delete(\"abcdedcba\",\"ab\")\n\texpected_3 := []interface{}{\"cdedc\", true}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := reverse_delete(\"dwik\",\"w\")\n\texpected_4 := []interface{}{\"dik\", false}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := reverse_delete(\"a\",\"a\")\n\texpected_5 := []interface{}{\"\", true}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := reverse_delete(\"abcdedcba\",\"\")\n\texpected_6 := []interface{}{\"abcdedcba\", true}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := reverse_delete(\"abcdedcba\",\"v\")\n\texpected_7 := []interface{}{\"abcdedcba\", true}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := reverse_delete(\"vabba\",\"v\")\n\texpected_8 := []interface{}{\"abba\", true}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := reverse_delete(\"mamma\",\"mia\")\n\texpected_9 := []interface{}{\"\", true}\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "任务\n给定两个字符串s和c，您必须删除s中所有与c中任何字符相等的字符，然后检查结果字符串是否为回文。\n如果一个字符串从前往后读和从后往前读是一样的，那么这个字符串就是回文的。\n您应该返回一个包含结果字符串和True/False检查的元组。\n例子\n对于s =“abcde”，c =“ae”，结果应该是（'bcd'，False）\n对于s =“abcdef”，c =“b”，结果应该是（'acdef'，False）\n对于s =“abcdedcba”，c =“ab”，结果应该是（'cdedc'，True）", "entry_point": "reverse_delete", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/52", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 你有一个井的矩形网格。每一行代表一个井，每一行中的1代表一个单位的水。每个井都有一个对应的桶，可以用来从中提取水，所有桶的容量相同。你的任务是使用桶来排空井。输出你需要降低桶的次数。\n// \n// 例1：\n// 输入：\n//     grid：[[0,0,1,0]，[0,1,0,0]，[1,1,1,1]]\n//     bucket_capacity：1\n// 输出：6\n// \n// 例2：\n// 输入：\n//     grid：[[0,0,1,1]，[0,0,0,0]，[1,1,1,1]，[0,1,1,1]]\n//     bucket_capacity：2\n// 输出：5\n// \n// 例3：\n// 输入：\n//     grid：[[0,0,0]，[0,0,0]]\n//     bucket_capacity：5\n// 输出：0\n// \n// 约束：\n// *所有井的长度相同\n// *1 <= grid.length <= 10^2\n// *1 <= grid [:,1].length <= 10^2\n// *grid [i] [j] -> 0 | 1\n// *1 <= capacity <= 10\n// \n// \nfunc max_fill (grid [][]int, capacity int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}},1)\n\texpected_1 := 6\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := max_fill([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}},2)\n\texpected_2 := 5\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}},5)\n\texpected_3 := 0\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := max_fill([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}},2)\n\texpected_4 := 4\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := max_fill([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}},9)\n\texpected_5 := 2\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "你有一个井的矩形网格。每一行代表一个井，每一行中的1代表一个单位的水。每个井都有一个对应的桶，可以用来从中提取水，所有桶的容量相同。你的任务是使用桶来排空井。输出你需要降低桶的次数。\n\n例1：\n输入：\n    grid：[[0,0,1,0]，[0,1,0,0]，[1,1,1,1]]\n    bucket_capacity：1\n输出：6\n\n例2：\n输入：\n    grid：[[0,0,1,1]，[0,0,0,0]，[1,1,1,1]，[0,1,1,1]]\n    bucket_capacity：2\n输出：5\n\n例3：\n输入：\n    grid：[[0,0,0]，[0,0,0]]\n    bucket_capacity：5\n输出：0\n\n约束：\n*所有井的长度相同\n*1 <= grid.length <= 10^2\n*1 <= grid [:,1].length <= 10^2\n*grid [i] [j] -> 0 | 1\n*1 <= capacity <= 10", "entry_point": "max_fill", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/53", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 给定一个字符串s和一个自然数n，你被要求实现一个函数，该函数返回字符串s中包含恰好n个辅音字母的所有单词的列表，按照它们在字符串s中出现的顺序。\n// 如果字符串s为空，则函数应返回一个空列表。\n// 注意：您可以假设输入字符串仅包含字母和空格。\n// 示例：\n// \n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n// \nfunc select_words (s string, n int) []string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := select_words(\"Mary had a little lamb\",4)\n\texpected_1 := []string{\"little\"}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := select_words(\"Mary had a little lamb\",3)\n\texpected_2 := []string{\"Mary\", \"lamb\"}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := select_words(\"simple white space\",2)\n\texpected_3 := []string{}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := select_words(\"Hello world\",4)\n\texpected_4 := []string{\"world\"}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := select_words(\"Uncle sam\",3)\n\texpected_5 := []string{\"Uncle\"}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := select_words(\"\",4)\n\texpected_6 := []string{}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := select_words(\"a b c d e f\",1)\n\texpected_7 := []string{\"b\", \"c\", \"d\", \"f\"}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "给定一个字符串s和一个自然数n，你被要求实现一个函数，该函数返回字符串s中包含恰好n个辅音字母的所有单词的列表，按照它们在字符串s中出现的顺序。\n如果字符串s为空，则函数应返回一个空列表。\n注意：您可以假设输入字符串仅包含字母和空格。\n示例：", "entry_point": "select_words", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/54", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定一个整数数组arr和一个正整数k，返回一个长度为k的排序列表，其中包含arr中最大的k个数字。\n// \n// 示例1：\n// \n//     输入：arr = [-3，-4，5]，k = 3\n//     输出：[-4，-3，5]\n// \n// 示例2：\n// \n//     输入：arr = [4，-4，4]，k = 2\n//     输出：[4，4]\n// \n// 示例3：\n// \n//     输入：arr = [-3，2，1，2，-1，-2，1]，k = 1\n//     输出：[2]\n// \n// 注意：\n// \n//     1.数组的长度将在[1，1000]范围内。\n//     2.数组中的元素将在[-1000，1000]范围内。\n//     3.0 <= k <= len（arr）\n// \n// \nfunc maximum (arr []int, k int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := maximum([]int{-3, -4, 5},3)\n\texpected_1 := []int{-4, -3, 5}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := maximum([]int{4, -4, 4},2)\n\texpected_2 := []int{4, 4}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := maximum([]int{-3, 2, 1, 2, -1, -2, 1},1)\n\texpected_3 := []int{2}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := maximum([]int{123, -123, 20, 0, 1, 2, -3},3)\n\texpected_4 := []int{2, 20, 123}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := maximum([]int{-123, 20, 0, 1, 2, -3},4)\n\texpected_5 := []int{0, 1, 2, 20}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := maximum([]int{5, 15, 0, 3, -13, -8, 0},7)\n\texpected_6 := []int{-13, -8, 0, 0, 3, 5, 15}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := maximum([]int{-1, 0, 2, 5, 3, -10},2)\n\texpected_7 := []int{3, 5}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := maximum([]int{1, 0, 5, -7},1)\n\texpected_8 := []int{5}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := maximum([]int{4, -4},2)\n\texpected_9 := []int{-4, 4}\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := maximum([]int{-10, 10},2)\n\texpected_10 := []int{-10, 10}\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := maximum([]int{1, 2, 3, -23, 243, -400, 0},0)\n\texpected_11 := []int{}\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n}", "language": "go", "description": "给定一个整数数组arr和一个正整数k，返回一个长度为k的排序列表，其中包含arr中最大的k个数字。\n\n示例1：\n\n    输入：arr = [-3，-4，5]，k = 3\n    输出：[-4，-3，5]\n\n示例2：\n\n    输入：arr = [4，-4，4]，k = 2\n    输出：[4，4]\n\n示例3：\n\n    输入：arr = [-3，2，1，2，-1，-2，1]，k = 1\n    输出：[2]\n\n注意：\n\n    1.数组的长度将在[1，1000]范围内。\n    2.数组中的元素将在[-1000，1000]范围内。\n    3.0 <= k <= len（arr）", "entry_point": "maximum", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/55", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定一个非空整数数组 arr 和一个整数 k，返回 arr 的前 k 个元素中最多有两位数的元素的和。\n// \n// 示例：\n// \n//     输入：arr = [111,21,3,4000,5,6,7,8,9]，k = 4\n//     输出：24 # 21 + 3 的和\n// \n// 限制条件：\n//     1. 1 <= len(arr) <= 100\n//     2. 1 <= k <= len(arr)\n// \n// \nfunc add_elements (arr []int, k int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := add_elements([]int{1, -2, -3, 41, 57, 76, 87, 88, 99},3)\n\texpected_1 := -4\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := add_elements([]int{111, 121, 3, 4000, 5, 6},2)\n\texpected_2 := 0\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := add_elements([]int{11, 21, 3, 90, 5, 6, 7, 8, 9},4)\n\texpected_3 := 125\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9},4)\n\texpected_4 := 24\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := add_elements([]int{1},1)\n\texpected_5 := 1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "给定一个非空整数数组 arr 和一个整数 k，返回 arr 的前 k 个元素中最多有两位数的元素的和。\n\n示例：\n\n    输入：arr = [111,21,3,4000,5,6,7,8,9]，k = 4\n    输出：24 # 21 + 3 的和\n\n限制条件：\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)", "entry_point": "add_elements", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/56", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 给定两个区间，\n//     每个区间都是一对整数。例如，区间 = (起始，结束) = (1，2)。\n//     给定的区间是闭合的，这意味着区间（起始，结束）\n//     包括起始和结束。\n//     对于每个给定的区间，假定其起始小于或等于其结束。\n//     您的任务是确定这两个区间的交集长度是否为质数。\n//     例如，区间（1，3），（2，4）的交集是（2，3）\n//     其长度为1，不是质数。\n//     如果交集的长度是质数，则返回“YES”，\n//     否则返回“NO”。\n//     如果两个区间不相交，则返回“NO”。\n// \n//     [输入/输出]示例：\n// \n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\n// \nfunc intersection (interval1 []int, interval2 []int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := intersection([]int{1, 2},[]int{2, 3})\n\texpected_1 := \"NO\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := intersection([]int{-1, 1},[]int{0, 4})\n\texpected_2 := \"NO\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := intersection([]int{-3, -1},[]int{-5, 5})\n\texpected_3 := \"YES\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := intersection([]int{-2, 2},[]int{-4, 0})\n\texpected_4 := \"YES\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := intersection([]int{-11, 2},[]int{-1, -1})\n\texpected_5 := \"NO\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := intersection([]int{1, 2},[]int{3, 5})\n\texpected_6 := \"NO\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := intersection([]int{1, 2},[]int{1, 2})\n\texpected_7 := \"NO\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := intersection([]int{-2, -2},[]int{-3, -2})\n\texpected_8 := \"NO\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "给定两个区间，\n    每个区间都是一对整数。例如，区间 = (起始，结束) = (1，2)。\n    给定的区间是闭合的，这意味着区间（起始，结束）\n    包括起始和结束。\n    对于每个给定的区间，假定其起始小于或等于其结束。\n    您的任务是确定这两个区间的交集长度是否为质数。\n    例如，区间（1，3），（2，4）的交集是（2，3）\n    其长度为1，不是质数。\n    如果交集的长度是质数，则返回“YES”，\n    否则返回“NO”。\n    如果两个区间不相交，则返回“NO”。\n\n    [输入/输出]示例：", "entry_point": "intersection", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/57", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 每个人都知道斐波那契数列，在过去的几个世纪里，数学家们对其进行了深入研究。然而，人们不知道的是特里波那契数列。特里波那契数列由递归定义：\n// tri(1) = 3\n// tri(n) = 1 + n / 2，如果n是偶数。\n// tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)，如果n是奇数。\n// 例如：\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8\n// 给定一个非负整数n，您必须返回特里波那契数列的前n + 1个数字的列表。\n// 例子：\n// tri(3) = [1, 3, 2, 8]\n// \n// \nfunc tri (n int) []interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := tri(3)\n\texpected_1 := []interface{}{1, 3, 2.0, 8.0}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := tri(4)\n\texpected_2 := []interface{}{1, 3, 2.0, 8.0, 3.0}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := tri(5)\n\texpected_3 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := tri(6)\n\texpected_4 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := tri(7)\n\texpected_5 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := tri(8)\n\texpected_6 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := tri(9)\n\texpected_7 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := tri(20)\n\texpected_8 := []interface{}{1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := tri(0)\n\texpected_9 := []interface{}{1}\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := tri(1)\n\texpected_10 := []interface{}{1, 3}\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "每个人都知道斐波那契数列，在过去的几个世纪里，数学家们对其进行了深入研究。然而，人们不知道的是特里波那契数列。特里波那契数列由递归定义：\ntri(1) = 3\ntri(n) = 1 + n / 2，如果n是偶数。\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)，如果n是奇数。\n例如：\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\n给定一个非负整数n，您必须返回特里波那契数列的前n + 1个数字的列表。\n例子：\ntri(3) = [1, 3, 2, 8]", "entry_point": "tri", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/58", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 给定一个正整数n，返回所有奇数位数字的乘积。\n// 如果所有数字都是偶数，则返回0。\n// 例如：\n// \n// digits(1)  == 1\n// digits(4)  == 0\n// digits(235) == 15\n// \nfunc digits (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := digits(5)\n\texpected_1 := 5\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := digits(54)\n\texpected_2 := 5\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := digits(120)\n\texpected_3 := 1\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := digits(5014)\n\texpected_4 := 5\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := digits(98765)\n\texpected_5 := 315\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := digits(5576543)\n\texpected_6 := 2625\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := digits(2468)\n\texpected_7 := 0\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "给定一个正整数n，返回所有奇数位数字的乘积。\n如果所有数字都是偶数，则返回0。\n例如：", "entry_point": "digits", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/59", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 创建一个函数，该函数以仅包含方括号的字符串作为输入。\n//     如果存在有效的括号子序列且至少有一个括号嵌套，则函数应返回True。\n// is_nested('[[]]') ➞ True\n// is_nested('[]]]]]]][[[[[]') ➞ False\n// is_nested('[][]') ➞ False\n// is_nested('[]') ➞ False\n// is_nested('[[][]]') ➞ True\n// is_nested('[[]][[') ➞ True\n// \nfunc is_nested (string0 string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := is_nested(\"[[]]\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := is_nested(\"[]]]]]]][[[[[]\")\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := is_nested(\"[][]\")\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := is_nested(\"[]\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := is_nested(\"[[[[]]]]\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := is_nested(\"[]]]]]]]]]]\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := is_nested(\"[][][[]]\")\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := is_nested(\"[[]\")\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := is_nested(\"[]]\")\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := is_nested(\"[[]][[\")\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := is_nested(\"[[][]]\")\n\texpected_11 := true\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := is_nested(\"\")\n\texpected_12 := false\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := is_nested(\"[[[[[[[[\")\n\texpected_13 := false\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := is_nested(\"]]]]]]]]\")\n\texpected_14 := false\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n}", "language": "go", "description": "创建一个函数，该函数以仅包含方括号的字符串作为输入。\n    如果存在有效的括号子序列且至少有一个括号嵌套，则函数应返回True。", "entry_point": "is_nested", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/60", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 给定一个数字列表。\n// 你需要返回给定列表中平方数的总和，\n// 首先将列表中的每个元素四舍五入到上限整数（Ceiling）。\n// 例子：\n// 对于lst = [1,2,3]，输出应该是14\n// 对于lst = [1,4,9]，输出应该是98\n// 对于lst = [1,3,5,7]，输出应该是84\n// 对于lst = [1.4,4.2,0]，输出应该是29\n// 对于lst = [-2.4,1,1]，输出应该是6\n// \n// \n// \n// \nfunc sum_squares (lst []interface{}) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := sum_squares([]interface{}{1, 2, 3})\n\texpected_1 := 14\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := sum_squares([]interface{}{1.0, 2, 3})\n\texpected_2 := 14\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := sum_squares([]interface{}{1, 3, 5, 7})\n\texpected_3 := 84\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := sum_squares([]interface{}{1.4, 4.2, 0})\n\texpected_4 := 29\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := sum_squares([]interface{}{-2.4, 1, 1})\n\texpected_5 := 6\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := sum_squares([]interface{}{100, 1, 15, 2})\n\texpected_6 := 10230\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := sum_squares([]interface{}{10000, 10000})\n\texpected_7 := 200000000\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := sum_squares([]interface{}{-1.4, 4.6, 6.3})\n\texpected_8 := 75\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := sum_squares([]interface{}{-1.4, 17.9, 18.9, 19.9})\n\texpected_9 := 1086\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := sum_squares([]interface{}{0})\n\texpected_10 := 0\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := sum_squares([]interface{}{-1})\n\texpected_11 := 1\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := sum_squares([]interface{}{-1, 1, 0})\n\texpected_12 := 2\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n}", "language": "go", "description": "给定一个数字列表。\n你需要返回给定列表中平方数的总和，\n首先将列表中的每个元素四舍五入到上限整数（Ceiling）。\n例子：\n对于lst = [1,2,3]，输出应该是14\n对于lst = [1,4,9]，输出应该是98\n对于lst = [1,3,5,7]，输出应该是84\n对于lst = [1.4,4.2,0]，输出应该是29\n对于lst = [-2.4,1,1]，输出应该是6", "entry_point": "sum_squares", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/61", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 创建一个函数，如果给定字符串的最后一个字符是字母字符且不是单词的一部分，则返回True，否则返回False。\n// 注意：“单词”是由空格分隔的一组字符。\n// \n// 例子：\n// \n// check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n// check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n// check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n// check_if_last_char_is_a_letter(\"\") ➞ False \n// \nfunc check_if_last_char_is_a_letter (txt string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := check_if_last_char_is_a_letter(\"apple\")\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := check_if_last_char_is_a_letter(\"apple pi e\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := check_if_last_char_is_a_letter(\"eeeee\")\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := check_if_last_char_is_a_letter(\"A\")\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := check_if_last_char_is_a_letter(\"Pumpkin pie \")\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := check_if_last_char_is_a_letter(\"Pumpkin pie 1\")\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := check_if_last_char_is_a_letter(\"\")\n\texpected_7 := false\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := check_if_last_char_is_a_letter(\"eeeee e \")\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := check_if_last_char_is_a_letter(\"apple pie\")\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := check_if_last_char_is_a_letter(\"apple pi e \")\n\texpected_10 := false\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "创建一个函数，如果给定字符串的最后一个字符是字母字符且不是单词的一部分，则返回True，否则返回False。\n注意：“单词”是由空格分隔的一组字符。\n\n例子：", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/62", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 创建一个函数，该函数返回一个元素的最大索引，该元素不大于或等于其前面的元素。如果不存在这样的元素，则返回-1。给定的数组不包含重复值。\n// \n// 例子：\n// \n// can_arrange([1,2,4,3,5]) = 3\n// can_arrange([1,2,3]) = -1\n// \nfunc can_arrange (arr []int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := can_arrange([]int{1, 2, 4, 3, 5})\n\texpected_1 := 3\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := can_arrange([]int{1, 2, 4, 5})\n\texpected_2 := -1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := can_arrange([]int{1, 4, 2, 5, 6, 7, 8, 9, 10})\n\texpected_3 := 2\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := can_arrange([]int{4, 8, 5, 7, 3})\n\texpected_4 := 4\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := can_arrange([]int{})\n\texpected_5 := -1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n}", "language": "go", "description": "创建一个函数，该函数返回一个元素的最大索引，该元素不大于或等于其前面的元素。如果不存在这样的元素，则返回-1。给定的数组不包含重复值。\n\n例子：", "entry_point": "can_arrange", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/63", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 创建一个函数，返回一个元组（a，b），其中'a'是负整数中最大的，'b'是正整数中最小的。如果列表中没有负数或正数，则将它们作为None返回。\n// \n// 例子：\n// \n// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0]) == (None, None)\n// \nfunc largest_smallest_integers (lst []int) []interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})\n\texpected_1 := []interface{}{nil, 1}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := largest_smallest_integers([]int{2, 4, 1, 3, 5, 7, 0})\n\texpected_2 := []interface{}{nil, 1}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := largest_smallest_integers([]int{1, 3, 2, 4, 5, 6, -2})\n\texpected_3 := []interface{}{-2, 1}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := largest_smallest_integers([]int{4, 5, 3, 6, 2, 7, -7})\n\texpected_4 := []interface{}{-7, 2}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := largest_smallest_integers([]int{7, 3, 8, 4, 9, 2, 5, -9})\n\texpected_5 := []interface{}{-9, 2}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := largest_smallest_integers([]int{})\n\texpected_6 := []interface{}{nil, nil}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := largest_smallest_integers([]int{0})\n\texpected_7 := []interface{}{nil, nil}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := largest_smallest_integers([]int{-1, -3, -5, -6})\n\texpected_8 := []interface{}{-1, nil}\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := largest_smallest_integers([]int{-1, -3, -5, -6, 0})\n\texpected_9 := []interface{}{-1, nil}\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := largest_smallest_integers([]int{-6, -4, -4, -3, 1})\n\texpected_10 := []interface{}{-3, 1}\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := largest_smallest_integers([]int{-6, -4, -4, -3, -100, 1})\n\texpected_11 := []interface{}{-3, 1}\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n}", "language": "go", "description": "创建一个函数，返回一个元组（a，b），其中'a'是负整数中最大的，'b'是正整数中最小的。如果列表中没有负数或正数，则将它们作为None返回。\n\n例子：", "entry_point": "largest_smallest_integers", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/64", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 巴西阶乘被定义为：\n//     巴西阶乘(n) = n! * (n-1)! * (n-2)! * ... * 1!\n//     其中 n > 0\n// \n//     例如：\n// >>> special_factorial(4)\n// 288\n// \n// The function will receive an integer as input and should return the special\n// factorial of this integer.\n// \nfunc special_factorial (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := special_factorial(4)\n\texpected_1 := 288\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := special_factorial(5)\n\texpected_2 := 34560\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := special_factorial(7)\n\texpected_3 := 125411328000\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := special_factorial(1)\n\texpected_4 := 1\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "巴西阶乘被定义为：\n    巴西阶乘(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    其中 n > 0\n\n    例如：", "entry_point": "special_factorial", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/65", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定一个表示句子的字符串，\n// 句子包含一些由空格分隔的单词，\n// 您必须返回一个字符串，其中包含原始句子中长度为质数的单词，\n// 新字符串中单词的顺序应与原始字符串相同。\n// \n// 示例1：\n//     输入：sentence = \"This is a test\"\n//     输出：\"is\"\n// \n// 示例2：\n//     输入：sentence = \"lets go for swimming\"\n//     输出：\"go for\"\n// \n// 限制：\n//     * 1 <= len(sentence) <= 100\n//     * 句子只包含字母\n// \n// \nfunc words_in_sentence (sentence string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := words_in_sentence(\"This is a test\")\n\texpected_1 := \"is\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := words_in_sentence(\"lets go for swimming\")\n\texpected_2 := \"go for\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := words_in_sentence(\"there is no place available here\")\n\texpected_3 := \"there is no place\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := words_in_sentence(\"Hi I am Hussein\")\n\texpected_4 := \"Hi am Hussein\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := words_in_sentence(\"go for it\")\n\texpected_5 := \"go for it\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := words_in_sentence(\"here\")\n\texpected_6 := \"\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := words_in_sentence(\"here is\")\n\texpected_7 := \"is\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "给定一个表示句子的字符串，\n句子包含一些由空格分隔的单词，\n您必须返回一个字符串，其中包含原始句子中长度为质数的单词，\n新字符串中单词的顺序应与原始字符串相同。\n\n示例1：\n    输入：sentence = \"This is a test\"\n    输出：\"is\"\n\n示例2：\n    输入：sentence = \"lets go for swimming\"\n    输出：\"go for\"\n\n限制：\n    * 1 <= len(sentence) <= 100\n    * 句子只包含字母", "entry_point": "words_in_sentence", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/66", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 你的任务是实现一个函数，简化表达式 x * n。如果 x * n 可以计算为整数，则函数返回 True，否则返回 False。x 和 n 都是分数的字符串表示形式，格式为 <分子>/<分母>，其中分子和分母都是正整数。\n// \n// 你可以假设 x 和 n 都是有效的分数，并且分母不为零。\n// simplify(\"1/5\", \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\", \"10/2\") = False\n// \nfunc simplify (x string, n string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := simplify(\"1/5\",\"5/1\")\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := simplify(\"1/6\",\"2/1\")\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := simplify(\"5/1\",\"3/1\")\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := simplify(\"7/10\",\"10/2\")\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := simplify(\"2/10\",\"50/10\")\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := simplify(\"7/2\",\"4/2\")\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := simplify(\"11/6\",\"6/1\")\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := simplify(\"2/3\",\"5/2\")\n\texpected_8 := false\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := simplify(\"5/2\",\"3/5\")\n\texpected_9 := false\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := simplify(\"2/4\",\"8/4\")\n\texpected_10 := true\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := simplify(\"2/4\",\"4/2\")\n\texpected_11 := true\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := simplify(\"1/5\",\"5/1\")\n\texpected_12 := true\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := simplify(\"1/5\",\"1/5\")\n\texpected_13 := false\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n}", "language": "go", "description": "你的任务是实现一个函数，简化表达式 x * n。如果 x * n 可以计算为整数，则函数返回 True，否则返回 False。x 和 n 都是分数的字符串表示形式，格式为 <分子>/<分母>，其中分子和分母都是正整数。\n\n你可以假设 x 和 n 都是有效的分数，并且分母不为零。", "entry_point": "simplify", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/67", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 编写一个函数，根据数字的各位数字之和，将给定的整数列表按升序排序。\n// 注意：如果有多个数字的各位数字之和相似，则按照它们在原始列表中的索引排序。\n// \n// 例如：\n// >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n// >>> order_by_points([]) == []\n// \nfunc order_by_points (nums []int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := order_by_points([]int{1, 11, -1, -11, -12})\n\texpected_1 := []int{-1, -11, 1, -12, 11}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := order_by_points([]int{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46})\n\texpected_2 := []int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := order_by_points([]int{})\n\texpected_3 := []int{}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := order_by_points([]int{1, -11, -32, 43, 54, -98, 2, -3})\n\texpected_4 := []int{-3, -32, -98, -11, 1, 2, 43, 54}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := order_by_points([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11})\n\texpected_5 := []int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := order_by_points([]int{0, 6, 6, -76, -21, 23, 4})\n\texpected_6 := []int{-76, -21, 0, 4, 23, 6, 6}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "编写一个函数，根据数字的各位数字之和，将给定的整数列表按升序排序。\n注意：如果有多个数字的各位数字之和相似，则按照它们在原始列表中的索引排序。\n\n例如：", "entry_point": "order_by_points", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/68", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 编写一个函数，它以数字数组作为输入，并返回数组中大于10且数字的第一个和最后一个数字都是奇数（1、3、5、7、9）的元素数量。例如：\n// \n// specialFilter([15, -73, 14, -15]) => 1 \n// specialFilter([33, -2, -3, 45, 21, 109]) => 2\n// \nfunc specialFilter (nums []int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := specialFilter([]int{5, -2, 1, -5})\n\texpected_1 := 0\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := specialFilter([]int{15, -73, 14, -15})\n\texpected_2 := 1\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := specialFilter([]int{33, -2, -3, 45, 21, 109})\n\texpected_3 := 2\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := specialFilter([]int{43, -12, 93, 125, 121, 109})\n\texpected_4 := 4\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := specialFilter([]int{71, -2, -33, 75, 21, 19})\n\texpected_5 := 3\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := specialFilter([]int{1})\n\texpected_6 := 0\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := specialFilter([]int{})\n\texpected_7 := 0\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "编写一个函数，它以数字数组作为输入，并返回数组中大于10且数字的第一个和最后一个数字都是奇数（1、3、5、7、9）的元素数量。例如：", "entry_point": "specialFilter", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/69", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定一个正整数n。你需要创建一个长度为n的整数数组a。\n// 对于每个i（1≤i≤n），a[i]的值=i * i-i + 1。\n// 返回a中i <j <k的三元组（a[i]，a[j]，a[k]）的数量，\n// 并且a[i] + a[j] + a[k]是3的倍数。\n// \n// 例子：\n// 输入：n = 5\n// 输出：1\n// 解释：\n// a = [1, 3, 7, 13, 21]\n// 唯一有效的三元组是（1，7，13）。\n// \n// \nfunc get_max_triples (n int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := get_max_triples(5)\n\texpected_1 := 1\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := get_max_triples(6)\n\texpected_2 := 4\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := get_max_triples(10)\n\texpected_3 := 36\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := get_max_triples(100)\n\texpected_4 := 53361\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "给定一个正整数n。你需要创建一个长度为n的整数数组a。\n对于每个i（1≤i≤n），a[i]的值=i * i-i + 1。\n返回a中i <j <k的三元组（a[i]，a[j]，a[k]）的数量，\n并且a[i] + a[j] + a[k]是3的倍数。\n\n例子：\n输入：n = 5\n输出：1\n解释：\na = [1, 3, 7, 13, 21]\n唯一有效的三元组是（1，7，13）。", "entry_point": "get_max_triples", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/70", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 我们的太阳系中有八颗行星：最靠近太阳的是水星，其次是金星，然后是地球、火星、木星、土星、天王星和海王星。编写一个函数，该函数接受两个行星名称作为字符串planet1和planet2。该函数应返回一个元组，其中包含所有轨道位于planet1和planet2之间的行星，按距离太阳的近度排序。如果planet1或planet2不是正确的行星名称，则函数应返回一个空元组。示例\n// \n// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n// \nfunc bf (planet1 string, planet2 string) []string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := bf(\"Jupiter\",\"Neptune\")\n\texpected_1 := []string{\"Saturn\", \"Uranus\"}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := bf(\"Earth\",\"Mercury\")\n\texpected_2 := []string{\"Venus\"}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := bf(\"Mercury\",\"Uranus\")\n\texpected_3 := []string{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := bf(\"Neptune\",\"Venus\")\n\texpected_4 := []string{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := bf(\"Earth\",\"Earth\")\n\texpected_5 := []string{}\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := bf(\"Mars\",\"Earth\")\n\texpected_6 := []string{}\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := bf(\"Jupiter\",\"Makemake\")\n\texpected_7 := []string{}\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "我们的太阳系中有八颗行星：最靠近太阳的是水星，其次是金星，然后是地球、火星、木星、土星、天王星和海王星。编写一个函数，该函数接受两个行星名称作为字符串planet1和planet2。该函数应返回一个元组，其中包含所有轨道位于planet1和planet2之间的行星，按距离太阳的近度排序。如果planet1或planet2不是正确的行星名称，则函数应返回一个空元组。示例", "entry_point": "bf", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/71", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 一个简单的程序，如果n是质数，则应返回x的值，否则应返回y的值。\n// \n// 例子：\n// \n// for x_or_y(7, 34, 12) == 34\n// for x_or_y(15, 8, 5) == 5\n// \n// \nfunc x_or_y (n int, x int, y int) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := x_or_y(7,34,12)\n\texpected_1 := 34\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := x_or_y(15,8,5)\n\texpected_2 := 5\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := x_or_y(3,33,5212)\n\texpected_3 := 33\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := x_or_y(1259,3,52)\n\texpected_4 := 3\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := x_or_y(7919,-1,12)\n\texpected_5 := -1\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := x_or_y(3609,1245,583)\n\texpected_6 := 583\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := x_or_y(91,56,129)\n\texpected_7 := 129\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := x_or_y(6,34,1234)\n\texpected_8 := 1234\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := x_or_y(1,2,0)\n\texpected_9 := 0\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := x_or_y(2,2,0)\n\texpected_10 := 2\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n}", "language": "go", "description": "一个简单的程序，如果n是质数，则应返回x的值，否则应返回y的值。\n\n例子：", "entry_point": "x_or_y", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/72", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定一个数字列表，返回列表中奇数的平方和。忽略负数或非整数。\n// \n// double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n// double_the_difference([-1, -2, 0]) == 0\n// double_the_difference([9, -2]) == 81\n// double_the_difference([0]) == 0\n// \n// 如果输入列表为空，则返回0。\n// \n// \nfunc double_the_difference (lst []interface{}) int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := double_the_difference([]interface{}{})\n\texpected_1 := 0\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := double_the_difference([]interface{}{5, 4})\n\texpected_2 := 25\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := double_the_difference([]interface{}{0.1, 0.2, 0.3})\n\texpected_3 := 0\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := double_the_difference([]interface{}{-10, -20, -30})\n\texpected_4 := 0\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := double_the_difference([]interface{}{-1, -2, 8})\n\texpected_5 := 0\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := double_the_difference([]interface{}{0.2, 3, 5})\n\texpected_6 := 34\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := double_the_difference([]interface{}{-99, -97, -95, -93, -91, -89, -87, -85, -83, -81, -79, -77, -75, -73, -71, -69, -67, -65, -63, -61, -59, -57, -55, -53, -51, -49, -47, -45, -43, -41, -39, -37, -35, -33, -31, -29, -27, -25, -23, -21, -19, -17, -15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99})\n\texpected_7 := 166650\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n}", "language": "go", "description": "给定一个数字列表，返回列表中奇数的平方和。忽略负数或非整数。\n\ndouble_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0\n\n如果输入列表为空，则返回0。", "entry_point": "double_the_difference", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/73", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 你将得到一个类的名称（一个字符串）和一个扩展名列表。扩展名用于加载附加的类到该类中。扩展名的强度如下：让CAP为扩展名中大写字母的数量，让SM为扩展名中小写字母的数量，强度由CAP-SM分数给出。您应该找到最强的扩展名并返回一个字符串，格式为：ClassName.StrongestExtensionName。如果有两个或更多的扩展名具有相同的强度，则应选择列表中先出现的扩展名。例如，如果您给出“Slices”作为类和扩展名列表：['SErviNGSliCes'，'Cheese'，'StuFfed']，则应返回'Slices.SErviNGSliCes'，因为'SErviNGSliCes'是最强的扩展名（其强度为-1）。示例：\n// \n// for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n// \nfunc Strongest_Extension (class_name string, extensions []string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := Strongest_Extension(\"Watashi\",[]string{\"tEN\", \"niNE\", \"eIGHt8OKe\"})\n\texpected_1 := \"Watashi.eIGHt8OKe\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := Strongest_Extension(\"Boku123\",[]string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"})\n\texpected_2 := \"Boku123.YEs.WeCaNe\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := Strongest_Extension(\"__YESIMHERE\",[]string{\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"})\n\texpected_3 := \"__YESIMHERE.NuLl__\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := Strongest_Extension(\"K\",[]string{\"Ta\", \"TAR\", \"t234An\", \"cosSo\"})\n\texpected_4 := \"K.TAR\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := Strongest_Extension(\"__HAHA\",[]string{\"Tab\", \"123\", \"781345\", \"-_-\"})\n\texpected_5 := \"__HAHA.123\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := Strongest_Extension(\"YameRore\",[]string{\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"})\n\texpected_6 := \"YameRore.okIWILL123\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := Strongest_Extension(\"finNNalLLly\",[]string{\"Die\", \"NowW\", \"Wow\", \"WoW\"})\n\texpected_7 := \"finNNalLLly.WoW\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := Strongest_Extension(\"_\",[]string{\"Bb\", \"91245\"})\n\texpected_8 := \"_.Bb\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := Strongest_Extension(\"Sp\",[]string{\"671235\", \"Bb\"})\n\texpected_9 := \"Sp.671235\"\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n}", "language": "go", "description": "你将得到一个类的名称（一个字符串）和一个扩展名列表。扩展名用于加载附加的类到该类中。扩展名的强度如下：让CAP为扩展名中大写字母的数量，让SM为扩展名中小写字母的数量，强度由CAP-SM分数给出。您应该找到最强的扩展名并返回一个字符串，格式为：ClassName.StrongestExtensionName。如果有两个或更多的扩展名具有相同的强度，则应选择列表中先出现的扩展名。例如，如果您给出“Slices”作为类和扩展名列表：['SErviNGSliCes'，'Cheese'，'StuFfed']，则应返回'Slices.SErviNGSliCes'，因为'SErviNGSliCes'是最强的扩展名（其强度为-1）。示例：", "entry_point": "Strongest_Extension", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/74", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 给定两个单词。如果第二个单词或其任何旋转是第一个单词的子字符串，则需要返回True。\n// cycpattern_check(\"abcd\",\"abd\") => False\n// cycpattern_check(\"hello\",\"ell\") => True\n// cycpattern_check(\"whassup\",\"psus\") => False\n// cycpattern_check(\"abab\",\"baa\") => True\n// cycpattern_check(\"efef\",\"eeff\") => False\n// cycpattern_check(\"himenss\",\"simen\") => True\n// \n// \nfunc cycpattern_check (a string, b string) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := cycpattern_check(\"xyzw\",\"xyw\")\n\texpected_1 := false\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := cycpattern_check(\"yello\",\"ell\")\n\texpected_2 := true\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := cycpattern_check(\"whattup\",\"ptut\")\n\texpected_3 := false\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := cycpattern_check(\"efef\",\"fee\")\n\texpected_4 := true\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := cycpattern_check(\"abab\",\"aabb\")\n\texpected_5 := false\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := cycpattern_check(\"winemtt\",\"tinem\")\n\texpected_6 := true\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n}", "language": "go", "description": "给定两个单词。如果第二个单词或其任何旋转是第一个单词的子字符串，则需要返回True。", "entry_point": "cycpattern_check", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/75", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定一个正整数，将其转换为罗马数字字符串，并以小写形式返回。\n// 限制条件：1 <= num <= 1000\n// \n// 示例：\n// >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n// >>> int_to_mini_roman(426) == 'cdxxvi'\n// \nfunc int_to_mini_roman (number int) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := int_to_mini_roman(19)\n\texpected_1 := \"xix\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := int_to_mini_roman(152)\n\texpected_2 := \"clii\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := int_to_mini_roman(251)\n\texpected_3 := \"ccli\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := int_to_mini_roman(426)\n\texpected_4 := \"cdxxvi\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := int_to_mini_roman(500)\n\texpected_5 := \"d\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := int_to_mini_roman(1)\n\texpected_6 := \"i\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := int_to_mini_roman(4)\n\texpected_7 := \"iv\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := int_to_mini_roman(43)\n\texpected_8 := \"xliii\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := int_to_mini_roman(90)\n\texpected_9 := \"xc\"\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := int_to_mini_roman(94)\n\texpected_10 := \"xciv\"\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := int_to_mini_roman(532)\n\texpected_11 := \"dxxxii\"\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n\tactual_12 := int_to_mini_roman(900)\n\texpected_12 := \"cm\"\n\tdeepCompare(actual_12, expected_12, \"Exception --- test case 11 failed to pass\")\n\n\tactual_13 := int_to_mini_roman(994)\n\texpected_13 := \"cmxciv\"\n\tdeepCompare(actual_13, expected_13, \"Exception --- test case 12 failed to pass\")\n\n\tactual_14 := int_to_mini_roman(1000)\n\texpected_14 := \"m\"\n\tdeepCompare(actual_14, expected_14, \"Exception --- test case 13 failed to pass\")\n\n}", "language": "go", "description": "给定一个正整数，将其转换为罗马数字字符串，并以小写形式返回。\n限制条件：1 <= num <= 1000\n\n示例：", "entry_point": "int_to_mini_roman", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/76", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定三角形的三条边长。如果这三条边可以组成一个直角三角形，则返回True，否则返回False。\n//     直角三角形是一个其中一个角是直角或90度的三角形。\n//     例子：\n// \n// right_angle_triangle(3, 4, 5) == True\n// right_angle_triangle(1, 2, 3) == False\n// \nfunc right_angle_triangle (a int, b int, c int) bool {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := right_angle_triangle(3,4,5)\n\texpected_1 := true\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := right_angle_triangle(1,2,3)\n\texpected_2 := false\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := right_angle_triangle(10,6,8)\n\texpected_3 := true\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := right_angle_triangle(2,2,2)\n\texpected_4 := false\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := right_angle_triangle(7,24,25)\n\texpected_5 := true\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := right_angle_triangle(10,5,7)\n\texpected_6 := false\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := right_angle_triangle(5,12,13)\n\texpected_7 := true\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := right_angle_triangle(15,8,17)\n\texpected_8 := true\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n\tactual_9 := right_angle_triangle(48,55,73)\n\texpected_9 := true\n\tdeepCompare(actual_9, expected_9, \"Exception --- test case 8 failed to pass\")\n\n\tactual_10 := right_angle_triangle(1,1,1)\n\texpected_10 := false\n\tdeepCompare(actual_10, expected_10, \"Exception --- test case 9 failed to pass\")\n\n\tactual_11 := right_angle_triangle(2,2,10)\n\texpected_11 := false\n\tdeepCompare(actual_11, expected_11, \"Exception --- test case 10 failed to pass\")\n\n}", "language": "go", "description": "给定三角形的三条边长。如果这三条边可以组成一个直角三角形，则返回True，否则返回False。\n    直角三角形是一个其中一个角是直角或90度的三角形。\n    例子：", "entry_point": "right_angle_triangle", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/77", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// 给定一个字符串s。\n// 如果s[i]是一个字母，将其大小写反转，从小写变为大写或反之亦然，\n// 否则保持不变。\n// 如果字符串不包含字母，则反转字符串。\n// 函数应返回结果字符串。\n// 例子\n// \n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\n// \nfunc solve (s string) string {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := solve(\"AsDf\")\n\texpected_1 := \"aSdF\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := solve(\"1234\")\n\texpected_2 := \"4321\"\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := solve(\"ab\")\n\texpected_3 := \"AB\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := solve(\"#a@C\")\n\texpected_4 := \"#A@c\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n\tactual_5 := solve(\"#AsdfW^45\")\n\texpected_5 := \"#aSDFw^45\"\n\tdeepCompare(actual_5, expected_5, \"Exception --- test case 4 failed to pass\")\n\n\tactual_6 := solve(\"#6@2\")\n\texpected_6 := \"2@6#\"\n\tdeepCompare(actual_6, expected_6, \"Exception --- test case 5 failed to pass\")\n\n\tactual_7 := solve(\"#$a^D\")\n\texpected_7 := \"#$A^d\"\n\tdeepCompare(actual_7, expected_7, \"Exception --- test case 6 failed to pass\")\n\n\tactual_8 := solve(\"#ccc\")\n\texpected_8 := \"#CCC\"\n\tdeepCompare(actual_8, expected_8, \"Exception --- test case 7 failed to pass\")\n\n}", "language": "go", "description": "给定一个字符串s。\n如果s[i]是一个字母，将其大小写反转，从小写变为大写或反之亦然，\n否则保持不变。\n如果字符串不包含字母，则反转字符串。\n函数应返回结果字符串。\n例子", "entry_point": "solve", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/78", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定一个字符串“text”，返回其MD5哈希等效字符串。\n// 如果“text”是一个空字符串，则返回null。\n// >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n// \nfunc string_to_md5 (text string) interface{} {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := string_to_md5(\"Hello world\")\n\texpected_1 := \"3e25960a79dbc69b674cd4ec67a72c62\"\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := string_to_md5(\"\")\n\texpected_2 := nil\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := string_to_md5(\"A B C\")\n\texpected_3 := \"0ef78513b0cb8cef12743f5aeb35f888\"\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := string_to_md5(\"password\")\n\texpected_4 := \"5f4dcc3b5aa765d61d8327deb882cf99\"\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "给定一个字符串“text”，返回其MD5哈希等效字符串。\n如果“text”是一个空字符串，则返回null。", "entry_point": "string_to_md5", "canonical_solution": NaN, "natural_language": "Chinese"}
{"task_id": "go/79", "prompt": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n// 你是一位专业的Golang程序员。\n// \n// 给定两个正整数a和b，返回a和b之间的偶数位数字，按升序排列。\n// \n// 例如：\n// \n// generate_integers(2, 8) => [2, 4, 6, 8]\n// generate_integers(8, 2) => [2, 4, 6, 8]\n// generate_integers(10, 14) => []\n// \nfunc generate_integers (a int, b int) []int {\n", "test": "\n\nfunc deepCompare(a interface{}, b interface{}, msg string) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tvar a2 interface{}\n\tvar b2 interface{}\n\terr = json.Unmarshal(aJSON, &a2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\terr = json.Unmarshal(bJSON, &b2)\n\tif err != nil {\n\t\tpanic(msg)\n\t}\n\tresult := reflect.DeepEqual(a2, b2)\n\tif result {\n\t\treturn true\n\t} else {\n\t\tpanic(msg)\n\t}\n}\n\nfunc main() {\n\tactual_1 := generate_integers(2,10)\n\texpected_1 := []int{2, 4, 6, 8}\n\tdeepCompare(actual_1, expected_1, \"Exception --- test case 0 failed to pass\")\n\n\tactual_2 := generate_integers(10,2)\n\texpected_2 := []int{2, 4, 6, 8}\n\tdeepCompare(actual_2, expected_2, \"Exception --- test case 1 failed to pass\")\n\n\tactual_3 := generate_integers(132,2)\n\texpected_3 := []int{2, 4, 6, 8}\n\tdeepCompare(actual_3, expected_3, \"Exception --- test case 2 failed to pass\")\n\n\tactual_4 := generate_integers(17,89)\n\texpected_4 := []int{}\n\tdeepCompare(actual_4, expected_4, \"Exception --- test case 3 failed to pass\")\n\n}", "language": "go", "description": "给定两个正整数a和b，返回a和b之间的偶数位数字，按升序排列。\n\n例如：", "entry_point": "generate_integers", "canonical_solution": NaN, "natural_language": "Chinese"}
